[
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1644$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1645$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "axiom range_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term univs.Type3 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "Axiom le_log2_sqrt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "postulate dpi1__o__aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1500$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1501$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Aop_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1500 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1501 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_to_dividesb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "Axiom not_divides_to_dividesb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_aux. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "Axiom gcd_aux : forall _p : nat, forall _m : nat, forall _n : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "postulate not_divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Proj1. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $A$.",
    "output": "postulate proj1 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop A"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_theta. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$.",
    "output": "Axiom lt_O_theta : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_gcd_1. For all natural numbers $n$ and $m$, if $n$ is prime, then if $n$ is not divisible by $m$, then the greatest common divisor of $n$ and $m$ is equal to $1$.",
    "output": "prime_to_gcd_1 : n : Nat -> m : Nat -> __ : prime n -> __1 : not (divisible n m) -> Eq (gcd n m) (nd 1) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_1_max_prime. For all natural numbers $n$, if $1$ is less than $n$, then $1$ is less than $max$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $andb$ applied to $primeb$ applied to $i$ and $dividesb$ applied to $i$ and $n$.",
    "output": "axiom lt_1_max_prime (n : Nat) (x__ : 1 < n) : 1 < max (n + 1) (λ i => andb (primeb i) (dividesb i n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_73. For all natural numbers $x$ and $y$ and $z$ and $x134$ and $x135$ and $x136$, the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (x : Nat) -> (y : Nat) -> (z : Nat) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primeb_false_to_not_prime. For all natural numbers $n$, if $primeb$ applied to $n$ is equal to absurdity, then $n$ is not prime.",
    "output": "Axiom primeb_false_to_not_prime : forall n : nat, forall x__ : (primeb n = false), ~ prime n ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Conj. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$.",
    "output": "Axiom conj : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop A, forall __1 : cic.Term cic.prop B, cic.Term cic.prop (matita_basics_logic.And A B) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lprim_ex. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.nil$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.nil$ applied to $matita_arithmetics_nat.nat$.",
    "output": "lprim_ex : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_CProp4. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z689$ to propositions, for all functions $_H1$ from elements $_z690$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_394$ and functions $_x_396$ from elements $_z690$ of $Eq$ of $Hterm$ and $x_394$ to elements of $P$ of $x_394$ and elements $_z690$ of $Eq$ of $Hterm$ and the sum of $x_394$ and $1$ to elements of $P$ of the sum of $x_394$ and $1$, $P$ holds for $Hterm$.",
    "output": "axiom nat_inv_rect_CProp4 (Hterm : Nat) (P : (_z689 : Nat) -> Prop) (_H1 : (_z690 : Hterm = 0) -> P 0) (_H2 : (x_394 : Nat) -> (_x_396 : (_z690 : Hterm = x_394) -> P x_394) -> (_z690 : Hterm = x_394 + 1) -> P (x_394 + 1)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_false_to_not_eq. For all natural numbers $n$ and $m$, if $eqb$ applied to $n$ and $m$ is equal to absurdity, then $n$ is not equal to $m$.",
    "output": "axiom eqb_false_to_not_eq (n m : Nat) (x__ : eqb n m = false) : ¬ (n = m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_n_to_le. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $n$, for all functions $__2$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $m$ and $m$, for all elements $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $j$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $h$ applied to $j$.",
    "output": "permut_n_to_le : h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le k n) -> __1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n) -> __2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le k j) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.le j n) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_n_1. For all natural numbers $n$, $n$ is equal to the exponentiation of $n$ and $1$.",
    "output": "postulate exp_n_1 : (n : Nat) -> Eq n (pow n 1)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_pi_p_M1. For all natural numbers $m$ and $i$, if $i$ is less than or equal to the sum of the product of $2$ and $m$ and $2$, then $bigop$ applied to $i$ and the function that maps $p$ to $andb$ applied to $leb$ applied to the sum of $m$ and $2$ and $p$ and $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$ is divisible by $M$ applied to $m$.",
    "output": "divides_pi_p_M1 : m : Nat -> i : Nat -> __ : Leq i (plus (times (nd 2) m) (nd 2)) -> divisible (bigop i (p : Nat => andb (leb (plus m (nd 2)) p) (primeb p)) Nat (nd 1) times (p : Nat => p)) (M m) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_n. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $m$.",
    "output": "Axiom le_plus_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate prod : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (_x_969 : cic.Term univs.Type0 A) -> (_x_970 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bertrand_up. For all natural numbers $n$, if the exponentiation of $2$ and $8$ is less than or equal to $n$, then $bertrand$ holds for $n$.",
    "output": "bertrand_up : n : Nat -> __ : Leq (pow (nd 2) (nd 8)) n -> bertrand n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_891$.",
    "output": "ACop_rect_Type4_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type4) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type4 (Q_ x_891) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pair_elim. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $T$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $C$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $lft$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $rgt$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $p$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $lft$ and $rgt$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $lft$ and $rgt$ and $T$ applied to $lft$ and $rgt$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $p$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $_0$ to $C$ and the function that maps $lft$ and $rgt$ to $T$ applied to $lft$ and $rgt$ and $p$.",
    "output": "pair_elim : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> T : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> p : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> __1 : cic.Term univs.Type0 C -> cic.Univ cic.prop) -> __ : (lft : cic.Term univs.Type0 A -> rgt : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (_0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) => C) (lft : cic.Term univs.Type0 A => rgt : cic.Term univs.Type0 B => T lft rgt) p)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_557$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_557$, for all functions $_H_inr$ from elements $x_558$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_558$, for all elements $x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_556$.",
    "output": "Axiom Sum_rect_CProp4 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop), forall _H_inl : ((x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))), forall _H_inr : ((x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))), forall x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term cic.prop (Q_ x_556) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_n_O. For all natural numbers $n$, $n$ is equal to the difference of $n$ and $0$.",
    "output": "Axiom minus_n_O : forall n : nat, n = n - 0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_ltransitive. For all sets $B$, for all elements $R$ of $relation$ of $B$, $inv_ltransitive$ holds for $B$ and $lstar$ applied to $B$ and $R$.",
    "output": "axiom lstar_inv_ltransitive (B : Set) (R : relation B) : inv_ltransitive B (lstar B R)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n2. For all natural numbers $n$, if $7$ is less than or equal to $n$, then $prim$ applied to the sum of the product of $2$ and $n$ and $1$ is less than or equal to $pred$ applied to $n$.",
    "output": "postulate le_prim_n2 : (n : Nat) -> (_ : Leq 7 n) -> Leq (prim (plus (times 2 n) 1)) (pred n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "TimesAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "Axiom Aop_rect_Type4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type4 (Q_ x_783) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_706$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_706$.",
    "output": "Axiom Prod_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_706) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_discr. For all natural numbers $a1$ and $a2$ and $a3$ and $a4$, for all elements $x$ and $y$ of $div_mod_spec$ of $a1$ and $a2$ and $a3$ and $a4$, if $x$ is equal to $y$, then $match_div_mod_spec$ holds for $a1$ and $a2$ and $a3$ and $a4$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ to $match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $Lt$ applied to $a4$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $Lt$ applied to $a4$ and $a2$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $Eq$ applied to $a1$ and the sum of the product of $a3$ and $a2$ and $a4$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z53$ to $P$ and $y$ and $x$.",
    "output": "div_mod_spec_discr : a1 : Nat -> a2 : Nat -> a3 : Nat -> a4 : Nat -> x : div_mod_spec a1 a2 a3 a4 -> y : div_mod_spec a1 a2 a3 a4 -> _e : Eq x y -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 (nd 1)) (__ : div_mod_spec a1 a2 a3 a4 => univ Type2) (t0 : Lt a4 a2 => t1 : Eq a1 (plus (times a3 a2) a4) => match_div_mod_spec a1 a2 a3 a4 (plus Type2 (nd 1)) (__ : div_mod_spec a1 a2 a3 a4 => univ Type2) (u0 : Lt a4 a2 => u1 : Eq a1 (plus (times a3 a2) a4) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (e0 : Eq (R0 (Lt a4 a2) t0) u0 => prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (x_19 : Lt a4 a2 => _x_20 : Eq t0 x_19 => (x0 : Lt a4 a2 => p0 : Eq t0 x0 => Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1) (_e1 : Eq (R1 (Lt a4 a2) t0 (x_19 : Lt a4 a2 => _x_20 : Eq t0 x_19 => (x0 : Lt a4 a2 => p0 : Eq t0 x0 => Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 => P))) (_z53 : (e0 : Eq (R0 (Lt a4 a2) t0) u0 -> _e1 : Eq (R1 (Lt a4 a2) t0 (x_19 : Lt a4 a2 => _x_20 : Eq t0 x_19 => (x0 : Lt a4 a2 => p0 : Eq t0 x0 => Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 -> P) => P))) y) x ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type5_body. For all functions $Q_$ from elements $_x_332$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_true$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_332$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_332$.",
    "output": "axiom bool_rect_Type5_body (Q_ : (_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5) (_H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false)) (x_332 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type5 (Q_ x_332)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_not_bertrand_to_bertrand. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "axiom not_not_bertrand_to_bertrand (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n))) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_Sn. For all natural numbers $b$ and $n$, the exponentiation of $b$ and the sum of $n$ and $1$ is equal to the product of $b$ and the exponentiation of $b$ and $n$.",
    "output": "Axiom exp_Sn : forall b : nat, forall n : nat, pow b (n + 1) = b * pow b n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_10$ and $x_11$.",
    "output": "eq_rect_Type3_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_10 : cic.Term univs.Type2 A -> _x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Univ univs.Type3) -> _H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)) -> x_10 : cic.Term univs.Type2 A -> x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Term univs.Type3 (Q_ x_10 x_11) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_not_divides_fact. For all natural numbers $p$, if $p$ is prime, then for all natural numbers $n$, if $n$ is less than $p$, then $p$ is not divisible by the factorial of $n$.",
    "output": "postulate prime_to_not_divides_fact : (p : Nat) -> (_ : prime p) -> (n : Nat) -> (__1 : Lt n p) -> not (divisible p (factorial n))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below_lop. For all natural numbers $n$, $primes_below$ holds for $list_of_primes$ applied to $n$ and the sum of $n$ and $2$.",
    "output": "axiom primes_below_lop (n : Nat) : primes_below (list_of_primes n) (n + 2)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Andb_elim. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_bool.match_bool$ applied to $cic.type$ applied to $cic.z$ and the function that maps $__$ to $cic.univ$ applied to $cic.prop$ and $P$ applied to $b2$ and $P$ applied to $matita_basics_bool.false$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_basics_bool.andb$ applied to $b1$ and $b2$.",
    "output": "Axiom andb_elim : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (fun __ => cic.univ cic.prop) (P b2) (P matita_basics_bool.false) b1), cic.Term cic.prop (P (matita_basics_bool.andb b1 b2)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example13. $nth_prime$ applied to $4$ is equal to $11$.",
    "output": "postulate example13 : Eq (nth_prime 4) 11"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type0. For all functions $Q_$ from elements $_x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_488$.",
    "output": "void_rect_Type0 : Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type0) -> x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type0 (Q_ x_488) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bc2. For all elements $n$ and $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_factorial.fact$ applied to $k$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $k$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate bc2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact k) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k))) (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate exp_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp n matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15624. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.",
    "output": "axiom let_clause_15624 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : m * d - n * c = 1"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp4. For all functions $Q_$ from elements $_x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_54$.",
    "output": "postulate True_rect_CProp4 : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_CProp1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1488$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1489$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max'. For all natural numbers $__$, for all functions $__1$ from natural numbers $__1$ to booleans, for all natural numbers $__2$, $Nat$.",
    "output": "max' : __ : Nat -> __1 : (__1 : Nat -> bool) -> __2 : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $s$ be an element of $Sort$. Let $a$ be an element of $Univ$ of $s$. Then $Term$ applied to $s$ and $a$ is a type.",
    "output": "axiom Term (s : Sort) (a : Univ s) : Type"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Confluent1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$.",
    "output": "Axiom confluent1 : forall A : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Term univs.Type0 (matita_basics_relations.predicate A) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1194$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1195$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate Sig_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_Psi_Psi'. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi'$ applied to $n$.",
    "output": "postulate eq_Psi_Psi' : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi' n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_164$ and $x_163$, for all elements $x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_162$.",
    "output": "postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_theta. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$.",
    "output": "lt_O_theta : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp3_body. For all functions $Q_$ from elements $_x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_353$.",
    "output": "axiom bool_rect_CProp3_body (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_353)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_commute. For all natural numbers $n$ and $m$, for all functions $p11$ from natural numbers to booleans, for all functions $p12$ from natural numbers and natural numbers $__1$ to booleans, for all functions $p21$ from natural numbers to booleans, for all functions $p22$ from natural numbers and natural numbers $__1$ to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers and natural numbers $__1$ to elements of $B$, if $0$ is less than $n$, then if $0$ is less than $m$, then for all functions $__2$ from natural numbers $i$ and natural numbers $j$ and elements $__2$ of $Lt$ of $i$ and $n$ and elements $__3$ of $Lt$ of $j$ and $m$ to elements of $Eq$ of $andb$ applied to $p11$ applied to $i$ and $p12$ applied to $i$ and $j$ and $andb$ applied to $p21$ applied to $j$ and $p22$ applied to $i$ and $j$, $bigop$ applied to $n$ and the function that maps $i$ to $p11$ applied to $i$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $bigop$ applied to $m$ and the function that maps $j$ to $p12$ applied to $i$ and $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $f$ applied to $i$ and $j$ is equal to $bigop$ applied to $m$ and the function that maps $j$ to $p21$ applied to $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $bigop$ applied to $n$ and the function that maps $i$ to $p22$ applied to $i$ and $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $j$.",
    "output": "postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (_ : Nat) -> bool) -> (p12 : (_ : Nat) -> (__1 : Nat) -> bool) -> (p21 : (_ : Nat) -> bool) -> (p22 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (\\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\\ i : Nat -> bigop m (\\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\\ j : Nat -> f i j))) (bigop m (\\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\\ j : Nat -> bigop n (\\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\\ i : Nat -> f i j)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1062$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z1063$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_607$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1063$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_607$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_607$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_elim. For all natural numbers $n$ and $m$, for all functions $P$ from booleans to propositions, for all functions $__$ from elements of $Eq$ of $n$ and $m$ to elements of $P$ of $true$, for all functions $__1$ from elements $__1$ of $not$ of $Eq$ applied to $n$ and $m$ to elements of $P$ of absurdity, $P$ holds for $eqb$ applied to $n$ and $m$.",
    "output": "postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_895$.",
    "output": "Axiom ACop_rect_Type3_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type3 (Q_ x_895) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_ind_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_586$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_587$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_587$, for all elements $x_586$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_586$.",
    "output": "axiom option_ind_body (_A : cic.Univ univs.Type0) (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_586)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_div_div_div_times. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_div_and_mod.div$ applied to $q$ and $n$ and $m$ and $matita_arithmetics_div_and_mod.div$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "eq_div_div_div_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q n) m) (matita_arithmetics_div_and_mod.div q (matita_arithmetics_nat.times n m))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15621. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.",
    "output": "Axiom let_clause_15621 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), n * c - m * d = 1 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_aux_mod_aux. For all natural numbers $p$ and $n$ and $m$, $n$ is equal to the sum of the product of $div_aux$ applied to $p$ and $n$ and $m$ and the sum of $m$ and $1$ and $mod_aux$ applied to $p$ and $n$ and $m$.",
    "output": "postulate div_aux_mod_aux : (p : Nat) -> (n : Nat) -> (m : Nat) -> Eq n (plus (times (div_aux p n m) (plus m 1)) (mod_aux p n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Op_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $_x_807$ and $_x_808$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate op_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (_x_807 : cic.Term univs.Type0 A) -> (_x_808 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_787$.",
    "output": "Axiom Aop_rect_Type3_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type3 (Q_ x_787) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_gcd_times_1. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and the product of $n$ and $m$ is equal to $1$.",
    "output": "Axiom eq_gcd_times_1 : forall p : nat, forall n : nat, forall m : nat, forall x__ : (0 < n), forall __1 : (0 < m), forall __2 : (gcd p n = 1), forall __3 : (gcd p m = 1), gcd p (n * m) = 1 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_fact. For all natural numbers $n$ and $i$, if $0$ is less than $i$, then if $i$ is less than or equal to $n$, then $i$ is divisible by the factorial of $n$.",
    "output": "axiom divides_fact (n i : Nat) (x__ : 0 < i) (__1 : i ≤ n) : divisible i (factorial n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp0. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "postulate nat_rect_CProp0 : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10331. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g2$ applied to $i$, for all functions $Hle$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$, for all elements $Hcase$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $n1$ and $matita_basics_bool.true$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))) -> (Hle : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.S n1))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> (Hcase : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p n1) matita_basics_bool.true)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1590$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1591$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "axiom ACop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1590 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1591 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp5_body. For all functions $Q_$ from elements $_x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_56$.",
    "output": "Axiom True_rect_CProp5_body : forall Q_ : ((_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop), forall _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I), forall x_56 : cic.Term cic.prop matita_basics_logic.True, cic.Term cic.prop (Q_ x_56) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_pred. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $matita_arithmetics_nat.pred$.",
    "output": "Axiom monotonic_pred : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le matita_arithmetics_nat.pred) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_795$.",
    "output": "Axiom Aop_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_795) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Comm. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $ACop$ of $A$ and $nil$, for all elements $a$ and $b$ of $A$, $op$ applied to $A$ and $nil$ and $aop$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ is equal to $op$ applied to $A$ and $nil$ and $aop$ applied to $A$ and $nil$ and $xxx$ and $b$ and $a$.",
    "output": "comm : A : Set -> nil : A -> xxx : ACop A nil -> a : A -> b : A -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_le_to_lt. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$.",
    "output": "lt_to_le_to_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m p) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_times_gcd_aux. For all natural numbers $p$ and $m$ and $n$ and $d$ and $c$, if $0$ is less than $c$, then if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then if $d$ is divisible by the product of $c$ and $m$, then if $d$ is divisible by the product of $c$ and $n$, then $d$ is divisible by the product of $c$ and $gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "axiom divides_times_gcd_aux (p m n d c : Nat) (x__ : 0 < c) (__1 : 0 < n) (__2 : n ≤ m) (__3 : n ≤ p) (__4 : divisible d (c * m)) (__5 : divisible d (c * n)) : divisible d (c * gcd_aux p m n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ltransitive. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.ltransitive$ applied to $B$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$.",
    "output": "Axiom lstar_ltransitive : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), cic.Term cic.prop (matita_arithmetics_lstar.ltransitive B (matita_arithmetics_lstar.lstar B R)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leq_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "leq_sqrt_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "transitive : A : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fold. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_b$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "fold : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _b : cic.Term univs.Type0 B -> _p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Hint_declaration_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type1$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type1$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom hint_declaration_Type1 (A : cic.Univ univs.Type1) (_a _b : cic.Term univs.Type1 A) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_le. $transitive$ holds for $Nat$ and $Leq$.",
    "output": "Axiom transitive_le : transitive nat Leq ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "Axiom Aop_rect_Type3 : forall A : Set, forall _nil : A, forall Q_ : ((_x_867 : Aop A _nil) -> Type3), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_867 : Aop A _nil, Q_ x_867 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp2_body. For all functions $Q_$ from elements $_x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_356$.",
    "output": "Axiom bool_rect_CProp2_body : forall Q_ : ((_x_356 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_356 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_356) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_741$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_743$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_742$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_745$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_742$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_743$ and $x_742$, for all elements $x_741$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_741$.",
    "output": "Axiom list_rect_Type1_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type1), forall _H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_743 : cic.Term univs.Type0 _A) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_745 : cic.Term univs.Type1 (Q_ x_742)) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))), forall x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type1 (Q_ x_741) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Sum. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_Sum (_A _B : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp2. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1284$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1285$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Prod_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ cic.prop) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ex_intro. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $P$.",
    "output": "ex_intro : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> x : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (P x) -> cic.Term cic.prop (matita_basics_logic.ex A P) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Or_div_mod. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$.",
    "output": "Axiom or_div_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n q)) q))) (matita_basics_logic.And (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n q) q) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_572$, for all functions $_H_inr$ from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_573$, for all elements $x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_571$.",
    "output": "Axiom Sum_rect_CProp2_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop), forall _H_inl : ((x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))), forall _H_inr : ((x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))), forall x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term cic.prop (Q_ x_571) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_times_plus_to_congruent. For all natural numbers $n$ and $m$ and $p$ and $r$, if $0$ is less than $p$, then if $n$ is equal to the sum of the product of $r$ and $p$ and $m$, then $congruent$ holds for $n$ and $m$ and $p$.",
    "output": "eq_times_plus_to_congruent : n : Nat -> m : Nat -> p : Nat -> r : Nat -> __ : Lt 0 p -> __1 : Eq n (plus (times r p) m) -> congruent n m p ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1. For all sets $_A$, for all functions $Q_$ from elements $_x_925$ of $range$ of $_A$ to elements of $Type1$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $range$ of $_A$, $Q_$ holds for $x_925$.",
    "output": "postulate range_rect_Type1 : (_A : Set) -> (Q_ : (_x_925 : range _A) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_CProp3. For all sets $x1$, for all elements $Hterm$ of $range$ of $x1$, for all functions $P$ from elements $_z1674$ of $range$ of $x1$ to propositions, for all functions $_H1$ from functions $_enum$ from natural numbers to elements of $x1$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans and elements $_z1675$ of $Eq$ of $Hterm$ and $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $P$ of $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $P$ holds for $Hterm$.",
    "output": "range_inv_rect_CProp3 : x1 : Set -> Hterm : range x1 -> P : (_z1674 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1675 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15321. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_15321 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $_n$ be a natural number. Let $_f$ be a function from natural numbers to booleans. Let $__$ be a natural number. Then $max_spec$ applied to $_n$ and $_f$ and $__$ is a proposition.",
    "output": "axiom max_spec (_n : Nat) (_f : (x__ : Nat) -> bool) (x__ : Nat) : Prop"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom bijn : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop110. For all instances $a$ and $c$ of integers, if we can prove that $a$ is odd and $c$ is odd, then we can prove that for all integers $b$, the sum of the product of $a$ and $b$ and the product of $b$ and $c$ is even.",
    "output": "Axiom prop110 : forall a : Int, forall c : Int, (odd a /\\ odd c -> forall b : Int, even (a * b + b * c)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_aux. For all elements $__$ and $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate p_ord_aux : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_642$.",
    "output": "Axiom DPair_rect_Type5_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type5 (Q_ x_642) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Orb_elim. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_bool.match_bool$ applied to $cic.type$ applied to $cic.z$ and the function that maps $__$ to $cic.univ$ applied to $cic.prop$ and $P$ applied to $matita_basics_bool.true$ and $P$ applied to $b2$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_basics_bool.orb$ applied to $b1$ and $b2$.",
    "output": "orb_elim : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ cic.prop) (P matita_basics_bool.true) (P b2) b1) -> cic.Term cic.prop (P (matita_basics_bool.orb b1 b2)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z173$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z174$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom True_inv_rect_CProp2 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z173 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop), forall _H1 : ((_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_plus_Sn_r. For all natural numbers $a$ and $x$ and $n$, $a$ is less than the sum of the sum of $a$ and $x$ and the sum of $n$ and $1$.",
    "output": "axiom lt_plus_Sn_r (a x n : Nat) : a < a + x + (n + 1)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10331. For all natural numbers $p$ and $n$ and $n1$ and $q$ and $p1$ and $p2$ and $qa$ and $ra$, if $p_ord_aux$ applied to the sum of $n1$ and $1$ and the sum of $n1$ and $1$ and the sum of $p2$ and $2$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $qa$ and $ra$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10331 : p : Nat -> n : Nat -> n1 : Nat -> q : Nat -> p1 : Nat -> p2 : Nat -> qa : Nat -> ra : Nat -> H : Eq (p_ord_aux (plus n1 (nd 1)) (plus n1 (nd 1)) (plus p2 (nd 2))) (mk_Prod Nat Nat qa ra) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "axiom distr_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) (a b c : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.",
    "output": "div_mod_spec_rect_Type5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type5) -> _H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type5 (Q_ x_817) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_Type1. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z677$ to elements of $Type1$, for all functions $_H1$ from elements $_z678$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_386$ and functions $_x_388$ from elements $_z678$ of $Eq$ of $Hterm$ and $x_386$ to elements of $P$ of $x_386$ and elements $_z678$ of $Eq$ of $Hterm$ and the sum of $x_386$ and $1$ to elements of $P$ of the sum of $x_386$ and $1$, $P$ holds for $Hterm$.",
    "output": "axiom nat_inv_rect_Type1 (Hterm : Nat) (P : (_z677 : Nat) -> Type1) (_H1 : (_z678 : Hterm = 0) -> P 0) (_H2 : (x_386 : Nat) -> (_x_388 : (_z678 : Hterm = x_386) -> P x_386) -> (_z678 : Hterm = x_386 + 1) -> P (x_386 + 1)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.",
    "output": "axiom DPair_rect_Type3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distr_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Dop$ of $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $A$, $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $aop__o__op$ applied to $A$ and $nil$ and $sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ is equal to $aop__o__op$ applied to $A$ and $nil$ and $sum$ applied to $A$ and $nil$ and $xxx$ and $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "distr_body : A : Set -> nil : A -> xxx : Dop A nil -> a : A -> b : A -> c : A -> Eq (prod A nil xxx a (aop__o__op A nil (sum A nil xxx) b c)) (aop__o__op A nil (sum A nil xxx) (prod A nil xxx a b) (prod A nil xxx a c)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_ind. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $x_1340$ and $b2$ and $x_1339$, for all elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1336$ and $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1337$ and $x_1336$ and $x_1335$ and $x_1338$.",
    "output": "Axiom lstar_r_ind : forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall Q_ : ((x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop), forall _H_lstar_r_O : ((b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))), forall _H_lstar_r_S : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339))), forall x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_1336 : cic.Term univs.Type0 B, forall x_1335 : cic.Term univs.Type0 B, forall x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335), cic.Term cic.prop (Q_ x_1337 x_1336 x_1335 x_1338) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_797$.",
    "output": "Aop_rect_CProp5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_797) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_discr. For all elements $a1$ and $a2$ and $a3$ and $a4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x$ and $y$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_arithmetics_div_and_mod.match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_arithmetics_div_and_mod.match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $matita_basics_logic.R0$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $a3$ and $a2$ and $a4$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_nat.lt$ applied to $a4$ and $a2$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $a3$ and $a2$ and $a4$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z53$ to $P$ and $y$ and $x$.",
    "output": "postulate div_mod_spec_discr : (a1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (y : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\\ t0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ t1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) -> matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\\ u0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ u1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1) -> P))) (\\ _z53 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) (matita_basics_logic.R0 (cic.lift cic.prop univs.Type0 (matita_arithmetics_nat.lt a4 a2)) t0) x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) u0 e0)) (matita_basics_logic.R1 (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 (\\ x_19 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_nat.lt a4 a2)) t0 x0) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) x_19 _x_20)) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_863$ of $Aop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_863$.",
    "output": "axiom Aop_rect_Type4_body (A : Set) (_nil : A) (Q_ : (_x_863 : Aop A _nil) -> Type4) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_863 : Aop A _nil) : Q_ x_863"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Singlevalued. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation2$ applied to $A$ and $B$.",
    "output": "axiom singlevalued (A B : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_to_not_le_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate not_le_to_not_le_S_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp1_body. For all functions $Q_$ from elements $_x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_493$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_493$.",
    "output": "void_rect_CProp1_body : Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_493 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_493) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z960$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z961$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate unit_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z185$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z186$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom True_inv_rect_CProp0 (Hterm : cic.Term cic.prop matita_basics_logic.True) (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_rem_eq. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_basics_types.snd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$.",
    "output": "axiom ord_rem_eq (n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord_rem n p) (matita_basics_types.snd matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord n p)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1561. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $p$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $p$ is divisible by the product of $m$ and $n$, then for all natural numbers $c$, if the product of $m$ and $n$ is equal to the product of $p$ and $c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the difference of the product of $p$ and $a$ and the product of $m$ and $b$ is equal to $1$.",
    "output": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_648$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_648$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_648$.",
    "output": "postulate DPair_rect_Type1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type1) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type1 (Q_ x_648)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate divides_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides n matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_l. For all sets $B$, for all functions $R$ from elements of $B$ and elements $__1$ of $B$ to propositions, for all elements $b2$ of $B$, for all elements $P$ of $relation2$ of $Nat$ and $B$, for all elements $__$ of $P$ of $0$ and $b2$, for all functions $__1$ from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $__1$ of $R$ of $b1$ and $b$ and elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b1$, for all natural numbers $l$, for all elements $b1$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b1$.",
    "output": "lstar_ind_l : B : Set -> R : (__ : B -> __1 : B -> Prop) -> b2 : B -> P : relation2 Nat B -> __ : P 0 b2 -> __1 : (l : Nat -> b1 : B -> b : B -> __1 : R b1 b -> __2 : lstar B R l b b2 -> __3 : P l b -> P (plus l (nd 1)) b1) -> l : Nat -> b1 : B -> __2 : lstar B R l b1 b2 -> P l b1 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_615$, for all elements $x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_614$.",
    "output": "postulate option_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_615 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_615))) -> (x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_614)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom exp_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_exp4. For all natural numbers $n$, if $1$ is less than $n$, then $Psi$ applied to $n$ is less than or equal to the product of $pred$ applied to $n$ and the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "le_Psi_exp4 : n : Nat -> __ : Lt (nd 1) n -> Leq (Psi n) (times (pred n) (pow (nd 2) (minus (times (nd 2) n) (nd 3)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10336. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.pred$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hlt$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Ha$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10336 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt p m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> Hm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) -> Hlt : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) -> Ha : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "commutative2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10335. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "Axiom let_clause_10335 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime1. For all natural numbers $n$, $Nat$.",
    "output": "let_previous_prime1 : n : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. For all elements $n$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "axiom let_clause_1033 (n x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type3. For all functions $Q_$ from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.",
    "output": "True_rect_Type3 : Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type3) -> _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I) -> x_46 : cic.Term cic.prop matita_basics_logic.True -> cic.Term univs.Type3 (Q_ x_46) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_869$ of $Aop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_869$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_869$.",
    "output": "Aop_rect_Type2 : A : Set -> _nil : A -> Q_ : (_x_869 : Aop A _nil -> Type2) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_869 : Aop A _nil -> Q_ x_869 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Type. If $Nat$, then $Sort$.",
    "output": "type : Nat -> Sort ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_863$ of $Aop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_863$.",
    "output": "Aop_rect_Type4 : A : Set -> _nil : A -> Q_ : (_x_863 : Aop A _nil -> Type4) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_863 : Aop A _nil -> Q_ x_863 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example11. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom example11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_exp_to_lt. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $n$ and $matita_arithmetics_exp.exp$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "Axiom lt_exp_to_lt : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp a n) (matita_arithmetics_exp.exp a m)), cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_log. For all natural numbers $p$ and $n$, if $1$ is less than $n$, then if $p$ is less than or equal to $n$, then $0$ is less than the logarithm of $p$ and $n$.",
    "output": "postulate lt_O_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq p n) -> Lt 0 (log p n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "lt_S_to_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_forall_to_exists. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ to elements of $decidable$ of $P$ applied to $i$, if it is not the case that $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__1$ to $P$ applied to $i$, then $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and the negation of $P$ applied to $i$.",
    "output": "axiom not_forall_to_exists (P : (x__ : Nat) -> Prop) (n : Nat) (x__ : (i : Nat) -> decidable (P i)) (__1 : ¬ prod Set Prop Nat (λ i => prod Prop Prop (i < n) (λ __1 => P i))) : ex Nat (λ i => i < n ∧ ¬ P i)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta_def. For all natural numbers $n$, $theta$ applied to $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$.",
    "output": "Axiom theta_def : forall n : nat, theta n = bigop (n + 1) (fun p => primeb p) nat 1 times (fun p => p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1500$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1501$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1500 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1501 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_priml1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_priml1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_ind_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_522$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_522$, for all functions $_H_inr$ from elements $x_523$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_523$, for all elements $x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_521$.",
    "output": "postulate Sum_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1544. For all natural numbers $p$ and $q$, for all functions $Hind$ from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$, for all natural numbers $m$ and $n$, if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to the sum of $q$ and $1$, then if $n$ is not divisible by $m$, then for all natural numbers $a$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ or the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $n$ and $b$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$.",
    "output": "let_clause_1544 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n)) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "Axiom And_rect_CProp4 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))), forall x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_146) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length_unique_le. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__1$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $n$.",
    "output": "axiom length_unique_le (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) (__1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1034. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$.",
    "output": "Axiom let_clause_1034 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_false. For all natural numbers $n$, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, $bigop$ applied to $n$ and the function that maps $i$ to absurdity and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $nil$.",
    "output": "Axiom bigop_false : forall n : nat, forall B : Set, forall nil : B, forall op : ((x__ : B) -> (__1 : B) -> B), forall f : ((x__ : nat) -> B), bigop n (fun i => false) B nil op (fun i => f i) = nil ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "To_max. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.",
    "output": "axiom to_max (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m i)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dividesb. For all natural numbers $__$ and $__1$, $bool$.",
    "output": "postulate dividesb : (_ : Nat) -> (__1 : Nat) -> bool"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp5. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_931$.",
    "output": "postulate range_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_931)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_Sn_n. For all natural numbers $n$, $1$ is equal to the difference of the sum of $n$ and $1$ and $n$.",
    "output": "axiom minus_Sn_n (n : Nat) : 1 = n + 1 - n"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type1. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z347$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_140$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_139$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z348$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_140$ and $x_139$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_140$ and $x_139$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom And_inv_rect_Type1 : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2), forall P : ((_z347 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((x_140 : cic.Term cic.prop x1) -> (x_139 : cic.Term cic.prop x2) -> (_z348 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_140 x_139))) -> cic.Term univs.Type1 (P (matita_basics_logic.conj x1 x2 x_140 x_139))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prim. For all natural numbers $_n$, $Nat$.",
    "output": "Axiom prim : forall _n : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_615$, for all elements $x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_614$.",
    "output": "axiom option_rect_CProp4 (_A : cic.Univ univs.Type0) (Q_ : (_x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_615 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_615))) (x_614 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_614)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_Sn_m. For all natural numbers $n$ and $m$, the sum of $m$ and the product of $n$ and $m$ is equal to the product of the sum of $n$ and $1$ and $m$.",
    "output": "postulate times_Sn_m : (n : Nat) -> (m : Nat) -> Eq (plus m (times n m)) (times (plus n 1) m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below2. $primes_below$ holds for $nil$ applied to $Nat$ and $2$.",
    "output": "postulate primes_below2 : primes_below (nil Nat) 2"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lenght_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "axiom lenght_to_nil (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.",
    "output": "Axiom Sig_rect_Type4_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type4), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type4 (Q_ x_666) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_O. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b1$ and $b2$.",
    "output": "postulate lstar_inv_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Enum_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "enum_body : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z131$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z132$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "Axiom True_inv_rect_Type4 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z131 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4), forall _H1 : ((_z132 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type4 (P matita_basics_logic.I)), cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate monotonic : (A : cic.Univ univs.Type0) -> (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Coerc_pair_sigma. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.snd$ applied to $A$ and $B$ and $p$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $matita_basics_types.Sig$ applied to $B$ and the function that maps $x$ to $P$ applied to $x$.",
    "output": "postulate coerc_pair_sigma : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (P (matita_basics_types.snd A B p))) -> cic.Term univs.Type0 (matita_basics_types.Prod A (matita_basics_types.Sig B (\\ x : cic.Term univs.Type0 B -> P x)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_cr_pair. For all natural numbers $m$ and $n$ and $a$ and $b$, if $a$ is less than $m$, then if $b$ is less than $n$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then $mod$ applied to $cr_pair$ applied to $m$ and $n$ and $a$ and $b$ and $m$ is equal to $a$ and $mod$ applied to $cr_pair$ applied to $m$ and $n$ and $a$ and $b$ and $n$ is equal to $b$.",
    "output": "axiom mod_cr_pair (m n a b : Nat) (x__ : a < m) (__1 : b < n) (__2 : gcd n m = 1) : mod (cr_pair m n a b) m = a ∧ mod (cr_pair m n a b) n = b"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop50. We can prove that for all natural numbers $n$, it is not the case that $n$ is even and $n$ is odd.",
    "output": "Axiom prop50 : forall n : nat, ~ (even n /\\ odd n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1122$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1123$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "axiom DPair_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1122 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type2) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1123 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rewrite_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $x$, for all elements $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $y$.",
    "output": "Axiom rewrite_r : forall A : cic.Univ univs.Type2, forall x : cic.Term univs.Type2 A, forall P : ((__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2), forall __ : cic.Term univs.Type2 (P x), forall y : cic.Term univs.Type2 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq A y x), cic.Term univs.Type2 (P y) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_plus_Sn_r. For all natural numbers $a$ and $x$ and $n$, $a$ is less than the sum of the sum of $a$ and $x$ and the sum of $n$ and $1$.",
    "output": "postulate lt_plus_Sn_r : (a : Nat) -> (x : Nat) -> (n : Nat) -> Lt a (plus (plus a x) (plus n 1))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S_times_2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom le_S_times_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_sqrt_log. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $b$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "le_sqrt_log : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log b n) (matita_arithmetics_sqrt.sqrt n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_plus_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $m$ and $m$.",
    "output": "axiom minus_plus_m_m (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n m) m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate let_previous_prime6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_divides. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "Axiom list_divides : forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Relation4. For all elements $__$ and $__1$ and $__2$ and $__3$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom relation4 (__ __1 __2 __3 : cic.Univ univs.Type0) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_895$.",
    "output": "postulate ACop_rect_Type3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type3 (Q_ x_895)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Aop. For all sets $A$, for all elements $_nil$ of $A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Aop$ of $A$ and $_nil$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $Aop$ of $A$ and $_nil$ to elements of $return_type$ of $z$, for all elements $z$ of $Aop$ of $A$ and $_nil$, $return_type$ holds for $z$.",
    "output": "filter_Aop : A : Set -> _nil : A -> return_sort : Sort -> return_type : (z : Aop A _nil -> return_sort) -> return : (z : Aop A _nil -> return_type z) -> z : Aop A _nil -> return_type z ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_plus_comm_23. For all natural numbers $x$ and $y$ and $z$, the sum of the sum of $x$ and $y$ and $z$ is equal to the sum of the sum of $x$ and $z$ and $y$.",
    "output": "plus_plus_comm_23 : x : Nat -> y : Nat -> z : Nat -> Eq (plus (plus x y) z) (plus (plus x z) y) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.",
    "output": "postulate eq_rect_CProp3_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_aux. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "axiom div_aux (_p _m _n : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_length_to_mem. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__2$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $n$ and $l$.",
    "output": "Axiom eq_length_to_mem : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) (matita_arithmetics_nat.S n)), forall __1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l), forall __2 : ((x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.le x n)), cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_Type4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_590$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_None$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_591$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_591$, for all elements $x_590$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_590$.",
    "output": "postulate option_rect_Type4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type4) -> (_H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_591 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> (x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type4 (Q_ x_590)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_exp_pred_SO. For all natural numbers $p$ and $a$, if $p$ is prime, then if $p$ is not divisible by $a$, then $congruent$ holds for the exponentiation of $a$ and $pred$ applied to $p$ and $1$ and $p$.",
    "output": "postulate congruent_exp_pred_SO : (p : Nat) -> (a : Nat) -> (_ : prime p) -> (__1 : not (divisible p a)) -> congruent (pow a (pred p)) 1 p"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp2_body. For all functions $Q_$ from elements $_x_60$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_60$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_60$.",
    "output": "True_rect_CProp2_body : Q_ : (_x_60 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_60 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_60) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type1. For all functions $Q_$ from elements $_x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_true$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_341$.",
    "output": "axiom bool_rect_Type1 (Q_ : (_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1) (_H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false)) (x_341 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type1 (Q_ x_341)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_n_fact_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "Axiom lt_n_fact_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n), cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_factorial.fact n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.",
    "output": "postulate pi_p_primeb : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $Lt$ of $_r$ and $_m$ and elements $x_846$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_845$.",
    "output": "axiom div_mod_spec_rect_CProp3_body (_n _m _q _r : Nat) (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_847 : _r < _m) -> (x_846 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) (x_845 : div_mod_spec _n _m _q _r) : Q_ x_845"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_sqrt_to_le_times_l. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $n$ and $m$.",
    "output": "le_sqrt_to_le_times_l : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_sqrt.sqrt m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n n) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp0_body. For all functions $Q_$ from elements $_x_362$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_362$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_362$.",
    "output": "bool_rect_CProp0_body : Q_ : (_x_362 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_362 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_362) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type3_body. For all functions $Q_$ from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.",
    "output": "Axiom True_rect_Type3_body : forall Q_ : ((_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3), forall _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I), forall x_46 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type3 (Q_ x_46) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_780$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_777$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_778$ and $x_777$, for all elements $x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_776$.",
    "output": "list_rect_CProp0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_778 : cic.Term univs.Type0 _A -> x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_780 : cic.Term cic.prop (Q_ x_777) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) -> x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_776) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp4. For all functions $Q_$ from elements $_x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_489$.",
    "output": "void_rect_CProp4 : Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_489 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_489) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.tail$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$.",
    "output": "Axiom eq_lop : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.tail matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus_plus_plus_l. For all natural numbers $z$ and $x$ and $y$ and $h$, the difference of the sum of $z$ and the sum of $x$ and $h$ and the sum of $y$ and $h$ is equal to the difference of the sum of $z$ and $x$ and $y$.",
    "output": "Axiom plus_minus_plus_plus_l : forall z : nat, forall x : nat, forall y : nat, forall h : nat, z + (x + h) - (y + h) = z + x - y ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sigma_p_dividesb. For all natural numbers $m$ and $n$ and $p$, if $0$ is less than $n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $m$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "sigma_p_dividesb : m : Nat -> n : Nat -> p : Nat -> __ : Lt 0 n -> __1 : prime p -> __2 : not (divisible p n) -> Eq m (bigop m (i : Nat => dividesb (pow p (plus i (nd 1))) (times (pow p m) n)) Nat 0 plus (i : Nat => nd 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.",
    "output": "postulate And_rect_Type5_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5) -> (_H_conj : (x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) -> (x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type5 (Q_ x_126)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_ind. For all sets $x1$, for all elements $Hterm$ of $range$ of $x1$, for all functions $P$ from elements $_z1632$ of $range$ of $x1$ to propositions, for all functions $_H1$ from functions $_enum$ from natural numbers to elements of $x1$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans and elements $_z1633$ of $Eq$ of $Hterm$ and $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $P$ of $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $P$ holds for $Hterm$.",
    "output": "Axiom range_inv_ind : forall x1 : Set, forall Hterm : range x1, forall P : ((_z1632 : range x1) -> Prop), forall _H1 : ((_enum : (x__ : nat) -> x1) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> (_z1633 : Hterm = mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)), P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_times_l. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "postulate log_times_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_square_exp. For all natural numbers $n$, if $3$ is less than $n$, then the exponentiation of $n$ and $2$ is less than or equal to the exponentiation of $2$ and $n$.",
    "output": "postulate le_square_exp : (n : Nat) -> (_ : Lt 3 n) -> Leq (pow n 2) (pow 2 n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z353$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z354$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (x_144 : cic.Term cic.prop x1) -> (x_143 : cic.Term cic.prop x2) -> (_z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1562. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.",
    "output": "Axiom let_clause_1562 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), n * c - m * d = 1 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_668$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_668$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_668$.",
    "output": "Axiom Sig_rect_Type5_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type5), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type5 (Q_ x_668) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp5. For all functions $Q_$ from elements $_x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_490$.",
    "output": "void_rect_CProp5 : Q_ : (_x_490 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_490 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_490) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1595. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $primepn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $primepm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $lt1gcd$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$.",
    "output": "Axiom let_clause_1595 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))), forall H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_plus_l. For all natural numbers $n$, $injective$ holds for $Nat$ and $Nat$ and the function that maps $m$ to the sum of $m$ and $n$.",
    "output": "Axiom injective_plus_l : forall n : nat, injective nat nat (fun m => m + n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_pred_n. For all natural numbers $n$, $pred$ applied to $n$ is less than or equal to $n$.",
    "output": "Axiom le_pred_n : forall n : nat, Leq (pred n) n ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_rem_eq. For all natural numbers $n$ and $p$, $ord_rem$ applied to $n$ and $p$ is equal to $snd$ applied to $Nat$ and $Nat$ and $p_ord$ applied to $n$ and $p$.",
    "output": "axiom ord_rem_eq (n p : Nat) : ord_rem n p = snd Nat Nat (p_ord n p)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_diff. For all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i$ is less than $n$, then if $p$ applied to $i$ is equal to $true$, then $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_aux_to_not_mod_O. For all elements $p$ and $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $r$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "axiom p_ord_aux_to_not_mod_O (p n m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_Type3. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1446$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to elements of $Type3$, for all functions $_H1$ from elements $x_823$ of $Lt$ of $x4$ and $x2$ and elements $x_822$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1447$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$, $P$ holds for $Hterm$.",
    "output": "Axiom div_mod_spec_inv_rect_Type3 : forall x1 : nat, forall x2 : nat, forall x3 : nat, forall x4 : nat, forall Hterm : div_mod_spec x1 x2 x3 x4, forall P : ((_z1446 : div_mod_spec x1 x2 x3 x4) -> Type3), forall _H1 : ((x_823 : x4 < x2) -> (x_822 : x1 = x3 * x2 + x4) -> (_z1447 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_823 x_822) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)), P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_a. For all natural numbers $a$ and $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than or equal to the sum of $a$ and $m$.",
    "output": "postulate le_plus_a : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Leq n (plus a m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_861$.",
    "output": "axiom Aop_ind (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_861)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_CProp3. For all sets $x1$, for all elements $Hterm$ of $range$ of $x1$, for all functions $P$ from elements $_z1674$ of $range$ of $x1$ to propositions, for all functions $_H1$ from functions $_enum$ from natural numbers to elements of $x1$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans and elements $_z1675$ of $Eq$ of $Hterm$ and $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $P$ of $mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $P$ holds for $Hterm$.",
    "output": "axiom range_inv_rect_CProp3 (x1 : Set) (Hterm : range x1) (P : (_z1674 : range x1) -> Prop) (_H1 : (_enum : (x__ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (x__ : Nat) -> bool) -> (_z1675 : Hterm = mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop. For all sets $x0$, for all elements $x1$ of $x0$, for all functions $x2$ from elements of $ACop$ of $x0$ and $x1$ to sets, for all elements $x3$ of $DPair$ of $ACop$ applied to $x0$ and $x1$ and $x2$, $Aop$ holds for $x0$ and $x1$.",
    "output": "dpi1__o__aop : x0 : Set -> x1 : x0 -> x2 : (__ : ACop x0 x1 -> Set) -> x3 : DPair (ACop x0 x1) x2 -> Aop x0 x1 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_CProp0. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1494$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_859$ of $Lt$ of $x4$ and $x2$ and elements $x_858$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1495$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_859$ and $x_858$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_859$ and $x_858$, $P$ holds for $Hterm$.",
    "output": "axiom div_mod_spec_inv_rect_CProp0 (x1 x2 x3 x4 : Nat) (Hterm : div_mod_spec x1 x2 x3 x4) (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) (_H1 : (x_859 : x4 < x2) -> (x_858 : x1 = x3 * x2 + x4) -> (_z1495 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_859 x_858) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nth_prime. For all natural numbers $__$, $Nat$.",
    "output": "Axiom nth_prime : forall x__ : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_primes. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "all_primes : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_881$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_881$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_881$.",
    "output": "axiom Aop_rect_CProp2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_881)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F3_ind_aux. For all elements $A1$ and $A2$ and $A3$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $A3$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation3$ applied to $A1$ and $A2$ and $A3$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $a3$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $a3$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $a3$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$.",
    "output": "Axiom f3_ind_aux : forall A1 : cic.Univ univs.Type0, forall A2 : cic.Univ univs.Type0, forall A3 : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> (__2 : cic.Term univs.Type0 A3) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall P : cic.Term univs.Type0 (matita_basics_relations.relation3 A1 A2 A3), forall __ : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (a3 : cic.Term univs.Type0 A3) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n)) -> cic.Term cic.prop (P a1 a2 a3)), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a1 : cic.Term univs.Type0 A1, forall a2 : cic.Term univs.Type0 A2, forall a3 : cic.Term univs.Type0 A3, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n), cic.Term cic.prop (P a1 a2 a3) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sqrt. For all natural numbers $n$, $n$ is less than the exponentiation of the sum of the square root of $n$ and $1$ and $2$.",
    "output": "lt_sqrt : n : Nat -> Lt n (pow (plus (sqrt n) (nd 1)) (nd 2)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_aux_0. For all natural numbers $n$ and $m$, $p_ord_aux$ applied to $0$ and $n$ and $m$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $0$ and $n$.",
    "output": "Axiom p_ord_aux_0 : forall n : nat, forall m : nat, p_ord_aux 0 n m = mk_Prod nat nat 0 n ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_m2. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $i$ and $b$, $Nat$.",
    "output": "Axiom let_m2 : forall f : ((x__ : nat) -> bool), forall n : nat, forall i : nat, forall b : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z299$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z300$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_107$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_107$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Not_inv_rect_CProp3 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop), forall _H1 : ((x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Antisymmetric_divides. For all natural numbers $n$ and $m$, if $n$ is divisible by $m$, then if $m$ is divisible by $n$, then $n$ is equal to $m$.",
    "output": "Axiom antisymmetric_divides : forall n : nat, forall m : nat, forall x__ : divisible n m, forall __1 : divisible m n, n = m ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Dop$ of $A$ and $nil$, $ACop$ holds for $A$ and $nil$.",
    "output": "Axiom sum_body : forall A : Set, forall nil : A, forall _xxx : Dop A nil, ACop A nil ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "K. For all elements $_n$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate k : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_conj$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_144$ and $x_143$, for all elements $x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_142$.",
    "output": "And_rect_Type0_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type0) -> _H_conj : (x_144 : cic.Term cic.prop _A -> x_143 : cic.Term cic.prop _B -> cic.Term univs.Type0 (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) -> x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type0 (Q_ x_142) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom option : forall _A : cic.Univ univs.Type0, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fst_eq. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $a$.",
    "output": "axiom fst_eq (A B : cic.Univ univs.Type0) (a : cic.Term univs.Type0 A) (b : cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_types.fst A B (matita_basics_types.mk_Prod A B a b)) a)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_631$, for all elements $x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_630$.",
    "output": "axiom option_rect_CProp1 (_A : cic.Univ univs.Type0) (Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) (x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_630)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_not_eq_O. For all elements $n$ and $p$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $r$ and $matita_arithmetics_nat.O$.",
    "output": "p_ord_to_not_eq_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime p)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_ind_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x$ and $p$.",
    "output": "Axiom eq_ind_r : forall A : cic.Univ univs.Type2, forall a : cic.Term univs.Type2 A, forall P : ((x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)), forall x : cic.Term univs.Type2 A, forall p : cic.Term cic.prop (matita_basics_logic.eq A x a), cic.Term cic.prop (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_minus_gcd. For all natural numbers $m$ and $n$, $ex$ holds for $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and the greatest common divisor of $n$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and the greatest common divisor of $n$ and $m$.",
    "output": "eq_minus_gcd : m : Nat -> n : Nat -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd n m)) (Eq (minus (times b m) (times a n)) (gcd n m)))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_smallest_factor_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.",
    "output": "Axiom le_smallest_factor_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_primes.smallest_factor n) n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_exp. For all natural numbers $n$ and $m$ and $p$, the product of the exponentiation of $n$ and $p$ and the exponentiation of $m$ and $p$ is equal to the exponentiation of the product of $n$ and $m$ and $p$.",
    "output": "axiom times_exp (n m p : Nat) : pow n p * pow m p = pow (n * m) p"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type2. For all functions $Q_$ from elements $_x_486$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $x_486$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_486$.",
    "output": "axiom void_rect_Type2 (Q_ : (_x_486 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type2) (x_486 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term univs.Type2 (Q_ x_486)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15623. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15623 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp3. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_154$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_156$ and $x_155$, for all elements $x_154$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_154$.",
    "output": "axiom And_rect_CProp3 (_A _B : cic.Univ cic.prop) (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_154)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_length_to_not_mem. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__1$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.Not$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $i$ and $l$.",
    "output": "lt_length_to_not_mem : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l) -> __1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.Not (matita_basics_lists_list.mem matita_arithmetics_nat.nat i l)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_905$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_905$.",
    "output": "postulate ACop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n. For all natural numbers $n$, $n$ is less than or equal to $n$.",
    "output": "Axiom le_n : forall n : nat, Leq n n ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Smallest_factor_to_min. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is equal to $min$ applied to $n$ and $2$ and the function that maps $m$ to $eqb$ applied to $mod$ applied to $n$ and $m$ and $0$.",
    "output": "postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\\ m : Nat -> eqb (mod n m) 0))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_prime_to_primeb_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$.",
    "output": "axiom not_prime_to_primeb_false (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $n$.",
    "output": "Axiom divides_to_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux p m n) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ and $K$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h2$ and $k2$ and $A$ and $J$ and $K$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "postulate transitive_sub : (h1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (K : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (__ : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h1 k1 A I J)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h2 k2 A J K)) -> cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> h2 (h1 x)) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k1 (k2 x)) A I K)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_pi_l. For all natural numbers $n$ and $a$, for all functions $f$ from natural numbers to natural numbers, the product of the exponentiation of $a$ and $n$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of $a$ and $f$ applied to $i$.",
    "output": "postulate exp_pi_l : (n : Nat) -> (a : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (times (pow a n) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> f i))) (bigop n (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> times a (f i)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_Type4. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1440$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1441$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "Axiom div_mod_spec_inv_rect_Type4 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4), forall _H1 : ((x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))), cic.Term univs.Type4 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_minl. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$.",
    "output": "le_minl : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le i n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_times_l. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $m$ and $n$.",
    "output": "postulate injective_times_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times m n))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1686. For all natural numbers $n$ and $m$, for all functions $Hind$ from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi$ applied to $p$ and the product of $pred$ applied to $p$ and the exponentiation of $2$ and the difference of the product of $2$ and $p$ and $3$, for all natural numbers $a$, if $m$ is equal to the product of $2$ and $a$ or $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $1$ is less than the sum of the product of $2$ and $a$ and $1$, then if $0$ is less than $a$, then $pred$ applied to $m$ is equal to the sum of $a$ and $a$.",
    "output": "Axiom let_clause_1686 : forall n : nat, forall m : nat, forall Hind : ((p : nat) -> (x__ : p < m) -> (__1 : 1 < p) -> Leq (Psi p) (pred p * pow 2 (2 * p - 3))), forall a : nat, forall _clearme : (m = 2 * a \\/ m = 2 * a + 1), forall Hm : (m = 2 * a + 1), forall Hlt : (1 < 2 * a + 1), forall Ha : (0 < a), pred m = a + a ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom plus_O_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Type0. $cic.Sort$.",
    "output": "Axiom Type0 : cic.Sort ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_BPsi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "le_Psi_BPsi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_S_to_permut_transpose. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $m$, for all elements $__$ of $permut$ of $f$ and the sum of $m$ and $1$, $permut$ holds for the function that maps $n$ to $transpose$ applied to $f$ applied to the sum of $m$ and $1$ and the sum of $m$ and $1$ and $f$ applied to $n$ and $m$.",
    "output": "postulate permut_S_to_permut_transpose : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> permut (\\ n : Nat -> transpose (f (plus m 1)) (plus m 1) (f n)) m"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_spec_inv_ind. For all elements $x1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $x1$ and $x2$ and $x3$, for all functions $P$ from elements $_z1769$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $x1$ and elements $_x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1770$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$, for all functions $_H2$ from functions $_x_976$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1770$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x3$.",
    "output": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 m)) -> cic.Term cic.prop (P m)) -> (_H2 : (_x_976 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P x3)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "mod_times : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10471. For all natural numbers $n1$ and $n2$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f1$ and $f2$ from natural numbers to elements of $B$, for all elements $_clearme$ of $iso$ of $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, for all functions $h$ from natural numbers to natural numbers, for all elements $_clearme0$ of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$, for all functions $k$ from natural numbers to natural numbers, if $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $sub_hk$ holds for $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ holds for $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$, then if $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ holds for $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, then for all functions $same$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, for all natural numbers $i$ and $m$, for all functions $Hind$ from functions $f$ from natural numbers to booleans and elements of $Leq$ of $0$ and $n1$ and elements $__1$ of $sub_hk$ of $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $0$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and elements $__2$ of $sub_hk$ of $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $m$ and $f$ and $mk_range$ applied to $B$ and $f1$ and $0$ and $p1$ to elements of $Eq$ of $bigop$ applied to $0$ and the function that maps $i0$ to $p1$ applied to $i0$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f1$ applied to $i0$ and $bigop$ applied to $m$ and the function that maps $i0$ to $f$ applied to $i0$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i0$ to $f2$ applied to $i0$, for all functions $p20$ from natural numbers to booleans, if $0$ is less than or equal to $n1$, then for all elements $sub1$ of $sub_hk$ of $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $0$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and the sum of $m$ and $1$ and $p20$, for all elements $sub2$ of $sub_hk$ of $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and the sum of $m$ and $1$ and $p20$ and $mk_range$ applied to $B$ and $f1$ and $0$ and $p1$, for all natural numbers $x2571$ and $x2572$, $x2571$ is equal to the sum of the product of $x2572$ and the quotient of $x2571$ and $x2572$ and $mod$ applied to $x2571$ and $x2572$.",
    "output": "axiom let_clause_10471 (n1 n2 : Nat) (p1 p2 : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : ACop B nil) (f1 f2 : (x__ : Nat) -> B) (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (h : (x__ : Nat) -> Nat) (_clearme0 : ex (prod Set Set Nat (λ x__ => Nat)) (λ k => prod Set Prop Nat (λ i => prod Prop Prop (i < n1) (λ x__ => prod Prop Prop (p1 i = true) (λ __1 => f1 i = f2 (h i)))) ∧ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) ∧ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) (k : (x__ : Nat) -> Nat) (_clearme1 : prod Set Prop Nat (λ i => prod Prop Prop (i < n1) (λ x__ => prod Prop Prop (p1 i = true) (λ __1 => f1 i = f2 (h i)))) ∧ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) ∧ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)) (_clearme2 : prod Set Prop Nat (λ i => prod Prop Prop (i < n1) (λ x__ => prod Prop Prop (p1 i = true) (λ __1 => f1 i = f2 (h i)))) ∧ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (same : (i : Nat) -> (x__ : i < n1) -> (__1 : p1 i = true) -> f1 i = f2 (h i)) (i m : Nat) (Hind : (f : (x__ : Nat) -> bool) -> (x__ : 0 ≤ n1) -> (__1 : sub_hk h k B (mk_range B f1 0 p1) (mk_range B f2 m f)) -> (__2 : sub_hk k h B (mk_range B f2 m f) (mk_range B f1 0 p1)) -> bigop 0 (λ i0 => p1 i0) B nil (aop__o__op B nil op) (λ i0 => f1 i0) = bigop m (λ i0 => f i0) B nil (aop__o__op B nil op) (λ i0 => f2 i0)) (p20 : (x__ : Nat) -> bool) (x__ : 0 ≤ n1) (sub1 : sub_hk h k B (mk_range B f1 0 p1) (mk_range B f2 (m + 1) p20)) (sub2 : sub_hk k h B (mk_range B f2 (m + 1) p20) (mk_range B f1 0 p1)) (x2571 x2572 : Nat) : x2571 = x2572 * (x2571 / x2572) + mod x2571 x2572"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bertrand. For all natural numbers $n$, if $0$ is less than $n$, then $bertrand$ holds for $n$.",
    "output": "bertrand : n : Nat -> __ : Lt 0 n -> bertrand n ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "Axiom lt_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_pred. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $matita_arithmetics_nat.pred$.",
    "output": "monotonic_pred : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le matita_arithmetics_nat.pred) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_exp1. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $n$ is less than $m$, then the exponentiation of $n$ and $p$ is less than the exponentiation of $m$ and $p$.",
    "output": "Axiom lt_exp1 : forall n : nat, forall m : nat, forall p : nat, forall x__ : (0 < p), forall __1 : (n < m), pow n p < pow m p ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1728$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1729$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "Axiom Dop_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1728 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type0), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1729 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Relation. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom relation : forall __ : cic.Univ univs.Type0, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_SO_n. For all natural numbers $n$, the greatest common divisor of $1$ and $n$ is equal to $1$.",
    "output": "postulate gcd_SO_n : (n : Nat) -> Eq (gcd 1 n) 1"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "bijn : __ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iter. For all sets $H$, for all functions $__$ from elements of $H$ to elements of $H$, for all natural numbers $__1$, for all elements $__2$ of $H$, $H$.",
    "output": "Axiom iter : forall H : Set, forall x__ : ((x__ : H) -> H), forall __1 : nat, forall __2 : H, H ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_length_to_mem. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__2$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $n$ and $l$.",
    "output": "eq_length_to_mem : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) (matita_arithmetics_nat.S n)) -> __1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l) -> __2 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l) -> cic.Term cic.prop (matita_arithmetics_nat.le x n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_O_S. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "not_eq_O_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.S n))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus1. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$.",
    "output": "Axiom plus_minus1 : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le c b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a b) c)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $m$ and $n$ and $q$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.",
    "output": "axiom div_mod_spec_to_divides (n m q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n q matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_primes.divides n m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type0_body. For all functions $Q_$ from elements $_x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_488$.",
    "output": "axiom void_rect_Type0_body (Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type0) (x_488 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term univs.Type0 (Q_ x_488)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_953$ of $Dop$ of $A$ and $_nil$ to elements of $Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "FactS. For all natural numbers $n$, the factorial of the sum of $n$ and $1$ is equal to the product of the sum of $n$ and $1$ and the factorial of $n$.",
    "output": "Axiom factS : forall n : nat, factorial (n + 1) = (n + 1) * factorial n ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_minus. For all natural numbers $n$ and $m$ and $p$, if $p$ is less than or equal to $m$, then if $m$ is less than or equal to $n$, then the sum of $p$ and the difference of $n$ and $m$ is equal to the difference of $n$ and the difference of $m$ and $p$.",
    "output": "axiom minus_minus (n m p : Nat) (x__ : p ≤ m) (__1 : m ≤ n) : p + (n - m) = n - (m - p)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type2. For all functions $Q_$ from elements $_x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_I$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_48$.",
    "output": "postulate True_rect_Type2 : (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) -> (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) -> (x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type2 (Q_ x_48)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop110. For all instances $a$ and $c$ of integers, if we can prove that $a$ is odd and $c$ is odd, then we can prove that for all integers $b$, the sum of the product of $a$ and $b$ and the product of $b$ and $c$ is even.",
    "output": "axiom prop110 (a c : Int) (x : odd a ∧ odd c) : ∀ b : Int, even (a * b + b * c)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_exp_r. For all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $b$ and $i$.",
    "output": "injective_exp_r : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp b i)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bc1. For all elements $n$ and $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $k$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $k$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_binomial.bc$ applied to $n$ and $k$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $k$.",
    "output": "postulate bc1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt k n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S k)) (matita_arithmetics_nat.plus (matita_arithmetics_binomial.bc n k) (matita_arithmetics_binomial.bc n (matita_arithmetics_nat.S k))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "axiom Aop_rect_Type3 (A : Set) (_nil : A) (Q_ : (_x_867 : Aop A _nil) -> Type3) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_867 : Aop A _nil) : Q_ x_867"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_mod_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "axiom divides_mod_gcd (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_S. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "postulate lt_O_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_nat.S n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp1. For all elements $n$ and $m$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $a$ and $matita_arithmetics_exp.exp$ applied to $m$ and $a$.",
    "output": "postulate le_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n a) (matita_arithmetics_exp.exp m a))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bk. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom Bk : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_to_divides. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then for all elements $__1$ of $congruent$ of $n$ and $m$ and $p$, $p$ is divisible by the difference of $n$ and $m$.",
    "output": "congruent_to_divides : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : congruent n m p -> divisible p (minus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "axiom lt_to_leb_false (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type3. For all functions $Q_$ from elements $_x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_O$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_380$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, for all elements $x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_377$.",
    "output": "postulate nat_rect_Type3 : (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type3 (Q_ x_377)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n. For all natural numbers $n$, $prim$ applied to $n$ is less than or equal to $n$.",
    "output": "le_prim_n : n : Nat -> Leq (prim n) n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $g$.",
    "output": "min_f_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_le. $transitive$ holds for $Nat$ and $Leq$.",
    "output": "transitive_le : transitive Nat Leq ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Psi'. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate Psi' : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_ind_body. For all functions $Q_$ from natural numbers $_x_365$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_366$ and elements $_x_368$ of $Q_$ of $x_366$ to elements of $Q_$ of the sum of $x_366$ and $1$, for all natural numbers $x_365$, $Q_$ holds for $x_365$.",
    "output": "postulate nat_ind_body : (Q_ : (_x_365 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_366 : Nat) -> (_x_368 : Q_ x_366) -> Q_ (plus x_366 1)) -> (x_365 : Nat) -> Q_ x_365"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_not_bertrand_to_bertrand1. For all natural numbers $n$, if it is not the case that $not_bertrand$ holds for $n$, then for all natural numbers $x$, if $n$ is less than or equal to $x$, then if $x$ is less than or equal to the product of $2$ and $n$, then for all functions $__3$ from natural numbers $p$ and elements $__3$ of $Lt$ of $x$ and $p$ and elements $__4$ of $Leq$ of $p$ and the product of $2$ and $n$ to elements of $not$ of $prime$ applied to $p$, $ex$ holds for $Nat$ and the function that maps $p$ to the conjunction of the conjunction of $Lt$ applied to $n$ and $p$ and $Leq$ applied to $p$ and $x$ and $prime$ applied to $p$.",
    "output": "not_not_bertrand_to_bertrand1 : n : Nat -> __ : not (not_bertrand n) -> x : Nat -> __1 : Leq n x -> __2 : Leq x (times (nd 2) n) -> __3 : (p : Nat -> __3 : Lt x p -> __4 : Leq p (times (nd 2) n) -> not (prime p)) -> ex Nat (p : Nat => and (and (Lt n p) (Leq p x)) (prime p)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_iso. For all elements $n1$ and $n2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f1$ and $f2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f2$ applied to $i$.",
    "output": "Axiom bigop_iso : forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall p2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil), forall f1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall f2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall __ : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n1 (fun i => p1 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (fun i => f1 i)) (matita_arithmetics_bigops.bigop n2 (fun i => p2 i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (fun i => f2 i))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_lop. For all natural numbers $n$, if $1$ is less than or equal to $n$, then $list_of_primes$ applied to $n$ is equal to $cons$ applied to $Nat$ and $2$ and $tail$ applied to $Nat$ and $list_of_primes$ applied to $n$.",
    "output": "Axiom eq_lop : forall n : nat, forall x__ : Leq 1 n, list_of_primes n = cons nat 2 (tail nat (list_of_primes n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_903$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_903$.",
    "output": "ACop_rect_CProp4_body : A : Set -> _nil : A -> Q_ : (_x_903 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_903 : ACop A _nil -> Q_ x_903 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primeb. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "axiom primeb (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp2. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_109$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_110$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_110$, for all elements $x_109$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_109$.",
    "output": "postulate Not_rect_CProp2 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_110 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))) -> (x_109 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_109)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "Axiom iso : forall A : Set, relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dividesb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "axiom dividesb (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z365$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z366$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate And_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_156 : cic.Term cic.prop x1) -> (x_155 : cic.Term cic.prop x2) -> (_z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_trans. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $C$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $C$.",
    "output": "postulate iff_trans : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) -> cic.Term cic.prop (matita_basics_logic.iff A C)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_fact. For all natural numbers $n$ and $i$, if $0$ is less than $i$, then if $i$ is less than or equal to $n$, then $i$ is divisible by the factorial of $n$.",
    "output": "Axiom divides_fact : forall n : nat, forall i : nat, forall x__ : (0 < i), forall __1 : Leq i n, divisible i (factorial n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.",
    "output": "postulate Sig_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_lt. For all natural numbers $n$ and $m$, $decidable$ holds for $Lt$ applied to $n$ and $m$.",
    "output": "decidable_lt : n : Nat -> m : Nat -> decidable (Lt n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Associative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.associative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate associative_plus : cic.Term cic.prop (matita_basics_relations.associative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "list_divides_false : l : list Nat -> n : Nat -> __ : Eq (list_divides l n) false -> p : Nat -> __1 : mem Nat p l -> not (divisible p n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.",
    "output": "Axiom Dop_rect_CProp3_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_961 : Dop A _nil) -> Prop), forall _H_mk_Dop : ((sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)), forall x_961 : Dop A _nil, Q_ x_961 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mdef. For all natural numbers $m$, $M$ applied to $m$ is equal to $bc$ applied to the sum of the product of $2$ and $m$ and $1$ and $m$.",
    "output": "postulate Mdef : (m : Nat) -> Eq (M m) (bc (plus (times 2 m) 1) m)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_False. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $return_sort$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_False : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort), forall z : cic.Term cic.prop matita_basics_logic.False, cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_n. For all natural numbers $n$ and $m$, $m$ is less than or equal to the sum of $n$ and $m$.",
    "output": "le_plus_n : n : Nat -> m : Nat -> Leq m (plus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nilr_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $a$.",
    "output": "axiom nilr_body (A : Set) (nil : A) (xxx : Aop A nil) (a : A) : op A nil xxx a nil = a"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_exp5. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "le_Psi_exp5 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_ind_plus. For all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $n$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $n$.",
    "output": "Axiom nat_ind_plus : forall R : cic.Term univs.Type0 (matita_basics_relations.predicate matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (R matita_arithmetics_nat.O), forall __1 : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (R n)) -> cic.Term cic.prop (R (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (R n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_times_div_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $n$.",
    "output": "axiom le_times_div_m_m (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $permut$ of $f$ and $n$, $injn$ holds for $invert_permut$ applied to $n$ and $f$ and $n$.",
    "output": "injective_invert_permut : f : (__ : Nat -> Nat) -> n : Nat -> __ : permut f n -> injn (invert_permut n f) n ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_I_gen. For all natural numbers $a$ and $b$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a$ is less than or equal to $b$, then $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$ is equal to $bigop$ applied to $b$ and the function that maps $i$ to $andb$ applied to $leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_div_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$.",
    "output": "lt_div_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m)) m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pos_div. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.",
    "output": "postulate pos_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_939$.",
    "output": "Axiom range_rect_CProp0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_939) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_exp_r. For all natural numbers $b$, if $1$ is less than $b$, then $injective$ holds for $Nat$ and $Nat$ and the function that maps $i$ to the exponentiation of $b$ and $i$.",
    "output": "Axiom injective_exp_r : forall b : nat, forall x__ : (1 < b), injective nat nat (fun i => pow b i) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_Psi_Psi'. For all natural numbers $n$, $Psi$ applied to $n$ is equal to $Psi'$ applied to $n$.",
    "output": "eq_Psi_Psi' : n : Nat -> Eq (Psi n) (Psi' n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_range. For all sets $_A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $return_type$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.",
    "output": "postulate match_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (case_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> (z : range _A) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bc_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate bc_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_rect_Type1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z996$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_547$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$, for all functions $_H2$ from elements $x_548$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Sum_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ univs.Type1) -> _H1 : (x_547 : cic.Term univs.Type0 x1 -> _z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547)) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) -> _H2 : (x_548 : cic.Term univs.Type0 x2 -> _z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548)) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_31$ and $x_32$.",
    "output": "postulate eq_rect_CProp2 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_31 : cic.Term univs.Type2 A) -> (x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Term cic.prop (Q_ x_31 x_32)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_957$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_957$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_957$.",
    "output": "Axiom Dop_rect_CProp4_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_957) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_to_nat_body. For all elements $_b$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate bool_to_nat_body : (_b : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp4_body. For all functions $Q_$ from elements $_x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_509$.",
    "output": "axiom unit_rect_CProp4_body (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_509 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_509)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $m$.",
    "output": "plus_minus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp4_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_929$.",
    "output": "postulate range_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_929)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inv_ltransitive. For all elements $B$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__$ to $matita_basics_relations.relation$ applied to $B$.",
    "output": "inv_ltransitive : B : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_relations.predicate (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_relations.relation B))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Orb_true_l. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "Axiom orb_true_l : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp0. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_168$ and $x_167$, for all elements $x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_166$.",
    "output": "And_rect_CProp0 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_168 : cic.Term cic.prop _A -> x_167 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) -> x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_166) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_CProp3_body. For all functions $Q_$ from elements $_x_513$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_513$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_513$.",
    "output": "axiom unit_rect_CProp3_body (Q_ : (_x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_513 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_513)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type1_body. For all functions $Q_$ from elements $_x_487$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $x_487$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_487$.",
    "output": "Axiom void_rect_Type1_body : forall Q_ : ((_x_487 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type1), forall x_487 : cic.Term univs.Type0 matita_basics_types.void, cic.Term univs.Type1 (Q_ x_487) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn_transpose. For all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$.",
    "output": "Axiom bijn_transpose : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le j n), cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp3. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1608$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1609$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.",
    "output": "postulate ACop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1608 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1609 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Natural numbers are a basic type.",
    "output": "Nat : Type ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_to_le_theta_exp_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "lt_O_to_le_theta_exp_theta : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m)))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z972$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_522$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z973$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_522$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_522$, for all functions $_H2$ from elements $x_523$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z973$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_523$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_523$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Sum_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z972 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_522 : cic.Term univs.Type0 x1) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_522))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_522))), forall _H2 : ((x_523 : cic.Term univs.Type0 x2) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_523))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_body. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "postulate minus_body : (_ : Nat) -> (__1 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb5. For all natural numbers $n$, if $1$ is less than $n$, then $bigop$ applied to the sum of the product of $2$ and $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and the product of $2$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$.",
    "output": "Axiom pi_p_primeb5 : forall n : nat, forall x__ : (1 < n), bigop (2 * n + 1) (fun p => primeb p) nat 1 times (fun p => bigop (log p (2 * n)) (fun i => true) nat 1 times (fun i => pow p (2 * (n / pow p (i + 1))))) = bigop (n + 1) (fun p => primeb p) nat 1 times (fun p => bigop (log p n) (fun i => true) nat 1 times (fun i => pow p (2 * (n / pow p (i + 1))))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_rem. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "Axiom ord_rem : forall x__ : nat, forall __1 : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_times_gcd_aux. For all natural numbers $p$ and $m$ and $n$ and $d$ and $c$, if $0$ is less than $c$, then if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then if $d$ is divisible by the product of $c$ and $m$, then if $d$ is divisible by the product of $c$ and $n$, then $d$ is divisible by the product of $c$ and $gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "Axiom divides_times_gcd_aux : forall p : nat, forall m : nat, forall n : nat, forall d : nat, forall c : nat, forall x__ : (0 < c), forall __1 : (0 < n), forall __2 : Leq n m, forall __3 : Leq n p, forall __4 : divisible d (c * m), forall __5 : divisible d (c * n), divisible d (c * gcd_aux p m n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $n$.",
    "output": "Axiom divides_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_primes.divides n n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "Axiom Aop_rect_Type0 : forall A : Set, forall _nil : A, forall Q_ : ((_x_873 : Aop A _nil) -> Set), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_873 : Aop A _nil, Q_ x_873 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Upto. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate upto : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ and $x2$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$.",
    "output": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_ord. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$ and $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$.",
    "output": "Axiom exp_ord : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)) (matita_arithmetics_ord.ord_rem n p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.",
    "output": "postulate cr_pair1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.O matita_arithmetics_nat.O) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_O_to_not_divides. For all natural numbers $p$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $ord$ applied to $m$ and $p$ is equal to $0$, then $p$ is not divisible by $m$.",
    "output": "Axiom ord_O_to_not_divides : forall p : nat, forall m : nat, forall x__ : (0 < m), forall __1 : prime p, forall __2 : (ord m p = 0), ~ divisible p m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_iter2. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $i$ and $j$, for all functions $__$ from natural numbers $x$ to elements of $Leq$ of $x$ and $g$ applied to $x$, if $i$ is less than or equal to $j$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $j$ and $a$.",
    "output": "monotonic_iter2 : g : (__ : Nat -> Nat) -> a : Nat -> i : Nat -> j : Nat -> __ : (x : Nat -> Leq x (g x)) -> __1 : Leq i j -> Leq (iter Nat g i a) (iter Nat g j a) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Succ. If $Sort$, then $Sort$.",
    "output": "axiom succ (x : Sort) : Sort"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "example1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_SO. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.",
    "output": "axiom log_SO (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Length_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_arithmetics_nat.plus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$.",
    "output": "length_append : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 l2)) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_n_Sm. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "axiom times_n_Sm (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.times n (matita_arithmetics_nat.S m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_div. For all elements $d$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $n$.",
    "output": "postulate divides_div : (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_div_and_mod.div n d) n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_max_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $n$.",
    "output": "lt_max_n : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_theta. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$.",
    "output": "axiom lt_O_theta (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_to_bijn. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $i$ and $g$ applied to $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $g$ and $n$.",
    "output": "eq_to_bijn : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f i) (g i))) -> __1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn g n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_965$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_965$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_965$.",
    "output": "postulate Dop_rect_CProp1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $f$, $cic.Term$ holds for $cic.prop$ and $f$ applied to $matita_basics_types.pi1$ applied to $A$ and $f$ and $xxx$.",
    "output": "axiom pi2 (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) : cic.Term cic.prop (f (matita_basics_types.pi1 A f xxx))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_minus_S_pred. For all natural numbers $n$ and $m$, the difference of $n$ and the sum of $m$ and $1$ is equal to $pred$ applied to the difference of $n$ and $m$.",
    "output": "axiom eq_minus_S_pred (n m : Nat) : n - (m + 1) = pred (n - m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_sub. For all functions $h1$ and $k1$ and $h2$ and $k2$ from natural numbers to natural numbers, for all sets $A$, for all elements $I$ and $J$ and $K$ of $range$ of $A$, for all elements $__$ of $sub_hk$ of $h1$ and $k1$ and $A$ and $I$ and $J$, for all elements $__1$ of $sub_hk$ of $h2$ and $k2$ and $A$ and $J$ and $K$, $sub_hk$ holds for the function that maps $x$ to $h2$ applied to $h1$ applied to $x$ and the function that maps $x$ to $k1$ applied to $k2$ applied to $x$ and $A$ and $I$ and $K$.",
    "output": "axiom transitive_sub (h1 k1 h2 k2 : (x__ : Nat) -> Nat) (A : Set) (I J K : range A) (x__ : sub_hk h1 k1 A I J) (__1 : sub_hk h2 k2 A J K) : sub_hk (λ x => h2 (h1 x)) (λ x => k1 (k2 x)) A I K"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_to_le_max. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $m$ is less than $n$, then if $f$ applied to $m$ is equal to $true$, then $m$ is less than or equal to $max$ applied to $n$ and $f$.",
    "output": "axiom true_to_le_max (f : (x__ : Nat) -> bool) (n m : Nat) (x__ : m < n) (__1 : f m = true) : m ≤ max n f"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_ord_rem. For all elements $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$.",
    "output": "Axiom not_divides_ord_rem : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_ord.ord_rem m p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Sum. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Sum : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Natural numbers are a basic type.",
    "output": "postulate Nat : Set"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z677$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z678$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_388$ from elements $_z678$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_386$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $x_386$ and elements $_z678$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_386$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_386$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "postulate nat_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z677 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type1) -> (_H1 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type1 (P matita_arithmetics_nat.O)) -> (_H2 : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_388 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_386)) -> cic.Term univs.Type1 (P x_386)) -> (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_386))) -> cic.Term univs.Type1 (P (matita_arithmetics_nat.S x_386))) -> cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "Axiom lstar_lstar_r : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_S. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.",
    "output": "postulate lstar_S : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_fact_n. For all natural numbers $n$, $n$ is less than or equal to the factorial of $n$.",
    "output": "axiom le_n_fact_n (n : Nat) : n ≤ factorial n"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S_S. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then the sum of $n$ and $1$ is less than or equal to the sum of $m$ and $1$.",
    "output": "axiom le_S_S (n m : Nat) (x__ : n ≤ m) : n + 1 ≤ m + 1"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fst. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "axiom fst (A B : cic.Univ univs.Type0) (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) : cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp4. For all functions $Q_$ from natural numbers $_x_393$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_394$ and elements $_x_396$ of $Q_$ of $x_394$ to elements of $Q_$ of the sum of $x_394$ and $1$, for all natural numbers $x_393$, $Q_$ holds for $x_393$.",
    "output": "axiom nat_rect_CProp4 (Q_ : (_x_393 : Nat) -> Prop) (_H_O : Q_ 0) (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (x_394 + 1)) (x_393 : Nat) : Q_ x_393"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "LePsi_prim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "Axiom lePsi_prim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => p)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_Conf3. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $matita_arithmetics_lstar.lstar$ applied to $A$ and $R$ and $l$.",
    "output": "axiom lstar_Conf3 (A B : cic.Univ univs.Type0) (S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B)) (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) (__ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_lstar_r. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $lstar_r$ holds for $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "postulate lstar_lstar_r : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> lstar_r B R l b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_priml. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "le_priml : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_73. For all elements $x$ and $y$ and $z$ and $x134$ and $x135$ and $x136$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $x136$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $x136$.",
    "output": "postulate let_clause_73 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "Axiom le_to_le_to_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primeb_true_to_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$.",
    "output": "axiom primeb_true_to_prime (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true)) : cic.Term cic.prop (matita_arithmetics_primes.prime n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_times. For all elements $p$ and $a$ and $b$ and $qa$ and $ra$ and $qb$ and $rb$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qb$ and $rb$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $qa$ and $qb$ and $matita_arithmetics_nat.times$ applied to $ra$ and $rb$.",
    "output": "Axiom p_ord_times : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall qa : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall ra : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall qb : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall rb : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra)), forall __4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.plus qa qb) (matita_arithmetics_nat.times ra rb))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Predicate. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom predicate : forall __ : cic.Univ univs.Type0, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_gcd_SO_to_not_divides. For all natural numbers $n$ and $m$, if $1$ is less than $n$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then $n$ is not divisible by $m$.",
    "output": "axiom eq_gcd_SO_to_not_divides (n m : Nat) (x__ : 1 < n) (__1 : gcd n m = 1) : ¬ divisible n m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Append_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "append_body : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp4. For all functions $Q_$ from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.",
    "output": "axiom bool_rect_CProp4 (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_347)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_861$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_861$.",
    "output": "postulate Aop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_861 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_861 : Aop A _nil) -> Q_ x_861"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_Type2. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z671$ to elements of $Type2$, for all functions $_H1$ from elements $_z672$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_382$ and functions $_x_384$ from elements $_z672$ of $Eq$ of $Hterm$ and $x_382$ to elements of $P$ of $x_382$ and elements $_z672$ of $Eq$ of $Hterm$ and the sum of $x_382$ and $1$ to elements of $P$ of the sum of $x_382$ and $1$, $P$ holds for $Hterm$.",
    "output": "postulate nat_inv_rect_Type2 : (Hterm : Nat) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_nmk$ from functions $x_89$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_89$, for all elements $x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_88$.",
    "output": "axiom Not_rect_Type3 (_A : cic.Univ cic.prop) (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type3 (Q_ x_88)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.",
    "output": "list_rect_Type3 : _A : cic.Univ univs.Type0 -> Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type3) -> _H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_733 : cic.Term univs.Type0 _A -> x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_735 : cic.Term univs.Type3 (Q_ x_732) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) -> x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type3 (Q_ x_731) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.",
    "output": "Axiom Prod_rect_Type3 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type3 (Q_ x_696) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type0_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "Aop_rect_Type0_body : A : Set -> _nil : A -> Q_ : (_x_873 : Aop A _nil -> Set) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_873 : Aop A _nil -> Q_ x_873 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "It. $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.unit$.",
    "output": "postulate it : cic.Term univs.Type0 matita_basics_types.unit"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_rev_len. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ and $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $acc$.",
    "output": "Axiom split_rev_len : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_arithmetics_nat.plus n (matita_basics_lists_list.length A acc))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp5_body. For all sets $_A$, for all functions $Q_$ from elements $_x_931$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $range$ of $_A$, $Q_$ holds for $x_931$.",
    "output": "range_rect_CProp5_body : _A : Set -> Q_ : (_x_931 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_931 : range _A -> Q_ x_931 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod. For all natural numbers $n$ and $m$, $n$ is equal to the sum of the product of the quotient of $n$ and $m$ and $m$ and $mod$ applied to $n$ and $m$.",
    "output": "Axiom div_mod : forall n : nat, forall m : nat, n = n / m * m + mod n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example7. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_bool.true$.",
    "output": "example7 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_S_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "Axiom lt_S_S_to_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)), cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_fact_10. The factorial of the product of $2$ and $5$ is less than or equal to the product of the product of the exponentiation of $2$ and the difference of the product of $2$ and $5$ and $2$ and the factorial of $5$ and the factorial of $5$.",
    "output": "Axiom le_fact_10 : Leq (factorial (2 * 5)) (pow 2 (2 * 5 - 2) * factorial 5 * factorial 5) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_coerc. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.succ$ applied to $univs.Type0$ and $univs.Type2$ and $cic.univ$ applied to $univs.Type0$ and $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate eq_coerc : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift (cic.succ univs.Type0) univs.Type2 (cic.univ univs.Type0)) A B)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing. For all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom increasing : forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "divides_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. For all elements $n$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ProdF. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_m$ and $_x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$.",
    "output": "Axiom prodF : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall _g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _x : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_types.Prod A B) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leb_body. For all natural numbers $__$ and $__1$, $bool$.",
    "output": "axiom leb_body (x__ __1 : Nat) : bool"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom ex2 : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z972$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_522$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z973$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_522$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_522$, for all functions $_H2$ from elements $x_523$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z973$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_523$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_523$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Sum_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z972 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_522 : cic.Term univs.Type0 x1) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_522))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_522))) -> (_H2 : (x_523 : cic.Term univs.Type0 x2) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_log_exp. For all natural numbers $p$ and $n$, if $1$ is less than $p$, then the logarithm of $p$ and the exponentiation of $p$ and $n$ is equal to $n$.",
    "output": "Axiom eq_log_exp : forall p : nat, forall n : nat, forall x__ : (1 < p), log p (pow p n) = n ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_exp1. For all natural numbers $n$, $Psi$ applied to the exponentiation of $2$ and $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and the exponentiation of $2$ and $n$ and the sum of $n$ and $2$.",
    "output": "Axiom le_Psi_exp1 : forall n : nat, Leq (Psi (pow 2 n)) (pow 2 (2 * pow 2 n - (n + 2))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type2_body. For all functions $Q_$ from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.",
    "output": "unit_rect_Type2_body : Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it) -> x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type2 (Q_ x_503) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_n_fact_n. For all natural numbers $n$, if $2$ is less than $n$, then $n$ is less than the factorial of $n$.",
    "output": "Axiom lt_n_fact_n : forall n : nat, forall x__ : (2 < n), n < factorial n ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_lt_plus_l. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $m$ to $matita_arithmetics_nat.plus$ applied to $m$ and $n$.",
    "output": "postulate monotonic_lt_plus_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Associative_times. $associative$ holds for $Nat$ and $times$.",
    "output": "postulate associative_times : associative Nat times"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_881$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_881$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_881$.",
    "output": "Aop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_881 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_881 : Aop A _nil -> Q_ x_881 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_div. For all natural numbers $n$ and $m$ and $d$, if $0$ is less than $d$, then if $d$ is divisible by $n$, then if $d$ is divisible by $m$, then the quotient of the sum of $n$ and $m$ and $d$ is equal to the sum of the quotient of $n$ and $d$ and the quotient of $m$ and $d$.",
    "output": "plus_div : n : Nat -> m : Nat -> d : Nat -> __ : Lt 0 d -> __1 : divisible d n -> __2 : divisible d m -> Eq (div (plus n m) d) (plus (div n d) (div m d)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15311. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then if $n$ is divisible by $m$, then for all natural numbers $d$ and $p$, if $m$ is equal to the product of $n$ and the sum of $p$ and $1$, then $m$ is equal to the sum of $n$ and the product of $n$ and $p$.",
    "output": "let_clause_15311 : n : Nat -> m : Nat -> posm : Lt 0 m -> _clearme : divisible n m -> d : Nat -> p : Nat -> eqm : Eq m (times n (plus p (nd 1))) -> Eq m (plus n (times n p)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_lstar_r. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all natural numbers $__$, for all elements $__1$ and $__2$ of $B$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_type$ of $z$, for all elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$, $return_type$ holds for $z$.",
    "output": "postulate filter_lstar_r : (B : Set) -> (_R : relation B) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (return_sort : Sort) -> (return_type : (z : lstar_r B _R __ __1 __2) -> return_sort) -> (return : (z : lstar_r B _R __ __1 __2) -> return_type z) -> (z : lstar_r B _R __ __1 __2) -> return_type z"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing_to_monotonic. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and $f$.",
    "output": "Axiom increasing_to_monotonic : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt f) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_bertrand_to_le2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom not_bertrand_to_le2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $x1$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x4$ and $x5$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from elements $_z2386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_z2385$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2384$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ and elements $_z2388$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b$ and elements $_z2387$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$, for all functions $_H2$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $x1$ and $x2$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_x_1339$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $b$ and $b2$ and functions $_x_1342$ from elements $_z2389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $l$ and elements $_z2388$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b1$ and elements $_z2387$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b1$ and $b$ and elements $_z2389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and elements $_z2388$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b1$ and elements $_z2387$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x3$ and $x4$ and $x5$.",
    "output": "Axiom lstar_r_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1), forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 x1, forall x5 : cic.Term univs.Type0 x1, forall _Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r x1 x2 x3 x4 x5), forall P : ((_z2386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_z2385 : cic.Term univs.Type0 x1) -> (_z2384 : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall _H1 : ((b : cic.Term univs.Type0 x1) -> (_z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> (_z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b)) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)), forall _H2 : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (_x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r x1 x2 l b1 b)) -> (b2 : cic.Term univs.Type0 x1) -> (_x_1339 : cic.Term cic.prop (x2 b b2)) -> (_x_1342 : (_z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 l)) -> (_z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b1)) -> (_z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b)) -> cic.Term cic.prop (P l b1 b)) -> (_z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (_z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b1)) -> (_z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b2)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)), cic.Term cic.prop (P x3 x4 x5) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Sig : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_49. For all instances $x$ and $y$ of integers, we can prove that if the product of $x$ and $y$ is odd, then $x$ is odd and $y$ is odd.",
    "output": "Axiom noLabel_49 : forall x : Int, forall y : Int, (odd (x * y) -> odd x /\\ odd y) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_883$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_883$.",
    "output": "Axiom Aop_rect_CProp1 : forall A : Set, forall _nil : A, forall Q_ : ((_x_883 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_883 : Aop A _nil, Q_ x_883 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_ord_O_to_divides. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$.",
    "output": "Axiom not_ord_O_to_divides : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O)), cic.Term cic.prop (matita_arithmetics_primes.divides p m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.",
    "output": "gcd_n_n : n : Nat -> Eq (gcd n n) n ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.",
    "output": "axiom Dop_rect_CProp3_body (A : Set) (_nil : A) (Q_ : (_x_961 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_961 : Dop A _nil) : Q_ x_961"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transpose. For all elements $__$ and $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate transpose : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Orb_true_r2. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.",
    "output": "orb_true_r2 : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_plus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$.",
    "output": "minus_plus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.plus m p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Opt_cons_tail_expand. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.option_cons$ applied to $A$ and $matita_basics_lists_list.option_hd$ applied to $A$ and $l$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$.",
    "output": "postulate opt_cons_tail_expand : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.option_cons A (matita_basics_lists_list.option_hd A l) (matita_basics_lists_list.tail A l)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type1. For all functions $Q_$ from elements $_x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_O$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_388$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_386$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_386$, for all elements $x_385$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_385$.",
    "output": "axiom nat_rect_Type1 (Q_ : (_x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type1) (_H_O : cic.Term univs.Type1 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_388 : cic.Term univs.Type1 (Q_ x_386)) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_nat.S x_386))) (x_385 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type1 (Q_ x_385)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.",
    "output": "Sum_rect_Type0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type0) -> _H_inl : (x_552 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> _H_inr : (x_553 : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type0 (Q_ x_551) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.",
    "output": "axiom log_exp (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_squareS_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate le_squareS_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Some. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "Axiom Some : forall A : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 A, cic.Term univs.Type0 (matita_basics_types.option A) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Assoc_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.",
    "output": "Axiom assoc_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_discr. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_bool.match_bool$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_bool.match_bool$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z19$ to $P$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and $matita_basics_bool.match_bool$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z20$ to $P$ and $y$ and $x$.",
    "output": "axiom bool_discr (x y : cic.Term univs.Type0 matita_basics_bool.bool) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) x y)) : cic.Term univs.Type2 (matita_basics_bool.match_bool (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (matita_basics_bool.match_bool (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 P (λ _z19 => P))) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => P)) y) (matita_basics_bool.match_bool (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => P)) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 P (λ _z20 => P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_smallest_factor_n. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is prime.",
    "output": "prime_smallest_factor_n : n : Nat -> __ : Lt (nd 1) n -> prime (smallest_factor n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type1_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_829$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $Lt$ of $_r$ and $_m$ and elements $x_830$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_829$.",
    "output": "axiom div_mod_spec_rect_Type1_body (_n _m _q _r : Nat) (Q_ : (_x_829 : div_mod_spec _n _m _q _r) -> Type1) (_H_div_mod_spec_intro : (x_831 : _r < _m) -> (x_830 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)) (x_829 : div_mod_spec _n _m _q _r) : Q_ x_829"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "K. For all natural numbers $_n$ and $_p$, $Nat$.",
    "output": "axiom k (_n _p : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_909$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_909$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_909$.",
    "output": "ACop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_909 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_909 : ACop A _nil -> Q_ x_909 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_RC_reflexive. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.bi_reflexive$ applied to $A$ and $B$ and $matita_basics_relations.bi_RC$ applied to $A$ and $B$ and $R$.",
    "output": "postulate bi_RC_reflexive : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) -> cic.Term cic.prop (matita_basics_relations.bi_reflexive A B (matita_basics_relations.bi_RC A B R))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_ind. For all natural numbers $x1$ and $x2$, if $x1$ is less than or equal to $x2$, then for all functions $P$ from natural numbers $_z724$ to propositions, for all functions $_H1$ from elements $_z725$ of $Eq$ of $x2$ and $x1$ to elements of $P$ of $x1$, for all functions $_H2$ from natural numbers $m$ and elements $_x_419$ of $Leq$ of $x1$ and $m$ and functions $_x_421$ from elements $_z725$ of $Eq$ of $x2$ and $m$ to elements of $P$ of $m$ and elements $_z725$ of $Eq$ of $x2$ and the sum of $m$ and $1$ to elements of $P$ of the sum of $m$ and $1$, $P$ holds for $x2$.",
    "output": "axiom le_inv_ind (x1 x2 : Nat) (_Hterm : x1 ≤ x2) (P : (_z724 : Nat) -> Prop) (_H1 : (_z725 : x2 = x1) -> P x1) (_H2 : (m : Nat) -> (_x_419 : x1 ≤ m) -> (_x_421 : (_z725 : x2 = m) -> P m) -> (_z725 : x2 = m + 1) -> P (m + 1)) : P x2"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_to_not_le_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "axiom not_le_to_not_le_S_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_not. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Not$ applied to $A$ and $matita_basics_logic.Not$ applied to $B$.",
    "output": "postulate iff_not : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Not A) (matita_basics_logic.Not B))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate permut : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_to_log_r. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_log.log$ applied to $b$ and $m$.",
    "output": "axiom exp_to_log_r (b n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_log.log b m))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Decidable_eq_nat. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "Axiom decidable_eq_nat : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "lt_sqrt_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_aux_false. For all elements $p$ and $n$ and $m$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $a$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate p_ord_aux_false : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) (matita_arithmetics_nat.S a))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_947$ of $Dop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_947$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_947$.",
    "output": "axiom Dop_rect_Type5 (A : Set) (_nil : A) (Q_ : (_x_947 : Dop A _nil) -> Type5) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_947 : Dop A _nil) : Q_ x_947"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min0. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, $Nat$.",
    "output": "postulate min0 : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.",
    "output": "And_rect_Type5 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type5) -> _H_conj : (x_128 : cic.Term cic.prop _A -> x_127 : cic.Term cic.prop _B -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) -> x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type5 (Q_ x_126) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Tri_relation. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "tri_relation : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.",
    "output": "postulate inl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_to_lt. For all natural numbers $n$ and $m$, if $n$ is not less than or equal to $m$, then $m$ is less than $n$.",
    "output": "axiom not_le_to_lt (n m : Nat) (x__ : ¬ (n ≤ m)) : m < n"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1272$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1273$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1272 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1273 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_div_le. For all natural numbers $a$ and $b$ and $c$ and $d$, if $0$ is less than $b$, then if $0$ is less than $d$, then the product of the quotient of $a$ and $b$ and the quotient of $c$ and $d$ is less than or equal to the quotient of the product of $a$ and $c$ and the product of $b$ and $d$.",
    "output": "axiom times_div_le (a b c d : Nat) (x__ : 0 < b) (__1 : 0 < d) : a / b * (c / d) ≤ a * c / (b * d)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_exp1. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$.",
    "output": "postulate p_ord_to_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_priml. For all natural numbers $n$, if $0$ is less than $n$, then the product of $2$ and $n$ is less than or equal to the product of the sum of the logarithm of $2$ and the product of $2$ and $n$ and $1$ and the sum of $prim$ applied to the product of $2$ and $n$ and $1$.",
    "output": "postulate le_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (times 2 n) (times (plus (log 2 (times 2 n)) 1) (plus (prim (times 2 n)) 1))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_680$.",
    "output": "Sig_rect_CProp5_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_680) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_not_exists. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $n$ and $b$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, $min$ applied to $n$ and $b$ and $f$ is equal to the sum of $n$ and $b$.",
    "output": "Axiom min_not_exists : forall f : ((x__ : nat) -> bool), forall n : nat, forall b : nat, forall x__ : ((i : nat) -> (x__ : Leq b i) -> (__1 : i < n + b) -> f i = false), min n b f = n + b ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15611. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $b$ and $matita_arithmetics_nat.times$ applied to $p$ and $a$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15611 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))) -> (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m b) (matita_arithmetics_nat.times p a)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_conj$ from elements $x_124$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_123$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_124$ and $x_123$, for all elements $x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_122$.",
    "output": "axiom And_rect_Type4_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4) (_H_conj : (x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) (x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type4 (Q_ x_122)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_times_times. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$.",
    "output": "Axiom div_times_times : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_iter. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$, for all functions $__$ from natural numbers $x$ to elements of $Leq$ of $x$ and $g$ applied to $x$, for all natural numbers $i$, $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $i$ and $a$.",
    "output": "le_iter : g : (__ : Nat -> Nat) -> a : Nat -> __ : (x : Nat -> Leq x (g x)) -> i : Nat -> Leq a (iter Nat g i a) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_comp_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ and $R1$ and $R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $R1$ and $R2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R$ and $R2$.",
    "output": "sub_comp_r : A : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb1. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $p$.",
    "output": "postulate pi_p_primeb1 : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> dividesb (pow p (plus i 1)) n) Nat 1 times (\\ i : Nat -> p)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_ind2. For all elements $T1$ and $T2$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T1$, for all elements $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T2$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T2$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $T1$ and $l1$ and $matita_basics_lists_list.length$ applied to $T2$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $T1$ and $matita_basics_lists_list.nil$ applied to $T2$, for all functions $__2$ from elements $tl1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T1$ and elements $tl2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T2$ and elements $hd1$ of $cic.Term$ of $univs.Type0$ and $T1$ and elements $hd2$ of $cic.Term$ of $univs.Type0$ and $T2$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $P$ applied to $tl1$ and $tl2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $T1$ and $hd1$ and $tl1$ and $matita_basics_lists_list.cons$ applied to $T2$ and $hd2$ and $tl2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.",
    "output": "Axiom list_ind2 : forall T1 : cic.Univ univs.Type0, forall T2 : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2), forall P : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length T1 l1) (matita_basics_lists_list.length T2 l2)), forall __1 : cic.Term cic.prop (P (matita_basics_lists_list.nil T1) (matita_basics_lists_list.nil T2)), forall __2 : ((tl1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (tl2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (hd1 : cic.Term univs.Type0 T1) -> (hd2 : cic.Term univs.Type0 T2) -> (__2 : cic.Term cic.prop (P tl1 tl2)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons T1 hd1 tl1) (matita_basics_lists_list.cons T2 hd2 tl2))), cic.Term cic.prop (P l1 l2) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sym_not_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$.",
    "output": "Axiom sym_not_eq : forall A : cic.Univ univs.Type2, forall x : cic.Term univs.Type2 A, forall y : cic.Term univs.Type2 A, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq A x y)), cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq A y x)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_ord_sigma_p. For all elements $n$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $x$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $x$ and $m$ and $n$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $x$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $n$ and $x$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $x$ and $matita_arithmetics_nat.S$ applied to $i$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate eq_ord_sigma_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime x)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp x m) n)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S m)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord n x) (matita_arithmetics_bigops.bigop m (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S i)) n) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_577$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_577$, for all functions $_H_inr$ from elements $x_578$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_578$, for all elements $x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_576$.",
    "output": "axiom Sum_rect_CProp1_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_576)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp4. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "Axiom False_rect_CProp4 : forall Q_ : ((_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_73 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_73) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Z. $Nat$.",
    "output": "axiom z : Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_to_decidable_eq. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.",
    "output": "Axiom bool_to_decidable_eq : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1686. For all natural numbers $n$ and $m$, for all functions $Hind$ from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi$ applied to $p$ and the product of $pred$ applied to $p$ and the exponentiation of $2$ and the difference of the product of $2$ and $p$ and $3$, for all natural numbers $a$, if $m$ is equal to the product of $2$ and $a$ or $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $1$ is less than the sum of the product of $2$ and $a$ and $1$, then if $0$ is less than $a$, then $pred$ applied to $m$ is equal to the sum of $a$ and $a$.",
    "output": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_DPair. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) -> (case_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term return_sort (return_type (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Null. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.",
    "output": "postulate null : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1227. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, for all elements $l1$ and $l2$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $Hlen$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $x$ and $n$, for all elements $Ha$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $a$ and $n$, for all elements $Hnil$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $a$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom let_clause_1227 (A : cic.Univ univs.Type0) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) (l1 l2 a : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (posn : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (Hlen : (x : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A x) n)) (Ha : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A a) n)) (Hnil : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.nil A) (matita_basics_lists_list.append A l1 (matita_basics_lists_list.append A a l2)))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_times. For all natural numbers $n$ and $m$ and $n1$ and $m1$ and $p$, if $0$ is less than $p$, then for all elements $__1$ of $congruent$ of $n$ and $n1$ and $p$, for all elements $__2$ of $congruent$ of $m$ and $m1$ and $p$, $congruent$ holds for the product of $n$ and $m$ and the product of $n1$ and $m1$ and $p$.",
    "output": "Axiom congruent_times : forall n : nat, forall m : nat, forall n1 : nat, forall m1 : nat, forall p : nat, forall x__ : (0 < p), forall __1 : congruent n n1 p, forall __2 : congruent m m1 p, congruent (n * m) (n1 * m1) p ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "Axiom Not_rect_CProp3 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))), forall x_106 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_106) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_704$.",
    "output": "Prod_rect_CProp4 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_704) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_CProp1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_771$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_773$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_772$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_775$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_772$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_773$ and $x_772$, for all elements $x_771$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_771$.",
    "output": "list_rect_CProp1 : _A : cic.Univ univs.Type0 -> Q_ : (_x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_773 : cic.Term univs.Type0 _A -> x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_775 : cic.Term cic.prop (Q_ x_772) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_773 x_772))) -> x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_771) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_913$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_913$.",
    "output": "ACop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_913) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_to_plus. For all natural numbers $n$ and $m$ and $p$, if $m$ is less than or equal to $n$, then if the difference of $n$ and $m$ is equal to $p$, then $n$ is equal to the sum of $m$ and $p$.",
    "output": "Axiom minus_to_plus : forall n : nat, forall m : nat, forall p : nat, forall x__ : Leq m n, forall __1 : (n - m = p), n = m + p ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_893$ of $ACop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_893$.",
    "output": "ACop_rect_Type5 : A : Set -> _nil : A -> Q_ : (_x_893 : ACop A _nil -> Type5) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_893 : ACop A _nil -> Q_ x_893 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_maxl. For all natural numbers $i$ and $n$ and $m$, if $max$ applied to $n$ and $m$ is less than or equal to $i$, then $n$ is less than or equal to $i$.",
    "output": "postulate le_maxl : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq n i"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_primr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom le_exp_primr (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type2. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1716$ of $Dop$ of $x1$ and $x2$ to elements of $Type2$, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1717$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "postulate Dop_inv_rect_Type2 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1716 : Dop x1 x2) -> Type2) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1717 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_n_O. For all natural numbers $n$, $1$ is equal to the exponentiation of $n$ and $0$.",
    "output": "Axiom exp_n_O : forall n : nat, 1 = pow n 0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_lt_SO. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$.",
    "output": "postulate prime_to_lt_SO : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_plus_Sn_r. For all natural numbers $a$ and $x$ and $n$, $a$ is less than the sum of the sum of $a$ and $x$ and the sum of $n$ and $1$.",
    "output": "lt_plus_Sn_r : a : Nat -> x : Nat -> n : Nat -> Lt a (plus (plus a x) (plus n (nd 1))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_gcd_r. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is divisible by $m$.",
    "output": "Axiom divides_gcd_r : forall n : nat, forall m : nat, divisible (gcd n m) m ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta_pi_p_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate theta_pi_p_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_plus_Sn_r. For all elements $a$ and $x$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $x$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "Axiom lt_plus_Sn_r : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus a x) (matita_arithmetics_nat.S n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Even_or_odd. For all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $a$ to the disjunction of $Eq$ applied to $n$ and the product of $2$ and $a$ and $Eq$ applied to $n$ and the sum of the product of $2$ and $a$ and $1$.",
    "output": "even_or_odd : n : Nat -> ex Nat (a : Nat => or (Eq n (times (nd 2) a)) (Eq n (plus (times (nd 2) a) (nd 1)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_n_fact_n. For all natural numbers $n$, if $2$ is less than $n$, then $n$ is less than the factorial of $n$.",
    "output": "axiom lt_n_fact_n (n : Nat) (x__ : 2 < n) : n < factorial n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_945$ of $Dop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_945$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_945$.",
    "output": "Dop_rect_Type4_body : A : Set -> _nil : A -> Q_ : (_x_945 : Dop A _nil -> Type4) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_945 : Dop A _nil -> Q_ x_945 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_sym. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $a$ and $b$ and $matita_arithmetics_nat.eqb$ applied to $b$ and $a$.",
    "output": "postulate eqb_sym : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb a b) (matita_arithmetics_nat.eqb b a))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10131. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n0$ and $f$ and $m$, for all elements $fm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltj$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $j$ and $matita_arithmetics_nat.S$ applied to $n0$, for all elements $x7$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x7$ and $matita_arithmetics_nat.plus$ applied to $m$ and $x7$.",
    "output": "postulate let_clause_10131 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m)) -> (fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0))) -> (x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_S. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ and $b$ of $B$, for all elements $__$ of $R$ of $b1$ and $b$, for all natural numbers $l$, for all elements $b2$ of $B$, for all elements $__1$ of $lstar$ of $B$ and $R$ and $l$ and $b$ and $b2$, $lstar$ holds for $B$ and $R$ and the sum of $l$ and $1$ and $b1$ and $b2$.",
    "output": "Axiom lstar_S : forall B : Set, forall R : relation B, forall b1 : B, forall b : B, forall x__ : R b1 b, forall l : nat, forall b2 : B, forall __1 : lstar B R l b b2, lstar B R (l + 1) b1 b2 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_4$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_4$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_4$ and $x_5$.",
    "output": "Axiom eq_rect_Type4_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_4 : cic.Term univs.Type2 A) -> (_x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Univ univs.Type4), forall _H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x)), forall x_4 : cic.Term univs.Type2 A, forall x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4), cic.Term univs.Type4 (Q_ x_4 x_5) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate Exists_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $permut$ of $f$ and $n$, $f$ applied to $invert_permut$ applied to $n$ and $f$ and $m$ is equal to $m$.",
    "output": "postulate f_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : permut f n) -> Eq (f (invert_permut n f m)) m"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop__o__op. For all sets $x0$, for all elements $x1$ of $x0$, for all functions $x2$ from elements of $ACop$ of $x0$ and $x1$ to sets, for all elements $x3$ of $DPair$ of $ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $x0$, $x0$.",
    "output": "postulate dpi1__o__aop__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime3. For all elements $n$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom let_previous_prime3 (n m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_881$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_881$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_881$.",
    "output": "Aop_rect_CProp2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_881) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type5_body. For all sets $_A$, for all functions $Q_$ from elements $_x_919$ of $range$ of $_A$ to elements of $Type5$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_919$ of $range$ of $_A$, $Q_$ holds for $x_919$.",
    "output": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_SO_n. For all natural numbers $n$, $1$ is divisible by $n$.",
    "output": "axiom divides_SO_n (n : Nat) : divisible 1 n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example13. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "example13 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_pi. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_div_and_mod.mod$ applied to $f$ applied to $i$ and $p$ and $p$.",
    "output": "axiom congruent_pi (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) : cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => f i)) (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_div_and_mod.mod (f i) p)) p)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_S1. For all natural numbers $x$ and $y$, if the sum of $x$ and $1$ is less than or equal to $y$, then $ex2$ holds for $Nat$ and the function that maps $z$ to $Leq$ applied to $x$ and $z$ and the function that maps $z$ to $Eq$ applied to $y$ and the sum of $z$ and $1$.",
    "output": "axiom le_inv_S1 (x y : Nat) (x__ : x + 1 ≤ y) : ex2 Nat (λ z => x ≤ z) (λ z => y = z + 1)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime7. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "Axiom let_previous_prime7 : forall n : nat, forall m : nat, forall ltml : (nth_prime n < m), nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1075. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $bijf$ of $bijn$ of $f$ and the sum of $n$ and $1$, if $f$ applied to the sum of $n$ and $1$ is equal to the sum of $n$ and $1$, then for all natural numbers $i$, if $i$ is less than or equal to $n$, then for all natural numbers $a$, if $a$ is less than or equal to the sum of $n$ and $1$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to the sum of $n$ and $1$, then if $f$ applied to $a$ is equal to $i$, then if $a$ is equal to the sum of $n$ and $1$, then $i$ is equal to $a$.",
    "output": "axiom let_clause_1075 (f : (x__ : Nat) -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (fS : f (n + 1) = n + 1) (i : Nat) (lein : i ≤ n) (a : Nat) (_clearme : a ≤ n + 1 ∧ f a = i) (lean : a ≤ n + 1) (fa : f a = i) (Hc : a = n + 1) : i = a"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example3. $smallest_factor$ applied to $7$ is equal to $7$.",
    "output": "axiom example3 : smallest_factor 7 = 7"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_17041. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x1029$, $x1029$ is equal to $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x1029$ and $0$.",
    "output": "postulate let_clause_17041 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_sym. For all natural numbers $a$ and $b$, $eqb$ applied to $a$ and $b$ is equal to $eqb$ applied to $b$ and $a$.",
    "output": "Axiom eqb_sym : forall a : nat, forall b : nat, eqb a b = eqb b a ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_gcd_aux. For all elements $p$ and $m$ and $n$ and $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $m$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$.",
    "output": "postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "axiom split (A : cic.Univ univs.Type0) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list A) (matita_basics_lists_list.list A))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_times_to_le. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the product of $a$ and $n$ is less than or equal to the product of $a$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "le_times_to_le : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 a -> __1 : Leq (times a n) (times a m) -> Leq n m ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_times_n_to_lt_r. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "Axiom lt_times_n_to_lt_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q)), cic.Term cic.prop (matita_arithmetics_nat.lt p q) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1551. For all natural numbers $m$ and $n$, if $0$ is equal to $n$, then for all natural numbers $x347$, $n$ is equal to the product of $x347$ and $n$.",
    "output": "let_clause_1551 : m : Nat -> n : Nat -> eqn0 : Eq 0 n -> x347 : Nat -> Eq n (times x347 n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Tri_relation. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "axiom tri_relation (__ __1 __2 : cic.Univ univs.Type0) : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z713$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_416$ from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_414$ and elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom nat_inv_rect_CProp0 (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $A$ be a set. Let $_nil$ be an element of $A$. Then $ACop$ applied to $A$ and $_nil$ is a set.",
    "output": "ACop : A : Set -> _nil : A -> Set ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_Psi_2_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_chebyshev_psi_bounds.bool_to_nat$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "Axiom eq_Psi_2_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_nat.S n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp5_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_841$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $Lt$ of $_r$ and $_m$ and elements $x_842$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_841$.",
    "output": "div_mod_spec_rect_CProp5_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_841 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_843 : Lt _r _m -> x_842 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> x_841 : div_mod_spec _n _m _q _r -> Q_ x_841 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_unit. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_it$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.it$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_unit : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort), forall case_it : cic.Term return_sort (return_type matita_basics_types.it), forall z : cic.Term univs.Type0 matita_basics_types.unit, cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair. For all elements $_n$ and $_m$ and $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "cr_pair : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_lt. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$.",
    "output": "transitive_lt : cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat matita_arithmetics_nat.lt) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_div_div_div_div. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_div_and_mod.div$ applied to $q$ and $n$ and $m$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_div_and_mod.div$ applied to $q$ and $m$ and $n$.",
    "output": "eq_div_div_div_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q n) m) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q m) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $_l$ be a list of natural numbers. Then we can say that $all_primes$ holds for $_l$.",
    "output": "axiom all_primes (_l : list Nat) : Prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_max_true. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_basics_bool.true$.",
    "output": "Axiom f_max_true : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.max n f)) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_inv_plus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $x$ and $z$ and $matita_arithmetics_nat.lt$ applied to $y$ and $matita_arithmetics_nat.minus$ applied to $z$ and $x$.",
    "output": "axiom lt_inv_plus_l (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus x y) z)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.lt x z) (matita_arithmetics_nat.lt y (matita_arithmetics_nat.minus z x)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1554$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1555$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1554 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1555 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "S_pred. For all natural numbers $n$, if $0$ is less than $n$, then the sum of $pred$ applied to $n$ and $1$ is equal to $n$.",
    "output": "postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (plus (pred n) 1) n"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_909$.",
    "output": "axiom ACop_rect_CProp2 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_909)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1600. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $n$ and $c$ and the product of $m$ and $d$.",
    "output": "Axiom let_clause_1600 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), gcd m n = n * c - m * d ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_le_to_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then if $m$ is less than or equal to $n$, then $n$ is equal to $m$.",
    "output": "axiom le_to_le_to_eq (n m : Nat) (x__ : n ≤ m) (__1 : m ≤ n) : n = m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "prod_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> _x_969 : cic.Term univs.Type0 A -> _x_970 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_priml. For all natural numbers $n$, if $0$ is less than $n$, then the exponentiation of $2$ and the product of $2$ and $n$ is less than or equal to the exponentiation of the product of $2$ and $n$ and the sum of $prim$ applied to the product of $2$ and $n$ and $1$.",
    "output": "axiom le_exp_priml (n : Nat) (x__ : 0 < n) : pow 2 (2 * n) ≤ pow (2 * n) (prim (2 * n) + 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_S. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$.",
    "output": "postulate injective_S : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.S)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_765$ from elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_762$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_762$ and elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_763$ and $x_762$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_763$ and $x_762$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_933$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_933$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_933$.",
    "output": "postulate range_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_933)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_pi. For all natural numbers $n$, for all functions $p$ from natural numbers to booleans, for all functions $f$ and $g$ from natural numbers to natural numbers, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of $f$ applied to $i$ and $g$ applied to $i$ is equal to the product of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g$ applied to $i$.",
    "output": "times_pi : n : Nat -> p : (__ : Nat -> bool) -> f : (__ : Nat -> Nat) -> g : (__ : Nat -> Nat) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => times (f i) (g i))) (times (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => f i)) (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => g i))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than or equal to the sum of $m$ and $1$.",
    "output": "le_S : n : Nat -> m : Nat -> __ : Leq n m -> Leq n (plus m (nd 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.",
    "output": "postulate bigop_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.false) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp4_body. For all functions $Q_$ from elements $_x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_489$.",
    "output": "postulate void_rect_CProp4_body : (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_489)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_B_Bk. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$.",
    "output": "postulate eq_B_Bk : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_plus_m_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $m$ and $m$.",
    "output": "postulate minus_plus_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n m) m))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp2. For all functions $Q_$ from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.",
    "output": "Axiom False_rect_CProp2 : forall Q_ : ((_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_76 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_76) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then the product of $__$ and $__1$ is a natural number.",
    "output": "times : __ : Nat -> __1 : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom injn : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_ord_rem. For all natural numbers $p$ and $n$, if $1$ is less than $p$, then if $0$ is less than $n$, then $0$ is less than $ord_rem$ applied to $n$ and $p$.",
    "output": "axiom lt_O_ord_rem (p n : Nat) (x__ : 1 < p) (__1 : 0 < n) : 0 < ord_rem n p"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_S. For all natural numbers $n$ and $m$, if $n$ is not equal to $m$, then the sum of $n$ and $1$ is not equal to the sum of $m$ and $1$.",
    "output": "axiom not_eq_S (n m : Nat) (x__ : ¬ (n = m)) : ¬ (n + 1 = m + 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_notb. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_basics_bool.bool$ and $matita_basics_bool.bool$ and $matita_basics_bool.notb$.",
    "output": "postulate injective_notb : cic.Term cic.prop (matita_basics_relations.injective matita_basics_bool.bool matita_basics_bool.bool matita_basics_bool.notb)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_bool. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_true$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.true$, for all elements $case_false$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.false$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_bool (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) (z : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Relation4. For all elements $__$ and $__1$ and $__2$ and $__3$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate relation4 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> (__2 : cic.Univ univs.Type0) -> (__3 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type2. For all functions $Q_$ from elements $_x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_O$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_384$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, for all elements $x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_381$.",
    "output": "axiom nat_rect_Type2 (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type2 (Q_ x_381)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_ind. For all functions $Q_$ from elements $_x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_326$.",
    "output": "axiom bool_ind (Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_326 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_326)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then for all elements $__1$ of $permut$ of $f$ and $n$, $f$ applied to $invert_permut$ applied to $n$ and $f$ and $m$ is equal to $m$.",
    "output": "Axiom f_invert_permut : forall f : ((x__ : nat) -> nat), forall n : nat, forall m : nat, forall x__ : Leq m n, forall __1 : permut f n, f (invert_permut n f m) = m ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus_plus_plus_l. For all elements $z$ and $x$ and $y$ and $h$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $z$ and $matita_arithmetics_nat.plus$ applied to $x$ and $h$ and $matita_arithmetics_nat.plus$ applied to $y$ and $h$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $z$ and $x$ and $y$.",
    "output": "Axiom plus_minus_plus_plus_l : forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall h : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z (matita_arithmetics_nat.plus x h)) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) y)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_925$.",
    "output": "axiom range_rect_Type1 (_A : cic.Univ univs.Type0) (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type1 (Q_ x_925)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_exp. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.",
    "output": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Associative. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "associative : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_ind. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_810$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_809$.",
    "output": "axiom div_mod_spec_ind (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_809)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "Axiom Not_rect_CProp3_body : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))), forall x_106 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_106) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10333. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "Axiom let_clause_10333 : forall n : nat, forall posn : (0 < n), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "K1. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $p$ and $matita_arithmetics_nat.O$.",
    "output": "axiom k1 (n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) p)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Op_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "op_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) -> _x_887 : cic.Term univs.Type0 A -> _x_888 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then the quotient of $__$ and $__1$ is a natural number.",
    "output": "Axiom div : forall x__ : nat, forall __1 : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_ACop. For all sets $A$, for all elements $nil$ of $A$, for all elements $aop$ of $Aop$ of $A$ and $nil$, for all functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $nil$ and $aop$ and $b$ and $a$, $ACop$ holds for $A$ and $nil$.",
    "output": "Axiom mk_ACop : forall A : Set, forall nil : A, forall aop : Aop A nil, forall _comm : ((a : A) -> (b : A) -> op A nil aop a b = op A nil aop b a), ACop A nil ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_945$ of $Dop$ of $A$ and $_nil$ to elements of $Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_945$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_945$.",
    "output": "postulate Dop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Position_of_aux_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_found$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_acc$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.",
    "output": "axiom position_of_aux_body (A : cic.Univ univs.Type0) (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Op. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "postulate op : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (_x_887 : cic.Term univs.Type0 A) -> (_x_888 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_sigma_l. For all natural numbers $n$ and $a$, for all functions $p$ from natural numbers to booleans, for all functions $f$ from natural numbers to natural numbers, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $a$ and $f$ applied to $i$ is equal to the exponentiation of $a$ and $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate exp_sigma_l : (n : Nat) -> (a : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> pow a (f i))) (pow a (bigop n (\\ i : Nat -> p i) Nat 0 plus (\\ i : Nat -> f i)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ld_to_prime. For all natural numbers $i$, for all lists $acc$ of natural numbers, if $1$ is less than $i$, then for all elements $__1$ of $primes_below$ of $acc$ and $i$, if $list_divides$ applied to $acc$ and $i$ is equal to absurdity, then $i$ is prime.",
    "output": "axiom ld_to_prime (i : Nat) (acc : list Nat) (x__ : 1 < i) (__1 : primes_below acc i) (__2 : list_divides acc i = false) : prime i"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair5. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "axiom cr_pair5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) matita_arithmetics_nat.O (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type4_body. For all functions $Q_$ from elements $_x_483$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $x_483$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_483$.",
    "output": "postulate void_rect_Type4_body : (Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type4 (Q_ x_483)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "gcd_O_l : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_le_max. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $max$ applied to $n$ and $f$ is less than or equal to $max$ applied to $m$ and $f$.",
    "output": "le_to_le_max : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Leq n m -> Leq (max n f) (max m f) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_coerc. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.succ$ applied to $univs.Type0$ and $univs.Type2$ and $cic.univ$ applied to $univs.Type0$ and $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "eq_coerc : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 A -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift (cic.succ univs.Type0) univs.Type2 (cic.univ univs.Type0)) A B) -> cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_aux_false. For all natural numbers $p$ and $n$ and $m$ and $a$, if $mod$ applied to $n$ and $m$ is equal to the sum of $a$ and $1$, then $p_ord_aux$ applied to $p$ and $n$ and $m$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $0$ and $n$.",
    "output": "p_ord_aux_false : p : Nat -> n : Nat -> m : Nat -> a : Nat -> __ : Eq (mod n m) (plus a (nd 1)) -> Eq (p_ord_aux p n m) (mk_Prod Nat Nat 0 n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_div_S. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then $n$ is less than the product of the sum of the quotient of $n$ and $m$ and $1$ and $m$.",
    "output": "axiom lt_div_S (n m : Nat) (x__ : 0 < m) : n < (n / m + 1) * m"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp4. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_839$ of $Lt$ of $_r$ and $_m$ and elements $x_838$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_839$ and $x_838$, for all elements $x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_837$.",
    "output": "Axiom div_mod_spec_rect_CProp4 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_837 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_839 : _r < _m) -> (x_838 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)), forall x_837 : div_mod_spec _n _m _q _r, Q_ x_837 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z647$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z648$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom bool_inv_rect_CProp0 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z647 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H1 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) (_H2 : (_z648 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1392$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1393$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "axiom Aop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) (P : (_z1392 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1393 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1500$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1501$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Aop_inv_ind (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1500 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1501 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_smallest_factor. For all natural numbers $n$, if $n$ is prime, then $smallest_factor$ applied to $n$ is equal to $n$.",
    "output": "Axiom prime_to_smallest_factor : forall n : nat, forall x__ : prime n, smallest_factor n = n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.",
    "output": "And_rect_Type5_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type5) -> _H_conj : (x_128 : cic.Term cic.prop _A -> x_127 : cic.Term cic.prop _B -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) -> x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type5 (Q_ x_126) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_rem. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom ord_rem (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "axiom le_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_557$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_557$, for all functions $_H_inr$ from elements $x_558$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_558$, for all elements $x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_556$.",
    "output": "axiom Sum_rect_CProp4_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_556)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z724$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x1$, for all functions $_H2$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x1$ and $m$ and functions $_x_421$ from elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$ and elements $_z725$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x2$.",
    "output": "postulate le_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_nat.le x1 x2)) -> (P : (_z724 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 x1)) -> cic.Term cic.prop (P x1)) -> (_H2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_419 : cic.Term cic.prop (matita_arithmetics_nat.le x1 m)) -> (_x_421 : (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 m)) -> cic.Term cic.prop (P m)) -> (_z725 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P x2)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_distr. For all natural numbers $n$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $R$ of $Dop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all elements $a$ of $B$, $let_mop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and $a$ and $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and the function that maps $i$ to $let_mop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and $a$ and $f$ applied to $i$.",
    "output": "axiom bigop_distr (n : Nat) (p : (x__ : Nat) -> bool) (B : Set) (nil : B) (R : Dop B nil) (f : (x__ : Nat) -> B) (a : B) : let_mop n p B nil R f a a (bigop n (λ i => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (λ i => f i)) = bigop n (λ i => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (λ i => let_mop n p B nil R f a a (f i))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_mod_to_divides. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $q$, then if $mod$ applied to $n$ and $q$ is equal to $mod$ applied to $m$ and $q$, then $q$ is divisible by the difference of $n$ and $m$.",
    "output": "Axiom eq_mod_to_divides : forall n : nat, forall m : nat, forall q : nat, forall x__ : (0 < q), forall __1 : (mod n q = mod m q), divisible q (n - m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "SameF_upto. For all natural numbers $__$, for all sets $A$, $relation$ holds for $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__1$ to $A$.",
    "output": "axiom sameF_upto (x__ : Nat) (A : Set) : relation (prod Set Set Nat (λ __1 => A))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1012. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $i$, for all functions $Hind$ from natural numbers $b$ to elements of $prod$ of $Prop$ and $Prop$ and $Eq$ applied to $f$ applied to $let_m2$ applied to $f$ and $n$ and $i$ and $b$ and absurdity and the function that maps $__$ to $Eq$ applied to $let_m2$ applied to $f$ and $n$ and $i$ and $b$ and the sum of $i$ and $b$, for all natural numbers $b$, if $f$ applied to $b$ is equal to $true$, then if $f$ applied to $b$ is equal to absurdity, then absurdity is equal to $true$.",
    "output": "let_clause_1012 : f : (__ : Nat -> bool) -> n : Nat -> i : Nat -> Hind : (b : Nat -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (__ : Eq (f (let_m2 f n i b)) false => Eq (let_m2 f n i b) (plus i b))) -> b : Nat -> fb : Eq (f b) true -> eqm : Eq (f b) false -> Eq false true ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_CProp1. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z707$ to propositions, for all functions $_H1$ from elements $_z708$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_410$ and functions $_x_412$ from elements $_z708$ of $Eq$ of $Hterm$ and $x_410$ to elements of $P$ of $x_410$ and elements $_z708$ of $Eq$ of $Hterm$ and the sum of $x_410$ and $1$ to elements of $P$ of the sum of $x_410$ and $1$, $P$ holds for $Hterm$.",
    "output": "axiom nat_inv_rect_CProp1 (Hterm : Nat) (P : (_z707 : Nat) -> Prop) (_H1 : (_z708 : Hterm = 0) -> P 0) (_H2 : (x_410 : Nat) -> (_x_412 : (_z708 : Hterm = x_410) -> P x_410) -> (_z708 : Hterm = x_410 + 1) -> P (x_410 + 1)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1272$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1273$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Prod_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1272 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1273 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_Type1. For all functions $Q_$ from elements $_x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_71$.",
    "output": "postulate False_rect_Type1 : (Q_ : (_x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type1) -> (x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ x_71)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1422$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1423$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1422 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1423 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_gen. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $i$ and $n$ to elements of $P$ of $i$, $P$ holds for $n$.",
    "output": "le_gen : P : (__ : Nat -> Prop) -> n : Nat -> __ : (i : Nat -> __ : Leq i n -> P i) -> P n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15591. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.",
    "output": "let_clause_15591 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m) -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Append. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "axiom append (H : cic.Univ univs.Type0) (__ __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Term univs.Type0 (matita_basics_lists_list.list H)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_14. We can prove that for all integers $n$, if $n$ is even, then the negation of the difference of the product of $5$ and $n$ and $3$ is odd.",
    "output": "noLabel_14 : Proof (forall Int (n => if (even n) (odd (neg (minus (times (nd 5) n) (nd 3)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type0. For all functions $Q_$ from elements $_x_507$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_it$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_507$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_507$.",
    "output": "Axiom unit_rect_Type0 : forall Q_ : ((_x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0), forall _H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it), forall x_507 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term univs.Type0 (Q_ x_507) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_785$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_785$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_785$.",
    "output": "Aop_rect_Type5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type5) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type5 (Q_ x_785) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__aop__o__op. For all sets $x0$, for all elements $x1$ of $x0$, for all functions $x2$ from elements of $ACop$ of $x0$ and $x1$ to sets, for all elements $x3$ of $DPair$ of $ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $x0$, $x0$.",
    "output": "dpi1__o__aop__o__op : x0 : Set -> x1 : x0 -> x2 : (__ : ACop x0 x1 -> Set) -> x3 : DPair (ACop x0 x1) x2 -> _x_887 : x0 -> _x_888 : x0 -> x0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_plus_to_le. For all natural numbers $n$ and $m$ and $p$, if $n$ is equal to the sum of $m$ and $p$, then $m$ is less than or equal to $n$.",
    "output": "axiom eq_plus_to_le (n m p : Nat) (x__ : n = m + p) : m ≤ n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_mod_to_divides. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $p$ is divisible by $mod$ applied to $m$ and $n$, then if $p$ is divisible by $n$, then $p$ is divisible by $m$.",
    "output": "axiom divides_mod_to_divides (p m n : Nat) (x__ : 0 < n) (__1 : divisible p (mod m n)) (__2 : divisible p n) : divisible p m"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Enum_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, for all natural numbers $_x_942$, $A$.",
    "output": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_lt_plus_r. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Lt$ and the function that maps $m$ to the sum of $n$ and $m$.",
    "output": "monotonic_lt_plus_r : n : Nat -> monotonic Nat Lt (m : Nat => plus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1410$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1411$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1410 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1411 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp4. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.",
    "output": "axiom False_rect_CProp4 (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_73 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_73)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_ind_body. For all elements $_n$ and $_b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_min_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and $matita_arithmetics_minimization.not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1075$ and $x_1076$.",
    "output": "min_spec_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> _H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077))) -> _H_not_found_min_spec : (x_1081 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus _n _b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus _n _b) (matita_arithmetics_minimization.not_found_min_spec _n _b _f x_1081))) -> x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Term cic.prop (Q_ x_1075 x_1076) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_945$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_945$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_945$.",
    "output": "Dop_rect_Type4_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type4 (Q_ x_945) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False. $cic.Univ$ holds for $cic.prop$.",
    "output": "False : cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void. $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate void : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Coerc_pair_sigma. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.snd$ applied to $A$ and $B$ and $p$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $matita_basics_types.Sig$ applied to $B$ and the function that maps $x$ to $P$ applied to $x$.",
    "output": "Axiom coerc_pair_sigma : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall p : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall __ : cic.Term cic.prop (P (matita_basics_types.snd A B p)), cic.Term univs.Type0 (matita_basics_types.Prod A (matita_basics_types.Sig B (fun x => P x))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp4_body. For all functions $Q_$ from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.",
    "output": "postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type5. For all functions $Q_$ from elements $_x_44$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_I$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_44$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_44$.",
    "output": "Axiom True_rect_Type5 : forall Q_ : ((_x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type5), forall _H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I), forall x_44 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type5 (Q_ x_44) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z173$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z174$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate True_inv_rect_CProp2 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z173 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "Dop_rect_Type1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type1 (Q_ x_953) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp2. For all functions $Q_$ from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.",
    "output": "postulate nat_rect_CProp2 : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_1_to_divides_times_to_divides. For all natural numbers $p$ and $n$ and $m$, if $0$ is less than $p$, then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if $p$ is divisible by the product of $n$ and $m$, then $p$ is divisible by $m$.",
    "output": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_le_times_to_lt_S_to_div. For all elements $a$ and $c$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $c$.",
    "output": "axiom lt_to_le_times_to_lt_S_to_div (a c b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.times b (matita_arithmetics_nat.S c)))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) c)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_aux. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "postulate gcd_aux : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_795$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_795$.",
    "output": "axiom Aop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_795)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "not_eq_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_times_to_lt_div. For all elements $m$ and $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $m$.",
    "output": "axiom lt_times_to_lt_div (m n q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times m q))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "axiom div_mod_spec_rect_Type1_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term univs.Type1 (Q_ x_829)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "K_def. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "k_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Snd_eq. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $b$.",
    "output": "postulate snd_eq : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_sigma_l. For all elements $n$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $a$ and $f$ applied to $i$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "Axiom exp_sigma_l : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp a (f i))) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => f i)))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z641$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z642$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z642$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom bool_inv_rect_CProp1 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z641 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H1 : ((_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)), forall _H2 : ((_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_p_ord. For all elements $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, for all elements $__5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $m$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $c$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $b$ and $d$ and $matita_arithmetics_nat.le$ applied to $a$ and $c$.",
    "output": "axiom divides_to_p_ord (p a b c d n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_arithmetics_nat.le a c))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.plus$ applied to $n2$ and $m2$.",
    "output": "postulate le_plus : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Invert_permut_f. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $f$ applied to $m$ and $m$.",
    "output": "postulate invert_permut_f : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.invert_permut n f (f m)) m)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_i_2n. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $n$ is less than $i$, then if $i$ is less than or equal to the product of $2$ and $n$, then the logarithm of $i$ and the product of $2$ and $n$ is equal to $1$.",
    "output": "Axiom log_i_2n : forall n : nat, forall i : nat, forall x__ : (1 < n), forall __1 : (n < i), forall __2 : Leq i (2 * n), log i (2 * n) = 1 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_17041. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_17041 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_160$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_159$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_160$ and $x_159$, for all elements $x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_158$.",
    "output": "Axiom And_rect_CProp2_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))), forall x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_158) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_ord_rem. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $n$.",
    "output": "axiom divides_ord_rem (p n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) n)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_lt_to_lt. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$.",
    "output": "axiom le_to_lt_to_lt (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) : cic.Term cic.prop (matita_arithmetics_nat.lt n p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n2. For all natural numbers $n$, if $7$ is less than or equal to $n$, then $prim$ applied to the sum of the product of $2$ and $n$ and $1$ is less than or equal to $pred$ applied to $n$.",
    "output": "le_prim_n2 : n : Nat -> __ : Leq (nd 7) n -> Leq (prim (plus (times (nd 2) n) (nd 1))) (pred n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_522$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_522$, for all functions $_H_inr$ from elements $x_523$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_523$, for all elements $x_521$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_521$.",
    "output": "axiom Sum_ind (_A _B : cic.Univ univs.Type0) (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_521)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_678$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_678$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_678$.",
    "output": "Sig_rect_CProp4_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_678) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_S1. For all natural numbers $x$ and $y$, if the sum of $x$ and $1$ is less than or equal to $y$, then $ex2$ holds for $Nat$ and the function that maps $z$ to $Leq$ applied to $x$ and $z$ and the function that maps $z$ to $Eq$ applied to $y$ and the sum of $z$ and $1$.",
    "output": "postulate le_inv_S1 : (x : Nat) -> (y : Nat) -> (_ : Leq (plus x 1) y) -> ex2 Nat (\\ z : Nat -> Leq x z) (\\ z : Nat -> Eq y (plus z 1))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound2. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "let_upper_bound2 : n : Nat -> m : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_inv. For all elements $_p$ and $_m$ and $_x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom p_ord_inv (_p _m _x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb4. For all natural numbers $n$, if $1$ is less than $n$, then $bigop$ applied to the sum of the product of $2$ and $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and the product of $2$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and the product of $2$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$.",
    "output": "axiom pi_p_primeb4 (n : Nat) (x__ : 1 < n) : bigop (2 * n + 1) (λ p => primeb p) Nat 1 times (λ p => bigop (log p (2 * n)) (λ i => true) Nat 1 times (λ i => pow p (2 * (n / pow p (i + 1))))) = bigop (n + 1) (λ p => primeb p) Nat 1 times (λ p => bigop (log p (2 * n)) (λ i => true) Nat 1 times (λ i => pow p (2 * (n / pow p (i + 1)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_inv_plus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $x$ and $z$ and $matita_arithmetics_nat.lt$ applied to $y$ and $matita_arithmetics_nat.minus$ applied to $z$ and $x$.",
    "output": "Axiom lt_inv_plus_l : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus x y) z), cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.lt x z) (matita_arithmetics_nat.lt y (matita_arithmetics_nat.minus z x))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_body. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "postulate plus_body : (_ : Nat) -> (__1 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_minus_comm. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $c$ and $b$.",
    "output": "Axiom minus_minus_comm : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus a b) c) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus a c) b)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then the equivalence of $_A$ and $_B$ is an element of $cic.Univ$ of $cic.prop$.",
    "output": "postulate iff : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type4_body. For all functions $Q_$ from elements $_x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_it$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_497$.",
    "output": "postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp2. For all functions $Q_$ from natural numbers $_x_405$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_406$ and elements $_x_408$ of $Q_$ of $x_406$ to elements of $Q_$ of the sum of $x_406$ and $1$, for all natural numbers $x_405$, $Q_$ holds for $x_405$.",
    "output": "nat_rect_CProp2 : Q_ : (_x_405 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_406 : Nat -> _x_408 : Q_ x_406 -> Q_ (plus x_406 (nd 1))) -> x_405 : Nat -> Q_ x_405 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom fact (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Or_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$, for all functions $_H2$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Or_inv_ind : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> (P : (_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_171 : cic.Term cic.prop x1) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_introl x1 x2 x_171))) -> cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))) -> (_H2 : (x_172 : cic.Term cic.prop x2) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_Sfalse. For all natural numbers $k$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $p$ applied to $k$ is equal to absurdity, then $bigop$ applied to the sum of $k$ and $1$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "bigop_Sfalse : k : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Eq (p k) false -> Eq (bigop (plus k (nd 1)) (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p i) B nil op (i : Nat => f i)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type1_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_94$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_nmk$ from functions $x_95$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_95$, for all elements $x_94$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_94$.",
    "output": "axiom Not_rect_Type1_body (_A : cic.Univ cic.prop) (Q_ : (_x_94 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type1) (_H_nmk : (x_95 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.nmk _A x_95))) (x_94 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type1 (Q_ x_94)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_map_some. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all elements $v$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $B$ and $matita_basics_types.option_map$ applied to $A$ and $B$ and $f$ and $x$ and $matita_basics_types.Some$ applied to $B$ and $v$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $y$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $y$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $y$ and $v$.",
    "output": "Axiom option_map_some : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall x : cic.Term univs.Type0 (matita_basics_types.option A), forall v : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.Some B v)), cic.Term cic.prop (matita_basics_logic.ex A (fun y => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f y) v))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_O. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b$ of $B$, $lstar_r$ holds for $B$ and $R$ and $0$ and $b$ and $b$.",
    "output": "lstar_r_O : B : Set -> R : relation B -> b : B -> lstar_r B R 0 b b ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B2_def. For all natural numbers $n$, $B2$ applied to $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and the product of $bool_to_nat$ applied to $leb$ applied to $2$ and $k$ applied to $n$ and $p$ and $k$ applied to $n$ and $p$.",
    "output": "postulate B2_def : (n : Nat) -> Eq (B2 n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> pow p (times (bool_to_nat (leb 2 (k n p))) (k n p))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp4. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z359$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z360$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_148$ and $x_147$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_148$ and $x_147$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom And_inv_rect_CProp4 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_148 : cic.Term cic.prop x1) -> (x_147 : cic.Term cic.prop x2) -> (_z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example11. $nth_prime$ applied to $2$ is equal to $5$.",
    "output": "axiom example11 : nth_prime 2 = 5"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sigma_const. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom sigma_const : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_959$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_959$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_959$.",
    "output": "axiom Dop_rect_CProp5 (A : Set) (_nil : A) (Q_ : (_x_959 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_959 : Dop A _nil) : Q_ x_959"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type4. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1506$ of $Aop$ of $x1$ and $x2$ to elements of $Type4$, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1507$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.",
    "output": "Axiom Prod_rect_Type3_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type3 (Q_ x_696) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type2$, for all functions $_H_div_mod_spec_intro$ from elements $x_827$ of $Lt$ of $_r$ and $_m$ and elements $x_826$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_827$ and $x_826$, for all elements $x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_825$.",
    "output": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_RC_reflexive. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.bi_reflexive$ applied to $A$ and $B$ and $matita_basics_relations.bi_RC$ applied to $A$ and $B$ and $R$.",
    "output": "bi_RC_reflexive : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Term cic.prop (matita_basics_relations.bi_reflexive A B (matita_basics_relations.bi_RC A B R)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_p_ord. For all natural numbers $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$, if $0$ is less than $n$, then if $0$ is less than $m$, then if $p$ is prime, then if $n$ is divisible by $m$, then if $p_ord$ applied to $n$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $a$ and $b$, then if $p_ord$ applied to $m$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $c$ and $d$, then $b$ is divisible by $d$ and $a$ is less than or equal to $c$.",
    "output": "Axiom divides_to_p_ord : forall p : nat, forall a : nat, forall b : nat, forall c : nat, forall d : nat, forall n : nat, forall m : nat, forall x__ : (0 < n), forall __1 : (0 < m), forall __2 : prime p, forall __3 : divisible n m, forall __4 : (p_ord n p = mk_Prod nat nat a b), forall __5 : (p_ord m p = mk_Prod nat nat c d), divisible b d /\\ Leq a c ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_mod_aux_m_m. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.mod_aux$ applied to $p$ and $n$ and $m$ and $m$.",
    "output": "le_mod_aux_m_m : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Antisymmetric. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom antisymmetric : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_priml1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "le_priml1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_elim1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $p$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "Axiom nat_elim1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (P p)) -> cic.Term cic.prop (P m)), cic.Term cic.prop (P n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nill_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ is equal to $a$.",
    "output": "nill_body : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> Eq (op A nil xxx nil a) a ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_925$.",
    "output": "Axiom range_rect_Type1 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type1 (Q_ x_925) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bi_RC. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$.",
    "output": "axiom bi_RC (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_664$.",
    "output": "Axiom Sig_ind_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term cic.prop (Q_ x_664) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_gcd. For all natural numbers $m$ and $n$, if $0$ is less than $n$, then if $n$ is divisible by $m$, then the greatest common divisor of $n$ and $m$ is equal to $n$.",
    "output": "postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (gcd n m) n"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_ord. For all natural numbers $p$ and $n$, if $1$ is less than $p$, then if $0$ is less than $n$, then $n$ is equal to the product of the exponentiation of $p$ and $ord$ applied to $n$ and $p$ and $ord_rem$ applied to $n$ and $p$.",
    "output": "Axiom exp_ord : forall p : nat, forall n : nat, forall x__ : (1 < p), forall __1 : (0 < n), n = pow p (ord n p) * ord_rem n p ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1617. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$, for all elements $H0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $a$ and $matita_arithmetics_nat.times$ applied to $m$ and $b$.",
    "output": "postulate let_clause_1617 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m))) -> (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times p a) (matita_arithmetics_nat.times m b)))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le. For all elements $_n$ and $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_Type5_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_nmk$ from functions $x_86$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_86$, for all elements $x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_85$.",
    "output": "postulate Not_rect_Type5_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type5) -> (_H_nmk : (x_86 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> (x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type5 (Q_ x_85)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_O_elim. For all natural numbers $n$, if $n$ is less than or equal to $0$, then for all functions $P$ from natural numbers $__1$ to propositions, for all elements $__1$ of $P$ of $0$, $P$ holds for $n$.",
    "output": "postulate le_n_O_elim : (n : Nat) -> (_ : Leq n 0) -> (P : (__1 : Nat) -> Prop) -> (__1 : P 0) -> P n"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_sigma_p_div. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$.",
    "output": "Axiom eq_sigma_p_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun m => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun m => matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n q)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_lt_plus_l. For all natural numbers $n$, $monotonic$ holds for $Nat$ and $Lt$ and the function that maps $m$ to the sum of $m$ and $n$.",
    "output": "monotonic_lt_plus_l : n : Nat -> monotonic Nat Lt (m : Nat => plus m n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then we can say that $__$ is greater than or equal to $__1$.",
    "output": "axiom Geq (x__ __1 : Nat) : Prop"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_8. For all instances $n$ of natural numbers, we can prove that if the sum of $n$ and the quotient of $1$ and $n$ is less than $2$, then the sum of the exponentiation of $n$ and $2$ and the quotient of $1$ and the exponentiation of $n$ and $2$ is less than $4$.",
    "output": "Axiom noLabel_8 : forall n : nat, (n + 1 / n < 2 -> pow n 2 + 1 / pow n 2 < 4) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le. For all natural numbers $b$ and $n$ and $m$, if $1$ is less than $b$, then if the exponentiation of $b$ and $n$ is less than or equal to the exponentiation of $b$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "Axiom le_exp_to_le : forall b : nat, forall n : nat, forall m : nat, forall x__ : (1 < b), forall __1 : Leq (pow b n) (pow b m), Leq n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair. For all natural numbers $_n$ and $_m$ and $_a$ and $_b$, $Nat$.",
    "output": "cr_pair : _n : Nat -> _m : Nat -> _a : Nat -> _b : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "postulate mod_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_S_S_to_not_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate not_le_S_S_to_not_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "axiom eq_rect_CProp4_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_22 : cic.Term univs.Type2 A) (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) : cic.Term cic.prop (Q_ x_22 x_23)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Some. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.",
    "output": "axiom Some (A : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 A) : cic.Term univs.Type0 (matita_basics_types.option A)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_799$.",
    "output": "axiom Aop_rect_CProp3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_799)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_gcd_aux_mn. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to $p$, then $gcd_aux$ applied to $p$ and $m$ and $n$ is divisible by $m$ and $gcd_aux$ applied to $p$ and $m$ and $n$ is divisible by $n$.",
    "output": "postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ltransitive. For all sets $B$, for all elements $R$ of $relation$ of $B$, $ltransitive$ holds for $B$ and $lstar$ applied to $B$ and $R$.",
    "output": "postulate lstar_ltransitive : (B : Set) -> (R : relation B) -> ltransitive B (lstar B R)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_le_max. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $m$ and $f$.",
    "output": "postulate le_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max m f))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop__o__op. For all sets $x0$, for all elements $x1$ of $x0$, for all elements $x2$ of $ACop$ of $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $x0$, $x0$.",
    "output": "axiom aop__o__op (x0 : Set) (x1 : x0) (x2 : ACop x0 x1) (_x_887 _x_888 : x0) : x0"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta. For all natural numbers $__$, $Nat$.",
    "output": "Axiom theta : forall x__ : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z161$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom True_inv_rect_CProp4 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop), forall _H1 : ((_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate transitive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_aop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$.",
    "output": "postulate let_aop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_lt. $transitive$ holds for $Nat$ and $Lt$.",
    "output": "Axiom transitive_lt : transitive nat Lt ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bk_def. For all natural numbers $n$, $Bk$ applied to $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and $k$ applied to $n$ and $p$.",
    "output": "axiom Bk_def (n : Nat) : Bk n = bigop (n + 1) (λ p => primeb p) Nat 1 times (λ p => pow p (k n p))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type5_body. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "unit_rect_Type5_body : Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type5) -> _H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it) -> x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type5 (Q_ x_499) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "axiom not_le_to_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) : cic.Term cic.prop (matita_arithmetics_nat.lt m n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_op. For all elements $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $g$ applied to $i$.",
    "output": "postulate bigop_op : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.aop__o__op B nil op (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.aop__o__op B nil op (f i) (g i))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_877$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_877$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_877$.",
    "output": "Aop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_877) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_div_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "Axiom eq_div_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n m) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_max_f_max_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $g$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.",
    "output": "Axiom le_max_f_max_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_ord_rem. For all natural numbers $p$ and $q$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $q$ is prime, then if $q$ is less than $p$, then $ord$ applied to $ord_rem$ applied to $m$ and $p$ and $q$ is equal to $ord$ applied to $m$ and $q$.",
    "output": "Axiom ord_ord_rem : forall p : nat, forall q : nat, forall m : nat, forall x__ : (0 < m), forall __1 : prime p, forall __2 : prime q, forall __3 : (q < p), ord (ord_rem m p) q = ord m q ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "plus_O_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nth_primeS. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_minimization.min$ applied to $matita_arithmetics_primes.let_upper_bound1$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_primes.let_previous_prime1$ applied to $n$ and $matita_arithmetics_primes.primeb$.",
    "output": "postulate nth_primeS : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)) (matita_arithmetics_minimization.min (matita_arithmetics_primes.let_upper_bound1 n) (matita_arithmetics_nat.S (matita_arithmetics_primes.let_previous_prime1 n)) matita_arithmetics_primes.primeb))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_Type1. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to elements of $Type1$, for all functions $_H1$ from elements $x_831$ of $Lt$ of $x4$ and $x2$ and elements $x_830$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1459$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $P$ holds for $Hterm$.",
    "output": "axiom div_mod_spec_inv_rect_Type1 (x1 x2 x3 x4 : Nat) (Hterm : div_mod_spec x1 x2 x3 x4) (P : (_z1458 : div_mod_spec x1 x2 x3 x4) -> Type1) (_H1 : (x_831 : x4 < x2) -> (x_830 : x1 = x3 * x2 + x4) -> (_z1459 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_831 x_830) -> P (div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_a. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $a$ and $m$.",
    "output": "le_plus_a : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus a m)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then we can say that $__$ is greater than $__1$.",
    "output": "Axiom Gt : forall x__ : nat, forall __1 : nat, Prop ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom primes_below_lop : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z623$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z624$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z624$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom bool_inv_rect_CProp4 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z623 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H1 : (_z624 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) (_H2 : (_z624 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_of_primes. For all natural numbers $_n$, $list$ holds for $Nat$.",
    "output": "postulate list_of_primes : (_n : Nat) -> list Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta_pred. For all natural numbers $n$, if $1$ is less than $n$, then $theta$ applied to the product of $2$ and $n$ is equal to $theta$ applied to $pred$ applied to the product of $2$ and $n$.",
    "output": "Axiom theta_pred : forall n : nat, forall x__ : (1 < n), theta (2 * n) = theta (pred (2 * n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod. For all natural numbers $n$ and $m$, $n$ is equal to the sum of the product of the quotient of $n$ and $m$ and $m$ and $mod$ applied to $n$ and $m$.",
    "output": "div_mod : n : Nat -> m : Nat -> Eq n (plus (times (div n m) m) (mod n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1146$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1147$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate DPair_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bijn_n_Sn. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_bertrand_to_le_B. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate not_bertrand_to_le_B : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_mod. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $n$ is equal to $mod$ applied to $n$ and $m$.",
    "output": "Axiom le_to_mod : forall n : nat, forall m : nat, forall x__ : (n < m), n = mod n m ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1551. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $x347$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $x347$ and $n$.",
    "output": "let_clause_1551 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_min_spec. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from natural numbers and elements $z$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $__$ to elements of $return_sort$, for all functions $case_found_min_spec$ from natural numbers $m$ and elements of $Leq$ of $_b$ and $m$ and elements $__1$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $__2$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $_b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $return_type$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $__$ and $__1$ and $__2$ and $__3$, for all functions $case_not_found_min_spec$ from functions from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $return_type$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $__$, for all natural numbers $__$, for all elements $z$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $__$, $return_type$ holds for $__$ and $z$.",
    "output": "postulate match_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) -> (case_found_min_spec : (m : Nat) -> (_ : Leq _b m) -> (__1 : Lt m (plus _n _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> (case_not_found_min_spec : (_ : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> (_ : Nat) -> (z : min_spec _n _b _f __) -> return_type __ z"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative_max. $commutative$ holds for $Nat$ and $max$.",
    "output": "Axiom commutative_max : commutative nat max ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_leb_true. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $leb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "le_to_leb_true : n : Nat -> m : Nat -> __ : Leq n m -> Eq (leb n m) true ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "It. $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.unit$.",
    "output": "it : cic.Term univs.Type0 matita_basics_types.unit ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.",
    "output": "axiom DPair_rect_CProp3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_656)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "postulate nat_rect_CProp3_body : (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_401)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_to_eq. For all natural numbers $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$, for all elements $__$ of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$, for all elements $__1$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, $q$ is equal to $q1$.",
    "output": "postulate div_mod_spec_to_eq : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq q q1"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z353$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z354$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "And_inv_rect_Type0 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ univs.Type0) -> _H1 : (x_144 : cic.Term cic.prop x1 -> x_143 : cic.Term cic.prop x2 -> _z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143)) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type2. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z341$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z342$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_136$ and $x_135$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_136$ and $x_135$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Axiom And_inv_rect_Type2 : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2), forall P : ((_z341 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((x_136 : cic.Term cic.prop x1) -> (x_135 : cic.Term cic.prop x2) -> (_z342 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_136 x_135))) -> cic.Term univs.Type2 (P (matita_basics_logic.conj x1 x2 x_136 x_135))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Tri_relation. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "Axiom tri_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, forall __2 : cic.Univ univs.Type0, cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.",
    "output": "axiom le_sqrt_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_sqrt.sqrt n) n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15624. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.",
    "output": "Axiom let_clause_15624 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), m * d - n * c = 1 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1692. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.",
    "output": "axiom let_clause_1692 (m : Nat) (posm : 0 < m) (a x358 x359 : Nat) : aop__o__op Nat 0 plusAC x358 (x358 * x359) = x358 * (x359 + 1)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1. For all sets $_A$, for all functions $Q_$ from elements $_x_925$ of $range$ of $_A$ to elements of $Type1$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $range$ of $_A$, $Q_$ holds for $x_925$.",
    "output": "Axiom range_rect_Type1 : forall _A : Set, forall Q_ : ((_x_925 : range _A) -> Type1), forall _H_mk_range : ((_enum : (x__ : nat) -> _A) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)), forall x_925 : range _A, Q_ x_925 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_times_n_to_lt_l. For all natural numbers $n$ and $p$ and $q$, if the product of $p$ and $n$ is less than the product of $q$ and $n$, then $p$ is less than $q$.",
    "output": "postulate lt_times_n_to_lt_l : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times p n) (times q n)) -> Lt p q"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp0. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_115$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_116$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_116$, for all elements $x_115$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_115$.",
    "output": "axiom Not_rect_CProp0 (_A : cic.Univ cic.prop) (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term cic.prop (Q_ x_115)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_ind. For all functions $Q_$ from elements $_x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_366$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_368$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_366$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_366$, for all elements $x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_365$.",
    "output": "axiom nat_ind (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_365)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $m$ and $m$.",
    "output": "f_invert_permut : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> __1 : cic.Term cic.prop (matita_arithmetics_permutation.permut f n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_permutation.invert_permut n f m)) m) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_smallest_factor_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.",
    "output": "Axiom divides_smallest_factor_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor n) n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop20. For all instances $n$ of natural numbers, if we can prove that $n$ is even, then we can prove that the sum of $n$ and $1$ is odd.",
    "output": "Axiom prop20 : forall n : nat, (even n -> odd (n + 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_Sfalse. For all natural numbers $k$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $p$ applied to $k$ is equal to absurdity, then $bigop$ applied to the sum of $k$ and $1$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_True. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_I$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.I$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (case_I : cic.Term return_sort (return_type matita_basics_logic.I)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_prime_O. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom not_prime_O : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_905$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_905$.",
    "output": "ACop_rect_CProp5_body : A : Set -> _nil : A -> Q_ : (_x_905 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_905 : ACop A _nil -> Q_ x_905 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_div_S_div. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then if the exponentiation of $m$ and $2$ is less than or equal to $n$, then the quotient of $n$ and the sum of $m$ and $1$ is less than the quotient of $n$ and $m$.",
    "output": "lt_div_S_div : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Leq (pow m (nd 2)) n -> Lt (div n (plus m (nd 1))) (div n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_mod. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.",
    "output": "axiom gcd_mod (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pred. For all natural numbers $_n$, $Nat$.",
    "output": "postulate pred : (_n : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_n_n. For all natural numbers $n$, if $0$ is less than $n$, then $mod$ applied to $n$ and $n$ is equal to $0$.",
    "output": "postulate mod_n_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (mod n n) 0"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_div_mod_spec. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $return_sort$, for all functions $case_div_mod_spec_intro$ from elements of $Lt$ of $_r$ and $_m$ and elements $__1$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $return_type$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $__$ and $__1$, for all elements $z$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $return_type$ holds for $z$.",
    "output": "Axiom match_div_mod_spec : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall return_sort : Sort, forall return_type : ((z : div_mod_spec _n _m _q _r) -> return_sort), forall case_div_mod_spec_intro : ((x__ : _r < _m) -> (__1 : _n = _q * _m + _r) -> return_type (div_mod_spec_intro _n _m _q _r x__ __1)), forall z : div_mod_spec _n _m _q _r, return_type z ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp5. For all functions $Q_$ from elements $_x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_74$.",
    "output": "False_rect_CProp5 : Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_74 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_74) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_inv_lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "axiom lstar_r_inv_lstar (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair4. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate cr_pair4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_877$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_877$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_877$.",
    "output": "axiom Aop_rect_CProp5 (A : Set) (_nil : A) (Q_ : (_x_877 : Aop A _nil) -> Prop) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_877 : Aop A _nil) : Q_ x_877"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1560. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "let_clause_1560 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_gcd_r. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is divisible by $m$.",
    "output": "axiom divides_gcd_r (n m : Nat) : divisible (gcd n m) m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_ind_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x$ and $p$.",
    "output": "eq_ind_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term cic.prop (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True. $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "true : cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type3_body. For all functions $Q_$ from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.",
    "output": "axiom True_rect_Type3_body (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) (x_46 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type3 (Q_ x_46)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type3. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_821$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type3$, for all functions $_H_div_mod_spec_intro$ from elements $x_823$ of $Lt$ of $_r$ and $_m$ and elements $x_822$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_823$ and $x_822$, for all elements $x_821$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_821$.",
    "output": "Axiom div_mod_spec_rect_Type3 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_821 : div_mod_spec _n _m _q _r) -> Type3), forall _H_div_mod_spec_intro : ((x_823 : _r < _m) -> (x_822 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)), forall x_821 : div_mod_spec _n _m _q _r, Q_ x_821 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nth_prime_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom nth_prime_body (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_640$.",
    "output": "DPair_rect_Type4_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type4) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type4 (Q_ x_640) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dividesb_true_to_lt_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$.",
    "output": "dividesb_true_to_lt_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_lstar_r. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from natural numbers and elements $__1$ of $B$ and elements $__2$ of $B$ and elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_sort$, for all functions $case_lstar_r_O$ from elements $b$ of $B$ to elements of $return_type$ of $0$ and $b$ and $b$ and $lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_r_S$ from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements of $lstar_r$ of $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $B$ and elements $__1$ of $_R$ of $b$ and $b2$ to elements of $return_type$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $__$ and $b2$ and $__1$, for all natural numbers $__$, for all elements $__1$ and $__2$ of $B$, for all elements $z$ of $lstar_r$ of $B$ and $_R$ and $__$ and $__1$ and $__2$, $return_type$ holds for $__$ and $__1$ and $__2$ and $z$.",
    "output": "match_lstar_r : B : Set -> _R : relation B -> return_sort : Sort -> return_type : (__ : Nat -> __1 : B -> __2 : B -> z : lstar_r B _R __ __1 __2 -> return_sort) -> case_lstar_r_O : (b : B -> return_type 0 b b (lstar_r_O B _R b)) -> case_lstar_r_S : (l : Nat -> b1 : B -> b : B -> __ : lstar_r B _R l b1 b -> b2 : B -> __1 : _R b b2 -> return_type (plus l (nd 1)) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> __ : Nat -> __1 : B -> __2 : B -> z : lstar_r B _R __ __1 __2 -> return_type __ __1 __2 z ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16003. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$.",
    "output": "postulate let_clause_16003 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_dividesb_true. For all natural numbers $n$ and $m$, if $0$ is less than $n$, then if $n$ is divisible by $m$, then $dividesb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "divides_to_dividesb_true : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : divisible n m -> Eq (dividesb n m) true ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_n_nth_prime_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.",
    "output": "axiom lt_n_nth_prime_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.nth_prime n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below_lop. For all natural numbers $n$, $primes_below$ holds for $list_of_primes$ applied to $n$ and the sum of $n$ and $2$.",
    "output": "postulate primes_below_lop : (n : Nat) -> primes_below (list_of_primes n) (plus n 2)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type0. For all functions $Q_$ from elements $_x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_true$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_344$.",
    "output": "postulate bool_rect_Type0 : (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) -> (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ x_344)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_times_div_minus_mod. For all natural numbers $a$ and $b$, the product of the quotient of $a$ and $b$ and $b$ is equal to the difference of $a$ and $mod$ applied to $a$ and $b$.",
    "output": "Axiom eq_times_div_minus_mod : forall a : nat, forall b : nat, a / b * b = a - mod a b ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1698$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1699$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Dop_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z281$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $x_95$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z282$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_95$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_95$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom Not_inv_rect_Type1 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z281 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type1), forall _H1 : ((x_95 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z282 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_95))) -> cic.Term univs.Type1 (P (matita_basics_logic.nmk x1 x_95))), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mem_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom mem_body (H : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 H) (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_max_spec. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_max_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "axiom div_mod_spec_rect_CProp2_body (_n _m _q _r : Nat) (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_851 : _r < _m) -> (x_850 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) (x_849 : div_mod_spec _n _m _q _r) : Q_ x_849"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_inv_ind. For all natural numbers $x1$ and $x2$, for all functions $x3$ from natural numbers to booleans, for all natural numbers $x4$, for all elements $_Hterm$ of $min_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from natural numbers $_z1890$ to propositions, for all functions $_H1$ from natural numbers $m$ and elements $_x_1080$ of $Leq$ of $x2$ and $m$ and elements $_x_1079$ of $Lt$ of $m$ and the sum of $x1$ and $x2$ and elements $_x_1078$ of $Eq$ of $x3$ applied to $m$ and $true$ and functions $_x_1077$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $x3$ applied to $i$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and $m$ to elements of $P$ of $m$, for all functions $_H2$ from functions $_x_1081$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $x1$ and $x2$ to elements of $Eq$ of $x3$ applied to $i$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and the sum of $x1$ and $x2$ to elements of $P$ of the sum of $x1$ and $x2$, $P$ holds for $x4$.",
    "output": "axiom min_spec_inv_ind (x1 x2 : Nat) (x3 : (x__ : Nat) -> bool) (x4 : Nat) (_Hterm : min_spec x1 x2 x3 x4) (P : (_z1890 : Nat) -> Prop) (_H1 : (m : Nat) -> (_x_1080 : x2 ≤ m) -> (_x_1079 : m < x1 + x2) -> (_x_1078 : x3 m = true) -> (_x_1077 : (i : Nat) -> (x__ : x2 ≤ i) -> (__1 : i < m) -> x3 i = false) -> (_z1891 : x4 = m) -> P m) (_H2 : (_x_1081 : (i : Nat) -> (x__ : x2 ≤ i) -> (__1 : i < x1 + x2) -> x3 i = false) -> (_z1891 : x4 = x1 + x2) -> P (x1 + x2)) : P x4"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type1_body. For all functions $Q_$ from natural numbers $_x_385$ to elements of $Type1$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_386$ and elements $_x_388$ of $Q_$ of $x_386$ to elements of $Q_$ of the sum of $x_386$ and $1$, for all natural numbers $x_385$, $Q_$ holds for $x_385$.",
    "output": "nat_rect_Type1_body : Q_ : (_x_385 : Nat -> Type1) -> _H_O : Q_ 0 -> _H_S : (x_386 : Nat -> _x_388 : Q_ x_386 -> Q_ (plus x_386 (nd 1))) -> x_385 : Nat -> Q_ x_385 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_O. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b$ of $B$, $lstar_r$ holds for $B$ and $R$ and $0$ and $b$ and $b$.",
    "output": "axiom lstar_r_O (B : Set) (R : relation B) (b : B) : lstar_r B R 0 b b"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp1. For all natural numbers $n$ and $m$ and $a$, if $0$ is less than $a$, then if $n$ is less than or equal to $m$, then the exponentiation of $n$ and $a$ is less than or equal to the exponentiation of $m$ and $a$.",
    "output": "postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Leq (pow n a) (pow m a)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1278$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1279$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_ord_rem. For all natural numbers $p$ and $q$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $q$ is prime, then if $q$ is less than $p$, then $ord$ applied to $ord_rem$ applied to $m$ and $p$ and $q$ is equal to $ord$ applied to $m$ and $q$.",
    "output": "postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_672$.",
    "output": "Axiom Sig_rect_Type2_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type2 (Q_ x_672) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop70. We can prove that $1$ is odd.",
    "output": "axiom prop70 : odd 1"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_conj$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_132$ and $x_131$, for all elements $x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_130$.",
    "output": "And_rect_Type3 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type3) -> _H_conj : (x_132 : cic.Term cic.prop _A -> x_131 : cic.Term cic.prop _B -> cic.Term univs.Type3 (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) -> x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type3 (Q_ x_130) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_log. For all natural numbers $p$ and $n$, if $0$ is less than $n$, then the exponentiation of $p$ and the logarithm of $p$ and $n$ is less than or equal to $n$.",
    "output": "le_exp_log : p : Nat -> n : Nat -> __ : Lt 0 n -> Leq (pow p (log p n)) n ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1608$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1609$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom ACop_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1608 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1609 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_to_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.",
    "output": "postulate le_plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_r_S$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and $__$ and $b2$ and $__1$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $__1$ and $__2$ and $z$.",
    "output": "Axiom match_lstar_r : forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort), forall case_lstar_r_O : ((b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))), forall case_lstar_r_S : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 B, forall __2 : cic.Term univs.Type0 B, forall z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2), cic.Term return_sort (return_type __ __1 __2 z) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $_A$ be a set. Then $range$ applied to $_A$ is a set.",
    "output": "Axiom range : forall _A : Set, Set ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "axiom Aop_rect_CProp1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_803)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_2_pred. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom times_2_pred : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred n)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_658$.",
    "output": "axiom DPair_rect_CProp2 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_658)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mdef. For all natural numbers $m$, $M$ applied to $m$ is equal to $bc$ applied to the sum of the product of $2$ and $m$ and $1$ and $m$.",
    "output": "Mdef : m : Nat -> Eq (M m) (bc (plus (times (nd 2) m) (nd 1)) m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_conj$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_132$ and $x_131$, for all elements $x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_130$.",
    "output": "postulate And_rect_Type3_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type3) -> (_H_conj : (x_132 : cic.Term cic.prop _A) -> (x_131 : cic.Term cic.prop _B) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) -> (x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type3 (Q_ x_130)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_nth_prime_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.",
    "output": "axiom lt_O_nth_prime_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_primes.nth_prime n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_minus_to_plus_r. For all natural numbers $a$ and $b$ and $c$, if $a$ is less than the difference of $b$ and $c$, then the sum of $a$ and $c$ is less than $b$.",
    "output": "lt_minus_to_plus_r : a : Nat -> b : Nat -> c : Nat -> __ : Lt a (minus b c) -> Lt (plus a c) b ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_f_g. For all functions $f$ and $g$ from natural numbers to booleans, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ to elements of $Eq$ of $f$ applied to $i$ and $g$ applied to $i$, $max$ applied to $n$ and $f$ is equal to $max$ applied to $n$ and $g$.",
    "output": "max_f_g : f : (__ : Nat -> bool) -> g : (__ : Nat -> bool) -> n : Nat -> __ : (i : Nat -> __ : Lt i n -> Eq (f i) (g i)) -> Eq (max n f) (max n g) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_748$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_747$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_750$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_747$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_748$ and $x_747$, for all elements $x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_746$.",
    "output": "axiom list_rect_Type0_body (_A : cic.Univ univs.Type0) (Q_ : (_x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type0) (_H_nil : cic.Term univs.Type0 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_748 : cic.Term univs.Type0 _A) -> (x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_750 : cic.Term univs.Type0 (Q_ x_747)) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.cons _A x_748 x_747))) (x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type0 (Q_ x_746)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_And. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_And (_A _B : cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "Axiom Dop_rect_CProp2_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_963 : Dop A _nil) -> Prop), forall _H_mk_Dop : ((sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)), forall x_963 : Dop A _nil, Q_ x_963 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "B : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.",
    "output": "Axiom ACop_rect_Type0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type0 (Q_ x_901) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_minr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$.",
    "output": "postulate le_minr : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le i m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_927$ of $range$ of $_A$ to sets, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $range$ of $_A$, $Q_$ holds for $x_927$.",
    "output": "range_rect_Type0_body : _A : Set -> Q_ : (_x_927 : range _A -> Set) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_927 : range _A -> Q_ x_927 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate log : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "axiom eqb_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_4_to_le_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "postulate lt_4_to_le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nill_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.",
    "output": "nill_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp5. For all functions $Q_$ from elements $_x_350$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_350$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_350$.",
    "output": "postulate bool_rect_CProp5 : (Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_350)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_sqrt_n. For all natural numbers $n$, the square root of $n$ is less than or equal to $n$.",
    "output": "Axiom le_sqrt_n : forall n : nat, Leq (sqrt n) n ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_mod. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then $mod$ applied to the sum of $m$ and $n$ and $q$ is less than or equal to the sum of $mod$ applied to $m$ and $q$ and $mod$ applied to $n$ and $q$.",
    "output": "postulate le_plus_mod : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> Leq (mod (plus m n) q) (plus (mod m q) (mod n q))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_25$ and $x_26$.",
    "output": "eq_rect_CProp5 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_25 : cic.Term univs.Type2 A -> _x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_25 : cic.Term univs.Type2 A -> x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) -> cic.Term cic.prop (Q_ x_25 x_26) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.",
    "output": "Axiom DPair_rect_Type0 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type0 (Q_ x_650) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_B. For all natural numbers $n$, if $0$ is less than $n$, then the exponentiation of $2$ and the product of $2$ and $n$ is less than or equal to the product of the product of $2$ and $n$ and $B$ applied to the product of $2$ and $n$.",
    "output": "Axiom le_exp_B : forall n : nat, forall x__ : (0 < n), Leq (pow 2 (2 * n)) (2 * n * B (2 * n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Is_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate is_nil : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_O_to_eq_O. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.",
    "output": "postulate permut_O_to_eq_O : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut h matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h matita_arithmetics_nat.O) matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_Sn_O. For all natural numbers $n$, the sum of $n$ and $1$ is not less than or equal to $0$.",
    "output": "Axiom not_le_Sn_O : forall n : nat, ~ Leq (n + 1) 0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_to_injn. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "injective_to_injn : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type5. For all functions $Q_$ from elements $_x_332$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_true$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_332$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_332$.",
    "output": "Axiom bool_rect_Type5 : forall Q_ : ((_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5), forall _H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false), forall x_332 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type5 (Q_ x_332) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.",
    "output": "eq_rect_Type1_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_16 : cic.Term univs.Type2 A -> _x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) -> cic.Univ univs.Type1) -> _H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x)) -> x_16 : cic.Term univs.Type2 A -> x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) -> cic.Term univs.Type1 (Q_ x_16 x_17) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "max : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_times_plus_to_congruent. For all natural numbers $n$ and $m$ and $p$ and $r$, if $0$ is less than $p$, then if $n$ is equal to the sum of the product of $r$ and $p$ and $m$, then $congruent$ holds for $n$ and $m$ and $p$.",
    "output": "postulate eq_times_plus_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : Eq n (plus (times r p) m)) -> congruent n m p"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_873$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_873$.",
    "output": "axiom Aop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type0 (Q_ x_873)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "minus_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.",
    "output": "commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_minr. For all natural numbers $i$ and $n$ and $m$, if $i$ is less than or equal to $min$ applied to $n$ and $m$, then $i$ is less than or equal to $m$.",
    "output": "Axiom le_minr : forall i : nat, forall n : nat, forall m : nat, forall x__ : Leq i (min n m), Leq i m ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reflexive_divides. $reflexive$ holds for $Nat$ and $divisible$.",
    "output": "axiom reflexive_divides : reflexive Nat divisible"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primeb. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "primeb : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1339$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_753$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_752$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_755$ from elements $_z1339$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_752$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_752$ and elements $_z1339$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_753$ and $x_752$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_753$ and $x_752$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "list_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1338 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ cic.prop) -> _H1 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_753 : cic.Term univs.Type0 x1 -> x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_755 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_752) -> cic.Term cic.prop (P x_752)) -> _z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_753 x_752)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_753 x_752))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_assoc_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R1$ and $R2$ and $R3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R2$ and $R3$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R3$.",
    "output": "postulate sub_assoc_r : (A : cic.Univ univs.Type0) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R3 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3) (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_invert_permut. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $permut$ of $f$ and $n$, $permut$ holds for $invert_permut$ applied to $n$ and $f$ and $n$.",
    "output": "Axiom permut_invert_permut : forall f : ((x__ : nat) -> nat), forall n : nat, forall x__ : permut f n, permut (invert_permut n f) n ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_false_to_le_max. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $p$.",
    "output": "postulate f_false_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "times_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp5. For all functions $Q_$ from elements $_x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_490$.",
    "output": "axiom void_rect_CProp5 (Q_ : (_x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_490 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_490)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_903$.",
    "output": "Axiom ACop_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_903) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_793$.",
    "output": "axiom Aop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type0 (Q_ x_793)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb5. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "axiom pi_p_primeb5 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.",
    "output": "postulate gcd_n_n : (n : Nat) -> Eq (gcd n n) n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_le_0. For all natural numbers $x$ and $y$, if the sum of $x$ and $y$ is less than or equal to $0$, then $x$ is equal to $0$ and $y$ is equal to $0$.",
    "output": "plus_le_0 : x : Nat -> y : Nat -> __ : Leq (plus x y) 0 -> and (Eq x 0) (Eq y 0) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "fact_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound6. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then for all natural numbers $x$, $Nat$.",
    "output": "Axiom let_upper_bound6 : forall n : nat, forall m : nat, forall ltml : (nth_prime n < m), forall x : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_ind_plus. For all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $n$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $n$.",
    "output": "postulate nat_ind_plus : (R : cic.Term univs.Type0 (matita_basics_relations.predicate matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (R matita_arithmetics_nat.O)) -> (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (R n)) -> cic.Term cic.prop (R (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R n)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_mod_to_divides. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $q$, then if $mod$ applied to $n$ and $q$ is equal to $mod$ applied to $m$ and $q$, then $q$ is divisible by the difference of $n$ and $m$.",
    "output": "postulate eq_mod_to_divides : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Eq (mod n q) (mod m q)) -> divisible q (minus n m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fmin_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, $prod$ holds for $Prop$ and $Prop$ and $Eq$ applied to $f$ applied to $let_m$ applied to $f$ and $n$ and $b$ and absurdity and the function that maps $__$ to $Eq$ applied to $let_m$ applied to $f$ and $n$ and $b$ and the sum of $n$ and $b$.",
    "output": "axiom fmin_false (f : (x__ : Nat) -> bool) (n b : Nat) : prod Prop Prop (f (let_m f n b) = false) (λ x__ => let_m f n b = n + b)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $Lt$ of $_r$ and $_m$ and elements $x_846$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_845$.",
    "output": "axiom div_mod_spec_rect_CProp3 (_n _m _q _r : Nat) (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_847 : _r < _m) -> (x_846 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) (x_845 : div_mod_spec _n _m _q _r) : Q_ x_845"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_not_eq_O. For all natural numbers $n$ and $p$ and $q$ and $r$, if $1$ is less than $n$, then if $p_ord$ applied to $n$ and $nth_prime$ applied to $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $q$ and $r$, then $r$ is not equal to $0$.",
    "output": "axiom p_ord_to_not_eq_O (n p q r : Nat) (x__ : 1 < n) (__1 : p_ord n (nth_prime p) = mk_Prod Nat Nat q r) : ¬ (r = 0)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp2_body. For all functions $Q_$ from elements $_x_60$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_60$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_60$.",
    "output": "postulate True_rect_CProp2_body : (Q_ : (_x_60 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_60 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_60)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus_m_m. For all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then $n$ is equal to the sum of the difference of $n$ and $m$ and $m$.",
    "output": "Axiom plus_minus_m_m : forall n : nat, forall m : nat, forall x__ : Leq m n, n = n - m + m ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_CProp2. For all functions $Q_$ from elements $_x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_356$.",
    "output": "Axiom bool_rect_CProp2 : forall Q_ : ((_x_356 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_356 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_356) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_ind. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions, for all functions $_H_found_min_spec$ from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all natural numbers $x_1075$, for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.",
    "output": "axiom min_spec_ind (_n _b : Nat) (_f : (x__ : Nat) -> bool) (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) (_H_found_min_spec : (m : Nat) -> (x_1080 : _b ≤ m) -> (x_1079 : m < _n + _b) -> (x_1078 : _f m = true) -> (x_1077 : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < m) -> _f i = false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < _n + _b) -> _f i = false) -> Q_ (_n + _b) (not_found_min_spec _n _b _f x_1081)) (x_1075 : Nat) (x_1076 : min_spec _n _b _f x_1075) : Q_ x_1075 x_1076"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_SO. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.",
    "output": "Axiom log_SO : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_877$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_877$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_877$.",
    "output": "Axiom Aop_rect_CProp5_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_877) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp1_body. For all functions $Q_$ from elements $_x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_62$.",
    "output": "axiom True_rect_CProp1_body (Q_ : (_x_62 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_62 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_62)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iter. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.",
    "output": "iter : H : cic.Univ univs.Type0 -> __ : (__ : cic.Term univs.Type0 H -> cic.Term univs.Type0 H) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 H -> cic.Term univs.Type0 H ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transpose_transpose. For all natural numbers $i$ and $j$ and $n$, $transpose$ applied to $i$ and $j$ and $transpose$ applied to $i$ and $j$ and $n$ is equal to $n$.",
    "output": "axiom transpose_transpose (i j n : Nat) : transpose i j (transpose i j n) = n"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_exp1. For all natural numbers $p$ and $n$ and $q$ and $r$, if $1$ is less than $p$, then if $0$ is less than $n$, then if $p_ord$ applied to $n$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $q$ and $r$, then $p$ is not divisible by $r$ and $n$ is equal to the product of the exponentiation of $p$ and $q$ and $r$.",
    "output": "postulate p_ord_to_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Eq (p_ord n p) (mk_Prod Nat Nat q r)) -> and (not (divisible p r)) (Eq n (times (pow p q) r))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_4_to_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "Axiom lt_4_to_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_times. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.times$ applied to $n2$ and $m2$.",
    "output": "Axiom le_times : forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n1 m1) (matita_arithmetics_nat.times n2 m2)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_n_1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "exp_n_1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_le. For all natural numbers $_n$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$, for all elements $case_le_n$ of $return_type$ of $_n$ and $le_n$ applied to $_n$, for all functions $case_le_S$ from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $__$, for all natural numbers $__$, if $_n$ is less than or equal to $__$, then $return_type$ holds for $__$ and $z$.",
    "output": "axiom match_le (_n : Nat) (return_sort : Sort) (return_type : (x__ : Nat) -> (z : _n ≤ __) -> return_sort) (case_le_n : return_type _n (le_n _n)) (case_le_S : (m : Nat) -> (x__ : _n ≤ m) -> return_type (m + 1) (le_S _n m __)) (x__ : Nat) (z : _n ≤ __) : return_type __ z"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Start_lop. For all natural numbers $n$, if $1$ is less than or equal to $n$, then $option_hd$ applied to $Nat$ and $list_of_primes$ applied to $n$ is equal to $Some$ applied to $Nat$ and $2$.",
    "output": "start_lop : n : Nat -> __ : Leq (nd 1) n -> Eq (option_hd Nat (list_of_primes n)) (Some Nat (nd 2)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_smallest_factor. For all natural numbers $n$, if $n$ is prime, then $smallest_factor$ applied to $n$ is equal to $n$.",
    "output": "axiom prime_to_smallest_factor (n : Nat) (x__ : prime n) : smallest_factor n = n"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1530$ of $Aop$ of $x1$ and $x2$ to sets, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1531$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F3_ind_aux. For all sets $A1$ and $A2$ and $A3$, for all functions $f$ from elements of $A1$ and elements $__1$ of $A2$ and elements $__2$ of $A3$ to natural numbers, for all elements $P$ of $relation3$ of $A1$ and $A2$ and $A3$, for all functions $__$ from natural numbers $n$ and functions from elements $a1$ of $A1$ and elements $a2$ of $A2$ and elements $a3$ of $A3$ and elements of $Lt$ of $f$ applied to $a1$ and $a2$ and $a3$ and $n$ to elements of $P$ of $a1$ and $a2$ and $a3$ and elements $a1$ of $A1$ and elements $a2$ of $A2$ and elements $a3$ of $A3$ and elements $__1$ of $Eq$ of $f$ applied to $a1$ and $a2$ and $a3$ and $n$ to elements of $P$ of $a1$ and $a2$ and $a3$, for all natural numbers $n$, for all elements $a1$ of $A1$, for all elements $a2$ of $A2$, for all elements $a3$ of $A3$, if $f$ applied to $a1$ and $a2$ and $a3$ is equal to $n$, then $P$ holds for $a1$ and $a2$ and $a3$.",
    "output": "postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nil_append_elim. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.",
    "output": "Axiom nil_append_elim : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall P : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A)), forall __1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A)), cic.Term cic.prop (P l1 l2) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt1n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type3. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_821$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type3$, for all functions $_H_div_mod_spec_intro$ from elements $x_823$ of $Lt$ of $_r$ and $_m$ and elements $x_822$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_823$ and $x_822$, for all elements $x_821$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_821$.",
    "output": "axiom div_mod_spec_rect_Type3 (_n _m _q _r : Nat) (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) (_H_div_mod_spec_intro : (x_823 : _r < _m) -> (x_822 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) (x_821 : div_mod_spec _n _m _q _r) : Q_ x_821"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.",
    "output": "f_ind : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.predicate A) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n) -> cic.Term cic.prop (P a)) -> a : cic.Term univs.Type0 A -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n) -> cic.Term cic.prop (P a)) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (P a) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_div_div_div_times. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $n$, then if $0$ is less than $m$, then the quotient of the quotient of $q$ and $n$ and $m$ is equal to the quotient of $q$ and the product of $n$ and $m$.",
    "output": "Axiom eq_div_div_div_times : forall n : nat, forall m : nat, forall q : nat, forall x__ : (0 < n), forall __1 : (0 < m), q / n / m = q / (n * m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_ind. For all functions $Q_$ from elements $_x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_366$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_368$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_366$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_366$, for all elements $x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_365$.",
    "output": "postulate nat_ind : (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) -> (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_365)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rev_append. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.",
    "output": "Axiom rev_append : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Term univs.Type0 (matita_basics_lists_list.list H) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_907$.",
    "output": "postulate ACop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_907)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative_max. $commutative$ holds for $Nat$ and $max$.",
    "output": "axiom commutative_max : commutative Nat max"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mem_append_l1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "Axiom mem_append_l1 : forall A : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a l1), cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_S_fact. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "Axiom not_divides_S_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le i n), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.",
    "output": "postulate aop_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair5. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "cr_pair5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) matita_arithmetics_nat.O (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp0. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_115$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_116$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_116$, for all elements $x_115$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_115$.",
    "output": "postulate Not_rect_CProp0 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.O$.",
    "output": "Axiom mod_O_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod matita_arithmetics_nat.O n) matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_869$ of $Aop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_869$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_869$.",
    "output": "Aop_rect_Type2_body : A : Set -> _nil : A -> Q_ : (_x_869 : Aop A _nil -> Type2) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_869 : Aop A _nil -> Q_ x_869 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp2. For all sets $_A$, for all functions $Q_$ from elements $_x_935$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_935$ of $range$ of $_A$, $Q_$ holds for $x_935$.",
    "output": "axiom range_rect_CProp2 (_A : Set) (Q_ : (_x_935 : range _A) -> Prop) (_H_mk_range : (_enum : (x__ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (x__ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) (x_935 : range _A) : Q_ x_935"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_len. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split$ applied to $A$ and $l$ and $n$ and $n$.",
    "output": "postulate split_len : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))) n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_891$.",
    "output": "Axiom ACop_rect_Type4_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type4 (Q_ x_891) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Type4. $cic.Sort$.",
    "output": "Axiom Type4 : cic.Sort ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injective_times_l. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $m$ and $n$.",
    "output": "Axiom injective_times_l : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (fun m => matita_arithmetics_nat.times m n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact_to_exp. For all natural numbers $n$, the factorial of the product of $2$ and $n$ is less than or equal to the product of the product of the exponentiation of $2$ and $pred$ applied to the product of $2$ and $n$ and the factorial of $n$ and the factorial of $n$.",
    "output": "postulate fact_to_exp : (n : Nat) -> Leq (factorial (times 2 n)) (times (times (pow 2 (pred (times 2 n))) (factorial n)) (factorial n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "lt_O_bc : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound4. For all natural numbers $n$ and $m$, $Nat$.",
    "output": "postulate let_upper_bound4 : (n : Nat) -> (m : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_47. We can prove that for all integers $n$, the sum of the difference of the exponentiation of $n$ and $2$ and the product of $3$ and $n$ and $9$ is odd.",
    "output": "Axiom noLabel_47 : forall n : Int, odd (pow n 2 - 3 * n + 9) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1554$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1555$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "postulate Aop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1554 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1555 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp4_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_100$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_101$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_101$, for all elements $x_100$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_100$.",
    "output": "axiom Not_rect_CProp4_body (_A : cic.Univ cic.prop) (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term cic.prop (Q_ x_100)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1617. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $p$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $p$ is divisible by the product of $m$ and $n$, then for all natural numbers $c$, if the product of $m$ and $n$ is equal to the product of $p$ and $c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.",
    "output": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_865$ of $Aop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_865$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_865$.",
    "output": "Axiom Aop_rect_Type5_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_865 : Aop A _nil) -> Type5), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_865 : Aop A _nil, Q_ x_865 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_Type2. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z341$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z342$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_136$ and $x_135$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_136$ and $x_135$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "axiom And_inv_rect_Type2 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z341 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type2) (_H1 : (x_136 : cic.Term cic.prop x1) -> (x_135 : cic.Term cic.prop x2) -> (_z342 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_136 x_135))) -> cic.Term univs.Type2 (P (matita_basics_logic.conj x1 x2 x_136 x_135))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type2. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "nat_rect_Type2 : Q_ : (_x_381 : Nat -> Type2) -> _H_O : Q_ 0 -> _H_S : (x_382 : Nat -> _x_384 : Q_ x_382 -> Q_ (plus x_382 (nd 1))) -> x_381 : Nat -> Q_ x_381 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_to_fact1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom exp_to_fact1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb_true_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "axiom eqb_true_to_eq (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact_pi_p2. For all natural numbers $n$, the factorial of the product of $2$ and $n$ is equal to $bigop$ applied to the sum of the product of $2$ and $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and the product of $2$ and $n$ and the function that maps $i$ to $true$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to the product of the exponentiation of $p$ and the product of $2$ and the quotient of $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ and the exponentiation of $p$ and $mod$ applied to the quotient of the product of $2$ and $n$ and the exponentiation of $p$ and the sum of $i$ and $1$ and $2$.",
    "output": "Axiom fact_pi_p2 : forall n : nat, factorial (2 * n) = bigop (2 * n + 1) (fun p => primeb p) nat 1 times (fun p => bigop (log p (2 * n)) (fun i => true) nat 1 times (fun i => pow p (2 * (n / pow p (i + 1))) * pow p (mod (2 * n / pow p (i + 1)) 2))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_to_divides. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "axiom congruent_to_divides (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)) : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing_to_monotonic. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, $monotonic$ holds for $Nat$ and $Lt$ and $f$.",
    "output": "Axiom increasing_to_monotonic : forall f : ((x__ : nat) -> nat), forall x__ : increasing f, monotonic nat Lt f ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_inv_ind. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z587$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "bool_inv_ind : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z587 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop140. For all instances $x$ and $y$ of integers, we can prove that $x$ is equal in parity with $y$, if and only if the sum of $x$ and $y$ is even.",
    "output": "Axiom prop140 : forall x : Int, forall y : Int, (same_parity x y <-> even (x + y)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1602$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1603$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom ACop_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1602 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1603 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_ord_rem. For all elements $p$ and $q$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$ and $q$ and $matita_arithmetics_ord.ord$ applied to $m$ and $q$.",
    "output": "postulate ord_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime q)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt q p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_ord.ord_rem m p) q) (matita_arithmetics_ord.ord m q))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_primeb_true. For all natural numbers $n$, if $n$ is prime, then $primeb$ applied to $n$ is equal to $true$.",
    "output": "Axiom prime_to_primeb_true : forall n : nat, forall x__ : prime n, primeb n = true ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and $ord$ applied to $n$ and $p$.",
    "output": "pi_p_primeb : n : Nat -> __ : Lt 0 n -> Eq n (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (ord n p))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ld_to_prime. For all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.list_divides$ applied to $acc$ and $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $i$.",
    "output": "ld_to_prime : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.false) -> cic.Term cic.prop (matita_arithmetics_primes.prime i) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "range_rect_Type0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type0) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type0 (Q_ x_927) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_O_to_eq. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom le_n_O_to_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "Sum_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_562 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> _H_inr : (x_563 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_561) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "DPair : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_leb_true. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.true$.",
    "output": "postulate le_to_leb_true : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb_dividesb. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $andb$ applied to $primeb$ applied to $p$ and $dividesb$ applied to $p$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to the exponentiation of $p$ and $ord$ applied to $n$ and $p$.",
    "output": "axiom pi_p_primeb_dividesb (n : Nat) (x__ : 0 < n) : n = bigop (n + 1) (λ p => andb (primeb p) (dividesb p n)) Nat 1 times (λ p => pow p (ord n p))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_exp1. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $n$ is less than $m$, then the exponentiation of $n$ and $p$ is less than the exponentiation of $m$ and $p$.",
    "output": "axiom lt_exp1 (n m p : Nat) (x__ : 0 < p) (__1 : n < m) : pow n p < pow m p"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fmin_true. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$.",
    "output": "axiom fmin_true (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_minimization.min n b f))) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_ind. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_720$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_717$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_718$ and $x_717$, for all elements $x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_716$.",
    "output": "postulate list_ind : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_718 : cic.Term univs.Type0 _A) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_720 : cic.Term cic.prop (Q_ x_717)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> (x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_716)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_S. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, for all natural numbers $l0$, if the sum of $l0$ and $1$ is equal to $l$, then $ex2$ holds for $B$ and the function that maps $b$ to $R$ applied to $b1$ and $b$ and the function that maps $b$ to $lstar$ applied to $B$ and $R$ and $l0$ and $b$ and $b2$.",
    "output": "postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (__1 : Eq (plus l0 1) l) -> ex2 B (\\ b : B -> R b1 b) (\\ b : B -> lstar B R l0 b b2)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type4. For all functions $Q_$ from elements $_x_369$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_O$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_370$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_372$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $x_370$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_370$, for all elements $x_369$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_369$.",
    "output": "Axiom nat_rect_Type4 : forall Q_ : ((_x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type4), forall _H_O : cic.Term univs.Type4 (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_370 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_372 : cic.Term univs.Type4 (Q_ x_370)) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_nat.S x_370))), forall x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type4 (Q_ x_369) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bc1. For all natural numbers $n$ and $k$, if $k$ is less than $n$, then $bc$ applied to the sum of $n$ and $1$ and the sum of $k$ and $1$ is equal to the sum of $bc$ applied to $n$ and $k$ and $bc$ applied to $n$ and the sum of $k$ and $1$.",
    "output": "postulate bc1 : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (bc (plus n 1) (plus k 1)) (plus (bc n k) (bc n (plus k 1)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_transpose_l. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $f$ applied to $n$ and $m$.",
    "output": "permut_transpose_l : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le j m) -> __2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_permutation.transpose i j (f n)) m) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_to_not_eq_O. For all elements $n$ and $p$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $r$ and $matita_arithmetics_nat.O$.",
    "output": "Axiom p_ord_to_not_eq_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime p)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)), cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_exp_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "Axiom exp_exp_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound7. For all natural numbers $n$ and $m$, if $nth_prime$ applied to $n$ is less than $m$, then $Nat$.",
    "output": "Axiom let_upper_bound7 : forall n : nat, forall m : nat, forall ltml : (nth_prime n < m), nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type0. For all functions $Q_$ from natural numbers $_x_389$ to sets, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_390$ and elements $_x_392$ of $Q_$ of $x_390$ to elements of $Q_$ of the sum of $x_390$ and $1$, for all natural numbers $x_389$, $Q_$ holds for $x_389$.",
    "output": "axiom nat_rect_Type0 (Q_ : (_x_389 : Nat) -> Set) (_H_O : Q_ 0) (_H_S : (x_390 : Nat) -> (_x_392 : Q_ x_390) -> Q_ (x_390 + 1)) (x_389 : Nat) : Q_ x_389"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "postulate fact_pi_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)))))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_4_to_le_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "axiom lt_4_to_le_Psi_exp (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sqrt_n. For all natural numbers $n$, if $1$ is less than $n$, then the square root of $n$ is less than $n$.",
    "output": "axiom lt_sqrt_n (n : Nat) (x__ : 1 < n) : sqrt n < n"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_times_div_minus_mod. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $b$ and $matita_arithmetics_nat.minus$ applied to $a$ and $matita_arithmetics_div_and_mod.mod$ applied to $a$ and $b$.",
    "output": "eq_times_div_minus_mod : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div a b) b) (matita_arithmetics_nat.minus a (matita_arithmetics_div_and_mod.mod a b))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_pi_p_primeb_divides_b. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_primes.dividesb$ applied to $p$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$.",
    "output": "postulate eq_pi_p_primeb_divides_b : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p m)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p))) (matita_arithmetics_bigops.bigop n (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_mod_m_m. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then $mod$ applied to $n$ and $m$ is less than $m$.",
    "output": "lt_mod_m_m : n : Nat -> m : Nat -> __ : Lt 0 m -> Lt (mod n m) m ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_to_dividesb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "postulate not_divides_to_dividesb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp5_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_877$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_877$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_877$.",
    "output": "Axiom Aop_rect_CProp5_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_877 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_877 : Aop A _nil, Q_ x_877 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_n_to_eq_n. For all functions $h$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $__$ of $permut$ of $h$ and $n$, for all functions $__1$ from natural numbers $m$ and elements $__1$ of $Lt$ of $m$ and $n$ to elements of $Eq$ of $h$ applied to $m$ and $m$, $h$ applied to $n$ is equal to $n$.",
    "output": "axiom permut_n_to_eq_n (h : (x__ : Nat) -> Nat) (n : Nat) (x__ : permut h n) (__1 : (m : Nat) -> (__1 : m < n) -> h m = m) : h n = n"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type1. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_829$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $Lt$ of $_r$ and $_m$ and elements $x_830$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_829$.",
    "output": "Axiom div_mod_spec_rect_Type1 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_829 : div_mod_spec _n _m _q _r) -> Type1), forall _H_div_mod_spec_intro : ((x_831 : _r < _m) -> (x_830 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)), forall x_829 : div_mod_spec _n _m _q _r, Q_ x_829 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_26. For all instances $x$ of integers, we can prove that if the difference of the product of $5$ and $x$ and $7$ is even, then $x$ is odd.",
    "output": "noLabel_26 : x : Elem Int -> Proof (if (even (minus (times (nd 5) x) (nd 7))) (odd x)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_Prod : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort), forall case_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))), forall z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16002. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "Axiom let_clause_16002 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_sqrt_n. For all natural numbers $n$, if $1$ is less than $n$, then the square root of $n$ is less than $n$.",
    "output": "Axiom lt_sqrt_n : forall n : nat, forall x__ : (1 < n), sqrt n < n ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_B_Bk. For all natural numbers $n$, $B$ applied to $n$ is equal to $Bk$ applied to $n$.",
    "output": "postulate eq_B_Bk : (n : Nat) -> Eq (B n) (Bk n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Example2. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "example2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_mod_gcd. For all natural numbers $m$ and $n$, if $0$ is less than $n$, then the greatest common divisor of $n$ and $mod$ applied to $m$ and $n$ is divisible by the greatest common divisor of $m$ and $n$.",
    "output": "Axiom divides_mod_gcd : forall m : nat, forall n : nat, forall x__ : (0 < n), divisible (gcd n (mod m n)) (gcd m n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Hint_declaration_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type1$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type1$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "hint_declaration_Type1 : A : cic.Univ univs.Type1 -> _a : cic.Term univs.Type1 A -> _b : cic.Term univs.Type1 A -> cic.Univ univs.Type0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "axiom And_rect_CProp4 (_A _B : cic.Univ cic.prop) (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_146)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $matita_arithmetics_exp.exp$ applied to $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "le_exp_to_le : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_to_bijn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$.",
    "output": "postulate permut_to_bijn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Split_rev_eq. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ and $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.reverse$ applied to $A$ and $acc$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.reverse$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$ and $matita_basics_types.snd$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$.",
    "output": "Axiom split_rev_eq : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A acc) l) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "Axiom not_le_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "axiom prod_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) (_x_969 _x_970 : cic.Term univs.Type0 A) : cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1320$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_740$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $x_737$ and elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_738$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_738$ and $x_737$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Axiom list_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1), forall P : ((_z1320 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type2), forall _H1 : ((_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.nil x1))), forall _H2 : ((x_738 : cic.Term univs.Type0 x1) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_740 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_737)) -> cic.Term univs.Type2 (P x_737)) -> (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.cons x1 x_738 x_737))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom mod : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_smallest_factor_to_not_divides. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $1$ is less than $i$, then if $i$ is less than $smallest_factor$ applied to $n$, then $i$ is not divisible by $n$.",
    "output": "postulate lt_smallest_factor_to_not_divides : (n : Nat) -> (i : Nat) -> (_ : Lt 1 n) -> (__1 : Lt 1 i) -> (__2 : Lt i (smallest_factor n)) -> not (divisible i n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_DPair. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_DPair : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ return_sort) -> case_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term return_sort (return_type (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> z : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp4_body. For all functions $Q_$ from elements $_x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_396$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, for all elements $x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_393$.",
    "output": "nat_rect_CProp4_body : Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_396 : cic.Term cic.prop (Q_ x_394) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) -> x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_393) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_Type1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1260$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1261$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Prod_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type1) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_distr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.let_mop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $matita_arithmetics_bigops.let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $matita_arithmetics_bigops.let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and the function that maps $i$ to $matita_arithmetics_bigops.let_mop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and $a$ and $f$ applied to $i$.",
    "output": "bigop_distr : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> a : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i))) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_bigops.let_mop n p B nil R f a a (f i)))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Theta. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom theta : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_sumI. For all natural numbers $a$ and $b$ and $c$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a$ is less than or equal to $b$, then if $b$ is less than or equal to $c$, then $bigop$ applied to the difference of $c$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$ is equal to $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to the difference of $c$ and $b$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $b$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $b$ and $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$.",
    "output": "bigop_sumI : a : Nat -> b : Nat -> c : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq a b -> __1 : Leq b c -> Eq (bigop (minus c a) (i : Nat => (i0 : Nat => p i0) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a))) (op B nil op (bigop (minus c b) (i : Nat => (i0 : Nat => p i0) (plus i b)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i b))) (bigop (minus b a) (i : Nat => (i0 : Nat => p i0) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $_l$ be a list of natural numbers. Then we can say that $all_primes$ holds for $_l$.",
    "output": "postulate all_primes : (_l : list Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Runion. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R1$ and $_R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Runion : A : cic.Univ univs.Type0 -> _R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _a : cic.Term univs.Type0 A -> _b : cic.Term univs.Type0 A -> cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_41. We can prove that for all integers $n$, the sum of the sum of the exponentiation of $n$ and $2$ and the product of $3$ and $n$ and $5$ is odd.",
    "output": "noLabel_41 : Proof (forall Int (n => odd (plus (plus (pow n (nd 2)) (times (nd 3) n)) (nd 5)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_arithmetics_bigops.match_Dop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_arithmetics_bigops.match_Dop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $a1$ and $a2$ and $matita_basics_logic.R0$ applied to $matita_arithmetics_bigops.ACop$ applied to $a1$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $a1$ and $a2$ and $t0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x1$ applied to $a$ and $a2$ and $a2$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $matita_arithmetics_bigops.ACop$ applied to $a1$ and $a2$ and $t0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x11$ applied to $a$ and $a2$ and $a2$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x1$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $a1$ and $a2$ and $x0$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $a1$ and $a2$ and $x0$ and $x1$ applied to $a$ and $b$ and $x1$ applied to $a$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $matita_arithmetics_bigops.ACop$ applied to $a1$ and $a2$ and $t0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x11$ applied to $a$ and $a2$ and $a2$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x11$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $a1$ and $a2$ and $x01$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $a1$ and $a2$ and $x01$ and $x11$ applied to $a$ and $b$ and $x11$ applied to $a$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z61$ to $P$ and $y$ and $x$.",
    "output": "Dop_discr : a1 : cic.Univ univs.Type0 -> a2 : cic.Term univs.Type0 a1 -> x : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> y : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop a1 a2)) x y) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => t1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => t2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t1 a a2) a2)) => t3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t1 a (matita_arithmetics_bigops.aop__o__op a1 a2 t0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 t0 (t1 a b) (t1 a c)))) => matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => u1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => u2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u1 a a2) a2)) => u3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u1 a (matita_arithmetics_bigops.aop__o__op a1 a2 u0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 u0 (u1 a b) (u1 a c)))) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 u0 e0) u1) (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 u0 e0) u1) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) u0 e0 u1 e1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) u0 e0 u1 e1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => x10 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a (matita_arithmetics_bigops.aop__o__op a1 a2 x0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x0 (x1 a b) (x1 a c)))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x12 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2))) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a (matita_arithmetics_bigops.aop__o__op a1 a2 x01 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => x10 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a (matita_arithmetics_bigops.aop__o__op a1 a2 x0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x0 (x1 a b) (x1 a c)))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x12 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2))) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a (matita_arithmetics_bigops.aop__o__op a1 a2 x01 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) => P))))) (_z61 : (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0) -> e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 u0 e0) u1) -> e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) u0 e0 u1 e1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) -> _e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x0) => x1 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x00) => x10 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x1 a (matita_arithmetics_bigops.aop__o__op a1 a2 x0 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x0 (x1 a b) (x1 a c)))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (matita_arithmetics_bigops.ACop a1 a2) t0 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 __)) t2 (x0 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x0) => x1 : cic.Term univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) x0 p0 x1 p1)) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 (x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : cic.Term univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x12 a a2) a2)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x01) => x11 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a a2) a2))) (matita_basics_logic.R2 (matita_arithmetics_bigops.ACop a1 a2) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 (x02 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x02) => x12 : cic.Term univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x00) => x10 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 (x011 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) t0 x011) => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1))) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x10 a a2) a2)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x11 a (matita_arithmetics_bigops.aop__o__op a1 a2 x01 b c)) (matita_arithmetics_bigops.aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_body. For all natural numbers $__$ and $__1$, $Nat$.",
    "output": "Axiom plus_body : forall x__ : nat, forall __1 : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "PlusAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$.",
    "output": "plusAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat matita_arithmetics_nat.O) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Confluent. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.",
    "output": "axiom confluent (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1573. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "axiom let_clause_1573 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_2_pred. For all natural numbers $n$, the product of $2$ and $pred$ applied to $n$ is less than or equal to $pred$ applied to the product of $2$ and $n$.",
    "output": "axiom times_2_pred (n : Nat) : 2 * pred n ≤ pred (2 * n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nth_primeS. For all natural numbers $n$, $nth_prime$ applied to the sum of $n$ and $1$ is equal to $min$ applied to $let_upper_bound1$ applied to $n$ and the sum of $let_previous_prime1$ applied to $n$ and $1$ and $primeb$.",
    "output": "nth_primeS : n : Nat -> Eq (nth_prime (plus n (nd 1))) (min (let_upper_bound1 n) (plus (let_previous_prime1 n) (nd 1)) primeb) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1034. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_1034 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_ind. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_1$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_1$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_1$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1$ and $x_2$.",
    "output": "eq_ind : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_1 : cic.Term univs.Type2 A -> _x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_1 : cic.Term univs.Type2 A -> x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1) -> cic.Term cic.prop (Q_ x_1 x_2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_minr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$.",
    "output": "axiom le_minr (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))) : cic.Term cic.prop (matita_arithmetics_nat.le i m)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_lt. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$.",
    "output": "Axiom transitive_lt : cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat matita_arithmetics_nat.lt) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime5. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom let_previous_prime5 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_ind. For all sets $x1$, for all elements $x2$ of $relation$ of $x1$, for all natural numbers $x3$, for all elements $x4$ and $x5$ of $x1$, for all elements $_Hterm$ of $lstar$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from natural numbers $_z2089$ and elements $_z2088$ of $x1$ and elements $_z2087$ of $x1$ to propositions, for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2092$ of $Eq$ of $x3$ and $0$ and elements $_z2091$ of $Eq$ of $x4$ and $b$ and elements $_z2090$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1236$ of $x2$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $x1$ and elements $_x_1235$ of $lstar$ of $x1$ and $x2$ and $l$ and $b$ and $b2$ and functions $_x_1238$ from elements $_z2092$ of $Eq$ of $x3$ and $l$ and elements $_z2091$ of $Eq$ of $x4$ and $b$ and elements $_z2090$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of $l$ and $b$ and $b2$ and elements $_z2092$ of $Eq$ of $x3$ and the sum of $l$ and $1$ and elements $_z2091$ of $Eq$ of $x4$ and $b1$ and elements $_z2090$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of the sum of $l$ and $1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.",
    "output": "Axiom lstar_inv_ind : forall x1 : Set, forall x2 : relation x1, forall x3 : nat, forall x4 : x1, forall x5 : x1, forall _Hterm : lstar x1 x2 x3 x4 x5, forall P : ((_z2089 : nat) -> (_z2088 : x1) -> (_z2087 : x1) -> Prop), forall _H1 : ((b : x1) -> (_z2092 : x3 = 0) -> (_z2091 : x4 = b) -> (_z2090 : x5 = b) -> P 0 b b), forall _H2 : ((b1 : x1) -> (b : x1) -> (_x_1236 : x2 b1 b) -> (l : nat) -> (b2 : x1) -> (_x_1235 : lstar x1 x2 l b b2) -> (_x_1238 : (_z2092 : x3 = l) -> (_z2091 : x4 = b) -> (_z2090 : x5 = b2) -> P l b b2) -> (_z2092 : x3 = l + 1) -> (_z2091 : x4 = b1) -> (_z2090 : x5 = b2) -> P (l + 1) b1 b2), P x3 x4 x5 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $Lt$ of $_r$ and $_m$ and elements $x_846$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_845$.",
    "output": "div_mod_spec_rect_CProp3 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_845 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_847 : Lt _r _m -> x_846 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> x_845 : div_mod_spec _n _m _q _r -> Q_ x_845 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_m. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom let_m : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "eqb : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "PlusAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$.",
    "output": "axiom plusAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.",
    "output": "postulate Sig_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_ind_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_889$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_889$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_889$.",
    "output": "ACop_ind_body : A : Set -> _nil : A -> Q_ : (_x_889 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_889 : ACop A _nil -> Q_ x_889 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_939$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $range$ of $_A$, $Q_$ holds for $x_939$.",
    "output": "Axiom range_rect_CProp0_body : forall _A : Set, forall Q_ : ((_x_939 : range _A) -> Prop), forall _H_mk_range : ((_enum : (x__ : nat) -> _A) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)), forall x_939 : range _A, Q_ x_939 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cr_pair5. $cr_pair$ applied to $3$ and $7$ and $0$ and $4$ is equal to $18$.",
    "output": "Axiom cr_pair5 : cr_pair 3 7 0 4 = 18 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_Type1_body. For all functions $Q_$ from elements $_x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_71$.",
    "output": "False_rect_Type1_body : Q_ : (_x_71 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type1) -> x_71 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type1 (Q_ x_71) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_B_Bk. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$.",
    "output": "axiom eq_B_Bk (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_of_primes. For all natural numbers $_n$, $list$ holds for $Nat$.",
    "output": "axiom list_of_primes (_n : Nat) : list Nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_907$.",
    "output": "axiom ACop_rect_CProp3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_907)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type0_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_955$ of $Dop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_955$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_955$.",
    "output": "Dop_rect_Type0_body : A : Set -> _nil : A -> Q_ : (_x_955 : Dop A _nil -> Set) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_955 : Dop A _nil -> Q_ x_955 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type3. For all sets $_A$, for all functions $Q_$ from elements $_x_921$ of $range$ of $_A$ to elements of $Type3$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $range$ of $_A$, $Q_$ holds for $x_921$.",
    "output": "postulate range_rect_Type3 : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_or_lt_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_907$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_907$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_907$.",
    "output": "postulate ACop_rect_CProp3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_907 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_907 : ACop A _nil) -> Q_ x_907"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_Sn. For all elements $b$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_exp.exp$ applied to $b$ and $n$.",
    "output": "exp_Sn : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp b (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times b (matita_arithmetics_exp.exp b n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Rewrite_l. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $x$, for all elements $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $y$.",
    "output": "axiom rewrite_l (A : cic.Univ univs.Type2) (x : cic.Term univs.Type2 A) (P : (__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2) (__ : cic.Term univs.Type2 (P x)) (y : cic.Term univs.Type2 A) (__1 : cic.Term cic.prop (matita_basics_logic.eq A x y)) : cic.Term univs.Type2 (P y)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_b. For all elements $b$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "postulate le_plus_b : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n b) m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1078. For all natural numbers $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$, for all elements $_clearme$ of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$, if $r$ is less than $b$, then if $a$ is equal to the sum of the product of $q$ and $b$ and $r$, then for all elements $_clearme0$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, if $r1$ is less than $b$, then if $a$ is equal to the sum of the product of $q1$ and $b$ and $r1$, then if $q$ is less than or equal to $q1$, then if $q$ is less than $q1$, then $a$ is equal to the sum of $r$ and the product of $b$ and $q$.",
    "output": "Axiom let_clause_1078 : forall a : nat, forall b : nat, forall q : nat, forall r : nat, forall q1 : nat, forall r1 : nat, forall _clearme : div_mod_spec a b q r, forall ltrb : (r < b), forall spec : (a = q * b + r), forall _clearme0 : div_mod_spec a b q1 r1, forall ltr1b : (r1 < b), forall spec1 : (a = q1 * b + r1), forall leqq1 : Leq q q1, forall ltqq1 : (q < q1), a = r + b * q ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.",
    "output": "postulate sum : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_957$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_957$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_957$.",
    "output": "postulate Dop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "Axiom prod : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall _x_969 : cic.Term univs.Type0 A, forall _x_970 : cic.Term univs.Type0 A, cic.Term univs.Type0 A ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1233$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1232$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1231$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1234$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_S$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1236$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1235$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b$ and $b2$ and $x_1235$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $x_1236$ and $l$ and $b2$ and $x_1235$, for all elements $x_1233$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_1232$ and $x_1231$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x_1234$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.",
    "output": "lstar_ind : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1232 : cic.Term univs.Type0 B -> x_1231 : cic.Term univs.Type0 B -> _x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231) -> cic.Univ cic.prop) -> _H_lstar_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> _H_lstar_S : (b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1236 : cic.Term cic.prop (_R b1 b) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2) -> _x_1238 : cic.Term cic.prop (Q_ l b b2 x_1235) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b x_1236 l b2 x_1235))) -> x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1232 : cic.Term univs.Type0 B -> x_1231 : cic.Term univs.Type0 B -> x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231) -> cic.Term cic.prop (Q_ x_1233 x_1232 x_1231 x_1234) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_not_bertrand_to_bertrand. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "not_not_bertrand_to_bertrand : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.",
    "output": "DPair_rect_Type3 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type3) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type3 (Q_ x_644) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1662$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1663$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.",
    "output": "axiom range_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1662 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type0) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1663 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term univs.Type0 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_exp. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $m$.",
    "output": "axiom lt_exp (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.",
    "output": "postulate Prod_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type3 (Q_ x_696)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1074$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1075$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1075$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_615$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_615$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom option_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.option x1), forall P : ((_z1074 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop), forall _H1 : ((_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))), forall _H2 : ((x_615 : cic.Term univs.Type0 x1) -> (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_615))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type1_body. For all functions $Q_$ from elements $_x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_it$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_505$.",
    "output": "axiom unit_rect_Type1_body (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) (x_505 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type1 (Q_ x_505)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Enum_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, for all natural numbers $_x_942$, $A$.",
    "output": "axiom enum_body (A : Set) (_xxx : range A) (_x_942 : Nat) : A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_925$.",
    "output": "postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1674$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1675$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "range_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1674 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1675 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_nth_prime_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.",
    "output": "Axiom lt_O_nth_prime_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_primes.nth_prime n)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_discr. For all natural numbers $x$ and $y$, if $x$ is equal to $y$, then $match_nat$ holds for the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and $match_nat$ applied to the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $P$ and the function that maps $_z23$ to $P$ and the function that maps $u0$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $match_nat$ applied to the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $Nat$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z24$ to $P$ and $y$ and $x$.",
    "output": "Axiom nat_discr : forall x : nat, forall y : nat, forall _e : (x = y), match_nat (Type2 + 1) (fun x__ => univ Type2) (match_nat (Type2 + 1) (fun x__ => univ Type2) (prod (Type1 + 1) Type1 (univ Type1) (fun P => prod Type1 Type1 P (fun _z23 => P))) (fun u0 => prod (Type1 + 1) Type1 (univ Type1) (fun P => P)) y) (fun t0 => match_nat (Type2 + 1) (fun x__ => univ Type2) (prod (Type1 + 1) Type1 (univ Type1) (fun P => P)) (fun u0 => prod (Type1 + 1) Type1 (univ Type1) (fun P => prod Type1 Type1 (prod Prop Type1 (R0 nat t0 = u0) (fun _e0 => P)) (fun _z24 => P))) y) x ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, for all functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $nil$ and $nil$, for all functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$.",
    "output": "Axiom mk_Dop : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil), forall prod : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A), forall _null : ((a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a nil) nil)), forall _distr : ((a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A nil sum b c)) (matita_arithmetics_bigops.aop__o__op A nil sum (prod a b) (prod a c)))), cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pair_destruct_1. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $c$.",
    "output": "axiom pair_destruct_1 (A B : cic.Univ univs.Type0) (a : cic.Term univs.Type0 A) (b : cic.Term univs.Type0 B) (c : cic.Term univs.Type0 (matita_basics_types.Prod A B)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_found_min_spec. For all natural numbers $n$ and $b$, for all functions $f$ from natural numbers to booleans, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $n$ and $b$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, $min_spec$ holds for $n$ and $b$ and $f$ and the sum of $n$ and $b$.",
    "output": "Axiom not_found_min_spec : forall n : nat, forall b : nat, forall f : ((x__ : nat) -> bool), forall x__ : ((i : nat) -> (x__ : Leq b i) -> (__1 : i < n + b) -> f i = false), min_spec n b f (n + b) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type3_body. For all sets $_A$, for all functions $Q_$ from elements $_x_921$ of $range$ of $_A$ to elements of $Type3$, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $range$ of $_A$, $Q_$ holds for $x_921$.",
    "output": "postulate range_rect_Type3_body : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_hk. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "Axiom sub_hk : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z707$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z708$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_412$ from elements $_z708$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_410$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_410$ and elements $_z708$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom nat_inv_rect_CProp1 : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z707 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall _H2 : ((x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_410)) -> cic.Term cic.prop (P x_410)) -> (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_410))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_410))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_div. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.div$ applied to $b$ and $c$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $c$.",
    "output": "postulate times_div : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div b c)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) c))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_S. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.",
    "output": "axiom lstar_r_S (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b)) (b2 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (R b b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_1_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "exp_1_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_inl$ from elements $x_542$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_542$, for all functions $_H_inr$ from elements $x_543$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_543$, for all elements $x_541$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_541$.",
    "output": "postulate Sum_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2) -> (_H_inl : (x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> (_H_inr : (x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> (x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type2 (Q_ x_541)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ltransitive. For all sets $B$, for all elements $R$ of $relation$ of $B$, $ltransitive$ holds for $B$ and $lstar$ applied to $B$ and $R$.",
    "output": "Axiom lstar_ltransitive : forall B : Set, forall R : relation B, ltransitive B (lstar B R) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_aux_body. For all natural numbers $_p$ and $_m$ and $_n$, $Nat$.",
    "output": "mod_aux_body : _p : Nat -> _m : Nat -> _n : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_883$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_883$.",
    "output": "postulate Aop_rect_CProp1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_883 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_883 : Aop A _nil) -> Q_ x_883"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_minus_associative. For all natural numbers $x$ and $y$ and $z$, if $z$ is less than or equal to $y$, then the sum of $x$ and the difference of $y$ and $z$ is equal to the difference of the sum of $x$ and $y$ and $z$.",
    "output": "Axiom plus_minus_associative : forall x : nat, forall y : nat, forall z : nat, forall x__ : Leq z y, x + (y - z) = x + y - z ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min. For all natural numbers $__$ and $__1$, for all functions $__2$ from natural numbers $__2$ to booleans, $Nat$.",
    "output": "min : __ : Nat -> __1 : Nat -> __2 : (__2 : Nat -> bool) -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_gcd_nm. For all natural numbers $n$ and $m$, the greatest common divisor of $n$ and $m$ is divisible by $m$ and the greatest common divisor of $n$ and $m$ is divisible by $n$.",
    "output": "divides_gcd_nm : n : Nat -> m : Nat -> and (divisible (gcd n m) m) (divisible (gcd n m) n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom Not : forall _A : cic.Univ cic.prop, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Invert_permut. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate invert_permut : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom reflexive : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing_to_le. For all functions $f$ from natural numbers to natural numbers, for all elements $__$ of $increasing$ of $f$, for all natural numbers $m$, $ex$ holds for $Nat$ and the function that maps $i$ to $Leq$ applied to $m$ and $f$ applied to $i$.",
    "output": "axiom increasing_to_le (f : (x__ : Nat) -> Nat) (x__ : increasing f) (m : Nat) : ex Nat (λ i => m ≤ f i)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_minus_to_plus. For all natural numbers $n$ and $m$ and $p$, if the difference of $n$ and $m$ is less than or equal to $p$, then $n$ is less than or equal to the sum of $p$ and $m$.",
    "output": "Axiom le_minus_to_plus : forall n : nat, forall m : nat, forall p : nat, forall x__ : Leq (n - m) p, Leq n (p + m) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative_min. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.min$.",
    "output": "postulate commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $a2$ and $a$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $matita_basics_logic.R2$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x0$ applied to $a$ and $x0$ applied to $b$ and $c$ and $x0$ applied to $x0$ applied to $a$ and $b$ and $c$ applied to $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $matita_basics_logic.R3$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p0$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $a$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $b$ to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $a1$ and the function that maps $c$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z51$ to $P$ and $y$ and $x$.",
    "output": "Aop_discr : a1 : cic.Univ univs.Type0 -> a2 : cic.Term univs.Type0 a1 -> x : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y) -> cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) => cic.univ univs.Type2) (t0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => t1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) => t2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) => t3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) => matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2) => cic.univ univs.Type2) (u0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => u1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a2 a) a)) => u2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a a2) a)) => u3 : (a : cic.Term univs.Type0 a1 -> b : cic.Term univs.Type0 a1 -> c : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a (u0 b c)) (u0 (u0 a b) c))) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) (e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) (e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t0 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : cic.Term cic.prop ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t0 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : cic.Term cic.prop ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) => P))))) (_z51 : (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) u0) -> e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) x_19 _x_20)) t1 u0 e0) u1) -> e2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) u0 e0 u1 e1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 u0 e0 u1 e1) u2) -> _e3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x0) => x1 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0) x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x00 p00)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x0 a (x0 b c)) (x0 (x0 a b) c))))) u0 e0 u1 e1 u2 e2)) (matita_basics_logic.R3 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 __)) t1 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 __)) t2 (x0 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x0) => x1 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0) => p1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) x_19 _x_20)) t1 x0 p0) x1) => x2 : cic.Term cic.prop ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) x0 p0 x1 p1)) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1))) t0 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 __)) t1 (x01 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : cic.Term cic.prop ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01) => __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x01 p01)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x02 : (__ : cic.Term univs.Type0 a1 -> __1 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__ : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => cic.lift cic.prop univs.Type0 ((x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x02 a a2) a)) x01 p01 x11 __)) t2 x0 p0 x1 p1) x2) => cic.lift cic.prop univs.Type0 ((x01 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p01 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x01) => x11 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a)) => p11 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x01 p01) x11) => x21 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a)) => p2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a a2) a))) (matita_basics_logic.R2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1))) t0 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 __1)) t1 (x02 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p02 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x02) => x12 : cic.Term cic.prop ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02) => __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x02 p02)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x00 : (__1 : cic.Term univs.Type0 a1 -> __2 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__1 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) x_19 _x_20)) t1 x02 p02) x12) => cic.lift cic.prop univs.Type0 ((x00 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p00 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x00) => x10 : (a : cic.Term univs.Type0 a1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a)) => p10 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a2 a) a))) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 (x_19 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x_19) => cic.lift cic.prop univs.Type0 ((x011 : (__2 : cic.Term univs.Type0 a1 -> __3 : cic.Term univs.Type0 a1 -> cic.Term univs.Type0 a1) => p011 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (__2 : cic.Term univs.Type0 a1 => cic.prod univs.Type0 univs.Type0 a1 (__3 : cic.Term univs.Type0 a1 => a1)))) t0 x011) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x011 a2 a) a)) x_19 _x_20)) t1 x00 p00) x10) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x00 a a2) a)) x02 p02 x12 __1)) t2 x01 p01 x11 p11) x21) => cic.prod univs.Type0 cic.prop a1 (a : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (b : cic.Term univs.Type0 a1 => cic.prod univs.Type0 cic.prop a1 (c : cic.Term univs.Type0 a1 => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __)) t3 u0 e0 u1 e1 u2 e2) u3) -> cic.Term univs.Type1 P) => P))) y) x) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop90. For all instances $n$ of natural numbers, we can prove that if $n$ is even and $n$ is prime, then $n$ is equal to $2$.",
    "output": "axiom prop90 (n : Nat) : even n ∧ prime n → n = 2"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "postulate gcd : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iso. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "iso : A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_31$ and $x_32$.",
    "output": "Axiom eq_rect_CProp2_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_31 : cic.Term univs.Type2 A, forall x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31), cic.Term cic.prop (Q_ x_31 x_32) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.",
    "output": "Axiom nat_rect_CProp3_body : forall Q_ : ((_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))), forall x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_401) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z930$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z931$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Axiom unit_inv_rect_Type1 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1), forall _H1 : ((_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)), cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "Sum_rect_Type5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type5) -> _H_inl : (x_532 : cic.Term univs.Type0 _A -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> _H_inr : (x_533 : cic.Term univs.Type0 _B -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type5 (Q_ x_531) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_True. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_True : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop matita_basics_logic.True, cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.",
    "output": "not_divides_to_gcd_aux : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_le_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.",
    "output": "monotonic_le_times_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_gen. For all functions $P$ from natural numbers to propositions, for all natural numbers $n$, for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $i$ and $n$ to elements of $P$ of $i$, $P$ holds for $n$.",
    "output": "Axiom le_gen : forall P : ((x__ : nat) -> Prop), forall n : nat, forall x__ : ((i : nat) -> (x__ : Leq i n) -> P i), P n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "primes_below_lop : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max. If $Sort$, then if $Sort$, then $Sort$.",
    "output": "postulate max : Sort -> Sort -> Sort"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Extract_pair. For all elements $A$ and $B$ and $C$ and $D$ of $cic.Univ$ of $univs.Type0$, for all elements $u$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $C$ and $D$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $C$, for all elements $y$ of $cic.Term$ of $univs.Type0$ and $D$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $__$ to $matita_basics_types.Prod$ applied to $C$ and $D$ and the function that maps $a$ and $b$ to $Q$ applied to $a$ and $b$ and $u$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $B$ and the function that maps $b$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $u$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $C$ and $D$ and $Q$ applied to $a$ and $b$ and $matita_basics_types.mk_Prod$ applied to $C$ and $D$ and $x$ and $y$.",
    "output": "extract_pair : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> D : cic.Univ univs.Type0 -> u : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> Q : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> x : cic.Term univs.Type0 C -> y : cic.Term univs.Type0 D -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B) => matita_basics_types.Prod C D) (a : cic.Term univs.Type0 A => b : cic.Term univs.Type0 B => Q a b) u) (matita_basics_types.mk_Prod C D x y)) -> cic.Term cic.prop (matita_basics_logic.ex A (a : cic.Term univs.Type0 A => matita_basics_logic.ex B (b : cic.Term univs.Type0 B => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16001. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $n$ and $c$ and the product of $m$ and $d$.",
    "output": "let_clause_16001 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (gcd m n) (minus (times n c) (times m d)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.",
    "output": "range_rect_Type0 : _A : cic.Univ univs.Type0 -> Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type0) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type0 (Q_ x_927) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Psi. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Psi : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_ind. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_861$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_861$.",
    "output": "Aop_ind : A : Set -> _nil : A -> Q_ : (_x_861 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_861 : Aop A _nil -> Q_ x_861 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ be a function from natural numbers to natural numbers. Let $__1$ be a natural number. Then we can say that $injn$ holds for $__$ and $__1$.",
    "output": "Axiom injn : forall x__ : ((x__ : nat) -> nat), forall __1 : nat, Prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "And_inv_rect_CProp1 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_164 : cic.Term cic.prop x1 -> x_163 : cic.Term cic.prop x2 -> _z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.",
    "output": "axiom lt_O_bc (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F2_ind_aux. For all elements $A1$ and $A2$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A1$ and $A2$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a1$ and $a2$.",
    "output": "f2_ind_aux : A1 : cic.Univ univs.Type0 -> A2 : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A1 -> __1 : cic.Term univs.Type0 A2 -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2)) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n) -> cic.Term cic.prop (P a1 a2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive2. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom distributive2 (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (_g : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "axiom injn_Sn_n (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom log_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_squareS_exp. For all natural numbers $n$, if $5$ is less than $n$, then the exponentiation of the sum of $n$ and $1$ and $2$ is less than or equal to the exponentiation of $2$ and $n$.",
    "output": "le_squareS_exp : n : Nat -> __ : Lt (nd 5) n -> Leq (pow (plus n (nd 1)) (nd 2)) (pow (nd 2) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp3_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.",
    "output": "div_mod_spec_rect_CProp3_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_845) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom match_ex2 : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort), forall case_ex2_intro : ((x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))), forall z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "Axiom snd : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B), cic.Term univs.Type0 B ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "filter_lstar_r : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.",
    "output": "axiom lstar_lstar_r (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_O_elim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $P$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "postulate le_n_O_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_times. For all natural numbers $p$ and $a$ and $b$ and $qa$ and $ra$ and $qb$ and $rb$, if $p$ is prime, then if $0$ is less than $a$, then if $0$ is less than $b$, then if $p_ord$ applied to $a$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $qa$ and $ra$, then if $p_ord$ applied to $b$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $qb$ and $rb$, then $p_ord$ applied to the product of $a$ and $b$ and $p$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and the sum of $qa$ and $qb$ and the product of $ra$ and $rb$.",
    "output": "p_ord_times : p : Nat -> a : Nat -> b : Nat -> qa : Nat -> ra : Nat -> qb : Nat -> rb : Nat -> __ : prime p -> __1 : Lt 0 a -> __2 : Lt 0 b -> __3 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra) -> __4 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Andb_true_r. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.",
    "output": "axiom andb_true_r (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10131. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$ and $n0$, if $max$ applied to the sum of $n0$ and $1$ and $f$ is equal to $m$, then if $f$ applied to $m$ is equal to absurdity, then for all natural numbers $i$ and $j$, if the sum of $j$ and $1$ is less than the sum of $n0$ and $1$, then for all natural numbers $x7$, $x7$ is equal to the sum of $m$ and $x7$.",
    "output": "axiom let_clause_10131 (f : (x__ : Nat) -> bool) (n m n0 : Nat) (eqm : max (n0 + 1) f = m) (fm : f m = false) (i j : Nat) (ltj : j + 1 < n0 + 1) (x7 : Nat) : x7 = m + x7"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type0_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $x$ and $p$.",
    "output": "eq_rect_Type0_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ univs.Type0) -> __ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term univs.Type0 (P x p) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psil1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.",
    "output": "le_Psil1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_Psi. $monotonic$ holds for $Nat$ and $Leq$ and $Psi$.",
    "output": "axiom monotonic_Psi : monotonic Nat Leq Psi"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1607. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "Axiom let_clause_1607 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_CProp3. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_847$ of $Lt$ of $x4$ and $x2$ and elements $x_846$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1477$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $P$ holds for $Hterm$.",
    "output": "div_mod_spec_inv_rect_CProp3 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1476 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_847 : Lt x4 x2 -> x_846 : Eq x1 (plus (times x3 x2) x4) -> _z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Enum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.",
    "output": "axiom enum (A : cic.Univ univs.Type0) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 A"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_max_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$.",
    "output": "postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_ind_body. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.",
    "output": "axiom void_ind_body (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_482 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_482)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_CProp3. For all functions $Q_$ from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.",
    "output": "axiom True_rect_CProp3 (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_58 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_58)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom match_Not (_A : cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) (z : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Cons_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.",
    "output": "cons_injective_r : A : cic.Univ univs.Type0 -> a1 : cic.Term univs.Type0 A -> a2 : cic.Term univs.Type0 A -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z275$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z276$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_92$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_92$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "Axiom Not_inv_rect_Type2 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2), forall _H1 : ((x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))), cic.Term univs.Type2 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_mod. For all natural numbers $n$ and $p$, if $0$ is less than $p$, then $mod$ applied to $n$ and $p$ is equal to $mod$ applied to $mod$ applied to $n$ and $p$ and $p$.",
    "output": "mod_mod : n : Nat -> p : Nat -> __ : Lt 0 p -> Eq (mod n p) (mod (mod n p) p) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $n$.",
    "output": "le_prim_n2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Checker_ab. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.andb$ applied to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $b$ and $matita_arithmetics_nat.leb$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$.",
    "output": "postulate checker_ab : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) (matita_basics_bool.andb (matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S a) b) (matita_arithmetics_nat.leb b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_lstar_r (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 __2 : cic.Term univs.Type0 B) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "True_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.",
    "output": "postulate True_rect_Type4 : (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) -> (x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type4 (Q_ x_42)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_p_ord_inv. For all natural numbers $p$ and $m$ and $x$, if $ord$ applied to $x$ and $p$ is less than $m$, then the quotient of $p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ is equal to $ord_rem$ applied to $x$ and $p$.",
    "output": "Axiom div_p_ord_inv : forall p : nat, forall m : nat, forall x : nat, forall x__ : (ord x p < m), p_ord_inv p m x / m = ord_rem x p ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit. $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate unit : cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_to_minus. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than or equal to the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than or equal to $p$.",
    "output": "axiom le_plus_to_minus (n m p : Nat) (x__ : n ≤ p + m) : n - m ≤ p"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $x32$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $x32$ and $matita_arithmetics_nat.plus$ applied to $x32$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_16 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> (x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_CProp0_body. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.",
    "output": "void_rect_CProp0_body : Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_494 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_494) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_diff. For all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i$ is less than $n$, then if $p$ applied to $i$ is equal to $true$, then $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.",
    "output": "bigop_diff : p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (__ : Nat -> B) -> i : Nat -> n : Nat -> __ : Lt i n -> __1 : Eq (p i) true -> Eq (bigop n (x : Nat => p x) B nil (aop__o__op B nil op) (x : Nat => f x)) (aop__o__op B nil op (f i) (bigop n (x : Nat => andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (x : Nat => f x))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_CProp0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_913$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_913$.",
    "output": "axiom ACop_rect_CProp0 (A : Set) (_nil : A) (Q_ : (_x_913 : ACop A _nil) -> Prop) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)) (x_913 : ACop A _nil) : Q_ x_913"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_O. For all functions $f$ from natural numbers to booleans, $max$ applied to $0$ and $f$ is equal to $0$.",
    "output": "axiom max_O (f : (x__ : Nat) -> bool) : max 0 f = 0"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom mod_aux_body (_p _m _n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1296$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1297$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Prod_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp2_body. For all functions $Q_$ from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.",
    "output": "Axiom nat_rect_CProp2_body : forall Q_ : ((_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))), forall x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_405) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.",
    "output": "postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp4_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_839$ of $Lt$ of $_r$ and $_m$ and elements $x_838$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_839$ and $x_838$, for all elements $x_837$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_837$.",
    "output": "div_mod_spec_rect_CProp4_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_837 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_839 : Lt _r _m -> x_838 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> x_837 : div_mod_spec _n _m _q _r -> Q_ x_837 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.",
    "output": "Axiom injn_Sn_n : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n)), cic.Term cic.prop (matita_arithmetics_permutation.injn f n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.",
    "output": "axiom lt_to_le (x y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) : cic.Term cic.prop (matita_arithmetics_nat.le x y)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1110$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1111$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "axiom DPair_inv_rect_Type4 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Dop_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ univs.Type1) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bool_rect_Type0_body. For all functions $Q_$ from elements $_x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_true$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_344$.",
    "output": "postulate bool_rect_Type0_body : (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) -> (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ x_344)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Aop_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_967$.",
    "output": "Dop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_967) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Times_n_1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom times_n_1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_hkO. For all functions $h$ and $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $I$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $A$ and $I$ and $J$.",
    "output": "sub_hkO : h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> A : cic.Univ univs.Type0 -> I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A I J) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prime_to_divides_M. For all natural numbers $m$ and $p$, if $p$ is prime, then if the sum of $m$ and $1$ is less than $p$, then if $p$ is less than or equal to the sum of the product of $2$ and $m$ and $1$, then $p$ is divisible by $M$ applied to $m$.",
    "output": "axiom prime_to_divides_M (m p : Nat) (x__ : prime p) (__1 : m + 1 < p) (__2 : p ≤ 2 * m + 1) : divisible p (M m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Monotonic_iter. For all functions $g$ from natural numbers to natural numbers, for all natural numbers $a$ and $b$ and $i$, for all elements $__$ of $monotonic$ of $Nat$ and $Leq$ and $g$, if $a$ is less than or equal to $b$, then $iter$ applied to $Nat$ and $g$ and $i$ and $a$ is less than or equal to $iter$ applied to $Nat$ and $g$ and $i$ and $b$.",
    "output": "postulate monotonic_iter : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (b : Nat) -> (i : Nat) -> (_ : monotonic Nat Leq g) -> (__1 : Leq a b) -> Leq (iter Nat g i a) (iter Nat g i b)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1723$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "axiom Dop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type1 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_20. We can prove that for all integers $b$, for all integers $a$, for all integers $c$, if $a$ is odd and $c$ is odd, then the sum of the product of $a$ and $b$ and the product of $b$ and $c$ is even.",
    "output": "postulate noLabel_20 : all Int (\\ b -> all Int (\\ a -> all Int (\\ c -> if (and (odd a) (odd c)) (even (plus (times a b) (times b c))))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "le_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417) -> cic.Univ cic.prop) -> _H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n)) -> _H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m) -> _x_421 : cic.Term cic.prop (Q_ m x_419) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417) -> cic.Term cic.prop (Q_ x_417 x_418) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iso. For all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "postulate iso : (A : Set) -> relation (range A)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "Axiom minus_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp4. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.",
    "output": "axiom Aop_rect_CProp4 (A : Set) (_nil : A) (Q_ : (_x_875 : Aop A _nil) -> Prop) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_875 : Aop A _nil) : Q_ x_875"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_hk. For all functions $__$ from natural numbers to natural numbers, for all functions $__1$ from natural numbers $__1$ to natural numbers, for all sets $A$, $relation$ holds for $range$ applied to $A$.",
    "output": "Axiom sub_hk : forall x__ : ((x__ : nat) -> nat), forall __1 : ((__1 : nat) -> nat), forall A : Set, relation (range A) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_863$.",
    "output": "Aop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type4 (Q_ x_863) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eqnot_to_noteq. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.",
    "output": "axiom eqnot_to_noteq (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_953$.",
    "output": "postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "postulate plus_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_inv_S1. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $matita_arithmetics_nat.nat$ and the function that maps $z$ to $matita_arithmetics_nat.le$ applied to $x$ and $z$ and the function that maps $z$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.S$ applied to $z$.",
    "output": "postulate le_inv_S1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S x) y)) -> cic.Term cic.prop (matita_basics_logic.ex2 matita_arithmetics_nat.nat (\\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.le x z) (\\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y (matita_arithmetics_nat.S z)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_primr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "Axiom le_exp_primr : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Iff_or_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $C$ and $A$ and $matita_basics_logic.Or$ applied to $C$ and $B$.",
    "output": "postulate iff_or_l : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "axiom filter_Sig (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.",
    "output": "postulate And_rect_CProp4 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_146)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "All_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l1$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "Axiom All_append : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.All A P l1), forall __1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2), cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_log2_sqrt. For all natural numbers $n$, if the exponentiation of $2$ and $4$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than or equal to the square root of $n$.",
    "output": "le_log2_sqrt : n : Nat -> __ : Leq (pow (nd 2) (nd 4)) n -> Leq (log (nd 2) n) (sqrt n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_ind. For all natural numbers $x1$ and $x2$ and $x3$ and $x4$, for all elements $Hterm$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1434$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to propositions, for all functions $_H1$ from elements $x_811$ of $Lt$ of $x4$ and $x2$ and elements $x_810$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1435$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_811$ and $x_810$, $P$ holds for $Hterm$.",
    "output": "div_mod_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1434 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_811 : Lt x4 x2 -> x_810 : Eq x1 (plus (times x3 x2) x4) -> _z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.",
    "output": "postulate eq_rect_Type0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_upper_bound2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom let_upper_bound2 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log_div. For all natural numbers $p$ and $n$ and $m$, if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.",
    "output": "log_div : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 m -> __2 : Leq m n -> Leq (log p (div n m)) (minus (log p n) (log p m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom min_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_2_fact. For all natural numbers $n$, if $1$ is less than $n$, then $2$ is less than or equal to the factorial of $n$.",
    "output": "Axiom le_2_fact : forall n : nat, forall x__ : (1 < n), Leq 2 (factorial n) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_max_forall_false. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ and $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity and $max$ applied to $n$ and $f$ is equal to $0$.",
    "output": "axiom exists_max_forall_false (f : (x__ : Nat) -> bool) (n : Nat) : ex Nat (λ i => i < n ∧ f i = true) ∧ f (max n f) = true ∨ (prod Set Prop Nat (λ i => prod Prop Prop (i < n) (λ x__ => f i = false)) ∧ max n f = 0)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Commutative_plus. $commutative$ holds for $Nat$ and $plus$.",
    "output": "Axiom commutative_plus : commutative nat plus ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1296$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1297$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "axiom Prod_inv_rect_CProp0 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from elements $_x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_O$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_384$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, for all elements $x_381$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_381$.",
    "output": "Axiom nat_rect_Type2_body : forall Q_ : ((_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2), forall _H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))), forall x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type2 (Q_ x_381) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nmk. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.",
    "output": "nmk : A : cic.Univ cic.prop -> __ : (__ : cic.Term cic.prop A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1692. For all natural numbers $m$, if $0$ is less than $m$, then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.",
    "output": "Axiom let_clause_1692 : forall m : nat, forall posm : (0 < m), forall a : nat, forall x358 : nat, forall x359 : nat, aop__o__op nat 0 plusAC x358 (x358 * x359) = x358 * (x359 + 1) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sig_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to $cic.lift$ applied to $cic.prop$ and $univs.Type0$ and the function that maps $x0$ and $p0$ to $a2$ applied to $x0$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z43$ to $P$ and $y$ and $x$.",
    "output": "postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term cic.prop (a2 t0) -> matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term cic.prop (a2 u0) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2 x0) x_19 _x_20)) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2 x0) x_19 _x_20)) t1 u0 e0) u1) -> P))) (\\ _z43 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_20 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x_19) -> cic.lift cic.prop univs.Type0 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2 x0) x_19 _x_20)) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom max : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.",
    "output": "postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_Aop. For all sets $A$, for all elements $nil$ of $A$, for all functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$, for all functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $Aop$ holds for $A$ and $nil$.",
    "output": "axiom mk_Aop (A : Set) (nil : A) (op : (x__ : A) -> (__1 : A) -> A) (_nill : (a : A) -> op nil a = a) (_nilr : (a : A) -> op a nil = a) (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) : Aop A nil"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Unit_rect_Type5_body. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.",
    "output": "axiom unit_rect_Type5_body (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) (x_499 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type5 (Q_ x_499)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_n_mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then if $0$ is less than $m$, then $congruent$ holds for $n$ and $mod$ applied to $n$ and the product of $m$ and $p$ and $p$.",
    "output": "postulate congruent_n_mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> congruent n (mod n (times m p)) p"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent. For all elements $_n$ and $_m$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "axiom congruent (_n _m _p : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Congruent_ab. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$.",
    "output": "congruent_ab : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_plus_to_le. For all natural numbers $a$ and $n$ and $m$, if the sum of $a$ and $n$ is less than or equal to the sum of $a$ and $m$, then $n$ is less than or equal to $m$.",
    "output": "axiom le_plus_to_le (a n m : Nat) (x__ : a + n ≤ a + m) : n ≤ m"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.",
    "output": "axiom Prod_rect_Type0_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type0 (Q_ x_702)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Plus_plus_comm_23. For all natural numbers $x$ and $y$ and $z$, the sum of the sum of $x$ and $y$ and $z$ is equal to the sum of the sum of $x$ and $z$ and $y$.",
    "output": "postulate plus_plus_comm_23 : (x : Nat) -> (y : Nat) -> (z : Nat) -> Eq (plus (plus x y) z) (plus (plus x z) y)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Null_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.",
    "output": "postulate null_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1068. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$, for all elements $permf$ of $permut$ of $f$ and $n$, for all natural numbers $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then for all natural numbers $a$, if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.",
    "output": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.",
    "output": "Axiom Sum_rect_Type3 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3), forall _H_inl : ((x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))), forall _H_inr : ((x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))), forall x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type3 (Q_ x_536) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_min. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $b$, if $f$ applied to $b$ is equal to absurdity, then $min$ applied to the sum of $n$ and $1$ and $b$ and $f$ is equal to $min$ applied to $n$ and the sum of $b$ and $1$ and $f$.",
    "output": "axiom false_min (f : (x__ : Nat) -> bool) (n b : Nat) (x__ : f b = false) : min (n + 1) b f = min n (b + 1) f"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_bertrand_to_le2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom not_bertrand_to_le2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.",
    "output": "Axiom not_exists_to_forall : forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i)))), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n), cic.Term cic.prop (matita_basics_logic.Not (P i)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "axiom ACop_rect_Type2_body (A : Set) (_nil : A) (Q_ : (_x_897 : ACop A _nil) -> Type2) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)) (x_897 : ACop A _nil) : Q_ x_897"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_plus_to_lt_l. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $p$ and $n$ and $matita_arithmetics_nat.plus$ applied to $q$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.",
    "output": "Axiom lt_plus_to_lt_l : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n)), cic.Term cic.prop (matita_arithmetics_nat.lt p q) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.",
    "output": "axiom lt_S_to_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) : cic.Term cic.prop (matita_arithmetics_nat.lt n m)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_prime_to_primeb_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$.",
    "output": "Axiom not_prime_to_primeb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime, then if $0$ is less than $m$, then if $n$ is divisible by $m$, then $ord_rem$ applied to $m$ and $n$ is less than $m$.",
    "output": "Axiom lt_ord_rem : forall n : nat, forall m : nat, forall x__ : prime n, forall __1 : (0 < m), forall __2 : divisible n m, ord_rem m n < m ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Smallest_factor. For all natural numbers $__$, $Nat$.",
    "output": "Axiom smallest_factor : forall x__ : nat, nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Append_l2_injective. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.",
    "output": "axiom append_l2_injective (A : cic.Univ univs.Type0) (l1 l2 l3 l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_B_Psi. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "le_B_Psi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bigop_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.",
    "output": "axiom bigop_false (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.false) B nil op (λ i => f i)) nil)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.",
    "output": "postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.",
    "output": "Axiom let_clause_1033 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Null_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Dop$ of $A$ and $nil$, for all elements $a$ of $A$, $prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $nil$.",
    "output": "postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prop30. For all instances $n$ of natural numbers, if we can prove that $n$ is odd, then we can prove that the sum of $n$ and $1$ is even.",
    "output": "postulate prop30 : (n : Nat) -> odd n -> even (plus n 1)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.",
    "output": "postulate Prod_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type5 (Q_ x_694)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_Sm_elim. For all natural numbers $n$ and $m$, if $n$ is less than or equal to the sum of $m$ and $1$, then for all propositions $P$, for all functions $__1$ from elements $__1$ of $Leq$ of the sum of $n$ and $1$ and the sum of $m$ and $1$ to elements of $P$, for all functions $__2$ from elements $__2$ of $Eq$ of $n$ and the sum of $m$ and $1$ to elements of $P$, $P$.",
    "output": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $a2$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $_e1$ to $P$ and the function that maps $_z45$ to $P$ and $y$ and $x$.",
    "output": "postulate Prod_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1) (\\ _e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1) -> P))) (\\ _z45 : ((e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> (_e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 x0) -> a2) t1 u0 e0) u1)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_to_fact1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "Axiom exp_to_fact1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_Sn. For all natural numbers $n$, $n$ is less than or equal to the sum of $n$ and $1$.",
    "output": "le_n_Sn : n : Nat -> Leq n (plus n (nd 1)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Allr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom Allr : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "PlusAC. $ACop$ holds for $Nat$ and $0$.",
    "output": "plusAC : ACop Nat 0 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.",
    "output": "Axiom max_f_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $bertrand$ holds for $_n$.",
    "output": "postulate bertrand : (_n : Nat) -> Prop"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_n_nth_prime_n. For all natural numbers $n$, $n$ is less than $nth_prime$ applied to $n$.",
    "output": "Axiom lt_n_nth_prime_n : forall n : nat, n < nth_prime n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B_SSSSO. $B$ applied to $4$ is equal to $6$.",
    "output": "B_SSSSO : Eq (B (nd 4)) (nd 6) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime3. For all natural numbers $n$ and $m$ and $x$, $Nat$.",
    "output": "postulate let_previous_prime3 : (n : Nat) -> (m : Nat) -> (x : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15321. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prim. For all natural numbers $_n$, $Nat$.",
    "output": "prim : _n : Nat -> Nat ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1648. For all elements $n$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$, for all elements $eqn1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.plus$ applied to $q$ and $matita_arithmetics_nat.times$ applied to $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$.",
    "output": "axiom let_clause_1648 (n q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (λ m => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ m => matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) (divq : cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1))) (eqn1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.plus q (matita_arithmetics_nat.times q (matita_arithmetics_div_and_mod.div n1 q))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_642$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_642$.",
    "output": "postulate DPair_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type5 (Q_ x_642)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Log. For all elements $_p$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom log (_p _n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_not_zero. For all natural numbers $n$ and $m$, if $n$ is less than $m$, then $not_zero$ holds for $m$.",
    "output": "axiom lt_to_not_zero (n m : Nat) (x__ : n < m) : not_zero m"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_631$, for all elements $x_630$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_630$.",
    "output": "postulate option_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) -> (x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_630)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.leb$ applied to $n$ and $m$.",
    "output": "axiom leb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_S. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all natural numbers $l$, for all elements $b1$ and $b$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $B$, for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and the sum of $l$ and $1$ and $b1$ and $b2$.",
    "output": "axiom lstar_r_S (B : Set) (R : relation B) (l : Nat) (b1 b : B) (x__ : lstar_r B R l b1 b) (b2 : B) (__1 : R b b2) : lstar_r B R (l + 1) b1 b2"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_r. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ of $B$, for all elements $P$ of $relation2$ of $Nat$ and $B$, for all elements $__$ of $P$ of $0$ and $b1$, for all functions $__1$ from natural numbers $l$ and elements $b$ of $B$ and elements $b2$ of $B$ and elements $__1$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $R$ of $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b2$, for all natural numbers $l$, for all elements $b2$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b2$.",
    "output": "Axiom lstar_ind_r : forall B : Set, forall R : relation B, forall b1 : B, forall P : relation2 nat B, forall x__ : P 0 b1, forall __1 : ((l : nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2), forall l : nat, forall b2 : B, forall __2 : lstar B R l b1 b2, P l b2 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Definition. Let $x$ and $y$ be instances of integers. Then $x$ is equal in parity with $y$, if $x$ is even and $y$ is even or $x$ is odd and $y$ is odd.",
    "output": "same_parity : Int -> Int -> Prop\nsame_parity = \\ x -> \\ y -> or (and (even x) (even y)) (and (odd x) (odd y))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Predicate. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate predicate : (__ : cic.Univ univs.Type0) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_exp_to_le1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.",
    "output": "axiom le_exp_to_le1 (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))) : cic.Term cic.prop (matita_arithmetics_nat.le n m)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "And_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_120$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_119$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_120$ and $x_119$, for all elements $x_118$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_118$.",
    "output": "axiom And_ind (_A _B : cic.Univ cic.prop) (Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) (x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_118)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_mod_to_divides. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "eq_mod_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_1_to_le_exp_B. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom lt_1_to_le_exp_B (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Orb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.",
    "output": "postulate orb_true_r1 : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_4_to_le_B_exp. For all natural numbers $n$, if $4$ is less than $n$, then $B$ applied to the product of $2$ and $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $2$.",
    "output": "postulate lt_4_to_le_B_exp : (n : Nat) -> (_ : Lt 4 n) -> Leq (B (times 2 n)) (pow 2 (minus (times 2 n) 2))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_le_to_lt. For all natural numbers $n$ and $m$ and $p$, if $n$ is less than $m$, then if $m$ is less than or equal to $p$, then $n$ is less than $p$.",
    "output": "lt_to_le_to_lt : n : Nat -> m : Nat -> p : Nat -> __ : Lt n m -> __1 : Leq m p -> Lt n p ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_maxr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$.",
    "output": "axiom le_maxr (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)) : cic.Term cic.prop (matita_arithmetics_nat.le m i)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then we can say that $__$ is greater than or equal to $__1$.",
    "output": "Axiom Geq : forall x__ : nat, forall __1 : nat, Prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1242$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1243$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.",
    "output": "postulate Prod_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1034. For all natural numbers $n$ and $m$ and $q$, if $0$ is less than $n$, then if $0$ is less than $m$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.",
    "output": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (q : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psi_BPsi1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.",
    "output": "le_Psi_BPsi1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_r_inv_ind. For all sets $x1$, for all elements $x2$ of $relation$ of $x1$, for all natural numbers $x3$, for all elements $x4$ and $x5$ of $x1$, for all elements $_Hterm$ of $lstar_r$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from natural numbers $_z2386$ and elements $_z2385$ of $x1$ and elements $_z2384$ of $x1$ to propositions, for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2389$ of $Eq$ of $x3$ and $0$ and elements $_z2388$ of $Eq$ of $x4$ and $b$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from natural numbers $l$ and elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1340$ of $lstar_r$ of $x1$ and $x2$ and $l$ and $b1$ and $b$ and elements $b2$ of $x1$ and elements $_x_1339$ of $x2$ of $b$ and $b2$ and functions $_x_1342$ from elements $_z2389$ of $Eq$ of $x3$ and $l$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $l$ and $b1$ and $b$ and elements $_z2389$ of $Eq$ of $x3$ and the sum of $l$ and $1$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of the sum of $l$ and $1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.",
    "output": "lstar_r_inv_ind : x1 : Set -> x2 : relation x1 -> x3 : Nat -> x4 : x1 -> x5 : x1 -> _Hterm : lstar_r x1 x2 x3 x4 x5 -> P : (_z2386 : Nat -> _z2385 : x1 -> _z2384 : x1 -> Prop) -> _H1 : (b : x1 -> _z2389 : Eq x3 0 -> _z2388 : Eq x4 b -> _z2387 : Eq x5 b -> P 0 b b) -> _H2 : (l : Nat -> b1 : x1 -> b : x1 -> _x_1340 : lstar_r x1 x2 l b1 b -> b2 : x1 -> _x_1339 : x2 b b2 -> _x_1342 : (_z2389 : Eq x3 l -> _z2388 : Eq x4 b1 -> _z2387 : Eq x5 b -> P l b1 b) -> _z2389 : Eq x3 (plus l (nd 1)) -> _z2388 : Eq x4 b1 -> _z2387 : Eq x5 b2 -> P (plus l (nd 1)) b1 b2) -> P x3 x4 x5 ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_times_to_le_div2. For all natural numbers $m$ and $n$ and $q$, if $0$ is less than $q$, then if $n$ is less than or equal to the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than or equal to $m$.",
    "output": "postulate le_times_to_le_div2 : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Leq n (times m q)) -> Leq (div n q) m"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_68. For all instances $n$ of integers, we can prove that if the difference of the product of $3$ and $n$ and $8$ is odd, then $n$ is odd.",
    "output": "noLabel_68 : n : Elem Int -> Proof (if (odd (minus (times (nd 3) n) (nd 8))) (odd n)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type0. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.",
    "output": "Aop_rect_Type0 : A : Set -> _nil : A -> Q_ : (_x_873 : Aop A _nil -> Set) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_873 : Aop A _nil -> Q_ x_873 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.",
    "output": "axiom le_to_le_to_eq (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate filter_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Void_rect_Type3. For all functions $Q_$ from elements $_x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $x_485$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_485$.",
    "output": "void_rect_Type3 : Q_ : (_x_485 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type3) -> x_485 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type3 (Q_ x_485) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp3. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.",
    "output": "axiom Dop_rect_CProp3 (A : Set) (_nil : A) (Q_ : (_x_961 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_961 : Dop A _nil) : Q_ x_961"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_789$.",
    "output": "Aop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type2 (Q_ x_789) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_803$.",
    "output": "Aop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_803) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_951$.",
    "output": "Dop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type2 (Q_ x_951) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp2. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_963$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_963$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_963$.",
    "output": "axiom Dop_rect_CProp2 (A : Set) (_nil : A) (Q_ : (_x_963 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_963 : Dop A _nil) : Q_ x_963"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp1_body. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "False_rect_CProp1_body : Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_77) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_times_to_lt_div. For all natural numbers $m$ and $n$ and $q$, if $n$ is less than the product of $m$ and $q$, then the quotient of $n$ and $q$ is less than $m$.",
    "output": "postulate lt_times_to_lt_div : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt n (times m q)) -> Lt (div n q) m"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_to_eqb_true. For all natural numbers $n$ and $m$, if $n$ is equal to $m$, then $eqb$ applied to $n$ and $m$ is equal to $true$.",
    "output": "postulate eq_to_eqb_true : (n : Nat) -> (m : Nat) -> (_ : Eq n m) -> Eq (eqb n m) true"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "postulate le_2_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n3. For all natural numbers $n$, if $15$ is less than or equal to $n$, then $prim$ applied to $n$ is less than or equal to $pred$ applied to the quotient of $n$ and $2$.",
    "output": "le_prim_n3 : n : Nat -> __ : Leq (nn 1 (nd 5)) n -> Leq (prim n) (pred (div n (nd 2))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_times_times. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$.",
    "output": "div_times_times : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B_SSSSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "B_SSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mk_range. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.",
    "output": "axiom mk_range (A : cic.Univ univs.Type0) (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Assoc_plus1. For all natural numbers $a$ and $b$ and $c$, the sum of $c$ and the sum of $b$ and $a$ is equal to the sum of the sum of $b$ and $c$ and $a$.",
    "output": "Axiom assoc_plus1 : forall a : nat, forall b : nat, forall c : nat, c + (b + a) = b + c + a ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Start_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sum_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z33$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_Sum$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a2$ and $matita_basics_logic.R0$ applied to $a2$ and $t0$ and $u0$ and the function that maps $_e0$ to $P$ and the function that maps $_z34$ to $P$ and $y$ and $x$.",
    "output": "postulate Sum_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ _e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> P)) (\\ _z33 : ((_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> cic.Term univs.Type1 P) -> P))) (\\ u0 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> P)) y) (\\ t0 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> P)) (\\ u0 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) (\\ _e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0) -> P)) (\\ _z34 : ((_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) (matita_basics_logic.R0 a2 t0) u0)) -> cic.Term univs.Type1 P) -> P))) y) x)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "DPair_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.",
    "output": "DPair_rect_Type0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type0) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type0 (Q_ x_650) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_Type1_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_div_mod_spec_intro$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_831$ and $x_830$, for all elements $x_829$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_829$.",
    "output": "Axiom div_mod_spec_rect_Type1_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1), forall _H_div_mod_spec_intro : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))), forall x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type1 (Q_ x_829) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "postulate le_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lists_length_split. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $la$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $lb$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$.",
    "output": "Axiom lists_length_split : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (fun la => matita_basics_logic.ex (matita_basics_lists_list.list A) (fun lb => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb)))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.",
    "output": "axiom eq_rect_CProp4 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_22 : cic.Term univs.Type2 A) (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) : cic.Term cic.prop (Q_ x_22 x_23)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_rect_CProp0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_939$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $range$ of $_A$, $Q_$ holds for $x_939$.",
    "output": "range_rect_CProp0_body : _A : Set -> Q_ : (_x_939 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_939 : range _A -> Q_ x_939 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.",
    "output": "axiom Not_rect_CProp3 (_A : cic.Univ cic.prop) (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term cic.prop (Q_ x_106)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Upto_body. For all sets $A$, for all elements $_xxx$ of $range$ of $A$, $Nat$.",
    "output": "postulate upto_body : (A : Set) -> (_xxx : range A) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_inv_rect_CProp3. For all natural numbers $Hterm$, for all functions $P$ from natural numbers $_z695$ to propositions, for all functions $_H1$ from elements $_z696$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$, for all functions $_H2$ from natural numbers $x_402$ and functions $_x_404$ from elements $_z696$ of $Eq$ of $Hterm$ and $x_402$ to elements of $P$ of $x_402$ and elements $_z696$ of $Eq$ of $Hterm$ and the sum of $x_402$ and $1$ to elements of $P$ of the sum of $x_402$ and $1$, $P$ holds for $Hterm$.",
    "output": "axiom nat_inv_rect_CProp3 (Hterm : Nat) (P : (_z695 : Nat) -> Prop) (_H1 : (_z696 : Hterm = 0) -> P 0) (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Hterm = x_402) -> P x_402) -> (_z696 : Hterm = x_402 + 1) -> P (x_402 + 1)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Leb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.",
    "output": "leb : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_inv_rect_CProp1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1290$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1291$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "Axiom Prod_inv_rect_CProp1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_discr. For all sets $a1$, for all elements $a2$ of $a1$, for all elements $x$ and $y$ of $Aop$ of $a1$ and $a2$, if $x$ is equal to $y$, then $match_Aop$ holds for $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $match_Aop$ applied to $a1$ and $a2$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x0$ applied to $a2$ and $a$ and $a$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R2$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and the function that maps $e2$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R3$ applied to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__$ to $prod$ applied to $Set$ and $Set$ and $a1$ and the function that maps $__1$ to $a1$ and $t0$ and the function that maps $x0$ and $__$ to the function that maps $x01$ and $p0$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a2$ and $a$ and $a$ applied to $x0$ and $__$ and $t1$ and the function that maps $x0$ and $p0$ and $x1$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p1$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $Eq$ applied to $x01$ applied to $a$ and $a2$ and $a$ applied to $x0$ and $p0$ and $x1$ and $__$ and $t2$ and the function that maps $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ to the function that maps $x01$ and $p01$ and $x11$ and $p11$ and $x21$ and $p2$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $a$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $b$ to $prod$ applied to $Set$ and $Prop$ and $a1$ and the function that maps $c$ to $Eq$ applied to $x01$ applied to $a$ and $x01$ applied to $b$ and $c$ and $x01$ applied to $x01$ applied to $a$ and $b$ and $c$ applied to $x0$ and $p0$ and $x1$ and $p1$ and $x2$ and $__$ and $t3$ and $u0$ and $e0$ and $u1$ and $e1$ and $u2$ and $e2$ and $u3$ and the function that maps $_e3$ to $P$ and the function that maps $_z55$ to $P$ and $y$ and $x$.",
    "output": "postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ t0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ t1 : ((a : a1) -> Eq (t0 a2 a) a) -> \\ t2 : ((a : a1) -> Eq (t0 a a2) a) -> \\ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ u0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ u1 : ((a : a1) -> Eq (u0 a2 a) a) -> \\ u2 : ((a : a1) -> Eq (u0 a a2) a) -> \\ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0) (\\ e0 : Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) (\\ e2 : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 -> prod Prop Type1 (Eq (R3 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> \\ x2 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 p1 -> \\ _ : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x01 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 __) t1 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 p01 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : ((a : a1) -> Eq (x02 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> \\ x21 : ((a : a1) -> Eq (x01 a a2) a) -> \\ p2 : Eq (R2 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ __1 : Eq t0 x02 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 __1) t1 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 p02 -> \\ __1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> \\ x10 : ((a : a1) -> Eq (x00 a2 a) a) -> \\ p10 : Eq (R1 (prod Set Set a1 (\\ __2 : a1 -> prod Set Set a1 (\\ __3 : a1 -> a1))) t0 (\\ x_19 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x011 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p011 : Eq t0 x011 -> prod Set Prop a1 (\\ a : a1 -> Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 -> prod Set Prop a1 (\\ a : a1 -> prod Set Prop a1 (\\ b : a1 -> prod Set Prop a1 (\\ c : a1 -> Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) (\\ _e3 : Eq (R3 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> \\ x2 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 p1 -> \\ _ : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x01 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 __) t1 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 p01 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : ((a : a1) -> Eq (x02 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> \\ x21 : ((a : a1) -> Eq (x01 a a2) a) -> \\ p2 : Eq (R2 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ __1 : Eq t0 x02 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 __1) t1 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 p02 -> \\ __1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> \\ x10 : ((a : a1) -> Eq (x00 a2 a) a) -> \\ p10 : Eq (R1 (prod Set Set a1 (\\ __2 : a1 -> prod Set Set a1 (\\ __3 : a1 -> a1))) t0 (\\ x_19 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x011 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p011 : Eq t0 x011 -> prod Set Prop a1 (\\ a : a1 -> Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 -> prod Set Prop a1 (\\ a : a1 -> prod Set Prop a1 (\\ b : a1 -> prod Set Prop a1 (\\ c : a1 -> Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 -> P))))) (\\ _z55 : ((e0 : Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0) -> (e1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) -> (e2 : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) -> (_e3 : Eq (R3 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 __) t2 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 p0 -> \\ p1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 -> \\ x2 : (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a a2) a)) x0 p0 x1 p1 -> \\ _ : Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x01 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 __) t1 (\\ x01 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x01 p01 -> \\ _ : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x02 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : ((a : a1) -> Eq (x02 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> prod Set Prop a1 (\\ a : a1 -> Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p01 : Eq t0 x01 -> \\ x11 : ((a : a1) -> Eq (x01 a2 a) a) -> \\ p11 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 -> \\ x21 : ((a : a1) -> Eq (x01 a a2) a) -> \\ p2 : Eq (R2 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ __1 : Eq t0 x02 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 __1) t1 (\\ x02 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p02 : Eq t0 x02 -> \\ x12 : (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x02 p02 -> \\ __1 : Eq (R1 (prod Set Set a1 (\\ __1 : a1 -> prod Set Set a1 (\\ __2 : a1 -> a1))) t0 (\\ x_19 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x00 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 -> (\\ x00 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p00 : Eq t0 x00 -> \\ x10 : ((a : a1) -> Eq (x00 a2 a) a) -> \\ p10 : Eq (R1 (prod Set Set a1 (\\ __2 : a1 -> prod Set Set a1 (\\ __3 : a1 -> a1))) t0 (\\ x_19 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x011 : ((__2 : a1) -> (__3 : a1) -> a1) -> \\ p011 : Eq t0 x011 -> prod Set Prop a1 (\\ a : a1 -> Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 -> prod Set Prop a1 (\\ a : a1 -> Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 -> prod Set Prop a1 (\\ a : a1 -> prod Set Prop a1 (\\ b : a1 -> prod Set Prop a1 (\\ c : a1 -> Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) -> P) -> P))) y) x"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from natural numbers $_x_413$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$, for all natural numbers $x_413$, $Q_$ holds for $x_413$.",
    "output": "postulate nat_rect_CProp0_body : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.",
    "output": "increasing_to_le2 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i))))) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.",
    "output": "axiom div_mod_spec_rect_CProp5 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) (x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_841)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom min (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_inv_rect_Type1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "div_mod_spec_inv_rect_Type1 : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> P : (_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> cic.Univ univs.Type1) -> _H1 : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2) -> x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4)) -> _z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Inv. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate inv : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_10334. For all natural numbers $n$, if $0$ is less than $n$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.",
    "output": "let_clause_10334 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "Axiom filter_eq : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall __ : cic.Term univs.Type2 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.eq A _x __), cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Option_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.",
    "output": "axiom option_rect_CProp5_body (_A : cic.Univ univs.Type0) (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_618)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_16005. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0$ is less than $n$, then if $0$ is less than $m$, then if the greatest common divisor of $n$ and $m$ is equal to $1$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.",
    "output": "Axiom let_clause_16005 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type0. For all functions $Q_$ from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.",
    "output": "axiom nat_rect_Type0 (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (Q_ x_389)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_previous_prime6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.",
    "output": "axiom let_previous_prime6 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_inv_step. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b1$ and $b2$ of $B$, for all elements $__$ of $lstar$ of $B$ and $R$ and $1$ and $b1$ and $b2$, $R$ holds for $b1$ and $b2$.",
    "output": "Axiom lstar_inv_step : forall B : Set, forall R : relation B, forall b1 : B, forall b2 : B, forall x__ : lstar B R 1 b1 b2, R b1 b2 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_rect_Type2_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_897$.",
    "output": "ACop_rect_Type2_body : A : Set -> _nil : A -> Q_ : (_x_897 : ACop A _nil -> Type2) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_897 : ACop A _nil -> Q_ x_897 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type3. For all functions $Q_$ from elements $_x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_O$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_380$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, for all elements $x_377$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_377$.",
    "output": "nat_rect_Type3 : Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type3) -> _H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_380 : cic.Term univs.Type3 (Q_ x_378) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type3 (Q_ x_377) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_961$.",
    "output": "Dop_rect_CProp3_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_961) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.",
    "output": "Axiom p_ord : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_34$ and $x_35$.",
    "output": "eq_rect_CProp1 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_34 : cic.Term univs.Type2 A -> _x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_34 : cic.Term univs.Type2 A -> x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) -> cic.Term cic.prop (Q_ x_34 x_35) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_nth_prime_to_not_prime. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.",
    "output": "lt_nth_prime_to_not_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_exp. For all natural numbers $p$ and $m$, if $1$ is less than $p$, then $ord$ applied to the exponentiation of $p$ and $m$ and $p$ is equal to $m$.",
    "output": "postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pad_bigop_nil. For all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $i$ and $nil$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.",
    "output": "postulate pad_bigop_nil : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f i) nil))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_n_n. For all natural numbers $n$, $n$ is divisible by $n$.",
    "output": "divides_n_n : n : Nat -> divisible n n ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.",
    "output": "minus_S_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Range_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1644$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1645$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.",
    "output": "range_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ univs.Type3) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_to_or_lt_eq. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than $m$ or $n$ is equal to $m$.",
    "output": "postulate le_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> or (Lt n m) (Eq n m)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transitive_lt. $transitive$ holds for $Nat$ and $Lt$.",
    "output": "transitive_lt : transitive Nat Lt ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Increasing_nth_prime. For all natural numbers $n$, $nth_prime$ applied to $n$ is less than $nth_prime$ applied to the sum of $n$ and $1$.",
    "output": "postulate increasing_nth_prime : (n : Nat) -> Lt (nth_prime n) (nth_prime (plus n 1))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_log2_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.",
    "output": "postulate le_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_1_n. For all natural numbers $n$, $1$ is equal to the exponentiation of $1$ and $n$.",
    "output": "exp_1_n : n : Nat -> Eq (nd 1) (pow (nd 1) n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_le. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_le_n$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $case_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.",
    "output": "Axiom match_le : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort), forall case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n)), forall case_le_S : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term cic.prop (matita_arithmetics_nat.le _n __), cic.Term return_sort (return_type __ z) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Op_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.",
    "output": "postulate op_body : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_exp_to_lt. For all natural numbers $a$ and $n$ and $m$, if $0$ is less than $a$, then if the exponentiation of $a$ and $n$ is less than the exponentiation of $a$ and $m$, then $n$ is less than $m$.",
    "output": "Axiom lt_exp_to_lt : forall a : nat, forall n : nat, forall m : nat, forall x__ : (0 < a), forall __1 : (pow a n < pow a m), n < m ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B_SSSSSSSSO. $B$ applied to $8$ is equal to $70$.",
    "output": "postulate B_SSSSSSSSO : Eq (B 8) 70"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_exp1. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.",
    "output": "Axiom p_ord_exp1 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_781$.",
    "output": "Aop_ind : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_781) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate distributive : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Eq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate eq_fact_pi_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.",
    "output": "Axiom not_le_to_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)), cic.Term cic.prop (matita_arithmetics_nat.lt m n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "F_max_true. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, for all elements $__$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$, $f$ applied to $max$ applied to $n$ and $f$ is equal to $true$.",
    "output": "Axiom f_max_true : forall f : ((x__ : nat) -> bool), forall n : nat, forall x__ : ex nat (fun i => i < n /\\ f i = true), f (max n f) = true ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Prod_rect_CProp3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_708$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_708$.",
    "output": "axiom Prod_rect_CProp3_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_708)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.",
    "output": "axiom let_clause_1572 (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sigma_p_dividesb. For all natural numbers $m$ and $n$ and $p$, if $0$ is less than $n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $m$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.",
    "output": "axiom sigma_p_dividesb (m n p : Nat) (x__ : 0 < n) (__1 : prime p) (__2 : ¬ divisible p n) : m = bigop m (λ i => dividesb (pow p (i + 1)) (pow p m * n)) Nat 0 plus (λ i => 1)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $_n$ be a natural number. Then we can say that $not_bertrand$ holds for $_n$.",
    "output": "not_bertrand : _n : Nat -> Prop ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1734$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1735$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.",
    "output": "postulate Dop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_8_to_le_Psi_exp. For all natural numbers $n$, if $n$ is less than or equal to $8$, then $Psi$ applied to $n$ is less than or equal to the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $3$.",
    "output": "postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (minus (times 2 n) 3))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $__$ and $__1$ be natural numbers. Then the exponentiation of $__$ and $__1$ is a natural number.",
    "output": "axiom pow (x__ __1 : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_1_to_lt_n. For all natural numbers $i$ and $n$, if $1$ is less than $n$, then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.",
    "output": "Axiom gcd_1_to_lt_n : forall i : nat, forall n : nat, forall x__ : (1 < n), forall __1 : Leq i n, forall __2 : (gcd i n = 1), i < n ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "To_max. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.",
    "output": "Axiom to_max : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m i), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp2. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $Lt$ of $_r$ and $_m$ and elements $x_850$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_849$.",
    "output": "div_mod_spec_rect_CProp2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_849 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_851 : Lt _r _m -> x_850 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> x_849 : div_mod_spec _n _m _q _r -> Q_ x_849 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_nat. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_O$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$, for all functions $case_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "match_nat : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ return_sort) -> case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O) -> case_S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))) -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.",
    "output": "map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list B) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Flatten. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.",
    "output": "postulate flatten : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Permut_S_mod. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.",
    "output": "permut_S_mod : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mem_append_l2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.",
    "output": "postulate mem_append_l2 : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2)) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_smallest_factor_to_not_divides. For all natural numbers $n$ and $i$, if $1$ is less than $n$, then if $1$ is less than $i$, then if $i$ is less than $smallest_factor$ applied to $n$, then $i$ is not divisible by $n$.",
    "output": "Axiom lt_smallest_factor_to_not_divides : forall n : nat, forall i : nat, forall x__ : (1 < n), forall __1 : (1 < i), forall __2 : (i < smallest_factor n), ~ divisible i n ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Pi_p_primeb1. For all natural numbers $n$, if $0$ is less than $n$, then $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $bigop$ applied to the logarithm of $p$ and $n$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $p$.",
    "output": "axiom pi_p_primeb1 (n : Nat) (x__ : 0 < n) : n = bigop (n + 1) (λ p => primeb p) Nat 1 times (λ p => bigop (log p n) (λ i => dividesb (pow p (i + 1)) n) Nat 1 times (λ i => p))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "StreicherK. For all elements $T$ of $cic.Univ$ of $univs.Type2$, for all elements $t$ of $cic.Term$ of $univs.Type2$ and $T$, for all functions $P$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.refl$ applied to $T$ and $t$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $p$.",
    "output": "streicherK : T : cic.Univ univs.Type2 -> t : cic.Term univs.Type2 T -> P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)) -> p : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Term univs.Type2 (P p) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.",
    "output": "Axiom mod_p_ord_inv : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "axiom Aop_rect_Type4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type4 (Q_ x_783)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_fact_to_le. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$.",
    "output": "Axiom divides_fact_to_le : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)), cic.Term cic.prop (matita_arithmetics_nat.le p n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.",
    "output": "Axiom le_n_Sn : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_prim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $p$ and $matita_arithmetics_primes.prime$ applied to $p$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $q$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $p$ and the function that maps $__1$ to $matita_arithmetics_nat.le$ applied to $q$ and $n$.",
    "output": "axiom min_prim (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ p => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (λ q => cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (λ __ => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (λ __1 => matita_arithmetics_nat.le q n))))))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Match_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.",
    "output": "postulate match_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_S_S_to_lt. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than the sum of $m$ and $1$, then $n$ is less than $m$.",
    "output": "postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distributive_times_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.plus$.",
    "output": "postulate distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_times. For all natural numbers $n$ and $m$ and $p$, if $0$ is less than $p$, then $mod$ applied to the product of $n$ and $m$ and $p$ is equal to $mod$ applied to the product of $mod$ applied to $n$ and $p$ and $mod$ applied to $m$ and $p$ and $p$.",
    "output": "Axiom mod_times : forall n : nat, forall m : nat, forall p : nat, forall x__ : (0 < p), mod (n * m) p = mod (mod n p * mod m p) p ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "Axiom aop__o__op : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1), forall _x_887 : cic.Term univs.Type0 x0, forall _x_888 : cic.Term univs.Type0 x0, cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Distr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.",
    "output": "axiom distr (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) (a b c : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by the exponentiation of $n$ and $m$, then $p$ is divisible by $n$.",
    "output": "axiom divides_exp_to_divides (p n m : Nat) (x__ : prime p) (__1 : divisible p (pow n m)) : divisible p n"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.",
    "output": "Axiom lstar_ind_r : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B), forall __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1), forall __1 : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b2 : cic.Term univs.Type0 B, forall __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2), cic.Term cic.prop (P l b2) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Filter_range. For all sets $_A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $range$ of $_A$ to elements of $return_type$ of $z$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.",
    "output": "axiom filter_range (_A : Set) (return_sort : Sort) (return_type : (z : range _A) -> return_sort) (return : (z : range _A) -> return_type z) (z : range _A) : return_type z"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lenght_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.",
    "output": "postulate lenght_to_nil : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_divides_false. For all lists $l$ of natural numbers, for all natural numbers $n$, if $list_divides$ applied to $l$ and $n$ is equal to absurdity, then for all natural numbers $p$, for all elements $__1$ of $mem$ of $Nat$ and $p$ and $l$, $p$ is not divisible by $n$.",
    "output": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_Psil. For all natural numbers $n$, $Psi$ applied to $n$ is less than or equal to the exponentiation of $n$ and $prim$ applied to $n$.",
    "output": "axiom le_Psil (n : Nat) : Psi n ≤ pow n (prim n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dividesb_div_true. For all natural numbers $d$ and $n$, if $0$ is less than $n$, then if $dividesb$ applied to $d$ and $n$ is equal to $true$, then $dividesb$ applied to the quotient of $n$ and $d$ and $n$ is equal to $true$.",
    "output": "dividesb_div_true : d : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Eq (dividesb d n) true -> Eq (dividesb (div n d) n) true ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_times. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "axiom divides_times (n m p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type3_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_867$ of $Aop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_867$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_867$.",
    "output": "Aop_rect_Type3_body : A : Set -> _nil : A -> Q_ : (_x_867 : Aop A _nil -> Type3) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.",
    "output": "axiom not_exists_to_forall (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) : cic.Term cic.prop (matita_basics_logic.Not (P i))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $univs.Type0$.",
    "output": "postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Let_clause_15624. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $d$ and $matita_arithmetics_nat.times$ applied to $n$ and $c$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.",
    "output": "postulate let_clause_15624 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times m d) (matita_arithmetics_nat.times n c)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.",
    "output": "postulate snd : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 B"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_reflexive. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $T$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $T$ and $R$ and $R$.",
    "output": "axiom sub_reflexive (T : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation T)) : cic.Term cic.prop (matita_basics_relations.subR T R R)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exists_forall_lt. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$, $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $Eq$ applied to $f$ applied to $i$ and $true$ or $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n$ and the function that maps $__$ to $Eq$ applied to $f$ applied to $i$ and absurdity.",
    "output": "axiom exists_forall_lt (f : (x__ : Nat) -> bool) (n : Nat) : ex Nat (λ i => i < n ∧ f i = true) ∨ prod Set Prop Nat (λ i => prod Prop Prop (i < n) (λ x__ => f i = false))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "ACop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.",
    "output": "axiom ACop_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term univs.Type2 (P Hterm)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "P_ord_inv. For all natural numbers $_p$ and $_m$ and $_x$, $Nat$.",
    "output": "axiom p_ord_inv (_p _m _x : Nat) : Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.",
    "output": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Bceq. For all natural numbers $n$ and $k$, $bc$ applied to $n$ and $k$ is equal to the quotient of the factorial of $n$ and the product of the factorial of $k$ and the factorial of the difference of $n$ and $k$.",
    "output": "axiom bceq (n k : Nat) : bc n k = factorial n / (factorial k * factorial (n - k))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "List_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.",
    "output": "axiom list_rect_Type3 (_A : cic.Univ univs.Type0) (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type3 (Q_ x_731)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_sigma. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.",
    "output": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Reverse_cons. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $l$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.",
    "output": "postulate reverse_cons : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_prim_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "le_prim_n1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_783$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_783$.",
    "output": "Aop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type4 (Q_ x_783) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lprim_invariant. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $i$ and $acc$ and $matita_arithmetics_nat.plus$ applied to $n$ and $i$.",
    "output": "axiom lprim_invariant (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_theta_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.",
    "output": "Axiom div_theta_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (fun p => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => p))) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_eq_true_false. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.true$ and $matita_basics_bool.false$.",
    "output": "Axiom not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_S_S_to_le. For all natural numbers $n$ and $m$, if the sum of $n$ and $1$ is less than or equal to the sum of $m$ and $1$, then $n$ is less than or equal to $m$.",
    "output": "postulate le_S_S_to_le : (n : Nat) -> (m : Nat) -> (_ : Leq (plus n 1) (plus m 1)) -> Leq n m"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_CProp0_body. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.",
    "output": "axiom nat_rect_CProp0_body (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_413)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_exp_times. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.",
    "output": "axiom exp_exp_times (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Mod_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.",
    "output": "mod_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p)) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Orb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.",
    "output": "Axiom orb_true_r1 : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp0_body. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.",
    "output": "False_rect_CProp0_body : Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_78 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_78) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_d_gcd. For all natural numbers $m$ and $n$ and $d$, if $d$ is divisible by $m$, then if $d$ is divisible by $n$, then $d$ is divisible by the greatest common divisor of $n$ and $m$.",
    "output": "Axiom divides_d_gcd : forall m : nat, forall n : nat, forall d : nat, forall x__ : divisible d m, forall __1 : divisible d n, divisible d (gcd n m) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "FactS. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.",
    "output": "axiom factS (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_factorial.fact n)))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Divides_to_not_ord_O. For all natural numbers $p$ and $m$, if $0$ is less than $m$, then if $p$ is prime, then if $p$ is divisible by $m$, then $ord$ applied to $m$ and $p$ is not equal to $0$.",
    "output": "Axiom divides_to_not_ord_O : forall p : nat, forall m : nat, forall x__ : (0 < m), forall __1 : prime p, forall __2 : divisible p m, ~ (ord m p = 0) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Minus_S_S. For all natural numbers $n$ and $m$, the difference of the sum of $n$ and $1$ and the sum of $m$ and $1$ is equal to the difference of $n$ and $m$.",
    "output": "minus_S_S : n : Nat -> m : Nat -> Eq (minus (plus n (nd 1)) (plus m (nd 1))) (minus n m) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "NoLabel_17. We can prove that for all integers $n$, if $n$ is even, then the product of $3$ and the exponentiation of $n$ and $5$ is even.",
    "output": "Axiom noLabel_17 : forall n : Int, (even n -> even (3 * pow n 5)) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Transpose. For all natural numbers $__$ and $__1$ and $__2$, $Nat$.",
    "output": "postulate transpose : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Nat"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Injn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "postulate injn : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Sub_lt. For all sets $A$, for all functions $e$ from natural numbers to elements of $A$, for all functions $p$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $sub_hk$ holds for the function that maps $x$ to $x$ and the function that maps $x$ to $x$ and $A$ and $mk_range$ applied to $A$ and $e$ and $n$ and $p$ and $mk_range$ applied to $A$ and $e$ and $m$ and $p$.",
    "output": "Axiom sub_lt : forall A : Set, forall e : ((x__ : nat) -> A), forall p : ((x__ : nat) -> bool), forall n : nat, forall m : nat, forall x__ : Leq n m, sub_hk (fun x => x) (fun x => x) A (mk_range A e n p) (mk_range A e m p) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ex2_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.",
    "output": "axiom ex2_ind (A : cic.Univ univs.Type0) (_P _Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) : cic.Term cic.prop (Q_ x_274)"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_ind_body. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.",
    "output": "axiom le_ind_body (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) : cic.Term cic.prop (Q_ x_417 x_418)"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_Type0. For all functions $Q_$ from elements $_x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_72$.",
    "output": "postulate False_rect_Type0 : (Q_ : (_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0) -> (x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ x_72)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Type2. $cic.Sort$.",
    "output": "Type2 : cic.Sort ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Gcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.",
    "output": "Axiom gcd_n_n : forall n : nat, gcd n n = n ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Exp_Sn. For all natural numbers $b$ and $n$, the exponentiation of $b$ and the sum of $n$ and $1$ is equal to the product of $b$ and the exponentiation of $b$ and $n$.",
    "output": "axiom exp_Sn (b n : Nat) : pow b (n + 1) = b * pow b n"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lstar_ind_body. For all sets $B$, for all elements $_R$ of $relation$ of $B$, for all functions $Q_$ from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions, for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $x_1236$ and $l$ and $b2$ and $x_1235$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.",
    "output": "axiom lstar_ind_body (B : Set) (_R : relation B) (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) (x_1233 : Nat) (x_1232 x_1231 : B) (x_1234 : lstar B _R x_1233 x_1232 x_1231) : Q_ x_1233 x_1232 x_1231 x_1234"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Max_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.",
    "output": "postulate max_f_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1561$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.",
    "output": "axiom Aop_inv_rect_CProp0 (x1 : Set) (x2 : x1) (Hterm : Aop x1 x2) (P : (_z1560 : Aop x1 x2) -> Prop) (_H1 : (op : (x__ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> op x2 a = a) -> (_nilr : (a : x1) -> op a x2 = a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> op a (op b c) = op (op a b) c) -> (_z1561 : Hterm = mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_885$.",
    "output": "Axiom Aop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_885) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1753$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.",
    "output": "axiom Dop_inv_rect_CProp1 (x1 : Set) (x2 : x1) (Hterm : Dop x1 x2) (P : (_z1752 : Dop x1 x2) -> Prop) (_H1 : (sum : ACop x1 x2) -> (prod : (x__ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> prod a x2 = x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> prod a (aop__o__op x1 x2 sum b c) = aop__o__op x1 x2 sum (prod a b) (prod a c)) -> (_z1753 : Hterm = mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) : P Hterm"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Refute_none_by_refl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $E$ to $matita_basics_logic.match_False$ applied to $univs.Type0$ and the function that maps $_0$ to $B$ and $H$ applied to $E$ and the function that maps $v$ and $_0$ to $P$ applied to $v$ and $x$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$.",
    "output": "axiom refute_none_by_refl (A B : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) : cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (λ y => cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (λ __1 => B)) (λ E => matita_basics_logic.match_False univs.Type0 (λ _0 => B) (H E)) (λ v => λ _0 => P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x)))"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "axiom le_O_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_zero. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.",
    "output": "Axiom not_zero : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Primes_below_to_bertrand. For all elements $pm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $pm$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $pm$, for all functions $__2$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $pm$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.",
    "output": "axiom primes_below_to_bertrand (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.",
    "output": "Aop_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type1) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Dpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.",
    "output": "dpi1__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1) -> cic.Univ univs.Type0) -> x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2) -> _x_887 : cic.Term univs.Type0 x0 -> _x_888 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "False_rect_CProp1. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.",
    "output": "False_rect_CProp1 : Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_77 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_77) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Axiom. Let $A$ be a set. Let $_nil$ be an element of $A$. Then $Dop$ applied to $A$ and $_nil$ is a set.",
    "output": "Axiom Dop : forall A : Set, forall _nil : A, Set ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Square_double. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.",
    "output": "square_double : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n)) ."
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Type3. $cic.Sort$.",
    "output": "axiom Type3 : cic.Sort"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type4_body. For all functions $Q_$ from natural numbers $_x_369$ to elements of $Type4$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_370$ and elements $_x_372$ of $Q_$ of $x_370$ to elements of $Q_$ of the sum of $x_370$ and $1$, for all natural numbers $x_369$, $Q_$ holds for $x_369$.",
    "output": "axiom nat_rect_Type4_body (Q_ : (_x_369 : Nat) -> Type4) (_H_O : Q_ 0) (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (x_370 + 1)) (x_369 : Nat) : Q_ x_369"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_times. For all natural numbers $a$ and $b$, if $0$ is less than $b$, then the quotient of the product of $a$ and $b$ and $b$ is equal to $a$.",
    "output": "axiom div_times (a b : Nat) (x__ : 0 < b) : a * b / b = a"
  },
  {
    "instruction": "Translate the following English statement into Lean. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Le_theta_M_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.",
    "output": "axiom le_theta_M_theta (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))"
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Min_spec_ind. For all natural numbers $_n$ and $_b$, for all functions $_f$ from natural numbers to booleans, for all functions $Q_$ from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions, for all functions $_H_found_min_spec$ from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$, for all functions $_H_not_found_min_spec$ from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$, for all natural numbers $x_1075$, for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.",
    "output": "Axiom min_spec_ind : forall _n : nat, forall _b : nat, forall _f : ((x__ : nat) -> bool), forall Q_ : ((x_1075 : nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop), forall _H_found_min_spec : ((m : nat) -> (x_1080 : Leq _b m) -> (x_1079 : m < _n + _b) -> (x_1078 : _f m = true) -> (x_1077 : (i : nat) -> (x__ : Leq _b i) -> (__1 : i < m) -> _f i = false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)), forall _H_not_found_min_spec : ((x_1081 : (i : nat) -> (x__ : Leq _b i) -> (__1 : i < _n + _b) -> _f i = false) -> Q_ (_n + _b) (not_found_min_spec _n _b _f x_1081)), forall x_1075 : nat, forall x_1076 : min_spec _n _b _f x_1075, Q_ x_1075 x_1076 ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Div_mod_spec_rect_CProp5. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.",
    "output": "Axiom div_mod_spec_rect_CProp5 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))), forall x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_841) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_case. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.",
    "output": "postulate nat_case : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Not_lt_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.",
    "output": "not_lt_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le m n) ."
  },
  {
    "instruction": "Translate the following English statement into Coq. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Ord_times. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.",
    "output": "Axiom ord_times : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p))) ."
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Nat_rect_Type2_body. For all functions $Q_$ from natural numbers $_x_381$ to elements of $Type2$, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of the sum of $x_382$ and $1$, for all natural numbers $x_381$, $Q_$ holds for $x_381$.",
    "output": "postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381"
  },
  {
    "instruction": "Translate the following English statement into Agda. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Aop_rect_CProp3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_879$.",
    "output": "postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_879)"
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "Lt_1_to_le_exp_B. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.",
    "output": "lt_1_to_le_exp_B : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."
  },
  {
    "instruction": "Translate the following English statement into Dedukti. Please imitate the input and output examples and output in the specified format. Give me the output text only (without any explains, inputs or 'Output:').\nExample1: \nInput: Translate the following French statement into Coq. Prop70. Nous pouvons démontrer que $1$ est impair. \nOutput: Axiom prop70 : odd 1 . \nExample2: \nInput: Translate the following English statement into Agda. Prop80. We can prove that $2$ is even. \nOutput: postulate prop80 : even 2  ",
    "input": "B_SSSSSSO. $B$ applied to $6$ is equal to $20$.",
    "output": "B_SSSSSSO : Eq (B (nd 6)) (nn 2 (nd 0)) ."
  }
]