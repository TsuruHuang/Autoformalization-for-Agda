{"input": "Statement in natural language:\nIf two functions f\u2081 and f\u2082 are eventually equal at a filter l\u2081, and if function f\u2081 tends from filter l\u2081 to filter l\u2082, then function f\u2082 also tends from filter l\u2081 to filter l\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem Tendsto.congr' {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (hl : f\u2081 =\u1da0[l\u2081] f\u2082)\n    (h : Tendsto f\u2081 l\u2081 l\u2082) : Tendsto f\u2082 l\u2081 l\u2082 :="}
{"input": "Statement in natural language:\nFor any element 'a' and any list 'l' of elements of the same type as 'a', the count of 'a' in the list that results from erasing 'a' from 'l' is equal to the count of 'a' in 'l' minus one.\nTranslate the statement in natural language to Lean:", "output": "theorem count_erase_self (a : \u03b1) (l : List \u03b1) : count a (List.erase l a) = count a l - 1 :="}
{"input": "Statement in natural language:\nFor any element 'x' of type '\u03b1' and any function 'u' that maps from a finite set of size 'm' to '\u03b1', the tail of a vector created by prepending 'x' to 'u' is equal to 'u'.\nTranslate the statement in natural language to Lean:", "output": "theorem tail_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) : vecTail (vecCons x u) = u :="}
{"input": "Statement in natural language:\nIf a polynomial g is monic, then the root of g is integral over the ring R.\nTranslate the statement in natural language to Lean:", "output": "theorem isIntegral_root' (hg : g.Monic) : IsIntegral R (root g) :="}
{"input": "Statement in natural language:\nIf b is less than or equal to c, then the natural sum of a and b is less than or equal to the natural sum of a and c.\nTranslate the statement in natural language to Lean:", "output": "theorem nadd_le_nadd_left (h : b \u2264 c) (a) : a \u266f b \u2264 a \u266f c :="}
{"input": "Statement in natural language:\nFor any unit 'u' in a ring 'R' and any natural number 'n', the coefficient of the term of degree 'n' in the power series expansion of the inverse of 'u' subtracted from 1 is equal to 1 divided by 'u' raised to the power of 'n + 1'.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_invUnitsSub (u : R\u02e3) (n : \u2115) : coeff R n (invUnitsSub u) = 1 /\u209a u ^ (n + 1) :="}
{"input": "Statement in natural language:\nA hyperreal number 'x' is infinitely positive if and only if for all real numbers 'r', 'r' is less than 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem infinitePos_def {x : \u211d*} : InfinitePos x \u2194 \u2200 r : \u211d, \u2191r < x :="}
{"input": "Statement in natural language:\nThe non-equal locus of the sum of two functions 'f' and 'g' with respect to 'f' is equal to the support of 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :="}
{"input": "Statement in natural language:\nFor a scalar multiplication operation on a set R and M, and a continuous constant scalar multiplication on R and M, given a scalar r from R, a continuous function f from \u03b2 to M, and a continuous function g from \u03b1 to \u03b2, the composition of the scalar multiplication of r and f with g is equal to the scalar multiplication of r with the composition of f and g.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : C(\u03b2, M)) (g : C(\u03b1, \u03b2)) :\n    (r \u2022 f).comp g = r \u2022 f.comp g :="}
{"input": "Statement in natural language:\nFor any relation 'r' on a set '\u03b1' that is well-ordered (denoted by 'wo'), the order type of the well-ordered set '\u27e8\u03b1, r, wo\u27e9' is equal to the order type of the relation 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem type_def (r) [wo : IsWellOrder \u03b1 r] : (\u27e6\u27e8\u03b1, r, wo\u27e9\u27e7 : Ordinal) = type r :="}
{"input": "Statement in natural language:\nFor any uniform space \u03b2 and any function f from \u03b2 to \u03b1 that is uniformly continuous, for any natural number n, the function that maps x to the nth power of f(x) is also uniformly continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem UniformContinuous.pow_const [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f) :\n    \u2200 n : \u2115, UniformContinuous fun x => f x ^ n"}
{"input": "Statement in natural language:\nFor any functions `n` mapping from \u03b3 to \u03b4, `m'` mapping from \u03b2 to \u03b1' to \u03b4, and `n'` mapping from \u03b1 to \u03b1', if for all `a` and `b`, `n` applied to `m` of `a` and `b` equals `m'` of `b` applied to `n'` of `a`, then mapping `n` over the result of applying the binary function `m` to `f` and `g` equals applying the binary function `m'` to `g` and the result of mapping `n'` over `f`.\nTranslate the statement in natural language to Lean:", "output": "theorem map_map\u2082_antidistrib_right {n : \u03b3 \u2192 \u03b4} {m' : \u03b2 \u2192 \u03b1' \u2192 \u03b4} {n' : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, n (m a b) = m' b (n' a)) : (map\u2082 m f g).map n = map\u2082 m' g (f.map n') :="}
{"input": "Statement in natural language:\nThe arctangent of a real number x is equal to the arcsine of the ratio of x to the square root of the sum of 1 and the square of x.\nTranslate the statement in natural language to Lean:", "output": "theorem arctan_eq_arcsin (x : \u211d) : arctan x = arcsin (x / sqrt (1 + x ^ 2)) :="}
{"input": "Statement in natural language:\nThe image of the function that adds a constant 'a' to a variable 'x', when applied to the closed interval from 'b' to 'c', is equal to the closed interval from 'a + b' to 'a + c'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_const_add_Icc : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) :="}
{"input": "Statement in natural language:\nFor any list 'l' of any type '\u03b1', given that 'l' is not an empty list, the cycle of 'l' is equal to 'l' appended to the cycle of 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem cycle_eq : \u2200 (l : List \u03b1) (h : l \u2260 []), cycle l h = l ++\u209b cycle l h"}
{"input": "Statement in natural language:\nFor any object 'n' in 'M' and any object 'X' in 'C', the application of the map of 'F.obj n' to 'F.\u03b5.app X' is equal to the composition of the application of 'F.map (\u03bb_ n).inv' to 'X' and the inverse application of 'F.\u03bcIso (\ud835\udfd9_ M) n' to 'X'.\nTranslate the statement in natural language to Lean:", "output": "theorem obj_\u03b5_app (n : M) (X : C) :\n    (F.obj n).map (F.\u03b5.app X) = (F.map (\u03bb_ n).inv).app X \u226b (F.\u03bcIso (\ud835\udfd9_ M) n).inv.app X :="}
{"input": "Statement in natural language:\nIf a set 's' is an element of the neighborhood of 'x', then 'x' has a unique differential within the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem uniqueDiffWithinAt_of_mem_nhds (h : s \u2208 \ud835\udcdd x) : UniqueDiffWithinAt \ud835\udd5c s x :="}
{"input": "Statement in natural language:\nFor a monovariant function pair f and g, the product of the sum of f(i) and the sum of g(i) is less than or equal to the product of the cardinality of the index set and the sum of the product of f(i) and g(i).\nTranslate the statement in natural language to Lean:", "output": "theorem Monovary.sum_mul_sum_le_card_mul_sum (hfg : Monovary f g) :\n    ((\u2211 i, f i) * \u2211 i, g i) \u2264 Fintype.card \u03b9 * \u2211 i, f i * g i :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, where \u03b1 is finite, and any two sets s and t (one from each type), if the cardinality of \u03b1 is equal to the cardinality of \u03b2, and the cardinality of set s is equal to the cardinality of set t, then the cardinality of the complement of set s in \u03b1 is equal to the cardinality of the complement of set t in \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_compl_eq_mk_compl_finite {\u03b1 \u03b2 : Type u} [Finite \u03b1] {s : Set \u03b1} {t : Set \u03b2}\n    (h1 : (#\u03b1) = (#\u03b2)) (h : (#s) = (#t)) : (#(s\u1d9c : Set \u03b1)) = (#(t\u1d9c : Set \u03b2)) :="}
{"input": "Statement in natural language:\nIf a function 'f' is monotone on a set 's', then the composition of 'f' and the value function of a subtype is also monotone when mapping from 's' to '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.MonotoneOn.monotone (h : MonotoneOn f s) :\n    Monotone (f \u2218 Subtype.val : s \u2192 \u03b2) :="}
{"input": "Statement in natural language:\nFor any two complex numbers x and y, the complex power function of x and y is equal to x raised to the power of y.\nTranslate the statement in natural language to Lean:", "output": "theorem cpow_eq_pow (x y : \u2102) : cpow x y = x ^ y :="}
{"input": "Statement in natural language:\nIf a set 's' of type \u03b1 and a set 't' of type \u03b2 are both measurable sets, then the Cartesian product of 's' and 't' is also a measurable set.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasurableSet.prod {s : Set \u03b1} {t : Set \u03b2} (hs : MeasurableSet s)\n    (ht : MeasurableSet t) : MeasurableSet (s \u00d7\u02e2 t) :="}
{"input": "Statement in natural language:\nFor any real number 'x' and any positive number '\u03b5', there exists a rational number 'q' such that the absolute difference between 'x' and 'q' is less than '\u03b5'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_rat_near (x : \u03b1) (\u03b50 : 0 < \u03b5) : \u2203 q : \u211a, |x - q| < \u03b5 :="}
{"input": "Statement in natural language:\nA function 'f' is in the Lp space of measurable functions from '\u03b1' to 'E' with respect to measure '\u03bc' if and only if the pth power of the norm of 'f' with respect to measure '\u03bc' is less than infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_Lp_iff_snorm_lt_top {f : \u03b1 \u2192\u2098[\u03bc] E} : f \u2208 Lp E p \u03bc \u2194 snorm f p \u03bc < \u221e :="}
{"input": "Statement in natural language:\nThe successor of one in the finite set of size n+2 is equal to two.\nTranslate the statement in natural language to Lean:", "output": "theorem succ_one_eq_two' : Fin.succ (1 : Fin (n + 2)) = 2 :="}
{"input": "Statement in natural language:\nFor a given relation R on elements of type \u03b2, a list of elements of type \u03b1, and a function from \u03b1 to a list of \u03b2, the list formed by binding the function over the list has the pairwise property with respect to R if and only if two conditions are met: firstly, for every element in the original list, the list produced by applying the function to that element has the pairwise property with respect to R; and secondly, for every pair of elements in the original list, for every pair of elements in the lists produced by applying the function to those elements, the relation R holds.\nTranslate the statement in natural language to Lean:", "output": "theorem pairwise_bind {R : \u03b2 \u2192 \u03b2 \u2192 Prop} {l : List \u03b1} {f : \u03b1 \u2192 List \u03b2} :\n    List.Pairwise R (l.bind f) \u2194\n      (\u2200 a \u2208 l, Pairwise R (f a)) \u2227 Pairwise (fun a\u2081 a\u2082 => \u2200 x \u2208 f a\u2081, \u2200 y \u2208 f a\u2082, R x y) l :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't' in a monoid '\u03b1' that also forms a star semigroup, the star of the product of 's' and 't' is equal to the product of the star of 't' and the star of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem star_mul [Monoid \u03b1] [StarSemigroup \u03b1] (s t : Set \u03b1) : (s * t)\u22c6 = t\u22c6 * s\u22c6 :="}
{"input": "Statement in natural language:\nThe set of all pairs of elements (p) from a set \u03b1, where the first element of the pair is less than the second, is an open set.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpen_lt_prod : IsOpen { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 } :="}
{"input": "Statement in natural language:\n'n is less than the predecessor of m' if and only if 'the successor of n is less than m'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_pred_iff : n < pred m \u2194 succ n < m :="}
{"input": "Statement in natural language:\nIf 'x' and 'y' are not in the same cycle of permutation 'f', then applying the cycle of 'f' at 'x' to 'y' results in 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem cycleOf_apply_of_not_sameCycle : \u00acSameCycle f x y \u2192 cycleOf f x y = y :="}
{"input": "Statement in natural language:\nFor a sequence of natural numbers 'u' and an initial sequence 'init' of order 'E.order', if 'u' is a solution of the linear recurrence 'E' and 'u' equals 'init' for all 'n' in the order of 'E', then for all natural numbers 'n', 'u' at 'n' equals the solution of 'E' made with 'init' at 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_mk_of_is_sol_of_eq_init {u : \u2115 \u2192 \u03b1} {init : Fin E.order \u2192 \u03b1} (h : E.IsSolution u)\n    (heq : \u2200 n : Fin E.order, u n = init n) : \u2200 n, u n = E.mkSol init n :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from 'M' to 'M\u2082' over the scalar field 'S', the same map 'f' considered over a larger scalar field 'R' is still the same map when considered as a function from 'M' to 'M\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_restrictScalars (f : M \u2192\u2097[S] M\u2082) : ((f : M \u2192\u2097[R] M\u2082) : M \u2192 M\u2082) = f :="}
{"input": "Statement in natural language:\nFor any two vertices 'u' and 'v' in a graph 'G' that are adjacent, concatenating an empty list with the adjacency of 'u' and 'v' is equivalent to adding the adjacency of 'u' and 'v' to the start of an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem concat_nil {u v : V} (h : G.Adj u v) : nil.concat h = cons h nil :="}
{"input": "Statement in natural language:\nFor a bijective function 'f' from '\u03b1' to '\u03b2', the preimage of a set 's' under 'f' is equal to another set 't' if and only if 's' is equal to the image of 't' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_eq_iff_eq_image {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) {s t} : f \u207b\u00b9' s = t \u2194 s = f '' t :="}
{"input": "Statement in natural language:\nFor any commutative monoid 'M', any natural number 'n', any element 'i' of the finite set of size 'n', and any function 'v' from the finite set of size 'n+1' to 'M', the product of the function 'v' over all elements 'j' in the strict upper half of 'i.succ' is equal to the product of the function 'v' over all elements 'j' in the strict upper half of 'i', where each 'j' is incremented by one.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_Ioi_succ {M : Type _} [CommMonoid M] {n : \u2115} (i : Fin n) (v : Fin n.succ \u2192 M) :\n    (\u220f j in Ioi i.succ, v j) = \u220f j in Ioi i, v j.succ :="}
{"input": "Statement in natural language:\nIf a sequence of functions `f'` is uniformly Cauchy on filters `l` and `l'`, then the sequence of functions obtained by multiplying `f'` by the constant function `1` is also uniformly Cauchy on the same filters.\nTranslate the statement in natural language to Lean:", "output": "theorem UniformCauchySeqOnFilter.one_smulRight {l' : Filter \ud835\udd5c}\n    (hf' : UniformCauchySeqOnFilter f' l l') :\n    UniformCauchySeqOnFilter (fun n => fun z => (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c).smulRight (f' n z)) l l' :="}
{"input": "Statement in natural language:\nThe absolute value of the difference between the norms of two elements 'a' and 'b' is less than or equal to the norm of the ratio of 'a' to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_norm_sub_norm_le' (a b : E) : |\u2016a\u2016 - \u2016b\u2016| \u2264 \u2016a / b\u2016 :="}
{"input": "Statement in natural language:\nFor an alternating map 'f' from a module 'M' to a module 'N' over a ring 'R' indexed by '\u03b9', and a linear map 'g' from a module 'M\u2082' to 'M', the application of the composition of 'f' with the linear map 'g' is equal to the composition of 'f' with the double composition of 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_compLinearMap (f : AlternatingMap R M N \u03b9) (g : M\u2082 \u2192\u2097[R] M) :\n    \u21d1(f.compLinearMap g) = f \u2218 (\u00b7 \u2218 \u00b7) g :="}
{"input": "Statement in natural language:\nIf a is not equal to zero, then the degree of the polynomial constant a is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_C (ha : a \u2260 0) : degree (C a) = (0 : WithBot \u2115) :="}
{"input": "Statement in natural language:\nFor any ordinal number 'o' and any element 'a' from the successor of 'o', 'a' is less than or equal to the enumeration of 'o' with respect to the successor of 'o', where the enumeration is defined by the order relation '<'. This is proven by rewriting the type of 'o' as less than its successor.\nTranslate the statement in natural language to Lean:", "output": "theorem le_enum_succ {o : Ordinal} (a : (succ o).out.\u03b1) :\n    a \u2264\n      @enum (succ o).out.\u03b1 (\u00b7 < \u00b7) _ o\n        (by\n          rw [type_lt]\n          exact lt_succ o) :="}
{"input": "Statement in natural language:\nIf x is not equal to zero, then the function that maps x to its inverse has a derivative at x, which is equal to the negative of the inverse of the square of x, scaled by 1.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFDerivAt_inv (x_ne_zero : x \u2260 0) :\n    HasFDerivAt (fun x => x\u207b\u00b9) (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (-(x ^ 2)\u207b\u00b9) : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) x :="}
{"input": "Statement in natural language:\nFor any two integers 'a' and 'b', the absolute value of 'a' is less than the absolute value of 'b' if and only if the square of 'a' is less than the square of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem natAbs_lt_iff_sq_lt {a b : \u2124} : a.natAbs < b.natAbs \u2194 a ^ 2 < b ^ 2 :="}
{"input": "Statement in natural language:\nFor a given topological space R and a topological ring R with an ideal J, J is adic if and only if for every natural number n, the set of elements in the nth power of J is open, and for every set s in the neighborhood of 0 in R, there exists a natural number n such that the set of elements in the nth power of J is a subset of s.\nTranslate the statement in natural language to Lean:", "output": "theorem isAdic_iff [top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} :\n    IsAdic J \u2194\n      (\u2200 n : \u2115, IsOpen ((J ^ n : Ideal R) : Set R)) \u2227\n        \u2200 s \u2208 \ud835\udcdd (0 : R), \u2203 n : \u2115, ((J ^ n : Ideal R) : Set R) \u2286 s :="}
{"input": "Statement in natural language:\nFor a function 'f' from an index set '\u03b9' to the closed subsets of a topological space '\u03b1', and a finite set 's' of indices, the underlying set of the intersection (infimum) of the closed subsets indexed by 's' is equal to the intersection of the sets obtained by applying the function 'f' to each element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_finset_inf (f : \u03b9 \u2192 Closeds \u03b1) (s : Finset \u03b9) :\n    (\u2191(s.inf f) : Set \u03b1) = s.inf ((\u2191) \u2218 f) :="}
{"input": "Statement in natural language:\nFor a finite set 's' of any type '\u03b1', the cardinality of 's' is equal to the cardinality of the finite set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Fintype.card_coe (s : Finset \u03b1) [Fintype s] : Fintype.card s = s.card :="}
{"input": "Statement in natural language:\nThe sum of 'a' and 'b' is in the half-open interval from 'c' to 'd' if and only if 'a' is in the half-open interval from 'c - b' to 'd - b'.\nTranslate the statement in natural language to Lean:", "output": "theorem add_mem_Ico_iff_left : a + b \u2208 Set.Ico c d \u2194 a \u2208 Set.Ico (c - b) (d - b) :="}
{"input": "Statement in natural language:\nFor a centroid homomorphism 'f' of a type '\u03b1', the conversion of 'f' to an additive monoid homomorphism is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem toAddMonoidHom_eq_coe (f : CentroidHom \u03b1) : f.toAddMonoidHom = f :="}
{"input": "Statement in natural language:\nFor a given element 's' of set 'S', the algebraic mapping of 's' from 'S' to the trivial square zero extension of 'R' and 'M' is equal to the inclusion of the left (inl) of the algebraic mapping of 's' from 'S' to 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem algebraMap_eq_inl' (s : S) : algebraMap S (tsze R M) s = inl (algebraMap S R s) :="}
{"input": "Statement in natural language:\nFor any three types \u03b1, \u03b2, \u03b3 that are primcodable, and any three properties p, q, r of type \u03b1, \u03b2, \u03b3 respectively, if property p is one-one reducible to property q, and property q is one-one reducible to property r, then property p is one-one reducible to property r. This is a statement of transitivity for one-one reducibility.\nTranslate the statement in natural language to Lean:", "output": "theorem OneOneReducible.trans {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : p \u2264\u2081 q \u2192 q \u2264\u2081 r \u2192 p \u2264\u2081 r"}
{"input": "Statement in natural language:\nIf a particular element 'a' does not belong to a given set 's', then the intersection of set 's' and the set containing only 'a' is an empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_singleton_of_not_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : s \u2229 {a} = \u2205 :="}
{"input": "Statement in natural language:\nThe negative of x is an element of p if and only if x is an element of p.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_mem_iff : -x \u2208 p \u2194 x \u2208 p :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from 'E' to 'F' that is differentiable on a set 's', and for all 'y', the derivative of 'f' within the set 's' at 'x' and 'y' is 'n' times continuously differentiable on 's', then 'f' is '(n + 1)' times continuously differentiable on 's'. Here, '\ud835\udd5c' is the field over which the function is defined and 'E' and 'F' are finite-dimensional vector spaces over '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem contDiffOn_succ_of_fderiv_apply [FiniteDimensional \ud835\udd5c E] {n : \u2115} {f : E \u2192 F} {s : Set E}\n    (hf : DifferentiableOn \ud835\udd5c f s) (h : \u2200 y, ContDiffOn \ud835\udd5c n (fun x => fderivWithin \ud835\udd5c f s x y) s) :\n    ContDiffOn \ud835\udd5c (n + 1 : \u2115) f s :="}
{"input": "Statement in natural language:\nThe homomorphism of the quotient of the integer power of a homomorphism, when the homomorphism is the identity on A, is equal to the identity homomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem homQuotientZPowOfHom_id : homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _ :="}
{"input": "Statement in natural language:\nThe range of the representation function of a basis 'b' (which maps from the module 'M' to the function space of '\u03b9' with coefficients in the ring 'R') is equal to the set of all finitely supported functions from '\u03b9' to 'R' that are supported everywhere (i.e., on the universal set).\nTranslate the statement in natural language to Lean:", "output": "theorem repr_range : LinearMap.range (b.repr : M \u2192\u2097[R] \u03b9 \u2192\u2080 R) = Finsupp.supported R R univ :="}
{"input": "Statement in natural language:\nIf polynomial q is not equal to zero and the trailing degree of polynomial p is less than or equal to the trailing degree of polynomial q, then the natural number trailing degree of polynomial p is less than or equal to the natural number trailing degree of polynomial q.\nTranslate the statement in natural language to Lean:", "output": "theorem natTrailingDegree_le_natTrailingDegree {hq : q \u2260 0}\n    (hpq : p.trailingDegree \u2264 q.trailingDegree) : p.natTrailingDegree \u2264 q.natTrailingDegree :="}
{"input": "Statement in natural language:\nIf we have a sequence of functions 'fs' and a function 'f' that are dominated by an integrable function 'bound', and each function in the sequence 'fs' is almost everywhere strongly measurable, then if for almost every 'a', the sequence 'fs' converges to 'f' at 'a', the limit of the sequence of the set function applied to 'fs' is the set function applied to 'f'. This is under the condition that 'T' is a dominated finite measure additive function.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_setToFun_of_dominated_convergence (hT : DominatedFinMeasAdditive \u03bc T C)\n    {fs : \u2115 \u2192 \u03b1 \u2192 E} {f : \u03b1 \u2192 E} (bound : \u03b1 \u2192 \u211d)\n    (fs_measurable : \u2200 n, AEStronglyMeasurable (fs n) \u03bc) (bound_integrable : Integrable bound \u03bc)\n    (h_bound : \u2200 n, \u2200\u1d50 a \u2202\u03bc, \u2016fs n a\u2016 \u2264 bound a)\n    (h_lim : \u2200\u1d50 a \u2202\u03bc, Tendsto (fun n => fs n a) atTop (\ud835\udcdd (f a))) :\n    Tendsto (fun n => setToFun \u03bc T hT (fs n)) atTop (\ud835\udcdd <| setToFun \u03bc T hT f) :="}
{"input": "Statement in natural language:\nIf y and z are coprime and x divides y, then x and z are also coprime.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCoprime.of_isCoprime_of_dvd_left (h : IsCoprime y z) (hdvd : x \u2223 y) : IsCoprime x z :="}
{"input": "Statement in natural language:\nFor a nonzero polynomial 'p' over a finite field 'Fq', the cardinality of the power of the degree of 'p' is equal to the cardinality of 'Fq' raised to the natural degree of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem cardPowDegree_nonzero (p : Fq[X]) (hp : p \u2260 0) :\n    cardPowDegree p = (Fintype.card Fq : \u2124) ^ p.natDegree :="}
{"input": "Statement in natural language:\nFor any interval 's' of any type '\u03b1', the length of 's' is always greater than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem length_nonneg : \u2200 s : Interval \u03b1, 0 \u2264 s.length"}
{"input": "Statement in natural language:\nIf an element 'y' has a finite order and for every prime number 'p' that divides the order of 'x', 'p' times the order of 'x' also divides the order of 'y', then the order of the product of 'x' and 'y' is equal to the order of 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem orderOf_mul_eq_right_of_forall_prime_mul_dvd (hy : IsOfFinOrder y)\n    (hdvd : \u2200 p : \u2115, p.Prime \u2192 p \u2223 orderOf x \u2192 p * orderOf x \u2223 orderOf y) :\n    orderOf (x * y) = orderOf y :="}
{"input": "Statement in natural language:\nFor any natural numbers k and l, and any Lie ideals I and J of a Lie algebra L over a ring R, if the k-th derived series of I and the l-th derived series of J are both the zero ideal (denoted by \u22a5), then the (k + l)-th derived series of the sum of I and J is also the zero ideal.\nTranslate the statement in natural language to Lean:", "output": "theorem derivedSeries_add_eq_bot {k l : \u2115} {I J : LieIdeal R L} (hI : derivedSeries R I k = \u22a5)\n    (hJ : derivedSeries R J l = \u22a5) : derivedSeries R (I + J) (k + l) = \u22a5 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type 'q.P.A' and any function 'f' from 'q.P.B a' to 'q.P.W', the fixed point of the function 'mk' applied to the abstraction of the pair consisting of 'a' and the function that maps 'x' to the equivalence class of 'f x', is equal to the equivalence class of the pair consisting of 'a' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Fix.ind_aux (a : q.P.A) (f : q.P.B a \u2192 q.P.W) :\n    Fix.mk (abs \u27e8a, fun x => \u27e6f x\u27e7\u27e9) = \u27e6\u27e8a, f\u27e9\u27e7 :="}
{"input": "Statement in natural language:\nIf for all elements 'x' in a certain set 'l', the function 'f' applied to 'x' is nonnegative (i.e., greater than or equal to zero), and if the function 'g' tends to infinity as 'x' tends to infinity in 'l', then the function that adds the results of 'f' and 'g' also tends to infinity as 'x' tends to infinity in 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_atTop_add_nonneg_left' (hf : \u2200\u1da0 x in l, 0 \u2264 f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop :="}
{"input": "Statement in natural language:\nIf N is a normal subgroup of a group G and the order of N is coprime to the index of N in G, then there exists a subgroup H of G such that N and H are complementary.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_right_complement'_of_coprime {N : Subgroup G} [N.Normal]\n    (hN : Nat.coprime (Nat.card N) N.index) : \u2203 H : Subgroup G, IsComplement' N H :="}
{"input": "Statement in natural language:\nFor a given set 'i' that is measurable, and another set 'j' that is also measurable, the restriction of the vector 'v' to the set 'i' applied to 'j' is equal to the vector 'v' applied to the intersection of 'j' and 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem restrict_apply {i : Set \u03b1} (hi : MeasurableSet i) {j : Set \u03b1} (hj : MeasurableSet j) :\n    v.restrict i j = v (j \u2229 i) :="}
{"input": "Statement in natural language:\nThe sine of two times pi is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sin_two_pi : sin (2 * \u03c0) = 0 :="}
{"input": "Statement in natural language:\nFor an affine equivalence 'e' between two points 'P\u2081' and 'P\u2082' in a field 'k', and for any two points 'a' and 'b' in 'P\u2081' and any scalar 'c' in 'k', applying 'e' to the line map of 'a', 'b', and 'c' is equivalent to the line map of 'e a', 'e b', and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_lineMap (e : P\u2081 \u2243\u1d43[k] P\u2082) (a b : P\u2081) (c : k) :\n    e (AffineMap.lineMap a b c) = AffineMap.lineMap (e a) (e b) c :="}
{"input": "Statement in natural language:\nIf we have an algebra A over B, and if A has a finite presentation over R and B has a finite presentation over A, then B also has a finite presentation over R. This is under the condition that R, A, and B form a scalar tower.\nTranslate the statement in natural language to Lean:", "output": "theorem trans [Algebra A B] [IsScalarTower R A B] (hfpA : FinitePresentation R A)\n    (hfpB : FinitePresentation A B) : FinitePresentation R B :="}
{"input": "Statement in natural language:\nFor a given point 'x' and a set 's' such that 's' is in the neighborhood of 'x', and another set 't', the difference of 's' and 't' is in the neighborhood of 'x' within the complement of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem diff_mem_nhdsWithin_compl {x : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd x) (t : Set \u03b1) :\n    s \\ t \u2208 \ud835\udcdd[t\u1d9c] x :="}
{"input": "Statement in natural language:\nFor any two types K and L, given that K and L are fields, R is a domain, R is a Dedekind domain, there are algebra structures between R and K, and between S and L, K and L are fraction rings of R and S respectively, there are algebra structures between K and L, and between R and L, R, S, and L form a scalar tower, as do R, K, and L, R and S form a Noetherian ring, S is an integral closure of R in L, and p is a maximal ideal of R that is not the zero ideal, the sum over all prime ideals P in the factorization of the ideal p in S, of the product of the ramification index and the inertia degree of P with respect to the ring homomorphism from R to S, is equal to the field extension degree of K over L.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_ramification_inertia (K L : Type _) [Field K] [Field L] [IsDomain R]\n    [IsDedekindDomain R] [Algebra R K] [IsFractionRing R K] [Algebra S L] [IsFractionRing S L]\n    [Algebra K L] [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] [IsNoetherian R S]\n    [IsIntegralClosure S R L] [p.IsMaximal] (hp0 : p \u2260 \u22a5) :\n    (\u2211 P in (factors (map (algebraMap R S) p)).toFinset,\n        ramificationIdx (algebraMap R S) p P * inertiaDeg (algebraMap R S) p P) =\n      finrank K L :="}
{"input": "Statement in natural language:\nFor a given Lie Submodule 'N'', the Lie bracket of the top Lie Ideal and 'N' is less than or equal to 'N'' if and only if 'N' is less than or equal to the normalizer of 'N''.\nTranslate the statement in natural language to Lean:", "output": "theorem top_lie_le_iff_le_normalizer (N' : LieSubmodule R L M) :\n    \u2045(\u22a4 : LieIdeal R L), N\u2046 \u2264 N' \u2194 N \u2264 N'.normalizer :="}
{"input": "Statement in natural language:\nThe Cramer's map for a matrix A is a linear map in the field of scalars \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem cramer_is_linear : IsLinearMap \u03b1 (cramerMap A) :="}
{"input": "Statement in natural language:\nFor any index 'i' in a set '\u03b9', if every '\u03b1 i' is nonempty and the filter 'f i' is not the smallest filter (NeBot), then the coproduct filter of 'f' is also not the smallest filter.\nTranslate the statement in natural language to Lean:", "output": "theorem NeBot.coprod\u1d62 [\u2200 i, Nonempty (\u03b1 i)] {i : \u03b9} (h : NeBot (f i)) : NeBot (Filter.coprod\u1d62 f) :="}
{"input": "Statement in natural language:\nIf 'l' is an exponential comparison filter, 'a' is a complex number, and 'b' is a real number less than zero, then the function that maps 'z' to the exponential of 'b' times 'z' is little-o of the function that maps 'z' to 'z' raised to the power of 'a' at the limit 'l'. This means that the growth rate of the exponential function is significantly smaller than the growth rate of the power function as 'z' approaches the limit 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem isLittleO_exp_cpow (hl : IsExpCmpFilter l) (a : \u2102) {b : \u211d} (hb : b < 0) :\n    (fun z => exp (b * z)) =o[l] fun z => z ^ a :="}
{"input": "Statement in natural language:\nFor two algebraic equivalences, the first one from A\u2081 to A\u2082 and the second one from A\u2082 to A\u2083, the composition of the first equivalence followed by the second one is equal to the transitive application of the first equivalence to the second one.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_trans (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) : \u21d1(e\u2081.trans e\u2082) = e\u2082 \u2218 e\u2081 :="}
{"input": "Statement in natural language:\nThe second projection of a pullback cone, derived from a left isomorphism of morphisms f and g, is equal to the identity morphism.\nTranslate the statement in natural language to Lean:", "output": "theorem pullbackConeOfLeftIso_snd : (pullbackConeOfLeftIso f g).snd = \ud835\udfd9 _ :="}
{"input": "Statement in natural language:\nIf a function 'f' is monotone and tends to zero as it approaches infinity, and if the norm of the sum of a sequence 'z' up to any given point 'n' is less than or equal to a constant 'b', then the sequence defined by the sum of the product of 'f' and 'z' up to the point 'n+1' is a Cauchy sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem Monotone.cauchySeq_series_mul_of_tendsto_zero_of_bounded (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) (hgb : \u2200 n, \u2016\u2211 i in range n, z i\u2016 \u2264 b) :\n    CauchySeq fun n \u21a6 \u2211 i in range (n + 1), f i \u2022 z i :="}
{"input": "Statement in natural language:\nFor any element 'a' of the set of elements that do not satisfy the predicate 'p', applying the equivalence relation 'ep.subtypeCongr en' to 'a' is the same as applying the equivalence relation 'en' to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem Perm.subtypeCongr.right_apply_subtype (a : { a // \u00acp a }) : ep.subtypeCongr en a = en a :="}
{"input": "Statement in natural language:\nFor any two multisets 's' and 't', if 's' does not contain any duplicate elements, then the intersection of 's' and 't' (where duplicates are not allowed) also does not contain any duplicate elements.\nTranslate the statement in natural language to Lean:", "output": "theorem Nodup.ndinter {s : Multiset \u03b1} (t : Multiset \u03b1) : Nodup s \u2192 Nodup (ndinter s t) :="}
{"input": "Statement in natural language:\nFor any two multiplicative characters \u03c7 and \u03c7' from a ring R to another ring R', \u03c7 is equal to \u03c7' if and only if for all units a in R, the value of \u03c7 at a is equal to the value of \u03c7' at a.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_iff {\u03c7 \u03c7' : MulChar R R'} : \u03c7 = \u03c7' \u2194 \u2200 a : R\u02e3, \u03c7 a = \u03c7' a :="}
{"input": "Statement in natural language:\nFor any natural numbers 'n' and 'k', if 'n' is not less than the square of 'k', then the difference between the square root of 'n' and 'k' is less than the difference between the square root of 'n' plus 2 and 'k'.\nTranslate the statement in natural language to Lean:", "output": "theorem minFac_lemma (n k : \u2115) (h : \u00acn < k * k) : sqrt n - k < sqrt n + 2 - k :="}
{"input": "Statement in natural language:\nThe application of the norm group norm to a normed group E is equal to the norm.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_normGroupNorm : \u21d1(normGroupNorm E) = norm :="}
{"input": "Statement in natural language:\nA function 'f' from '\u03b1' to non-negative extended real numbers is continuous if and only if the function 'f' is continuous when considered as a function from '\u03b1' to extended real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_coe_ennreal_iff {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    (Continuous fun a => (f a : EReal)) \u2194 Continuous f :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that is finite, any type \u03b2 that has a decidable equality, any function from \u03b1 to \u03b2, any element k of \u03b2, and any property p of \u03b2 that is decidable, if k is in the image of the function applied to all elements of \u03b1 and k does not satisfy the property p, then the image of the function applied to all elements of \u03b1 that satisfy the property p is a proper subset of the image of the function applied to all elements of \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem image_subtype_univ_ssubset_image_univ [Fintype \u03b1] [DecidableEq \u03b2] (k : \u03b2) (b : \u03b1 \u2192 \u03b2)\n    (hk : k \u2208 Finset.image b univ) (p : \u03b2 \u2192 Prop) [DecidablePred p] (hp : \u00acp k) :\n    image (fun i : { a // p (b a) } => b \u2191i) univ \u2282 image b univ :="}
{"input": "Statement in natural language:\nFor a set 'c' of linear maps from 'E' to 'F', if 'c' is directed on the relation 'less than or equal to', and 'l' is a linear map in 'c', then for any 'x' in the domain of 'l', the supremum of 'c' applied to 'x' (with 'x' satisfying the condition that it is less than or equal to the supremum of 'c') is equal to 'l' applied to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem sSup_apply {c : Set (E \u2192\u2097.[R] F)} (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) {l : E \u2192\u2097.[R] F}\n    (hl : l \u2208 c) (x : l.domain) :\n    (LinearPMap.sSup c hc) \u27e8x, (LinearPMap.le_sSup hc hl).1 x.2\u27e9 = l x :="}
{"input": "Statement in natural language:\nThe difference of 'a' and 'b' equals zero if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem tsub_eq_zero_iff_le : a - b = 0 \u2194 a \u2264 b :="}
{"input": "Statement in natural language:\nThe matrix representation of the identity linear map, when both the domain and codomain are the same vector space v\u2081, is the identity matrix.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearMap.toMatrix_one : LinearMap.toMatrix v\u2081 v\u2081 1 = 1 :="}
{"input": "Statement in natural language:\nFor any element 'x' and any element 'y' from set 'S', the mapping of 'f.mk' 'x' 'y' by 'f.map' 'hy' 'k' is equal to 'k.mk' of 'g' 'x' and the ordered pair consisting of 'g' 'y' and 'hy' 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_mk' (x) (y : S) : f.map hy k (f.mk' x y) = k.mk' (g x) \u27e8g y, hy y\u27e9 :="}
{"input": "Statement in natural language:\nIf a is not equal to zero, then there exists a natural number n such that the inverse of 2 to the power of n is less than a.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_inv_two_pow_lt (ha : a \u2260 0) : \u2203 n : \u2115, 2\u207b\u00b9 ^ n < a :="}
{"input": "Statement in natural language:\nFor any elements 'r' from ring 'R' and 's' from ring 'S', the application of the universal homomorphism to the quotient of 'r' and 's' is equal to the product of the image of 'r' under 'f' and the inverse of the image of 's' under 'fS' in the unit group of 'T'.\nTranslate the statement in natural language to Lean:", "output": "theorem universalHom_apply {r : R} {s : S} :\n    universalHom f fS hf (r /\u2092 s) = f r * ((fS s)\u207b\u00b9 : Units T) :="}
{"input": "Statement in natural language:\nFor a ring \u03b1 and a function f from \u03b1 to \u03b1, given integers na, nb, nc and natural numbers da, db, dc, k, if f is the addition function, a is a rational number with numerator na and denominator da, b is a rational number with numerator nb and denominator db, the sum of the product of na and db and the product of nb and da is equal to the product of k and nc, and the product of da and db is equal to the product of k and dc, then the result of applying the function f to a and b is a rational number with numerator nc and denominator dc.\nTranslate the statement in natural language to Lean:", "output": "theorem isRat_add {\u03b1} [Ring \u03b1] {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {na nb nc : \u2124} {da db dc k : \u2115} :\n    f = HAdd.hAdd \u2192 IsRat a na da \u2192 IsRat b nb db \u2192\n    Int.add (Int.mul na db) (Int.mul nb da) = Int.mul k nc \u2192\n    Nat.mul da db = Nat.mul k dc \u2192\n    IsRat (f a b) nc dc :="}
{"input": "Statement in natural language:\nFor any complex number 'z' and any natural number 'n', the absolute value of 'z' raised to the power of 'n' is equal to the absolute value of 'z' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_pow (z : \u2102) (n : \u2115) : Complex.abs (z ^ n) = Complex.abs z ^ n :="}
{"input": "Statement in natural language:\nFor a given element 'x' in a topological group 'G' that is equipped with a right multiplication operation, the inverse of the right multiplication by 'x' is the same as the right multiplication by the inverse of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem mulRight_symm [IsometricSMul G\u1d50\u1d52\u1d56 G] (x : G) : (mulRight x).symm = mulRight x\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor a given element 'a' from set A and a polynomial 'p' from the ring of polynomials over R, the application of the function 'toFunLinear' on the tensor product of 'a' and 'p' is equal to the application of the function 'toFunBilinear' on 'a' and 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem toFunLinear_tmul_apply (a : A) (p : R[X]) :\n    toFunLinear R A (a \u2297\u209c[R] p) = toFunBilinear R A a p :="}
{"input": "Statement in natural language:\nIf we have a nonempty set 's' of ideals of a ring '\u03b1', and 's' is a chain (meaning for any two elements in 's', one is less than or equal to the other), and every element 'p' in 's' is a prime ideal, then the infimum of 's' is also a prime ideal.\nTranslate the statement in natural language to Lean:", "output": "theorem sInf_isPrime_of_isChain {s : Set (Ideal \u03b1)} (hs : s.Nonempty) (hs' : IsChain (\u00b7 \u2264 \u00b7) s)\n    (H : \u2200 p \u2208 s, Ideal.IsPrime p) : (sInf s).IsPrime :="}
{"input": "Statement in natural language:\nFor any two continuous affine maps 'f' and 'g' from 'P' to 'Q' over a ring 'R', if for every 'x' in 'P', 'f' at 'x' equals 'g' at 'x', then 'f' equals 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {f g : P \u2192A[R] Q} (h : \u2200 x, f x = g x) : f = g :="}
{"input": "Statement in natural language:\nFor two star subalgebras S\u2081 and S\u2082 of a ring R and an algebra B, and a star algebra homomorphism f from A to B, if S\u2081 is a subset of or equal to S\u2082, then the preimage of S\u2081 under f is a subset of or equal to the preimage of S\u2082 under f.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_mono {S\u2081 S\u2082 : StarSubalgebra R B} {f : A \u2192\u22c6\u2090[R] B} :\n    S\u2081 \u2264 S\u2082 \u2192 S\u2081.comap f \u2264 S\u2082.comap f :="}
{"input": "Statement in natural language:\nFor a symmetrized element 'a' of type '\u03b1', 'a' being unequal to the unsymmetrized version of 1 is equivalent to 'a' being unequal to the symmetrized version of 1.\nTranslate the statement in natural language to Lean:", "output": "theorem unsym_ne_one_iff [One \u03b1] (a : \u03b1\u02e2\u02b8\u1d50) : unsym a \u2260 (1 : \u03b1) \u2194 a \u2260 (1 : \u03b1\u02e2\u02b8\u1d50) :="}
{"input": "Statement in natural language:\nFor any two positive natural numbers 'm' and 'n', and any natural numbers 'k' and 'l', if 'm' and 'n' are coprime, then 'm' to the power of 'k' is also coprime with 'n' to the power of 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem Coprime.pow {m n : \u2115+} (k l : \u2115) (h : m.Coprime n) : (m ^ k).coprime (n ^ l) :="}
{"input": "Statement in natural language:\nThe function coeFn is injective when applied to homotopies between two paths p\u2080 and p\u2081 in the topological space X. This means that if two homotopies produce the same output when coeFn is applied to them, then those two homotopies must have been the same to begin with.\nTranslate the statement in natural language to Lean:", "output": "theorem coeFn_injective : @Function.Injective (Homotopy p\u2080 p\u2081) (I \u00d7 I \u2192 X) (\u21d1) :="}
{"input": "Statement in natural language:\nIf set s and set t in the topological space \u03b1 are open, then their intersection is also an open set in \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem IsOpen.inter (s t : Set \u03b1) : IsOpen \u03b1 s \u2192 IsOpen \u03b1 t \u2192 IsOpen \u03b1 (s \u2229 t) :="}
{"input": "Statement in natural language:\nIf we have a type \u03b9 with a linear order, a filter 'f' on a set \u03b1, a filter 'g' on a set \u03b2, a function 's' from \u03b9 to the set of subsets of \u03b1, and a function 't' from \u03b9 to the set of subsets of \u03b2, and if 'f' has an antitone basis 's' and 'g' has an antitone basis 't', then the product filter of 'f' and 'g' has an antitone basis that is the product of the functions 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasAntitoneBasis.prod {\u03b9 : Type _} [LinearOrder \u03b9] {f : Filter \u03b1} {g : Filter \u03b2}\n    {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\n    HasAntitoneBasis (f \u00d7\u02e2 g) fun n => s n \u00d7\u02e2 t n :="}
{"input": "Statement in natural language:\nFor any multisets 's' and 't' and any element 'a', 's' with 'a' added is equal to 't' if and only if 'a' is an element of 't' and 's' is equal to 't' with 'a' removed.\nTranslate the statement in natural language to Lean:", "output": "theorem add_singleton_eq_iff {s t : Multiset \u03b1} {a : \u03b1} : s + {a} = t \u2194 a \u2208 t \u2227 s = t.erase a :="}
{"input": "Statement in natural language:\nFor a pullback 'p' of functions 'f' and 'g', the first component of the homomorphism of 'p' under the isomorphism 'pullbackIsoPullback f g' is equal to the first component of the pullback 'p' mapped to 'X' by 'pullback.fst'.\nTranslate the statement in natural language to Lean:", "output": "theorem pullbackIsoPullback_hom_fst (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X \u00d7 Y).fst = (pullback.fst : _ \u27f6 X) p :="}
{"input": "Statement in natural language:\nFor any given element 's' from the set '\u03c3' and any given element 'a' from the set 'R', the product of the constant 'a' and the variable 's' is equal to a monomial with 's' as the variable, '1' as the exponent, and 'a' as the coefficient.\nTranslate the statement in natural language to Lean:", "output": "theorem C_mul_X_eq_monomial {s : \u03c3} {a : R} : C a * X s = monomial (Finsupp.single s 1) a :="}
{"input": "Statement in natural language:\nFor a covariant class \u03b1 with respect to multiplication and less than or equal to relation, and another covariant class \u03b1 with respect to the swapped multiplication and strictly less than relation, if a is less than b and c is less than d, then the product of a and c is less than the product of b and d.\nTranslate the statement in natural language to Lean:", "output": "theorem Right.mul_lt_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c d : \u03b1}\n    (h\u2081 : a < b) (h\u2082 : c < d) :\n    a * c < b * d :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that has a uniform space structure and is a complete space, the entire set of \u03b1 is complete.\nTranslate the statement in natural language to Lean:", "output": "theorem complete_univ {\u03b1 : Type u} [UniformSpace \u03b1] [CompleteSpace \u03b1] :\n    IsComplete (univ : Set \u03b1) :="}
{"input": "Statement in natural language:\nFor any list 'l' of elements of type '\u03b1', if the reverse of 'l' is equal to 'l' itself, then 'l' is a palindrome.\nTranslate the statement in natural language to Lean:", "output": "theorem of_reverse_eq {l : List \u03b1} : reverse l = l \u2192 Palindrome l :="}
{"input": "Statement in natural language:\nIf a function 'f' from '\u03b1' to '\u03b2' is not absolutely measurable with respect to a measure '\u03bc', then the measure of the image of 'f' under '\u03bc' is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem map_of_not_aemeasurable {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1} (hf : \u00acAEMeasurable f \u03bc) :\n    \u03bc.map f = 0 :="}
{"input": "Statement in natural language:\nFor a function 'f' that takes a natural number and an element of type \u03b1 and returns an element of type \u03b2 in a monadic context, a starting natural number 'start', an element 'a' of type \u03b1, and a list 'as' of elements of type \u03b1, the specification of mapping 'f' over the indices and elements of the list starting from 'start' and consisting of 'a' followed by 'as' is equivalent to applying 'f' to 'start' and 'a', and then prepending this to the result of recursively applying the same mapping operation to the rest of the list, starting from the next index.\nTranslate the statement in natural language to Lean:", "output": "theorem mapIdxMAuxSpec_cons {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 m \u03b2) (start : \u2115) (a : \u03b1) (as : List \u03b1) :\n    mapIdxMAuxSpec f start (a :: as) = cons <$> f start a <*> mapIdxMAuxSpec f (start + 1) as :="}
{"input": "Statement in natural language:\nThe absolute value of negative one raised to any natural number power is equal to one.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_neg_one_pow (n : \u2115) : |(-1 : R) ^ n| = 1 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1' and any list 'l' of type '\u03b1', the encoding of the list that results from prepending 'a' to 'l' is equal to the successor of the pair of the encoding of 'a' and the encoding of 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem encode_list_cons (a : \u03b1) (l : List \u03b1) :\n    encode (a :: l) = succ (pair (encode a) (encode l)) :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b9' to 'E' that is linearly independent, the norm of the Gram-Schmidt normalized function at 'n' is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem gramSchmidtNormed_unit_length {f : \u03b9 \u2192 E} (n : \u03b9) (h\u2080 : LinearIndependent \ud835\udd5c f) :\n    \u2016gramSchmidtNormed \ud835\udd5c f n\u2016 = 1 :="}
{"input": "Statement in natural language:\nFor an isometry function 'h' from set \u03b1 to set \u03b2, and for any set 's' in \u03b2, the extended metric diameter of the preimage of 's' under 'h' is equal to the extended metric diameter of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem ediam_preimage (h : \u03b1 \u2243\u1d62 \u03b2) (s : Set \u03b2) : EMetric.diam (h \u207b\u00b9' s) = EMetric.diam s :="}
{"input": "Statement in natural language:\nFor a bijective function 'f', the inverse of 'f' (obtained through 'bijInv') is a right inverse of 'f'. This means that if you apply 'f' to an element and then apply the inverse, you get the original element back.\nTranslate the statement in natural language to Lean:", "output": "theorem rightInverse_bijInv (f_bij : Bijective f) : RightInverse (bijInv f_bij) f :="}
{"input": "Statement in natural language:\nThe product map of functions f and g is equal to the product of the composition of function f with the first element of the ordered pair (R, S) and the composition of function g with the second element of the ordered pair (R, S).\nTranslate the statement in natural language to Lean:", "output": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :="}
{"input": "Statement in natural language:\nSet 's' is less than set 't' if and only if set 's' is a proper subset of set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_iff_ssubset : s < t \u2194 s \u2282 t :="}
{"input": "Statement in natural language:\nFor any two filters 'f' and 'g' of types '\u03b1' and '\u03b2' respectively, the product of 'f' and 'g' is equal to the sequence of 'g' mapped by the product constructor 'Prod.mk' on 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_eq {f : Filter \u03b1} {g : Filter \u03b2} : f \u00d7\u02e2 g = (f.map Prod.mk).seq g :="}
{"input": "Statement in natural language:\nFor any three types Y\u2081, Y\u2082, and Y\u2083, and any two functions g from Y\u2082 to Y\u2083 and f from Y\u2081 to Y\u2082, the composition of the map of g and the map of f is equal to the map of the composition of g and f.\nTranslate the statement in natural language to Lean:", "output": "theorem map_comp {Y\u2081 Y\u2082 Y\u2083 : Type _} (g : Y\u2082 \u2192 Y\u2083) (f : Y\u2081 \u2192 Y\u2082) :\n    @map X _ _ _ g \u2218 map f = map (g \u2218 f) :="}
{"input": "Statement in natural language:\nFor a given pseudometric space 'm' over a set '\u03b1' with a uniform space 'U', if the uniformity of 'U' is equal to the uniformity of the pseudometric space converted to a uniform space, then replacing the uniformity of 'm' with 'H' (where 'H' is the condition that the uniformities are equal) results in the original pseudometric space 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem PseudoMetricSpace.replaceUniformity_eq {\u03b1} [U : UniformSpace \u03b1] (m : PseudoMetricSpace \u03b1)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m :="}
{"input": "Statement in natural language:\nFor any property 'C' of an element 'x' in the ring of polynomials adjoined by a root 'f', if the property 'C' holds for all polynomials 'p' in the ring 'R[X]', then the property 'C' also holds for the element 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem induction_on {C : AdjoinRoot f \u2192 Prop} (x : AdjoinRoot f) (ih : \u2200 p : R[X], C (mk f p)) :\n    C x :="}
{"input": "Statement in natural language:\nFor any two linear maps \u03c6 and \u03c8 from the direct sum of a family of modules M indexed by i to a module N over a ring R, if for every index i and element x in M, the value of \u03c6 applied to the singleton of i and x equals the value of \u03c8 applied to the same singleton, then \u03c6 and \u03c8 are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem lhom_ext \u2983\u03c6 \u03c8 : (\u03a0\u2080 i, M i) \u2192\u2097[R] N\u2984 (h : \u2200 i x, \u03c6 (single i x) = \u03c8 (single i x)) : \u03c6 = \u03c8 :="}
{"input": "Statement in natural language:\nIf a function 'f' has a strict Frechet derivative at a point 'a', then the local inverse of 'f' at 'a' also has a strict Frechet derivative at the point 'f(a)', with the derivative being the inverse of the derivative of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem to_localInverse (hf : HasStrictFDerivAt f (f' : E \u2192L[\ud835\udd5c] F) a) :\n    HasStrictFDerivAt (hf.localInverse f f' a) (f'.symm : F \u2192L[\ud835\udd5c] E) (f a) :="}
{"input": "Statement in natural language:\nIf the function pair (f, g) is anti-variant on a set s, then the function pair (g, f) is also anti-variant on the same set s.\nTranslate the statement in natural language to Lean:", "output": "theorem AntivaryOn.symm (h : AntivaryOn f g s) : AntivaryOn g f s :="}
{"input": "Statement in natural language:\nA completion of a set \u03b1 is nonempty if and only if the set \u03b1 itself is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem nonempty_completion_iff : Nonempty (Completion \u03b1) \u2194 Nonempty \u03b1 :="}
{"input": "Statement in natural language:\nFor a given filter 'l' and three functions 'f', 'g', and 'h' that map from '\u03b1' to '\u03b2', if 'f' is eventually equal to 'g' at 'l' and 'g' is eventually equal to 'h' at 'l', then 'f' is eventually equal to 'h' at 'l'. This is a transitivity property for eventual equality.\nTranslate the statement in natural language to Lean:", "output": "theorem EventuallyEq.trans {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2} (H\u2081 : f =\u1da0[l] g) (H\u2082 : g =\u1da0[l] h) :\n    f =\u1da0[l] h :="}
{"input": "Statement in natural language:\nFor a given order-isomorphism 'f' between two relations 'r' and 's', the function obtained by converting 'f' to a relation-embedding and then treating it as a function from '\u03b1' to '\u03b2' is the same as the original order-isomorphism 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_toRelEmbedding (f : r \u2243r s) : (f.toRelEmbedding : \u03b1 \u2192 \u03b2) = f :="}
{"input": "Statement in natural language:\nIf the inner product of vectors x and y equals zero, then the angle between vector x and the vector resulting from subtracting y from x is equal to the inverse cosine of the ratio of the norm of x to the norm of the vector resulting from subtracting y from x.\nTranslate the statement in natural language to Lean:", "output": "theorem angle_sub_eq_arccos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x - y) = Real.arccos (\u2016x\u2016 / \u2016x - y\u2016) :="}
{"input": "Statement in natural language:\nFor any submonoid 's' of 'M' and any submonoid 't' of 'N', the set of the product of 's' and 't' is equal to the Cartesian product of the set of 's' and the set of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_prod (s : Submonoid M) (t : Submonoid N) :\n    (s.prod t : Set (M \u00d7 N)) = (s : Set M) \u00d7\u02e2 (t : Set N) :="}
{"input": "Statement in natural language:\nIf there is a left inverse function 'f'' on function 'f' over set 's', and set 's\u2081' is a subset of 's', then 'f'' is also a left inverse function on 'f' over set 's\u2081'. This is a property of function monotonicity.\nTranslate the statement in natural language to Lean:", "output": "theorem LeftInvOn.mono (hf : LeftInvOn f' f s) (ht : s\u2081 \u2286 s) : LeftInvOn f' f s\u2081 :="}
{"input": "Statement in natural language:\nIf a set 's' is null measurable with respect to a measure '\u03bc', then the fundamental interior of the set 's' with respect to a group 'G' is also null measurable with respect to the same measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem NullMeasurableSet.fundamentalInterior (hs : NullMeasurableSet s \u03bc) :\n    NullMeasurableSet (fundamentalInterior G s) \u03bc :="}
{"input": "Statement in natural language:\nFor a given function 'f' from the direct sum over 'i' of '\u03b2 i', the function '\u03c8' applied to 'f' is equal to the function 'toAddMonoid' applied to the composition of '\u03c8' and 'of \u03b2 i' for each 'i', and then applied to 'f'. This uniqueness property holds in the context of additive monoids.\nTranslate the statement in natural language to Lean:", "output": "theorem toAddMonoid.unique (f : \u2a01 i, \u03b2 i) : \u03c8 f = toAddMonoid (fun i => \u03c8.comp (of \u03b2 i)) f :="}
{"input": "Statement in natural language:\nThe constant coefficient of the Witt subtraction function at a given natural number 'n' is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem constantCoeff_wittSub (n : \u2115) : constantCoeff (wittSub p n) = 0 :="}
{"input": "Statement in natural language:\nFor any three multisets s, t, and u, the sum of s and t is less than or equal to the sum of s and u if and only if t is less than or equal to u.\nTranslate the statement in natural language to Lean:", "output": "theorem add_le_add_iff_left' {s t u : Multiset \u03b1} : s + t \u2264 s + u \u2194 t \u2264 u :="}
{"input": "Statement in natural language:\nFor a convex set 's' in a topological vector space 'E', if 'x' is in the closure of 's' and 'y' is in the interior of 's', then for any non-negative scalar 'a' and positive scalar 'b' such that 'a + b = 1', the convex combination 'a \u2022 x + b \u2022 y' is in the interior of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b)\n    (hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s :="}
{"input": "Statement in natural language:\nIf we have two functions 'f' mapping from \u03b1 to \u03b2 and 'g' mapping from \u03b3 to \u03b1, and if 'f' is continuous at the greatest lower bound of the range of 'g' and 'f' is an antitone function (a function that preserves the order in the opposite direction), and the range of 'g' has a lower bound, then the value of 'f' at the greatest lower bound of the range of 'g' is equal to the least upper bound of the range of 'f' composed with 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem Antitone.map_ciInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (Cf : ContinuousAt f (\u2a05 i, g i))\n    (Af : Antitone f) (H : BddBelow (range g)) : f (\u2a05 i, g i) = \u2a06 i, f (g i) :="}
{"input": "Statement in natural language:\nFor a complex-valued function 'f', a complex number 'c', and real numbers 'R' and 'C' where 'R' is positive, if the function 'f' is continuous on the sphere with center 'c' and radius 'R', and the norm of 'f' at any point 'z' on the sphere is less than or equal to 'C', and there exists a point 'z' on the sphere where the norm of 'f' is less than 'C', then the norm of the contour integral of 'f' over the circle with center 'c' and radius 'R' is less than 2 times pi times 'R' times 'C'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_integral_lt_of_norm_le_const_of_lt {f : \u2102 \u2192 E} {c : \u2102} {R C : \u211d} (hR : 0 < R)\n    (hc : ContinuousOn f (sphere c R)) (hf : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C)\n    (hlt : \u2203 z \u2208 sphere c R, \u2016f z\u2016 < C) : \u2016\u222e z in C(c, R), f z\u2016 < 2 * \u03c0 * R * C :="}
{"input": "Statement in natural language:\nIn the context of an antisymmetric relation (\u00b7 \u2286 \u00b7) on a set \u03b1, if a is a subset of b and a is not equal to b, then a is a proper subset of b.\nTranslate the statement in natural language to Lean:", "output": "theorem ssubset_of_subset_of_ne [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] (h\u2081 : a \u2286 b) (h\u2082 : a \u2260 b) : a \u2282 b :="}
{"input": "Statement in natural language:\nThe intersection over a set S union the intersection over a set T is equal to the intersection of the union of each pair of sets in the Cartesian product of S and T. Here, each pair of sets is a member of the Cartesian product of S and T, and is a pair of sets of elements of type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem sInter_union_sInter {S T : Set (Set \u03b1)} :\n    \u22c2\u2080 S \u222a \u22c2\u2080 T = \u22c2 p \u2208 S \u00d7\u02e2 T, (p : Set \u03b1 \u00d7 Set \u03b1).1 \u222a p.2 :="}
{"input": "Statement in natural language:\nThe coefficient of the zeroth term in a multivariate polynomial (with variables \u03c3 and coefficients in the ring R) that equals one, is one.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_zero_one : coeff 0 (1 : MvPolynomial \u03c3 R) = 1 :="}
{"input": "Statement in natural language:\nFor any given elements 'a' from set \u0393 and 'r' from set R, the singleton of 'a' and 'r' equals zero if and only if 'r' equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem single_eq_zero_iff {a : \u0393} {r : R} : single a r = 0 \u2194 r = 0 :="}
{"input": "Statement in natural language:\nFor any two functors G from category C to category D, and F from category D to category E, whiskering on the right with the identity natural transformation on G and functor F is equal to the identity natural transformation on the composition of functors G and F.\nTranslate the statement in natural language to Lean:", "output": "theorem whiskerRight_id' {G : C \u2964 D} (F : D \u2964 E) : whiskerRight (\ud835\udfd9 G) F = \ud835\udfd9 (G.comp F) :="}
{"input": "Statement in natural language:\nFor any complex number z, the absolute value of the ratio of its imaginary part to its absolute value is less than or equal to one.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_im_div_abs_le_one (z : \u2102) : |z.im / Complex.abs z| \u2264 1 :="}
{"input": "Statement in natural language:\nFor any three objects 'a', 'b', and 'c' in a bicategory 'B', any path 'p' from 'a' to 'b', and any two morphisms 'f' and 'g' from 'b' to 'c' with a 2-morphism '\u03b7' from 'f' to 'g', the left whiskering of the map of the preinclusion of 'B' with respect to the pair 'p' and '\u03b7', followed by the homomorphism of the normalization isomorphism of 'p' and 'g', is equal to the homomorphism of the normalization isomorphism of 'p' and 'f', followed by the second map of the preinclusion of 'B' with respect to the homomorphism from the equality to the homomorphism (which is determined by the extension of the discrete category with respect to the congruence of the normalization auxiliary function of 'p' and '\u03b7').\nTranslate the statement in natural language to Lean:", "output": "theorem normalize_naturality {a b c : B} (p : Path a b) {f g : Hom b c} (\u03b7 : f \u27f6 g) :\n    (preinclusion B).map \u27e8p\u27e9 \u25c1 \u03b7 \u226b (normalizeIso p g).hom =\n      (normalizeIso p f).hom \u226b\n        (preinclusion B).map\u2082 (eqToHom (Discrete.ext _ _ (normalizeAux_congr p \u03b7))) :="}
{"input": "Statement in natural language:\nIf 'a' is less than 'b', then 'b' is the greatest element in the interval that is open on 'a' and closed on 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem isGreatest_Ioc (h : a < b) : IsGreatest (Ioc a b) b :="}
{"input": "Statement in natural language:\nFor any nonempty set n, the determinant of a zero matrix of size n by n with elements from set R is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :="}
{"input": "Statement in natural language:\nA module M over a ring R is Artinian if and only if the relation \"less than\" on the set of submodules of M is well-founded.\nTranslate the statement in natural language to Lean:", "output": "theorem isArtinian_iff_wellFounded :\n    IsArtinian R M \u2194 WellFounded ((\u00b7 < \u00b7) : Submodule R M \u2192 Submodule R M \u2192 Prop) :="}
{"input": "Statement in natural language:\nFor a unit 'a' in ring 'R', 'a' is a multiplication-regular element in the monoid 'M'.\nTranslate the statement in natural language to Lean:", "output": "theorem Units.isSMulRegular (a : R\u02e3) : IsSMulRegular M (a : R) :="}
{"input": "Statement in natural language:\nFor any finite type \u03b9, any ordered ring R, and any module M\u1d62 over R for each i, and any quadratic form Q on each M\u1d62, the function pi applied to Q is nonnegative for all x if and only if Q is nonnegative for all i and x.\nTranslate the statement in natural language to Lean:", "output": "theorem nonneg_pi_iff [Fintype \u03b9] {R} [OrderedRing R] [\u2200 i, Module R (M\u1d62 i)]\n    {Q : \u2200 i, QuadraticForm R (M\u1d62 i)} : (\u2200 x, 0 \u2264 pi Q x) \u2194 \u2200 i x, 0 \u2264 Q i x :="}
{"input": "Statement in natural language:\nFor a homeomorphism 'h' from a topological space '\u03b1' to another topological space '\u03b2', and a set 's' in '\u03b2', the preimage of the interior of 's' under 'h' is equal to the interior of the preimage of 's' under 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_interior (h : \u03b1 \u2243\u209c \u03b2) (s : Set \u03b2) : h \u207b\u00b9' interior s = interior (h \u207b\u00b9' s) :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' from type '\u03b1' to type '\u03b2', if 'f' is equal to 'g', and for any element 'a' of type '\u03b1', the congruence of 'h' (which is the equality of 'f' and 'g') and the reflexivity of 'a' is equal to the congruence function of 'h' and 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem congr_refl_right {f g : \u03b1 \u2192 \u03b2} (h : f = g) (a : \u03b1) :\n    congr h (Eq.refl a) = congr_fun h a :="}
{"input": "Statement in natural language:\nGiven a field \ud835\udd5c with characteristic zero, a ring R, an additive commutative group M, and the algebraic, module, and scalar tower structures between them, along with the topological structures on R and M and the continuity of scalar multiplication, if we have an element x of the twisted square zero extension of R by M such that the scalar multiplication of the opposite of the first component of x and the second component of x equals the scalar multiplication of the first component of x and the second component of x, and if the sum of the exponential series of the first component of x converges to e, then the sum of the exponential series of x converges to the sum of e and the scalar multiplication of e and the second component of x.\nTranslate the statement in natural language to Lean:", "output": "theorem hasSum_expSeries_of_smul_comm [Field \ud835\udd5c] [CharZero \ud835\udd5c] [Ring R] [AddCommGroup M] [Algebra \ud835\udd5c R]\n    [Module R M] [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M] [Module \ud835\udd5c M] [IsScalarTower \ud835\udd5c R M]\n    [IsScalarTower \ud835\udd5c R\u1d50\u1d52\u1d56 M] [TopologicalRing R] [TopologicalAddGroup M] [ContinuousSMul R M]\n    [ContinuousSMul R\u1d50\u1d52\u1d56 M] (x : tsze R M) (hx : MulOpposite.op x.fst \u2022 x.snd = x.fst \u2022 x.snd)\n    {e : R} (h : HasSum (fun n => expSeries \ud835\udd5c R n fun _ => x.fst) e) :\n    HasSum (fun n => expSeries \ud835\udd5c (tsze R M) n fun _ => x) (inl e + inr (e \u2022 x.snd)) :="}
{"input": "Statement in natural language:\n'f' is less than or equal to 'g' if and only if for all 'i' in the support of 'f', the value of 'f' at 'i' is less than or equal to the value of 'g' at 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_iff : f \u2264 g \u2194 \u2200 i \u2208 f.support, f i \u2264 g i :="}
{"input": "Statement in natural language:\nFor any three types X, Y, and Z, the composition of a morphism from X to Y and a morphism from Y to Z is equal to the function composition of the second morphism after the first.\nTranslate the statement in natural language to Lean:", "output": "theorem types_comp {X Y Z : Type u} (f : X \u27f6 Y) (g : Y \u27f6 Z) : f \u226b g = g \u2218 f :="}
{"input": "Statement in natural language:\nFor any element 'x' of a subset 'S' and any natural number 'n', the coercion of 'x' to the power of 'n' into a superset 'A' is equal to the coercion of 'x' into 'A' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_pow (x : S) (n : \u2115) : (\u2191(x ^ n) : A) = (x : A) ^ n :="}
{"input": "Statement in natural language:\nIf a matrix A is Hermitian, then any submatrix of A, obtained by a function f from m to n, is also Hermitian.\nTranslate the statement in natural language to Lean:", "output": "theorem IsHermitian.submatrix {A : Matrix n n \u03b1} (h : A.IsHermitian) (f : m \u2192 n) :\n    (A.submatrix f f).IsHermitian :="}
{"input": "Statement in natural language:\nFor a given point 'x' in set 'X', the set of indices 'i' for which the function 'f' applied to 'i' and 'x' is not equal to zero, is finite.\nTranslate the statement in natural language to Lean:", "output": "theorem point_finite (x : X) : { i | f i x \u2260 0 }.Finite :="}
{"input": "Statement in natural language:\nFor a given natural number 'p', a function 'f' from '\u03c3' to multivariate polynomials over '\u03c4' and 'R', and a multivariate polynomial '\u03c6' over '\u03c3' and 'R', expanding 'p' times the result of binding 'f' to '\u03c6' is equal to binding the function that maps 'i' to the result of expanding 'p' times 'f(i)' to '\u03c6'.\nTranslate the statement in natural language to Lean:", "output": "theorem expand_bind\u2081 (p : \u2115) (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (\u03c6 : MvPolynomial \u03c3 R) :\n    expand p (bind\u2081 f \u03c6) = bind\u2081 (fun i \u21a6 expand p (f i)) \u03c6 :="}
{"input": "Statement in natural language:\nIf the set of elements 'a' that satisfy the property 'p' is closed, then the function that maps each subtype 'p' to an element in '\u03b1' is a closed embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem closedEmbedding_subtype_val (h : IsClosed { a | p a }) :\n    ClosedEmbedding ((\u2191) : Subtype p \u2192 \u03b1) :="}
{"input": "Statement in natural language:\nFor any function 'f' that takes a pair of elements from sets '\u03b1' and '\u03b2' and maps to a set '\u03b3', and for any elements 'x' from '\u03b1' and 'y' from '\u03b2', applying the curried version of 'f' to 'x' and 'y' is the same as applying 'f' to the pair '(x, y)'.\nTranslate the statement in natural language to Lean:", "output": "theorem curry_apply {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (x : \u03b1) (y : \u03b2) : curry f x y = f (x, y) :="}
{"input": "Statement in natural language:\nIf a function 'f' is strictly decreasing (StrictAnti f) and 'a' is the minimum value of the function (IsMin (f a)), then 'a' is the maximum value of the input (IsMax a).\nTranslate the statement in natural language to Lean:", "output": "theorem StrictAnti.isMax_of_apply (hf : StrictAnti f) (ha : IsMin (f a)) : IsMax a :="}
{"input": "Statement in natural language:\nFor any two objects A and B in a category C that has binary coproducts, given a binary cofan c and assuming that c is a colimit, the morphism 'inr' of the cofan c is a monomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem binaryCofan_inr {A B : C} [MonoCoprod C] (c : BinaryCofan A B) (hc : IsColimit c) :\n    Mono c.inr :="}
{"input": "Statement in natural language:\nThe sum of the product of a constant and a sequence (for each term in the sequence) is equal to the product of the constant and the sum of the sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_mul_left : (\u2211' i, a * f i) = a * \u2211' i, f i :="}
{"input": "Statement in natural language:\nFor any three objects X, Y, Z and their isomorphic counterparts X\u2081, Y\u2081, Z\u2081 in a category C, and for any morphisms f from X to Y and g from Y to Z, the composition of the morphisms f and g, when congruent with the isomorphisms \u03b1 and \u03b3, is equal to the composition of the morphisms f congruent with the isomorphisms \u03b1 and \u03b2, and g congruent with the isomorphisms \u03b2 and \u03b3.\nTranslate the statement in natural language to Lean:", "output": "theorem homCongr_comp {X Y Z X\u2081 Y\u2081 Z\u2081 : C} (\u03b1 : X \u2245 X\u2081) (\u03b2 : Y \u2245 Y\u2081) (\u03b3 : Z \u2245 Z\u2081) (f : X \u27f6 Y)\n    (g : Y \u27f6 Z) : \u03b1.homCongr \u03b3 (f \u226b g) = \u03b1.homCongr \u03b2 f \u226b \u03b2.homCongr \u03b3 g :="}
{"input": "Statement in natural language:\n\"X\" is not a unit in the ring of polynomials over \"R\".\nTranslate the statement in natural language to Lean:", "output": "theorem not_isUnit_X : \u00acIsUnit (X : R[X]) :="}
{"input": "Statement in natural language:\nA point 'a' is in the interior of a set 's' if and only if the set 's' is in the neighborhood of the point 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_interior_iff_mem_nhds {s : Set \u03b1} {a : \u03b1} : a \u2208 interior s \u2194 s \u2208 \ud835\udcdd a :="}
{"input": "Statement in natural language:\nFor any multiset 't' and any two functions 'f\u2081' and 'f\u2082' from '\u03b9' to the set of '\u03b1', if for every element 'i' in 't', the image of 'i' under 'f\u2081' is a subset of the image of 'i' under 'f\u2082', then the product of the multiset 't' mapped by 'f\u2081' is a subset of the product of the multiset 't' mapped by 'f\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem multiset_prod_subset_multiset_prod (t : Multiset \u03b9) (f\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1)\n    (hf : \u2200 i \u2208 t, f\u2081 i \u2286 f\u2082 i) : (t.map f\u2081).prod \u2286 (t.map f\u2082).prod :="}
{"input": "Statement in natural language:\nIf 'f' is an open map, then for any set 's' in the neighborhood of 'x', the image of 's' under 'f' is in the neighborhood of 'f(x)'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_mem_nhds (hf : IsOpenMap f) {x : \u03b1} {s : Set \u03b1} (hx : s \u2208 \ud835\udcdd x) : f '' s \u2208 \ud835\udcdd (f x) :="}
{"input": "Statement in natural language:\nThe product of a nonempty interval of any type \u03b1, when set to 1, equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem toProd_one : (1 : NonemptyInterval \u03b1).toProd = 1 :="}
{"input": "Statement in natural language:\nIf we have a multiset 's' of functions from '\u03b1' to 'M', and every function in 's' is strongly measurable, then the function that maps 'x' to the product of the multiset 's' mapped with the function 'f' from '\u03b1' to 'M' at 'x', is also strongly measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (\u03b1 \u2192 M))\n    (hs : \u2200 f \u2208 s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod :="}
{"input": "Statement in natural language:\nA set 's' is nonempty if and only if there exists an element 'x' that belongs to the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem nonempty_def : s.Nonempty \u2194 \u2203 x, x \u2208 s :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to 'F' and a constant 'c' from the field '\ud835\udd5c', if 'q' is greater than 0, then the seminorm of 'c' times 'f' with respect to 'q' and measure '\u03bc' is equal to the absolute value of 'c' times the seminorm of 'f' with respect to 'q' and measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem snorm'_const_smul {f : \u03b1 \u2192 F} (c : \ud835\udd5c) (hq_pos : 0 < q) :\n    snorm' (c \u2022 f) q \u03bc = \u2016c\u2016\u208a \u2022 snorm' f q \u03bc :="}
{"input": "Statement in natural language:\nFor a submultiplicative action 'p' of a ring 'R' on a module 'M', and a set 's' of elements from 'M' such that 's' is equal to the underlying set of 'p', the copy of 'p' with set 's' and proof 'hs' is equal to 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem copy_eq (p : SubMulAction R M) (s : Set M) (hs : s = \u2191p) : p.copy s hs = p :="}
{"input": "Statement in natural language:\nThe set of all points x, for which the property p holds eventually in the neighborhood of x, is an open set.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpen_setOf_eventually_nhds {p : \u03b1 \u2192 Prop} : IsOpen { x | \u2200\u1da0 y in \ud835\udcdd x, p y } :="}
{"input": "Statement in natural language:\nFor any type '\u03b1' that is empty, and for any binary relation 'r' on '\u03b1', 'r' is well-founded.\nTranslate the statement in natural language to Lean:", "output": "theorem wellFounded_of_isEmpty {\u03b1} [IsEmpty \u03b1] (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : WellFounded r :="}
{"input": "Statement in natural language:\nFor any two types \ud835\udc9c and \u212c, given that they are both categories and preadditive, and given a functor F from \ud835\udc9c to \u212c that is additive, and objects A, B, C in \ud835\udc9c, and morphisms f from A to B and g from B to C that form a split sequence, then the sequence formed by the images of f and g under the functor F is also a split sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem Split.map {\ud835\udc9c \u212c : Type _} [Category \ud835\udc9c] [Preadditive \ud835\udc9c] [Category \u212c] [Preadditive \u212c]\n    (F : \ud835\udc9c \u2964 \u212c) [Functor.Additive F] {A B C : \ud835\udc9c} {f : A \u27f6 B} {g : B \u27f6 C} (h : Split f g) :\n    Split (F.map f) (F.map g) :="}
{"input": "Statement in natural language:\nThe cotangent of I is a singleton if and only if I is an idempotent element.\nTranslate the statement in natural language to Lean:", "output": "theorem cotangent_subsingleton_iff : Subsingleton I.Cotangent \u2194 IsIdempotentElem I :="}
{"input": "Statement in natural language:\nFor a list of permutations, if every permutation in the list is a swap, then the sign of the product of the list is equal to negative one raised to the power of the length of the list.\nTranslate the statement in natural language to Lean:", "output": "theorem sign_prod_list_swap {l : List (Perm \u03b1)} (hl : \u2200 g \u2208 l, IsSwap g) :\n    sign l.prod = (-1) ^ l.length :="}
{"input": "Statement in natural language:\nFor any given element 'a' of type '\u03b1', the cardinality (or size) of the set of elements less than 'a' is equal to the cardinality of the set of elements less than or equal to 'a' minus one.\nTranslate the statement in natural language to Lean:", "output": "theorem card_Iio_eq_card_Iic_sub_one (a : \u03b1) : (Iio a).card = (Iic a).card - 1 :="}
{"input": "Statement in natural language:\nFor a nontrivial field B, given a polynomial p over A, if p is irreducible, the algebraic evaluation of p at x equals zero, and p is monic, then p is equal to the minimal polynomial of x over A.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_irreducible_of_monic [Nontrivial B] {p : A[X]} (hp1 : Irreducible p)\n    (hp2 : Polynomial.aeval x p = 0) (hp3 : p.Monic) : p = minpoly A x :="}
{"input": "Statement in natural language:\nFor a bilinear map 'f' from 'M\u2097' to 'N\u2097' to 'P\u2097', and two linear maps 'g' from 'Q\u2097' to 'M\u2097' and 'g'' from 'Q\u2097'' to 'N\u2097', for any elements 'x' in 'Q\u2097' and 'y' in 'Q\u2097'', the application of the composition of 'f' with 'g' and 'g'' to 'x' and 'y' is equal to the application of 'f' to the images of 'x' and 'y' under 'g' and 'g'' respectively.\nTranslate the statement in natural language to Lean:", "output": "theorem compl\u2081\u2082_apply (f : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) (g : Q\u2097 \u2192\u2097[R] M\u2097) (g' : Q\u2097' \u2192\u2097[R] N\u2097) (x : Q\u2097)\n    (y : Q\u2097') : f.compl\u2081\u2082 g g' x y = f (g x) (g' y) :="}
{"input": "Statement in natural language:\nFor any two real numbers 'a' and 'b' where 'a' is less than 'b', the cardinality of the open interval between 'a' and 'b' is equal to the cardinality of the continuum.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_Ioo_real {a b : \u211d} (h : a < b) : (#Ioo a b) = \ud835\udd20 :="}
{"input": "Statement in natural language:\nIf I and J are ideals of a ring A and they are coprime (their supremum is the whole ring), then their infimum is equal to their product.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_eq_mul_of_coprime {I J : Ideal A} (coprime : I \u2294 J = \u22a4) : I \u2293 J = I * J :="}
{"input": "Statement in natural language:\nIf for every index 'i', 'f i' is an upper set, then the union over all 'i' of 'f i' is also an upper set.\nTranslate the statement in natural language to Lean:", "output": "theorem isUpperSet_iUnion {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i, IsUpperSet (f i)) : IsUpperSet (\u22c3 i, f i) :="}
{"input": "Statement in natural language:\nFor any positive compact subset 'K' of a group 'G' and any set 'V' in 'G' such that the interior of 'V' is nonempty, the index of 'K' in 'V' is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem index_pos (K : PositiveCompacts G) {V : Set G} (hV : (interior V).Nonempty) :\n    0 < index (K : Set G) V :="}
{"input": "Statement in natural language:\nFor a nonzero element 'x' from a normed vector space 'E' and any scalar 'c' from the field '\ud835\udd5c', the coordinate of the scaled vector 'c' times 'x' in the direction of 'x' is equal to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem coord_toSpanNonzeroSingleton {x : E} (h : x \u2260 0) (c : \ud835\udd5c) :\n    coord \ud835\udd5c x h (toSpanNonzeroSingleton \ud835\udd5c x h c) = c :="}
{"input": "Statement in natural language:\nThe sum of 'a' and 'b' equals the maximum possible value if and only if either 'a' or 'b' equals the maximum possible value.\nTranslate the statement in natural language to Lean:", "output": "theorem add_eq_top : a + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4 :="}
{"input": "Statement in natural language:\nFor a spectral map 'f' from \u03b2 to \u03b3 and a spectral map 'g' from \u03b1 to \u03b2, the composition of 'f' and 'g' as a continuous map from \u03b1 to \u03b3 is equal to the composition of 'f' as a continuous map from \u03b2 to \u03b3 and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_comp_continuousMap' (f : SpectralMap \u03b2 \u03b3) (g : SpectralMap \u03b1 \u03b2) :\n    (f.comp g : ContinuousMap \u03b1 \u03b3) = (f : ContinuousMap \u03b2 \u03b3).comp g :="}
{"input": "Statement in natural language:\nFor a given algebra homomorphism 'f' from algebra 'A' to algebra 'B', there exists a Galois connection between the map of 'f' and the comap of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem gc_map_comap (f : A \u2192\u2090[R] B) : GaloisConnection (map f) (comap f) :="}
{"input": "Statement in natural language:\nThe right value of 'x' being 'none' is equivalent to 'x' being a left value.\nTranslate the statement in natural language to Lean:", "output": "theorem getRight_eq_none_iff : x.getRight = none \u2194 x.isLeft :="}
{"input": "Statement in natural language:\nFor any multivariate polynomial 'p' over a ring 'R' and a variable 's' from a set '\u03c3', the coefficient of the term in 'p' multiplied by the variable 's' (represented by 'X s * p') with a monomial 'm' incremented by one in the 's' dimension (represented by 'Finsupp.single s 1 + m') is equal to the coefficient of the term in 'p' with the monomial 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_X_mul (m) (s : \u03c3) (p : MvPolynomial \u03c3 R) :\n    coeff (Finsupp.single s 1 + m) (X s * p) = coeff m p :="}
{"input": "Statement in natural language:\nFor a function 'g' mapping from 'M' to 'N' such that 'g' of 1 equals 1, and another function 'f' mapping from '\u03b1' to 'M', the multiplicative support of the composition of 'g' and 'f' is a subset of the multiplicative support of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mulSupport_comp_subset {g : M \u2192 N} (hg : g 1 = 1) (f : \u03b1 \u2192 M) :\n    mulSupport (g \u2218 f) \u2286 mulSupport f :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', a constant 'c', and an element 'a' of '\u03b1', lifting the function 'f' over the equivalence class of 'a' (denoted by 'mk a') is equal to the function 'f' applied to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_mk (f : \u03b1 \u2192 \u03b2) (c) (a : \u03b1) : lift f c (mk a) = f a :="}
{"input": "Statement in natural language:\nThe bottom element of the finset (finite set) of any type \u03b1 is equal to the empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem bot_eq_empty : (\u22a5 : Finset \u03b1) = \u2205 :="}
{"input": "Statement in natural language:\nIf an element 'a' belongs to the filtered list 'l' (filtered by some property 'p'), then 'a' also belongs to the original list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_of_mem_filter {a : \u03b1} {l} (h : a \u2208 filter p l) : a \u2208 l :="}
{"input": "Statement in natural language:\nFor any three integers a, b, and c, if they satisfy Fermat's 4-dimensional equation, then c cannot be equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_zero {a b c : \u2124} (h : Fermat42 a b c) : c \u2260 0 :="}
{"input": "Statement in natural language:\nA natural number 'n' equals one if and only if there does not exist a prime number 'p' that divides 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_one_iff_not_exists_prime_dvd {n : \u2115} : n = 1 \u2194 \u2200 p : \u2115, p.Prime \u2192 \u00acp \u2223 n :="}
{"input": "Statement in natural language:\n11 divides a natural number 'n' if and only if 11, as an integer, divides the alternating sum of the digits of 'n' when 'n' is expressed in base 10.\nTranslate the statement in natural language to Lean:", "output": "theorem eleven_dvd_iff :\n    11 \u2223 n \u2194 (11 : \u2124) \u2223 ((digits 10 n).map fun n : \u2115 => (n : \u2124)).alternatingSum :="}
{"input": "Statement in natural language:\nA hyperreal number 'x' is infinitely negative if and only if 'x' is less than any real number 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem infiniteNeg_def {x : \u211d*} : InfiniteNeg x \u2194 \u2200 r : \u211d, x < r :="}
{"input": "Statement in natural language:\nFor a local homeomorphism 'e' from type \u03b1 to \u03b2, given a set 's' of type \u03b2 and an element 'x' from the source of 'e', the mapping of 'e' on the neighborhood within the preimage of 's' at 'x' is equal to the neighborhood within 's' at the image of 'x' under 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_nhdsWithin_preimage_eq (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.source) (s : Set \u03b2) :\n    map e (\ud835\udcdd[e \u207b\u00b9' s] x) = \ud835\udcdd[s] e x :="}
{"input": "Statement in natural language:\nThe denominator of 1, when considered as an element of the set NumDenSameDeg \ud835\udc9c x, is equal to 1 in the algebra A.\nTranslate the statement in natural language to Lean:", "output": "theorem den_one : ((1 : NumDenSameDeg \ud835\udc9c x).den : A) = 1 :="}
{"input": "Statement in natural language:\nFor any types '\u03b2' and '\u03b3', any element 'x' of type '\u03b3', any natural number 'n', and any type vector '\u03b1' of length 'n', the type vector constant function applied to 'x' and the appended type vector of '\u03b1' and '\u03b2' is equal to the function that appends the type vector constant function applied to 'x' and '\u03b1' with the function that maps any element to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem const_append1 {\u03b2 \u03b3} (x : \u03b3) {n} (\u03b1 : TypeVec n) :\n    TypeVec.const x (\u03b1 ::: \u03b2) = appendFun (TypeVec.const x \u03b1) fun _ => x :="}
{"input": "Statement in natural language:\nFor a polynomial 'p' and a real number 'a', the root multiplicity of 'a' in 'p' is equal to the multiplicity of 'X - C a' in 'p'. However, if 'p' equals zero, then the root multiplicity is also zero. This is guaranteed by the condition that the multiplicity of 'X - C a' in 'p' is finite.\nTranslate the statement in natural language to Lean:", "output": "theorem rootMultiplicity_eq_multiplicity (p : R[X]) (a : R) :\n    rootMultiplicity a p =\n      if h0 : p = 0 then 0 else (multiplicity (X - C a) p).get (multiplicity_X_sub_C_finite a h0) :="}
{"input": "Statement in natural language:\nFor any given matrices M and N, where M is a matrix of size m by n and N is a matrix of size n by l, both with elements from a non-unital semiring that is also a star ring, the conjugate transpose of the product of M and N is equal to the product of the conjugate transpose of N and the conjugate transpose of M.\nTranslate the statement in natural language to Lean:", "output": "theorem conjTranspose_mul [Fintype n] [NonUnitalSemiring \u03b1] [StarRing \u03b1] (M : Matrix m n \u03b1)\n    (N : Matrix n l \u03b1) : (M \u2b1d N)\u1d34 = N\u1d34 \u2b1d M\u1d34 :="}
{"input": "Statement in natural language:\nIn the context of a Boolean algebra, if a set 's' is an antichain with respect to the less than or equal to relation, then the complement of 's' is also an antichain with respect to the same relation.\nTranslate the statement in natural language to Lean:", "output": "theorem image_compl [BooleanAlgebra \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (compl '' s) :="}
{"input": "Statement in natural language:\nThe derivative of a monomial with coefficient 'a' and degree 'n' is equal to a monomial with degree 'n - 1' and coefficient 'a * n'.\nTranslate the statement in natural language to Lean:", "output": "theorem derivative_monomial (a : R) (n : \u2115) :\n    derivative (monomial n a) = monomial (n - 1) (a * n) :="}
{"input": "Statement in natural language:\nThe difference of two rational functions 'f' and 'g' over a field 'F', when considered as a Laurent series over 'F', is equal to the difference of 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_sub : ((f - g : RatFunc F) : LaurentSeries F) = f - g :="}
{"input": "Statement in natural language:\nFor any object 'n' in 'M' and any object 'X' in 'C', the composition of the map of 'F.obj n' applied to 'F.\u03b5.app X', the application of 'F.\u03bc (\ud835\udfd9_ M) n' to 'X', and the application of 'F.map (\u03bb_ n).hom' to 'X' is equal to the identity.\nTranslate the statement in natural language to Lean:", "output": "theorem left_unitality_app (n : M) (X : C) :\n    (F.obj n).map (F.\u03b5.app X) \u226b (F.\u03bc (\ud835\udfd9_ M) n).app X \u226b (F.map (\u03bb_ n).hom).app X = \ud835\udfd9 _ :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type '\u03b1' and an option 'o' of type '\u03b1', 'a' is in the finite set derived from 'o' if and only if 'a' is in 'o'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_toFinset {a : \u03b1} {o : Option \u03b1} : a \u2208 o.toFinset \u2194 a \u2208 o :="}
{"input": "Statement in natural language:\nThe sum of a function over a finite set is equal to the supremum of the function over that set if and only if for all distinct elements in the set, the multisets generated by the function on these elements are disjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem finset_sum_eq_sup_iff_disjoint {\u03b2 : Type _} {i : Finset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1} :\n    i.sum f = i.sup f \u2194\n      \u2200 (x) (_ : x \u2208 i) (y) (_ : y \u2208 i), x \u2260 y \u2192 Multiset.Disjoint (f x) (f y) :="}
{"input": "Statement in natural language:\nFor any integer 'n' and any natural numbers 'k' and 'p', if 'p' is a prime number and 'p' divides 'n' raised to the power of 'k', then 'p' also divides 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem Int.Prime.dvd_pow' {n : \u2124} {k p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 n ^ k) :\n    (p : \u2124) \u2223 n :="}
{"input": "Statement in natural language:\nIf the co-domain of a function mapped by another function is not the least element (or bottom element), then the original function's co-domain is also not the least element.\nTranslate the statement in natural language to Lean:", "output": "theorem neBot_of_comap (h : (comap m g).NeBot) : g.NeBot :="}
{"input": "Statement in natural language:\nFor any non-zero element 'a' of 'A', the inverse of the image of 'a' under the function '\u03c3' is equal to the image of the inverse of 'a' under the function '\u03c3'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_inv (a : A\u02e3) : (\u03c3 (a : A))\u207b\u00b9 = \u03c3 (\u2191a\u207b\u00b9 : A) :="}
{"input": "Statement in natural language:\nThe square of the norm of zero in field K is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem normSq_zero : normSq (0 : K) = 0 :="}
{"input": "Statement in natural language:\nIf 't' is a pushout cocone of 'f' and 'g', and 't' is a colimit, then if 'f' is an epimorphism, 't.inr' is also an epimorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] :\n    Epi t.inr :="}
{"input": "Statement in natural language:\nThe product of two numbers is odd if and only if both numbers are odd.\nTranslate the statement in natural language to Lean:", "output": "theorem odd_mul : Odd (m * n) \u2194 Odd m \u2227 Odd n :="}
{"input": "Statement in natural language:\nFor a type \u03b1, which is a commutative group and a linear order, and for which the multiplication operation is covariant with the less than or equal to relation, the fraction a divided by b is less than or equal to the fraction b divided by a if and only if a is less than or equal to b.\nTranslate the statement in natural language to Lean:", "output": "theorem div_le_div_flip {\u03b1 : Type _} [CommGroup \u03b1] [LinearOrder \u03b1]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} : a / b \u2264 b / a \u2194 a \u2264 b :="}
{"input": "Statement in natural language:\nApplying the function 'toOuterMeasure' to a singleton set containing an element 'a' is equal to applying the function 'p' to the element 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem toOuterMeasure_apply_singleton (a : \u03b1) : p.toOuterMeasure {a} = p a :="}
{"input": "Statement in natural language:\nFor a given property 'p' of an element '\u03b1', and a given set 's' of elements 'x' that satisfy the property 'p', if an element 'a' does not satisfy the property 'p', then 'a' is not an element of the set 's' after it has been mapped using the subtype embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem not_mem_map_subtype_of_not_property {p : \u03b1 \u2192 Prop} (s : Finset { x // p x }) {a : \u03b1}\n    (h : \u00acp a) : a \u2209 s.map (Embedding.subtype _) :="}
{"input": "Statement in natural language:\nIf a function f has a strict derivative f' at a point x, and a function g has a strict derivative g' at the same point x, then the function that is the difference of f and g has a strict derivative equal to the difference of f' and g' at the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem HasStrictDerivAt.sub (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x) :\n    HasStrictDerivAt (fun x => f x - g x) (f' - g') x :="}
{"input": "Statement in natural language:\nFor any functor P from the opposite of category C to category D, the plus map of the identity morphism of P is equal to the identity morphism of the plus construction.\nTranslate the statement in natural language to Lean:", "output": "theorem plusMap_id (P : C\u1d52\u1d56 \u2964 D) : J.plusMap (\ud835\udfd9 P) = \ud835\udfd9 _ :="}
{"input": "Statement in natural language:\nThe morphism from the first kernel fork of a binary bicone 'c' is equal to the right inclusion of 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem BinaryBicone.fstKernelFork_\u03b9 : (BinaryBicone.fstKernelFork c).\u03b9 = c.inr :="}
{"input": "Statement in natural language:\nThe closure of the set of all elements x in K such that the valuation of x is less than \u03b3 (where \u03b3 is a nonzero element of \u0393\u2080), when these elements are mapped to the completion of K, is equal to the set of all elements x in the completion of K such that the extension of the valuation to the completion of K applied to x is less than \u03b3.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_coe_completion_v_lt {\u03b3 : \u0393\u2080\u02e3} :\n    closure ((\u2191) '' { x : K | v x < (\u03b3 : \u0393\u2080) }) =\n    { x : hat K | extensionValuation x < (\u03b3 : \u0393\u2080) } :="}
{"input": "Statement in natural language:\nFor any real number 'r' and any positive integer 'k', the Hasse derivative of the constant polynomial 'r' at 'k' is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem hasseDeriv_C (r : R) (hk : 0 < k) : hasseDeriv k (C r) = 0 :="}
{"input": "Statement in natural language:\nFor a given set 's' of vectors in a vector space 'V' over a field 'K', if 's' is finite, then the dimension of the span of 's' (i.e., the smallest subspace containing all vectors in 's') is less than or equal to the number of elements in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem finrank_span_le_card (s : Set V) [Fintype s] : finrank K (span K s) \u2264 s.toFinset.card :="}
{"input": "Statement in natural language:\nThe function that maps prime numbers to positive natural numbers is injective. This means that different prime numbers will always map to different positive natural numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_pnat_injective : Function.Injective ((\u2191) : Nat.Primes \u2192 \u2115+) :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2 that have a zero element, given a function 'f' from \u03b1 to \u03b2 such that 'f' of zero equals zero, and a function 'd' from 'n' to \u03b1, the map of the function 'f' over the diagonal of 'd' equals the diagonal of the function 'm' mapped to 'f' of 'd' of 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem diagonal_map [Zero \u03b1] [Zero \u03b2] {f : \u03b1 \u2192 \u03b2} (h : f 0 = 0) {d : n \u2192 \u03b1} :\n    (diagonal d).map f = diagonal fun m => f (d m) :="}
{"input": "Statement in natural language:\nThe auxiliary function for reparameterizing the transitive association is equal to zero when the input is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0 :="}
{"input": "Statement in natural language:\nGiven a topological space F and a topological add group F, for any type \u03b9, any property p of \u03b9, and any function b from \u03b9 to the set of F, if the neighborhood filter of 0 in F has a basis determined by p and b, then the neighborhood filter of the 0 function in the space of continuous linear maps from E to F also has a basis. This basis is determined by a function that takes a set of E and an element of \u03b9 and returns whether the set is Von Neumann bounded and the property p holds for the element of \u03b9, and a function that takes a set of E and an element of \u03b9 and returns the set of continuous linear maps from E to F such that for every element in the set of E, the image of the element under the map is in the set determined by applying b to the element of \u03b9.\nTranslate the statement in natural language to Lean:", "output": "theorem hasBasis_nhds_zero_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n    {\u03b9 : Type _} {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set F} (h : (\ud835\udcdd 0 : Filter F).HasBasis p b) :\n    (\ud835\udcdd (0 : E \u2192SL[\u03c3] F)).HasBasis (fun Si : Set E \u00d7 \u03b9 => Bornology.IsVonNBounded \ud835\udd5c\u2081 Si.1 \u2227 p Si.2)\n      fun Si => { f : E \u2192SL[\u03c3] F | \u2200 x \u2208 Si.1, f x \u2208 b Si.2 } :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the primorial of 'n' is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem primorial_pos (n : \u2115) : 0 < n# :="}
{"input": "Statement in natural language:\nFor any Witt vector 'x' over a ring 'R' and any natural number 'n', the coefficient of 'n' in the negation of 'x' is equal to the polynomial evaluation of the 'n'th Witt negation polynomial at the coefficients of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_coeff (x : \ud835\udd4e R) (n : \u2115) : (-x).coeff n = peval (wittNeg p n) ![x.coeff] :="}
{"input": "Statement in natural language:\nFor a given type K, if K is a field, and there is an algebra A over K, and A is a fraction ring of K, then A is a Dedekind domain if and only if the following conditions are met: A is a Noetherian ring, the dimension of A is less than or equal to one, and for every element x in K that is integral over A, there exists an element y such that the algebraic mapping of y from A to K equals x.\nTranslate the statement in natural language to Lean:", "output": "theorem isDedekindDomain_iff (K : Type _) [Field K] [Algebra A K] [IsFractionRing A K] :\n    IsDedekindDomain A \u2194\n      IsNoetherianRing A \u2227\n        DimensionLEOne A \u2227 \u2200 {x : K}, IsIntegral A x \u2192 \u2203 y, algebraMap A K y = x :="}
{"input": "Statement in natural language:\nFor any ordered ring \u03b1 that is nontrivial, the function that casts an integer x to \u03b1 is strictly monotonically increasing.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_strictMono [OrderedRing \u03b1] [Nontrivial \u03b1] : StrictMono (fun x : \u2124 => (x : \u03b1)) :="}
{"input": "Statement in natural language:\nIf 'a' is a maximum, then 'a' is a predecessor limit.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.IsMax.isPredLimit : IsMax a \u2192 IsPredLimit a :="}
{"input": "Statement in natural language:\nFor a given partial equivalence 'f' between 'm' and 'n', and for any 'i' and 'j', the application of 'f' to the matrix at position 'i', 'j' is equal to 1 if 'j' is in the image of 'f' at 'i', otherwise it is 0. This is under the conditions that 'n' is decidable equal, and '\u03b1' is a type with defined zero and one.\nTranslate the statement in natural language to Lean:", "output": "theorem toMatrix_apply [DecidableEq n] [Zero \u03b1] [One \u03b1] (f : m \u2243. n) (i j) :\n    toMatrix f i j = if j \u2208 f i then (1 : \u03b1) else 0 :="}
{"input": "Statement in natural language:\nFor a function 'g' mapping from '\u03b2' to 'F', if 'f' is a measurable embedding, then the p-seminorm of 'g' with respect to the measure obtained by mapping 'f' over '\u03bc' is equal to the p-seminorm of the composition of 'g' and 'f' with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.MeasurableEmbedding.snorm_map_measure {g : \u03b2 \u2192 F} (hf : MeasurableEmbedding f) :\n    snorm g p (Measure.map f \u03bc) = snorm (g \u2218 f) p \u03bc :="}
{"input": "Statement in natural language:\nIf 'f' is a function from \u03b2 to \u03b1 in a topological space \u03b2, and 'f' is inducing, then for any set 's' in \u03b1 that is separable, the preimage of 's' under 'f' is also separable.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Inducing.isSeparable_preimage {f : \u03b2 \u2192 \u03b1} [TopologicalSpace \u03b2]\n    (hf : Inducing f) {s : Set \u03b1} (hs : IsSeparable s) : IsSeparable (f \u207b\u00b9' s) :="}
{"input": "Statement in natural language:\nFor a given complex number 'c' with norm greater than 1, and a real number 'R' such that the norm of 'c' is less than 'R', if the field 'E' over the complex numbers is not finite-dimensional, and 's' is a finite set of elements from 'E', then there exists an element 'x' from 'E' such that the norm of 'x' is less than or equal to 'R' and for all elements 'y' in the set 's', the norm of the difference between 'y' and 'x' is greater than or equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_norm_le_le_norm_sub_of_finset {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {R : \u211d} (hR : \u2016c\u2016 < R)\n    (h : \u00acFiniteDimensional \ud835\udd5c E) (s : Finset E) : \u2203 x : E, \u2016x\u2016 \u2264 R \u2227 \u2200 y \u2208 s, 1 \u2264 \u2016y - x\u2016 :="}
{"input": "Statement in natural language:\nFor a function 'f' that maps elements of type \u03b1 to type \u03b2, and a list 'xs' of type \u03b1, the list obtained by first applying the function 'f' to each element of 'xs' and then converting the result to a list is the same as the list obtained by first converting 'xs' to a list and then applying the function 'f' to each element of the list.\nTranslate the statement in natural language to Lean:", "output": "theorem toList_map (f : \u03b1 \u2192 \u03b2) (xs : t \u03b1) : toList (f <$> xs) = f <$> toList xs :="}
{"input": "Statement in natural language:\nIf y is less than x, the difference between x and y is divisible by 2, and x is not divisible by 2, then for any natural number n greater than 0 that is even, the 2-adic valuation of the difference between x to the power of n and y to the power of n plus 1 is equal to the sum of the 2-adic valuation of the sum of x and y, the 2-adic valuation of the difference between x and y, and the 2-adic valuation of n.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_two_sub_pow (hyx : y < x) (hxy : 2 \u2223 x - y) (hx : \u00ac2 \u2223 x) {n : \u2115} (hn : 0 < n)\n    (hneven : Even n) :\n    padicValNat 2 (x ^ n - y ^ n) + 1 =\n      padicValNat 2 (x + y) + padicValNat 2 (x - y) + padicValNat 2 n :="}
{"input": "Statement in natural language:\nA filter 'g' is less than or equal to the product of filters 'f' if and only if for all 'i', the function 'eval i' tends towards 'f i' under the filter 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_pi {g : Filter (\u2200 i, \u03b1 i)} : g \u2264 pi f \u2194 \u2200 i, Tendsto (eval i) g (f i) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' in the lexicographical order of the function from '\u03b1' to 'N', and for any 'i' in '\u03b1', if for all 'j' less than 'i', the lexicographical order of 'a' at 'j' is equal to the lexicographical order of 'b' at 'j', and the lexicographical order of 'a' at 'i' is less than the lexicographical order of 'b' at 'i', then 'a' is less than 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_of_forall_lt_of_lt (a b : Lex (\u03b1 \u2192\u2080 N)) (i : \u03b1) :\n    (\u2200 j < i, ofLex a j = ofLex b j) \u2192 ofLex a i < ofLex b i \u2192 a < b :="}
{"input": "Statement in natural language:\nFor an algebraic equivalence 'e' between two algebraic structures 'A\u2081' and 'A\u2082' over a ring 'R', the inverse of 'e' is a left inverse of 'e'. This means that applying the inverse of 'e' to the result of 'e' will return the original input.\nTranslate the statement in natural language to Lean:", "output": "theorem leftInverse_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : Function.LeftInverse e.symm e :="}
{"input": "Statement in natural language:\nFor a given commutative group with zero '\u03b2', a finite set 's', and a function 'f' from '\u03b1' to '\u03b2', if we create a unit from the product of the function 'f' applied to each element in 's', it is equal to the product of the units created from each element in 's' (where each unit is created from the function 'f' applied to an element in 's'). The function 'h' is used to handle the case where the product of the function 'f' applied to each element in 's' is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem Units.mk0_prod [CommGroupWithZero \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (h) :\n    Units.mk0 (\u220f b in s, f b) h =\n      \u220f b in s.attach, Units.mk0 (f b) fun hh => h (Finset.prod_eq_zero b.2 hh) :="}
{"input": "Statement in natural language:\nThe function 'e' is right order continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem rightOrdContinuous : RightOrdContinuous e :="}
{"input": "Statement in natural language:\nFor a given limit \"t\" in category theory, and for any object \"W\" in category \"C\" with a morphism \"m\" from \"W\" to the point of \"t\", \"m\" is equal to the lift of \"h\" (where \"h\" is a limit of \"t\") with \"W\" as the point and the application of \"m\" followed by the application of the projection of \"t\" as the projection.\nTranslate the statement in natural language to Lean:", "output": "theorem hom_lift (h : IsLimit t) {W : C} (m : W \u27f6 t.pt) :\n    m = h.lift { pt := W, \u03c0 := { app := fun b => m \u226b t.\u03c0.app b } } :="}
{"input": "Statement in natural language:\nIf \ud835\udca2 is a coseparating set in a category C and \u210b is a set in C that contains \ud835\udca2, then \u210b is also a coseparating set in C.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCoseparating.mono {\ud835\udca2 : Set C} (h\ud835\udca2 : IsCoseparating \ud835\udca2) {\u210b : Set C} (h\ud835\udca2\u210b : \ud835\udca2 \u2286 \u210b) :\n    IsCoseparating \u210b :="}
{"input": "Statement in natural language:\nIf we have a function v from real numbers to a vector space E, and a non-negative real number K such that for every real number t, v is Lipschitz continuous with constant K at t. If we have two functions f and g from real numbers to E, and two real numbers a and b such that f is continuous on the closed interval from a to b, and for every t in the open interval from a to b, the derivative of f at t within the closed interval from t to infinity is v(t, f(t)). If g is also continuous on the closed interval from a to b, and for every t in the open interval from a to b, the derivative of g at t within the closed interval from t to infinity is v(t, g(t)), and if f(a) equals g(a), then for every t in the closed interval from a to b, f(t) equals g(t). This theorem is essentially stating the uniqueness of solutions to ordinary differential equations under certain conditions.\nTranslate the statement in natural language to Lean:", "output": "theorem ODE_solution_unique {v : \u211d \u2192 E \u2192 E} {K : \u211d\u22650} (hv : \u2200 t, LipschitzWith K (v t))\n    {f g : \u211d \u2192 E} {a b : \u211d} (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t) (hg : ContinuousOn g (Icc a b))\n    (hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t) (ha : f a = g a) :\n    \u2200 t \u2208 Icc a b, f t = g t :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuously differentiable 'n' times over the real numbers, then the function that applies the hyperbolic sine to 'f' is also continuously differentiable 'n' times over the real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiff.sinh {n} (h : ContDiff \u211d n f) : ContDiff \u211d n fun x => Real.sinh (f x) :="}
{"input": "Statement in natural language:\nFor any two finite sets s and t, the ratio of the number of intersecting edges between s and t to the product of the number of elements in s and t is equal to the edge density between s and t in the graph G.\nTranslate the statement in natural language to Lean:", "output": "theorem card_interedges_div_card (s t : Finset \u03b1) :\n    ((G.interedges s t).card : \u211a) / (s.card * t.card) = G.edgeDensity s t :="}
{"input": "Statement in natural language:\nThe composition of the relational coimage of relation 'r' and the relational coimage of relation 's' is equal to the relational coimage of the composition of relation 'r' and relation 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem rcomap_compose (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) : rcomap r \u2218 rcomap s = rcomap (r.comp s) :="}
{"input": "Statement in natural language:\nThe non-negative distance between points x and y is less than or equal to the sum of the non-negative distance from z to x and the non-negative distance from z to y. This is a version of the triangle inequality for non-negative distances.\nTranslate the statement in natural language to Lean:", "output": "theorem nndist_triangle_left (x y z : \u03b1) : nndist x y \u2264 nndist z x + nndist z y :="}
{"input": "Statement in natural language:\nFor any type \u03b3 that is a monoid, and any function f from M to \u03b3 that is a monoid homomorphism, the range of f is a submonoid.\nTranslate the statement in natural language to Lean:", "output": "theorem Range.isSubmonoid {\u03b3 : Type _} [Monoid \u03b3] {f : M \u2192 \u03b3} (hf : IsMonoidHom f) :\n    IsSubmonoid (Set.range f) :="}
{"input": "Statement in natural language:\nThe product of a constant 'a' and a variable 'X' is equal to a monomial of degree 1 with coefficient 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem C_mul_X_eq_monomial : C a * X = monomial 1 a :="}
{"input": "Statement in natural language:\nFor any natural numbers 'n' and 'k', if 'k' is less than or equal to 'n', then the binomial coefficient of 'n' and 'k' (denoted as \"choose n k\") is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem choose_pos : \u2200 {n k}, k \u2264 n \u2192 0 < choose n k"}
{"input": "Statement in natural language:\n\"a is equivalent to 0 modulo n if and only if n divides a\".\nTranslate the statement in natural language to Lean:", "output": "theorem modEq_zero_iff_dvd : a \u2261 0 [ZMOD n] \u2194 n \u2223 a :="}
{"input": "Statement in natural language:\nIf a function f is antitone (non-increasing) on the interval from x\u2080 to x\u2080 + a, then the sum of the function values at each point in the range a, offset by x\u2080 and incremented by 1, is less than or equal to the integral of the function over the interval from x\u2080 to x\u2080 + a.\nTranslate the statement in natural language to Lean:", "output": "theorem AntitoneOn.sum_le_integral (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u2211 i in Finset.range a, f (x\u2080 + (i + 1 : \u2115))) \u2264 \u222b x in x\u2080..x\u2080 + a, f x :="}
{"input": "Statement in natural language:\nFor any polynomial 'p' and any real number 'r', the evaluation of the product of 'p' and the difference between 'X' and the constant 'r' at 'r' is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eval_mul_X_sub_C {p : R[X]} (r : R) : (p * (X - C r)).eval r = 0 :="}
{"input": "Statement in natural language:\nFor any object 'X' and a function 'f' from 'X' to the object 'F.Obj X', and for any element 'x\u2080' of 'X', the corecursion of 'f' at 'x\u2080' in 'M' is equal to the creation in 'M' of the functor application of the corecursion of 'f' to 'f' at 'x\u2080'.\nTranslate the statement in natural language to Lean:", "output": "theorem corec_def {X} (f : X \u2192 F.Obj X) (x\u2080 : X) : M.corec f x\u2080 = M.mk (M.corec f <$> f x\u2080) :="}
{"input": "Statement in natural language:\nAn element 'a' is in the list 'l' if and only if there exists a number 'n' and a proof 'h' that the 'n'-th element of the list 'l', considering 'h', is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_iff_nthLe {a} {l : List \u03b1} : a \u2208 l \u2194 \u2203 n h, nthLe l n h = a :="}
{"input": "Statement in natural language:\nFor a given group homomorphism 'f' from group 'G' to group 'N' and a subgroup 'H' of 'G', the image of 'H' under 'f' is equal to the range of 'f' if and only if 'H' and the kernel of 'f' are codisjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem map_eq_range_iff {f : G \u2192* N} {H : Subgroup G} : H.map f = f.range \u2194 Codisjoint H f.ker :="}
{"input": "Statement in natural language:\nThe composition of a continuous open map 'f' from '\u03b1' to '\u03b2' with the identity continuous open map on '\u03b1' is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_id (f : \u03b1 \u2192CO \u03b2) : f.comp (ContinuousOpenMap.id \u03b1) = f :="}
{"input": "Statement in natural language:\nFor a given set S of intermediate fields between fields F and E, the set of elements in the greatest lower bound (infimum) of S is equal to the greatest lower bound of the set of elements in each intermediate field in S.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_sInf (S : Set (IntermediateField F E)) : (\u2191(sInf S) : Set E) =\n    sInf ((fun (x : IntermediateField F E) => (x : Set E)) '' S) :="}
{"input": "Statement in natural language:\nIf p is not equal to infinity, then the function that maps a simple function in Lp space to the Lp space itself is a dense embedding.\nTranslate the statement in natural language to Lean:", "output": "theorem denseEmbedding (hp_ne_top : p \u2260 \u221e) :\n    DenseEmbedding ((\u2191) : Lp.simpleFunc E p \u03bc \u2192 Lp E p \u03bc) :="}
{"input": "Statement in natural language:\nFor a given equivalence 'f' between two types '\u03b1' and '\u03b1'', and a function 'l' from '\u03b1' to 'R', the total function of the equivalent domain mapping of 'f' and 'l' is equal to the total function of '\u03b1' and 'R' with the composition of 'v'' and 'f' applied to 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem total_equivMapDomain (f : \u03b1 \u2243 \u03b1') (l : \u03b1 \u2192\u2080 R) :\n    (Finsupp.total \u03b1' M' R v') (equivMapDomain f l) = (Finsupp.total \u03b1 M' R (v' \u2218 f)) l :="}
{"input": "Statement in natural language:\nFor any three elements x, y, and z in a normed lattice, the norm of the supremum of x and z minus the supremum of y and z is less than or equal to the norm of x minus y.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_sup_sub_sup_le_norm (x y z : \u03b1) : \u2016x \u2294 z - y \u2294 z\u2016 \u2264 \u2016x - y\u2016 :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' from the multiplier algebra of a star algebra 'A' over a field '\ud835\udd5c', the second component of the product of 'a' and 'b' is equal to the product of the second component of 'b' and the second component of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_snd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a * b).snd = b.snd * a.snd :="}
{"input": "Statement in natural language:\nIf the function f is interval integrable over the intervals [a, b], [c, d], and [a, c] with respect to a measure \u03bc, then the difference between the integral of f from a to b and the integral of f from c to d is equal to the difference between the integral of f from a to c and the integral of f from b to d.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_interval_sub_interval_comm (hab : IntervalIntegrable f \u03bc a b)\n    (hcd : IntervalIntegrable f \u03bc c d) (hac : IntervalIntegrable f \u03bc a c) :\n    ((\u222b x in a..b, f x \u2202\u03bc) - \u222b x in c..d, f x \u2202\u03bc) =\n      (\u222b x in a..c, f x \u2202\u03bc) - \u222b x in b..d, f x \u2202\u03bc :="}
{"input": "Statement in natural language:\nFor a given addition monoid M, a monoid R, and a distributive multiplication action of R on M, and for a function f from \u03b1 to \u03b2, a scalar r from R, and a function v from \u03b2 to M, if the function f is injective on the preimage of the support of v and the preimage of the support of the scalar multiplication of r and v, then the comapDomain of f and the scalar multiplication of r and v is equal to the scalar multiplication of r and the comapDomain of f and v.\nTranslate the statement in natural language to Lean:", "output": "theorem comapDomain_smul [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : \u03b1 \u2192 \u03b2} (r : R)\n    (v : \u03b2 \u2192\u2080 M) (hfv : Set.InjOn f (f \u207b\u00b9' \u2191v.support))\n    (hfrv : Set.InjOn f (f \u207b\u00b9' \u2191(r \u2022 v).support) :=\n      hfv.mono <| Set.preimage_mono <| Finset.coe_subset.mpr support_smul) :\n    comapDomain f (r \u2022 v) hfrv = r \u2022 comapDomain f v hfv :="}
{"input": "Statement in natural language:\nFor any two subgroups H and K of a group G, if H is a subset of K, then the composition of the subtype of K and the inclusion of H in K is equal to the subtype of H.\nTranslate the statement in natural language to Lean:", "output": "theorem subtype_comp_inclusion {H K : Subgroup G} (hH : H \u2264 K) :\n    K.subtype.comp (inclusion hH) = H.subtype :="}
{"input": "Statement in natural language:\nFor a given set 's' of any type '\u03b1', and for another set 't' of the same type '\u03b1' where '1' of type '\u03b1' is an element of 't', 's' is a subset of the product of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_mul_left (s : Set \u03b1) {t : Set \u03b1} (ht : (1 : \u03b1) \u2208 t) : s \u2286 s * t :="}
{"input": "Statement in natural language:\nThe function f is almost everywhere measurable with respect to the measure restricted to the union of sets s and t if and only if the function f is almost everywhere measurable with respect to the measure restricted to set s and the function f is almost everywhere measurable with respect to the measure restricted to set t.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.aemeasurable_union_iff {s t : Set \u03b1} :\n    AEMeasurable f (\u03bc.restrict (s \u222a t)) \u2194\n      AEMeasurable f (\u03bc.restrict s) \u2227 AEMeasurable f (\u03bc.restrict t) :="}
{"input": "Statement in natural language:\nFor a given element 'x' from a field extension 'E', the field obtained by adjoining 'x' to the field obtained by adjoining a set 'S' to a field 'F' is the same as the field obtained by adjoining 'x' to the set 'S' and then adjoining this to the field 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem adjoin_insert_adjoin (x : E) :\n    adjoin F (insert x (adjoin F S : Set E)) = adjoin F (insert x S) :="}
{"input": "Statement in natural language:\nFor any polynomial 'x' over a field 'K', the function 'ofFractionRing' applied to the algebraic mapping of 'x' into the fraction ring of polynomials over 'K' is equal to the algebraic mapping of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofFractionRing_algebraMap (x : K[X]) :\n    ofFractionRing (algebraMap _ (FractionRing K[X]) x) = algebraMap _ _ x :="}
{"input": "Statement in natural language:\nFor any additive monoid with one element 'R' and any natural numbers 'm' and 'n', the cast of the sum of 'm' and 'n' to 'R' is equal to the sum of 'm' and 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_add [AddMonoidWithOne R] (m n : \u2115) : ((m + n : \u2115) : R) = m + n :="}
{"input": "Statement in natural language:\nTaking elements from the right of an empty list, regardless of the number of elements specified, will result in an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem rtake_nil : rtake ([] : List \u03b1) n = [] :="}
{"input": "Statement in natural language:\nIf a is greater than or equal to 1 and b is also greater than or equal to 1, then the product of a and b is greater than or equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem one_le_mul_of_one_le_of_one_le (ha : 1 \u2264 a) (hb : 1 \u2264 b) : (1 : \u03b1) \u2264 a * b :="}
{"input": "Statement in natural language:\nFor any two finite numbers 'i' and 'j' within a certain range 'n', if the values of 'i' and 'j' are not equal, then 'i' and 'j' themselves are not equal.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_of_vne {i j : Fin n} (h : i.val \u2260 j.val) : i \u2260 j :="}
{"input": "Statement in natural language:\nIf 'a' is a unit, then the multiplication of 'a' and 'b' being equal to the multiplication of 'a' and 'c' implies that 'b' is equal to 'c'. This is known as the left cancellation law in multiplication.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_left_cancel (h : IsUnit a) : a * b = a * c \u2192 b = c :="}
{"input": "Statement in natural language:\nFor a function 'f' which is non-negative almost everywhere with respect to measure '\u03bc' and is interval integrable over the interval from 'a' to 'b', the integral of 'f' over this interval is positive if and only if 'a' is less than 'b' and the measure of the intersection of the support of 'f' and the interval (a, b] is positive.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_pos_iff_support_of_nonneg_ae (hf : 0 \u2264\u1d50[\u03bc] f) (hfi : IntervalIntegrable f \u03bc a b) :\n    (0 < \u222b x in a..b, f x \u2202\u03bc) \u2194 a < b \u2227 0 < \u03bc (support f \u2229 Ioc a b) :="}
{"input": "Statement in natural language:\nThe transition from the inverse of a local homeomorphism 'e' to 'e' itself is equivalent to the local homeomorphism of the target set of 'e', given that the target set is open.\nTranslate the statement in natural language to Lean:", "output": "theorem trans_symm_self : e.symm.trans e \u2248 LocalHomeomorph.ofSet e.target e.open_target :="}
{"input": "Statement in natural language:\nIf a constant 'c' is not equal to zero, then the function that multiplies 'c' with the output of function 'f' for each input 'x' in set 's' is continuous if and only if the function 'f' is continuous on set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousOn_const_smul_iff\u2080 (hc : c \u2260 0) :\n    ContinuousOn (fun x => c \u2022 f x) s \u2194 ContinuousOn f s :="}
{"input": "Statement in natural language:\nFor any type M that is a monoid, and any unit 'u' and element 'a' of M, 'a' is a unit if and only if the product of 'u' and 'a' is a unit.\nTranslate the statement in natural language to Lean:", "output": "theorem Units.isUnit_units_mul {M : Type _} [Monoid M] (u : M\u02e3) (a : M) :\n    IsUnit (\u2191u * a) \u2194 IsUnit a :="}
{"input": "Statement in natural language:\nFor any two functions 'g' and 'h' that map sets of elements of type \u03b1 to sets of elements of type \u03b2 and sets of elements of type \u03b2 to sets of elements of type \u03b3 respectively, if 'g' and 'h' are monotone, then lifting 'f' by 'g' and then lifting the result by 'h' is the same as lifting 'f' by the function that applies 'h' to the result of applying 'g' to a set.\nTranslate the statement in natural language to Lean:", "output": "theorem lift'_lift'_assoc {g : Set \u03b1 \u2192 Set \u03b2} {h : Set \u03b2 \u2192 Set \u03b3} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift' h = f.lift' fun s => h (g s) :="}
{"input": "Statement in natural language:\nFor any additive group with one element R, the integer coefficient of one in the arithmetic function from integers to R is equal to one.\nTranslate the statement in natural language to Lean:", "output": "theorem intCoe_one [AddGroupWithOne R] : ((1 : ArithmeticFunction \u2124) :\n    ArithmeticFunction R) = 1 :="}
{"input": "Statement in natural language:\nFor any real numbers 'x' and 'p', given that 'x' is not equal to zero or 'p' is greater than or equal to 1, the derivative at 'x' of the function 'x' to the power of 'p' is 'p' times 'x' to the power of 'p - 1'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasDerivAt_rpow_const {x p : \u211d} (h : x \u2260 0 \u2228 1 \u2264 p) :\n    HasDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x :="}
{"input": "Statement in natural language:\nFor a ring homomorphism 'h' from a commutative semiring 'R' to another commutative semiring 'S', a function 'f' from a type '\u03b1' to a type 'M' with zero, and a function 'g' from '\u03b1' and 'M' to 'R', the image of the product of 'f' and 'g' under 'h' is equal to the product of 'f' and the image of 'g' under 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem RingHom.map_finsupp_prod [Zero M] [CommSemiring R] [CommSemiring S] (h : R \u2192+* S)\n    (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 R) : h (f.prod g) = f.prod fun a b => h (g a b) :="}
{"input": "Statement in natural language:\nFor a given equivalence between two sets m and l (denoted as e\u2098), and another equivalence between two sets n and o (denoted as e\u2099), and a matrix M with dimensions m by n with elements of type \u03b1, the reindexing of matrix M using the equivalences e\u2098 and e\u2099 is equal to the submatrix of M obtained by applying the inverse of the equivalences e\u2098 and e\u2099.\nTranslate the statement in natural language to Lean:", "output": "theorem reindex_apply (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) (M : Matrix m n \u03b1) :\n    reindex e\u2098 e\u2099 M = M.submatrix e\u2098.symm e\u2099.symm :="}
{"input": "Statement in natural language:\nThe dot product of vector v and the negation of vector w is equal to the negation of the dot product of vector v and vector w.\nTranslate the statement in natural language to Lean:", "output": "theorem dotProduct_neg : v \u2b1d\u1d65 -w = -(v \u2b1d\u1d65 w) :="}
{"input": "Statement in natural language:\nThe function that takes an element from subgroup H to group G, defined by the subtype of H, is equal to the function that takes an element from H to G, defined by the coercion function.\nTranslate the statement in natural language to Lean:", "output": "theorem coeSubtype : (SubgroupClass.subtype H : H \u2192 G) = ((\u2191) : H \u2192 G) :="}
{"input": "Statement in natural language:\nIf set t is almost everywhere equal to the empty set with respect to measure \u03bc, then the union of sets s and t is almost everywhere equal to set s with respect to the same measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem union_ae_eq_left_of_ae_eq_empty (h : t =\u1d50[\u03bc] (\u2205 : Set \u03b1)) : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] s :="}
{"input": "Statement in natural language:\nThe exponential function applied to the left injection of a real number in the direct sum of real numbers and some normed space is equal to the left injection of the exponential function applied to the real number.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_inl (x : R) : exp \ud835\udd5c (inl x : tsze R M) = inl (exp \ud835\udd5c x) :="}
{"input": "Statement in natural language:\nThe inverse of the extended chart at a point 'x' in a smooth manifold with corners 'I' is continuous at the image of 'x' under the extended chart.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousAt_extChartAt_symm : ContinuousAt (extChartAt I x).symm ((extChartAt I x) x) :="}
{"input": "Statement in natural language:\nThe operation that assigns to each element its opposite is surjective. This means that for every element in the set, there is at least one element in the original set that maps to it under this operation.\nTranslate the statement in natural language to Lean:", "output": "theorem op_surjective : Surjective (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56) :="}
{"input": "Statement in natural language:\n1 is less than the non-negative real part of p.\nTranslate the statement in natural language to Lean:", "output": "theorem one_lt_nnreal : 1 < Real.toNNReal p :="}
{"input": "Statement in natural language:\nIf there is a partial equivalence between type \u03b1 and type \u03b2 represented by 'f', then the composition of 'f' with the bottom partial equivalence (which represents no equivalence) between type \u03b2 and type \u03b3 is also the bottom partial equivalence.\nTranslate the statement in natural language to Lean:", "output": "theorem trans_bot (f : \u03b1 \u2243. \u03b2) : f.trans (\u22a5 : \u03b2 \u2243. \u03b3) = \u22a5 :="}
{"input": "Statement in natural language:\nFor any index set \u03b9, any weighting function w from \u03b9 to a field k, any point function p from \u03b9 to a space P, and any index i in \u03b9, the weighted difference of points from the set s with i removed, using the point function p and the weight function w, with respect to the point p(i), is equal to the weighted difference of points from the set s, using the point function p and the weight function w, with respect to the point p(i). This holds if \u03b9 has decidable equality.\nTranslate the statement in natural language to Lean:", "output": "theorem weightedVSubOfPoint_erase [DecidableEq \u03b9] (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (i : \u03b9) :\n    (s.erase i).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w :="}
{"input": "Statement in natural language:\nFor any ring homomorphism class F from ring R to ring S, and any function f from F, for all natural numbers n, applying the function f to n (considered as an element of ring R) equals n.\nTranslate the statement in natural language to Lean:", "output": "theorem map_natCast [RingHomClass F R S] (f : F) : \u2200 n : \u2115, f (n : R) = n :="}
{"input": "Statement in natural language:\nIf the series of f and g are both summable, and the series of the product of f and g (where f and g are functions of the elements from the sets \u03b9 and \u03ba respectively) is also summable, then the sum of the series of f times the sum of the series of g is equal to the sum of the series of the product of f and g.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_mul_tsum (hf : Summable f) (hg : Summable g)\n    (hfg : Summable fun x : \u03b9 \u00d7 \u03ba => f x.1 * g x.2) :\n    ((\u2211' x, f x) * \u2211' y, g y) = \u2211' z : \u03b9 \u00d7 \u03ba, f z.1 * g z.2 :="}
{"input": "Statement in natural language:\nThe cardinality of the multiset obtained by binding a function 'f' to a multiset 's' is equal to the sum of the multiset obtained by mapping the composition of the cardinality function and 'f' over 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_bind : card (s.bind f) = (s.map (card \u2218 f)).sum :="}
{"input": "Statement in natural language:\nFor a given element 'a' in set '\u03b1', 'l a' is the greatest lower bound of the set of all 'b' such that 'a' is less than or equal to 'u b'.\nTranslate the statement in natural language to Lean:", "output": "theorem isGLB_l {a : \u03b1} : IsGLB { b | a \u2264 u b } (l a) :="}
{"input": "Statement in natural language:\nFor any function 's' mapping from a pair of index sets '\u03b9' and '\u03b9'' to a set of '\u03b1', the union over 'j' of the intersection over 'i' of 's i j' is a subset of the intersection over 'i' of the union over 'j' of 's i j'.\nTranslate the statement in natural language to Lean:", "output": "theorem iUnion_iInter_subset {s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1} : (\u22c3 j, \u22c2 i, s i j) \u2286 \u22c2 i, \u22c3 j, s i j :="}
{"input": "Statement in natural language:\nIn the context of group theory, for a finite group G, the exponent of G is equal to the maximum order of any element in G. This maximum order is guaranteed to be at least 1.\nTranslate the statement in natural language to Lean:", "output": "theorem exponent_eq_max'_orderOf [Fintype G] :\n    exponent G = ((@Finset.univ G _).image orderOf).max' \u27e81, by simp\u27e9 :="}
{"input": "Statement in natural language:\nFor a finite dimensional field 'K' and vector space 'V', the application of the map evaluation equivalence on a subspace 'W' of 'V' is equal to the mapping of the subspace 'W' with the evaluation of 'K' and 'V'.\nTranslate the statement in natural language to Lean:", "output": "theorem mapEvalEquiv_apply [FiniteDimensional K V] (W : Subspace K V) :\n    mapEvalEquiv K V W = W.map (eval K V) :="}
{"input": "Statement in natural language:\nThe interval from 'a' to 'b' is equal to the interval from 'a' (interpreted as a natural number) to 'b', which is then finalized to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioc_eq_finset_subtype : Ioc a b = (Ioc (a : \u2115) b).fin n :="}
{"input": "Statement in natural language:\nFor any element 'x' of set 'M' and any natural number 'n', the first element of the application of 'of' function on 'I', 'M', and 'x' at 'n' is equal to the application of 'mkQ' function on '_' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem of_apply (x : M) (n : \u2115) : (of I M x).1 n = mkQ _ x :="}
{"input": "Statement in natural language:\nFor a given element 'x' from set 'E', there exists a unique 'v' from the integer span of the set range 'b', such that the vector addition of 'v' and 'x' belongs to the fundamental domain of 'b'. This theorem is applicable under the condition that '\u03b9' is finite.\nTranslate the statement in natural language to Lean:", "output": "theorem exist_unique_vadd_mem_fundamentalDomain [Finite \u03b9] (x : E) :\n    \u2203! v : span \u2124 (Set.range b), v +\u1d65 x \u2208 fundamentalDomain b :="}
{"input": "Statement in natural language:\nThe norm of 'x' when converted to an additive form in the set E is equal to the norm of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_toAdd (x) : \u2016(toAdd x : E)\u2016 = \u2016x\u2016 :="}
{"input": "Statement in natural language:\nFor a given element 'a' in set 'M' and given subrings 'S' and 'T' of ring 'R', the scalar multiplication of 'a' and 'S' is less than or equal to the scalar multiplication of 'a' and 'T' if and only if 'S' is less than or equal to 'T'.\nTranslate the statement in natural language to Lean:", "output": "theorem pointwise_smul_le_pointwise_smul_iff {a : M} {S T : Subring R} : a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T :="}
{"input": "Statement in natural language:\nA set 's' mapped by a function 'f' is nonempty if and only if the set 's' itself is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem map_nonempty : (s.map f).Nonempty \u2194 s.Nonempty :="}
{"input": "Statement in natural language:\nFor any two types \u03b1\u2081 and \u03b1\u2082, given a bijective function 'e' between them, an element 'i' of type \u03b1\u2081, and a module 'm', the domain of the linear congruence of 'e' applied to the single function of 'i' and 'm' is equal to the single function of 'e' applied to 'i' and 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem domLCongr_single {\u03b1\u2081 : Type _} {\u03b1\u2082 : Type _} (e : \u03b1\u2081 \u2243 \u03b1\u2082) (i : \u03b1\u2081) (m : M) :\n    (Finsupp.domLCongr e : _ \u2243\u2097[R] _) (Finsupp.single i m) = Finsupp.single (e i) m :="}
{"input": "Statement in natural language:\nThe singleton set containing only the number one in the submodule of R and A is equal to the span of R and 1.\nTranslate the statement in natural language to Lean:", "output": "theorem one_eq_span_one_set : (1 : Submodule R A) = span R 1 :="}
{"input": "Statement in natural language:\nIf function f is analytic at a point x and function g is also analytic at the same point x, then the sum of functions f and g is also analytic at point x.\nTranslate the statement in natural language to Lean:", "output": "theorem AnalyticAt.add (hf : AnalyticAt \ud835\udd5c f x) (hg : AnalyticAt \ud835\udd5c g x) : AnalyticAt \ud835\udd5c (f + g) x :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any finite set s of type \u03b1, the cardinality of s is equal to the cardinality of the set obtained by applying the cardinality function to s.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_coe_finset {\u03b1 : Type u} {s : Finset \u03b1} : (#s) = \u2191(Finset.card s) :="}
{"input": "Statement in natural language:\nIf for all points 'x' in a topological space 'X', the stalk functor mapping of 'f' (a morphism from sheaf 'F' to sheaf 'G') is a monomorphism, then 'f' itself is a monomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem mono_of_stalk_mono {F G : Sheaf C X} (f : F \u27f6 G) [\u2200 x, Mono <| (stalkFunctor C x).map f.1] :\n    Mono f :="}
{"input": "Statement in natural language:\nFor any equivalence relation 'e' from 'r' to 'r', applying 'e' to the inverse of 'e' applied to any element 'x' will yield 'x' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_inv_self (e : r \u2243r r) (x) : e (e\u207b\u00b9 x) = x :="}
{"input": "Statement in natural language:\nIf a set 's' is in the neighborhood of a point 'a', then 's' is also in the neighborhood within a set 't' of the point 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_nhdsWithin_of_mem_nhds {s t : Set \u03b1} {a : \u03b1} (h : s \u2208 \ud835\udcdd a) : s \u2208 \ud835\udcdd[t] a :="}
{"input": "Statement in natural language:\nFor a given equivalence 'e' between two index sets '\u03b9' and '\u03b9\u2082', and a function 'f' that maps each index to a module 'M', the tensor product of 'f' reindexed by 'e' is equal to the tensor product of 'f' composed with the inverse of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem reindex_tprod (e : \u03b9 \u2243 \u03b9\u2082) (f : \u2200 _, M) :\n    reindex R M e (tprod R f) = tprod R fun i \u21a6 f (e.symm i) :="}
{"input": "Statement in natural language:\nThe ceiling function, which maps any real number to the smallest integer greater than or equal to it, is monotone. This means that if a real number x is less than or equal to another real number y, then the ceiling of x is also less than or equal to the ceiling of y.\nTranslate the statement in natural language to Lean:", "output": "theorem ceil_mono : Monotone (ceil : \u03b1 \u2192 \u2124) :="}
{"input": "Statement in natural language:\nThe natural degree of twice a polynomial 'a' is less than or equal to the natural degree of the polynomial 'a' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_bit0 (a : R[X]) : (bit0 a).natDegree \u2264 a.natDegree :="}
{"input": "Statement in natural language:\nIf we have a matrix M with a nonzero determinant, and a vector v such that when we multiply M by v we get the zero vector, then v must be the zero vector.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_zero_of_mulVec_eq_zero [DecidableEq m] {M : Matrix m m A} (hM : M.det \u2260 0) {v : m \u2192 A}\n    (hv : M.mulVec v = 0) : v = 0 :="}
{"input": "Statement in natural language:\nFor two sets 's' and 't' that are both bounded below and nonempty, the greatest lower bound (infimum) of the union of 's' and 't' is equal to the intersection of the greatest lower bound of 's' and the greatest lower bound of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem csInf_union (hs : BddBelow s) (sne : s.Nonempty) (ht : BddBelow t) (tne : t.Nonempty) :\n    sInf (s \u222a t) = sInf s \u2293 sInf t :="}
{"input": "Statement in natural language:\nFor a given monoid 'G', a multiplication action of 'G' on a semiring '\ud835\udd38', and a continuous constant scalar multiplication of 'G' on '\ud835\udd38', for any element 'g' of 'G' and any element 'x' of '\ud835\udd38', the exponential of the scalar multiplication of 'g' and 'x' is equal to the scalar multiplication of 'g' and the exponential of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_smul {G} [Monoid G] [MulSemiringAction G \ud835\udd38] [ContinuousConstSMul G \ud835\udd38] (g : G) (x : \ud835\udd38) :\n    exp \ud835\udd42 (g \u2022 x) = g \u2022 exp \ud835\udd42 x :="}
{"input": "Statement in natural language:\nFor a nontrivial set 's', the first element chosen from 's' is not equal to the second element chosen from 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Nontrivial.choose_fst_ne_choose_snd (hs : s.Nontrivial) :\n    hs.choose.fst \u2260 hs.choose.snd :="}
{"input": "Statement in natural language:\nFor a Freiman homomorphism of class F from a set A to a set \u03b2 of size n, given a function f of type F, and two multisets s and t of elements from \u03b1, if every element of s and t is in A, both s and t have the same cardinality n, and the product of elements in s is equal to the product of elements in t, then the product of the elements in the multiset obtained by mapping f over s is equal to the product of the elements in the multiset obtained by mapping f over t.\nTranslate the statement in natural language to Lean:", "output": "theorem map_prod_eq_map_prod [FreimanHomClass F A \u03b2 n] (f : F) {s t : Multiset \u03b1}\n    (hsA : \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A) (htA : \u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n)\n    (h : s.prod = t.prod) : (s.map f).prod = (t.map f).prod :="}
{"input": "Statement in natural language:\nIf the supremum of sets s and t is nonempty, then set t is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem Nonempty.of_sups_right : (s \u22bb t).Nonempty \u2192 t.Nonempty :="}
{"input": "Statement in natural language:\nFor any two finite partitions P and Q of a set a, the parts of the intersection of P and Q are equal to the image of the Cartesian product of the parts of P and Q under the function that maps each pair to their intersection, with the bottom element removed.\nTranslate the statement in natural language to Lean:", "output": "theorem parts_inf (P Q : Finpartition a) :\n    (P \u2293 Q).parts = ((P.parts \u00d7\u02e2 Q.parts).image fun bc : \u03b1 \u00d7 \u03b1 \u21a6 bc.1 \u2293 bc.2).erase \u22a5 :="}
{"input": "Statement in natural language:\nFor any types \u03b1 and \u03b2, and any element b of type \u03b2, the function that takes an element a of type \u03b1 and pairs it with b to form a product of type \u03b1 \u00d7 \u03b2 is injective. In other words, if two pairs (a, b) and (a', b) are equal, then a must be equal to a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk.inj_right {\u03b1 \u03b2 : Type _} (b : \u03b2) :\n    Function.Injective (fun a \u21a6 Prod.mk a b : \u03b1 \u2192 \u03b1 \u00d7 \u03b2) :="}
{"input": "Statement in natural language:\nFor any object 'x' in 'X' and any 'U', the object 'U' remains unchanged when mapped with the identity on 'X'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_id_obj (x : X) (U) : (map (\ud835\udfd9 X) x).obj U = U :="}
{"input": "Statement in natural language:\nFor a given submonoid 's' of 'M' and an element 'x' of 'M', 'x' is in the subsemigroup of 's' if and only if 'x' is in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_toSubsemigroup {s : Submonoid M} {x : M} : x \u2208 s.toSubsemigroup \u2194 x \u2208 s :="}
{"input": "Statement in natural language:\nFor a given commutative semiring R and a semiring A with an algebra structure over R, if we have two algebra homomorphisms f and g from the dual numbers over R to A, and if these two homomorphisms map the dual number \u03b5 to the same element in A, then these two homomorphisms are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem algHom_ext {A} [CommSemiring R] [Semiring A] [Algebra R A] \u2983f g : R[\u03b5] \u2192\u2090[R] A\u2984\n    (h : f \u03b5 = g \u03b5) : f = g :="}
{"input": "Statement in natural language:\nFor any element 'a' and any multiset 's', if 'a' is an element of 's', then the cardinality (or size) of 's' after erasing 'a', plus one, is equal to the original cardinality of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_erase_add_one {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s \u2192 card (s.erase a) + 1 = card s :="}
{"input": "Statement in natural language:\nThe domain function, when applied to the fields R, E, and F, is strictly monotonic. This means that if we have two elements and the first is less than the second, then the image of the first under the domain function is less than the image of the second.\nTranslate the statement in natural language to Lean:", "output": "theorem domain_mono : StrictMono (@domain R _ E _ _ F _ _) :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', given the conditions 'h\u2081', 'h\u2082', and 'h\u2083', the function 'f' with the conditions 'h\u2081', 'h\u2082', and 'h\u2083' as a multiplicative homomorphism from '\u03b1' to '\u03b2' is equivalent to the function 'f' with the condition 'h\u2081' as a monoid homomorphism from '\u03b1' to '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mulHom_mk (f : \u03b1 \u2192 \u03b2) (h\u2081 h\u2082 h\u2083) :\n    ((\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9 : \u03b1 \u2192\u2099+* \u03b2) : \u03b1 \u2192\u2099* \u03b2) = \u27e8f, h\u2081\u27e9 :="}
{"input": "Statement in natural language:\nThe preimage of the boolean indicator function of set s for the value false is equal to the complement of set s.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_boolIndicator_false : s.boolIndicator \u207b\u00b9' {false} = s\u1d9c :="}
{"input": "Statement in natural language:\nIf x is an element of the source of e, then applying the inverse of the local homeomorphism e to the pair consisting of the projection of x and the second component of e at x, gives us back x.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_apply_mk_proj (ex : x \u2208 e.source) : e.toLocalHomeomorph.symm (proj x, (e x).2) = x :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any elements 'x' and 'a' of an additive commutative monoid '\u03b1', the term of 'n', 'x', and 'a' is equal to 'n' times 'x' plus 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem term_eq [AddCommMonoid \u03b1] (n : \u2115) (x a : \u03b1) : term n x a = n \u2022 x + a :="}
{"input": "Statement in natural language:\nFor two computations 'c\u2081' and 'c\u2082' of type \u03b1, if 'c\u2081' is equivalent to 'c\u2082', then the promise of 'c\u2081' leading to a result 'a' is equivalent to the promise of 'c\u2082' leading to the same result 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem promises_congr {c\u2081 c\u2082 : Computation \u03b1} (h : c\u2081 ~ c\u2082) (a) : c\u2081 ~> a \u2194 c\u2082 ~> a :="}
{"input": "Statement in natural language:\nFor any scalar 'r' and any two points 'p\u2081' and 'p\u2082', the line map from 'p\u2081' to 'p\u2082' at 'r' is included in the line spanned by 'p\u2081' and 'p\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (p\u2081 p\u2082 : P) :\n    AffineMap.lineMap p\u2081 p\u2082 r \u2208 line[k, p\u2081, p\u2082] :="}
{"input": "Statement in natural language:\nIf 'f' is a group homomorphism from group 'G' to group 'H', and 's' is a subgroup of 'G', then the image of 's' under 'f' is a subgroup of 'H'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_subgroup {f : G \u2192 H} (hf : IsGroupHom f) {s : Set G} (hs : IsSubgroup s) :\n    IsSubgroup (f '' s) :="}
{"input": "Statement in natural language:\nFor any list of elements of an arbitrary type and a natural number that is less than or equal to the length of the list, taking the first 'n' elements of the reversed list is the same as dropping the first 'length of the list minus n' elements from the original list and then reversing it.\nTranslate the statement in natural language to Lean:", "output": "theorem reverse_take {\u03b1} {xs : List \u03b1} (n : \u2115) (h : n \u2264 xs.length) :\n    xs.reverse.take n = (xs.drop (xs.length - n)).reverse :="}
{"input": "Statement in natural language:\nFor any real number 'a' and any natural number 'n', the absolute value of 'a' raised to the power of 'n' is equal to the absolute value of 'a' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_abs (a : R) (n : \u2115) : |a| ^ n = |a ^ n| :="}
{"input": "Statement in natural language:\nThe norm of the product of a variable 'x' and its conjugate is equal to the product of the norm of 'x' and the norm of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_self_mul_star {x : E} : \u2016x * x\u22c6\u2016 = \u2016x\u2016 * \u2016x\u2016 :="}
{"input": "Statement in natural language:\nMapping the identity multiplicative homomorphism on a set \u03b1 is equivalent to the identity monoid homomorphism on the set \u03b1 with an additional element.\nTranslate the statement in natural language to Lean:", "output": "theorem map_id : map (MulHom.id \u03b1) = MonoidHom.id (WithOne \u03b1) :="}
{"input": "Statement in natural language:\n\"a commutes with the inverse of u if and only if a commutes with u\".\nTranslate the statement in natural language to Lean:", "output": "theorem units_inv_right_iff : Commute a \u2191u\u207b\u00b9 \u2194 Commute a u :="}
{"input": "Statement in natural language:\nThe function 'ofNat' for the product of two natural numbers is equal to the 'unpair' function.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_nat_ofNat : ofNat (\u2115 \u00d7 \u2115) = unpair :="}
{"input": "Statement in natural language:\nFor any objects X' and Y' in category C and any morphism g from X' to Y' that has a kernel, if the functor G maps g and preserves the limit of the parallel pair (g, 0), then for any morphisms p from X to X' and q from Y to Y' such that the composition of f and q equals the composition of p and g, the composition of the kernel map of G.map f and G.map g with G.map p and G.map q (where the equality is proven by rewriting the composition using the functor G) and the inverse of the isomorphism that preserves the kernel of G is equal to the composition of the inverse of the isomorphism that preserves the kernel of G and the G.map of the kernel map of f and g with p and q.\nTranslate the statement in natural language to Lean:", "output": "theorem kernel_map_comp_preserves_kernel_iso_inv {X' Y' : C} (g : X' \u27f6 Y') [HasKernel g]\n    [HasKernel (G.map g)] [PreservesLimit (parallelPair g 0) G] (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (hpq : f \u226b q = p \u226b g) :\n    kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [\u2190 G.map_comp, hpq, G.map_comp]) \u226b\n        (PreservesKernel.iso G _).inv =\n      (PreservesKernel.iso G _).inv \u226b G.map (kernel.map f g p q hpq) :="}
{"input": "Statement in natural language:\nIf m and n are odd numbers, then the difference between m and n is an even number.\nTranslate the statement in natural language to Lean:", "output": "theorem Odd.sub_odd (hm : Odd m) (hn : Odd n) : Even (m - n) :="}
{"input": "Statement in natural language:\nFor all natural numbers n and p, if p is a prime number, then p divides the factorial of n if and only if p is less than or equal to n.\nTranslate the statement in natural language to Lean:", "output": "theorem Prime.dvd_factorial : \u2200 {n p : \u2115} (_ : Prime p), p \u2223 n ! \u2194 p \u2264 n"}
{"input": "Statement in natural language:\nFor a given element 'd' of type \u03b1 and two elements 'x' and 'y' of type WithBot \u03b1, the function 'unbot'' applied to 'd' and 'x' equals the function 'unbot'' applied to 'd' and 'y' if and only if 'x' equals 'y' or 'x' equals 'd' and 'y' equals bottom or 'x' equals bottom and 'y' equals 'd'.\nTranslate the statement in natural language to Lean:", "output": "theorem unbot'_eq_unbot'_iff {d : \u03b1} {x y : WithBot \u03b1} :\n    unbot' d x = unbot' d y \u2194 x = y \u2228 x = d \u2227 y = \u22a5 \u2228 x = \u22a5 \u2227 y = d :="}
{"input": "Statement in natural language:\nFor a given natural number 'n' which is greater than 0, and any two elements 'a' and 'x' of a ring 'R', 'x' is a member of the nth roots of 'a' if and only if 'x' raised to the power 'n' equals 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_nthRoots {n : \u2115} (hn : 0 < n) {a x : R} : x \u2208 nthRoots n a \u2194 x ^ n = a :="}
{"input": "Statement in natural language:\nIn a finite configuration of points P and lines L, for any given point p, the count of lines through that point is equal to the order of the configuration plus one.\nTranslate the statement in natural language to Lean:", "output": "theorem lineCount_eq [Finite P] [Finite L] (p : P) : lineCount L p = order P L + 1 :="}
{"input": "Statement in natural language:\nIn the theorem, assuming that R is an integral domain and x is a non-zero element of R, the product of an ideal I and the principal ideal generated by x equals the product of another ideal J and the principal ideal generated by x if and only if I equals J.\nTranslate the statement in natural language to Lean:", "output": "theorem span_singleton_mul_left_inj [IsDomain R] {x : R} (hx : x \u2260 0) :\n    I * span {x} = J * span {x} \u2194 I = J :="}
{"input": "Statement in natural language:\nIf a set 's' in the field 'F' is star-convex with respect to a linear map 'f' from 'E' to 'F' at a point 'f(x)', then the preimage of the set 's' under the function 'f' is star-convex at the point 'x' in the field '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem StarConvex.linear_preimage {s : Set F} (f : E \u2192\u2097[\ud835\udd5c] F) (hs : StarConvex \ud835\udd5c (f x) s) :\n    StarConvex \ud835\udd5c x (s.preimage f) :="}
{"input": "Statement in natural language:\nFor any finite type \u03b9 and an affine basis b of \u03b9 in real numbers and V, the centroid of the universal set with respect to real numbers and b is in the interior of the convex hull of the range of b with respect to real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem AffineBasis.centroid_mem_interior_convexHull {\u03b9} [Fintype \u03b9] (b : AffineBasis \u03b9 \u211d V) :\n    Finset.univ.centroid \u211d b \u2208 interior (convexHull \u211d (range b)) :="}
{"input": "Statement in natural language:\nIf J is an element of \u03c0, then the distortion of J is less than or equal to the distortion of \u03c0.\nTranslate the statement in natural language to Lean:", "output": "theorem distortion_le_of_mem (h : J \u2208 \u03c0) : J.distortion \u2264 \u03c0.distortion :="}
{"input": "Statement in natural language:\nFor a semilattice structure of type \u03b3, a set is bounded below by the union of sets s and t if and only if both set s and set t are bounded below.\nTranslate the statement in natural language to Lean:", "output": "theorem bddBelow_union [SemilatticeInf \u03b3] {s t : Set \u03b3} :\n    BddBelow (s \u222a t) \u2194 BddBelow s \u2227 BddBelow t :="}
{"input": "Statement in natural language:\nA vector 'v' is in the vector span of the set range of a function 'p' if and only if there exists a finite set 's' and a function 'w' such that the sum of 'w i' for all 'i' in 's' equals zero, and 'v' equals the weighted difference of 's' with respect to 'p' and 'w'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_vectorSpan_iff_eq_weightedVSub {v : V} {p : \u03b9 \u2192 P} :\n    v \u2208 vectorSpan k (Set.range p) \u2194\n      \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k) (_ : (\u2211 i in s, w i) = 0), v = s.weightedVSub p w :="}
{"input": "Statement in natural language:\nThe bounded limit superior of a function 'f' for a sequence 'u' where the property 'p' or 'q' holds is equal to the supremum of the bounded limit superior of 'f' for 'u' where 'p' holds and the bounded limit superior of 'f' for 'u' where 'q' holds.\nTranslate the statement in natural language to Lean:", "output": "theorem blimsup_or_eq_sup : (blimsup u f fun x => p x \u2228 q x) = blimsup u f p \u2294 blimsup u f q :="}
{"input": "Statement in natural language:\nFor a set 's' of elements of type 'M' and an element 'x' of type 'M', given the conditions 'h_one' and 'h_mul', 'x' is an element of the submonoid created from 's' with 'h_mul' and 'h_one' if and only if 'x' is an element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_mk {s : Set M} {x : M} (h_one) (h_mul) : x \u2208 mk \u27e8s, h_mul\u27e9 h_one \u2194 x \u2208 s :="}
{"input": "Statement in natural language:\nThe function 'lowerClosure', which maps a set of elements of type \u03b1 to a lower set of \u03b1, is monotone. This means that if one set is a subset of another, the lower closure of the first set is also a subset of the lower closure of the second set.\nTranslate the statement in natural language to Lean:", "output": "theorem lowerClosure_mono : Monotone (lowerClosure : Set \u03b1 \u2192 LowerSet \u03b1) :="}
{"input": "Statement in natural language:\nFor a relation 'r' on a set '\u03b2', given that 'r' is transitive, and a function 'f' from natural numbers to '\u03b2', and a natural number 'a', if for all natural numbers 'n' greater than or equal to 'a', 'r' holds between 'f(n)' and 'f(n+1)', then for any two natural numbers 'b' and 'c' such that 'b' is greater than or equal to 'a' and 'c' is strictly greater than 'b', 'r' holds between 'f(b)' and 'f(c)'.\nTranslate the statement in natural language to Lean:", "output": "theorem Nat.rel_of_forall_rel_succ_of_le_of_lt (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsTrans \u03b2 r] {f : \u2115 \u2192 \u03b2} {a : \u2115}\n    (h : \u2200 n, a \u2264 n \u2192 r (f n) (f (n + 1))) \u2983b c : \u2115\u2984 (hab : a \u2264 b) (hbc : b < c) :\n    r (f b) (f c) :="}
{"input": "Statement in natural language:\nThe function 'polarCoord.symm' has a Fr\u00e9chet derivative at a point 'p' in the real plane. The derivative is given by the continuous linear map corresponding to the matrix with entries 'cos p.2', '-p.1 * sin p.2', 'sin p.2', and 'p.1 * cos p.2'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFDerivAt_polarCoord_symm (p : \u211d \u00d7 \u211d) :\n    HasFDerivAt polarCoord.symm\n      (LinearMap.toContinuousLinearMap (Matrix.toLin (Basis.finTwoProd \u211d) (Basis.finTwoProd \u211d)\n        !![cos p.2, -p.1 * sin p.2; sin p.2, p.1 * cos p.2])) p :="}
{"input": "Statement in natural language:\nFor a function 'f' that maps from type \u03b1 to type \u03b2, a term 't' of type \u03b1, and a list 'ts' of type \u03b1, mapping 'f' over the list of permutations of 't' and 'ts' is equal to the list of permutations of 'f t' and the list obtained by mapping 'f' over 'ts'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_map_permutations'Aux (f : \u03b1 \u2192 \u03b2) (t : \u03b1) (ts : List \u03b1) :\n    map (map f) (permutations'Aux t ts) = permutations'Aux (f t) (map f ts) :="}
{"input": "Statement in natural language:\nFor a positive number y, the square root of x equals y if and only if the square of y equals x.\nTranslate the statement in natural language to Lean:", "output": "theorem sqrt_eq_iff_mul_self_eq_of_pos (h : 0 < y) : sqrt x = y \u2194 y * y = x :="}
{"input": "Statement in natural language:\nFor any set 's' of any type '\u03b1', 's' is countable if and only if the cardinality of 's' is less than aleph one.\nTranslate the statement in natural language to Lean:", "output": "theorem countable_iff_lt_aleph_one {\u03b1 : Type _} (s : Set \u03b1) : s.Countable \u2194 (#s) < aleph 1 :="}
{"input": "Statement in natural language:\nA function 'f' from '\u03b1' to the dual of '\u03b2' is antitone on a set 's' if and only if the function 'f' is monotone on the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem antitoneOn_toDual_comp_iff : AntitoneOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s :="}
{"input": "Statement in natural language:\nFor any given box I, there exists a sequence of boxes J indexed by natural numbers, such that for every natural number n, the closed interval of the box J at index n is a subset of the open interval of box I. Furthermore, the lower bound of the sequence of boxes J tends to the lower bound of box I, and the upper bound of the sequence of boxes J tends to the upper bound of box I.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_seq_mono_tendsto (I : Box \u03b9) :\n    \u2203 J : \u2115 \u2192o Box \u03b9,\n      (\u2200 n, Box.Icc (J n) \u2286 Box.Ioo I) \u2227\n        Tendsto (lower \u2218 J) atTop (\ud835\udcdd I.lower) \u2227 Tendsto (upper \u2218 J) atTop (\ud835\udcdd I.upper) :="}
{"input": "Statement in natural language:\nIf \u03b1 is a preconnected space and i is a dense inducing function, then \u03b2 is also a preconnected space.\nTranslate the statement in natural language to Lean:", "output": "theorem preconnectedSpace [PreconnectedSpace \u03b1] (di : DenseInducing i) :\n    PreconnectedSpace \u03b2 :="}
{"input": "Statement in natural language:\nIf a is congruent to b modulo p, then a minus c is congruent to b minus c modulo p.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_right (c : \u03b1) (h : a \u2261 b [PMOD p]) : a - c \u2261 b - c [PMOD p] :="}
{"input": "Statement in natural language:\nFor a pair 'p' from the product of two sets '\u03b1' and '\u03b2', and an element 'c' from set 'E', the power of 'p' to 'c' is equal to the pair formed by the power of the first element of 'p' to 'c' and the power of the second element of 'p' to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_def (p : \u03b1 \u00d7 \u03b2) (c : E) : p ^ c = (p.1 ^ c, p.2 ^ c) :="}
{"input": "Statement in natural language:\nA function `f` composed with a continuous linear equivalence `e` is continuously differentiable within a set `s` at the point `e.symm x` if and only if the function `f` itself is continuously differentiable within the set `s` at the point `x`. Here, `\ud835\udd5c` is the field over which the functions are defined and `n` is the order of differentiation.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousLinearEquiv.contDiffWithinAt_comp_iff (e : G \u2243L[\ud835\udd5c] E) :\n    ContDiffWithinAt \ud835\udd5c n (f \u2218 e) (e \u207b\u00b9' s) (e.symm x) \u2194 ContDiffWithinAt \ud835\udd5c n f s x :="}
{"input": "Statement in natural language:\nFor any element 'x' of type 'A', getting the constant from the object created by making 'x' a constant of type 'n' and 'A' is equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem const.get_mk (x : A) : const.get (const.mk n x : (const n A).Obj \u03b1) = x :="}
{"input": "Statement in natural language:\nThe ring R is of finite type over itself.\nTranslate the statement in natural language to Lean:", "output": "theorem self : FiniteType R R :="}
{"input": "Statement in natural language:\n\"0\" is a strictly multiplicative regular element in the algebraic structure M over the ring R if and only if M is a subsingleton.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_iff_subsingleton : IsSMulRegular M (0 : R) \u2194 Subsingleton M :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the norm of the difference between the (n + 1)th term and the nth term of the Newton sequence is equal to the ratio of the norm of the evaluation of the function 'F' at the nth term of the Newton sequence to the norm of the evaluation of the derivative of the function 'F' at the nth term of the Newton sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem newton_seq_norm_eq (n : \u2115) :\n    \u2016newton_seq (n + 1) - newton_seq n\u2016 =\n    \u2016F.eval (newton_seq n)\u2016 / \u2016F.derivative.eval (newton_seq n)\u2016 :="}
{"input": "Statement in natural language:\nIf a function 'c' has a strict derivative 'c'' at a point 'x', and a function 'd' has a strict derivative 'd'' at the same point 'x', then the composition of the function 'c' with the function 'd' also has a strict derivative at the point 'x'. This derivative is the sum of the composition of 'c'' with 'd' at 'x' and the composition of 'c' at 'x' with 'd''.\nTranslate the statement in natural language to Lean:", "output": "theorem HasStrictDerivAt.clm_comp (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :\n    HasStrictDerivAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x :="}
{"input": "Statement in natural language:\nIf an element 'a' belongs to set 's' and an element 'b' belongs to set 't', then the scalar multiplication of 'a' and 'b' belongs to the scalar multiplication of sets 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_mem_smul : a \u2208 s \u2192 b \u2208 t \u2192 a \u2022 b \u2208 s \u2022 t :="}
{"input": "Statement in natural language:\nIf a natural number 'n' is less than or equal to the ramification index of a function 'f', a prime 'p', and a prime ideal 'P', then the map of 'f' and 'p' is less than or equal to 'P' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_pow_of_le_ramificationIdx {n : \u2115} (hn : n \u2264 ramificationIdx f p P) :\n    map f p \u2264 P ^ n :="}
{"input": "Statement in natural language:\nIf two local equivalences 'e' and 'e'' are equivalent, then the restrictions of 'e' and 'e'' to a set 's' are also equivalent.\nTranslate the statement in natural language to Lean:", "output": "theorem EqOnSource.restr {e e' : LocalEquiv \u03b1 \u03b2} (he : e \u2248 e') (s : Set \u03b1) :\n    e.restr s \u2248 e'.restr s :="}
{"input": "Statement in natural language:\nA function 'g' is integrable with respect to the measure '\u03bc' mapped by a function 'f' if and only if the composition of 'g' and 'f' is integrable with respect to the measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem integrable_map_equiv (f : \u03b1 \u2243\u1d50 \u03b4) (g : \u03b4 \u2192 \u03b2) :\n    Integrable g (Measure.map f \u03bc) \u2194 Integrable (g \u2218 f) \u03bc :="}
{"input": "Statement in natural language:\nIf 'a' is the complement of 'b', then 'a' is equal to the negation of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCompl.eq_hnot (h : IsCompl a b) : a = \uffe2b :="}
{"input": "Statement in natural language:\nIn a ring R, if x is nilpotent, then its negation (-x) is also nilpotent.\nTranslate the statement in natural language to Lean:", "output": "theorem IsNilpotent.neg [Ring R] (h : IsNilpotent x) : IsNilpotent (-x) :="}
{"input": "Statement in natural language:\nIf an element 'a' belongs to the intersection of two finite sets 's\u2081' and 's\u2082', then 'a' belongs to the set 's\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_of_mem_inter_right {a : \u03b1} {s\u2081 s\u2082 : Finset \u03b1} (h : a \u2208 s\u2081 \u2229 s\u2082) : a \u2208 s\u2082 :="}
{"input": "Statement in natural language:\n'a' is equivalent to 'b' modulo 'p' if and only if the interval from 'a' to 'b' modulo 'p', where 'p' is positive, is equal to 'a' plus 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem modEq_iff_toIocMod_eq_right : a \u2261 b [PMOD p] \u2194 toIocMod hp a b = a + p :="}
{"input": "Statement in natural language:\nIf I and J are primary ideals in a ring R, and if the radical of I is equal to the radical of J, then the intersection of I and J is also a primary ideal.\nTranslate the statement in natural language to Lean:", "output": "theorem isPrimary_inf {I J : Ideal R} (hi : IsPrimary I) (hj : IsPrimary J)\n    (hij : radical I = radical J) : IsPrimary (I \u2293 J) :="}
{"input": "Statement in natural language:\nFor any two additive commutative monoids M and N, and a function 'f' from \u03b1 to the monoid homomorphisms from M to N, and any element 'a' of \u03b1, the composition of the liftAddHom function (with respect to \u03b1, M, and N) applied to 'f' and the singleAddHom function applied to 'a' is equal to the function 'f' applied to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem liftAddHom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : \u03b1 \u2192 M \u2192+ N) (a : \u03b1) :\n    ((liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)) f).comp (singleAddHom a) = f a :="}
{"input": "Statement in natural language:\nIf a property P lifts within a set s at a point x for a function g, and if the set s is in the neighborhood of x, then the property P lifts at the point x for the function g.\nTranslate the statement in natural language to Lean:", "output": "theorem liftPropAt_of_liftPropWithinAt (h : LiftPropWithinAt P g s x) (hs : s \u2208 \ud835\udcdd x) :\n    LiftPropAt P g x :="}
{"input": "Statement in natural language:\nA number x is in the closed interval between a and b if and only if x is greater than or equal to a and less than or equal to b.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_Icc : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b :="}
{"input": "Statement in natural language:\nA chain R exists from a to list l if and only if the following two conditions are met: \n1. For all h where h is less than the length of list l, R applies to a and the nth element of list l where n is 0.\n2. For all i and h where h is less than the length of list l minus 1, R applies to the ith element of list l and the (i+1)th element of list l. Here, i is derived from h being less than the predecessor of the length of list l.\nTranslate the statement in natural language to Lean:", "output": "theorem chain_iff_nthLe {R} {a : \u03b1} {l : List \u03b1} : Chain R a l \u2194\n        (\u2200 h : 0 < length l, R a (nthLe l 0 h)) \u2227\n          \u2200 (i) (h : i < length l - 1),\n            R (nthLe l i (lt_of_lt_pred h)) (nthLe l (i + 1) (lt_pred_iff.mp h)) :="}
{"input": "Statement in natural language:\nFor a given element 'x' in set 'S', 'x' being equal to zero in set 'A' is equivalent to 'x' being zero in set 'S'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_eq_zero {x : S} : (x : A) = 0 \u2194 x = 0 :="}
{"input": "Statement in natural language:\nFor any two functions, one from \u03b2 to \u03b3 and another from \u03b1 to \u03b2, the composition of the two functions after mapping over Sym2 is equal to the composition of the mapping of each function over Sym2.\nTranslate the statement in natural language to Lean:", "output": "theorem map_comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} : Sym2.map (g \u2218 f) = Sym2.map g \u2218 Sym2.map f :="}
{"input": "Statement in natural language:\nThe imaginary part of the negation of a quaternion 'a' is equal to the negation of the imaginary part of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_imI : (-a).imI = -a.imI :="}
{"input": "Statement in natural language:\nFor any summable family (s, t) of elements in the set of real numbers (R) indexed by a set (\u03b1) and ordered by a set (\u0393), the sum of the summable families at a particular index (a) is equal to the sum of the individual summable families at that same index.\nTranslate the statement in natural language to Lean:", "output": "theorem add_apply {s t : SummableFamily \u0393 R \u03b1} {a : \u03b1} : (s + t) a = s a + t a :="}
{"input": "Statement in natural language:\nFor any integer 'n' and any type '\u03b1' that can be cast to an integer, casting 'n' to '\u03b1' using the 'ofDual' function will result in 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofDual_intCast [IntCast \u03b1] (n : \u2124) : (ofDual n : \u03b1) = n :="}
{"input": "Statement in natural language:\nIn the context of a uniform space F and a uniform add group F, for a given set \ud835\udd16 of sets of E, the topological space derived from the strong uniformity of \u03c3, F, and \ud835\udd16 is equal to the strong topology of \u03c3, F, and \ud835\udd16.\nTranslate the statement in natural language to Lean:", "output": "theorem strongUniformity_topology_eq [UniformSpace F] [UniformAddGroup F] (\ud835\udd16 : Set (Set E)) :\n    (strongUniformity \u03c3 F \ud835\udd16).toTopologicalSpace = strongTopology \u03c3 F \ud835\udd16 :="}
{"input": "Statement in natural language:\nFor a non-zero scalar 's', 's' times 'x' is an element of 'p' if and only if 'x' is an element of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_mem_iff (s0 : s \u2260 0) : s \u2022 x \u2208 p \u2194 x \u2208 p :="}
{"input": "Statement in natural language:\nThe real number r, when converted to a non-negative extended real number, equals 1 if and only if r itself equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_eq_one : (\u2191r : \u211d\u22650\u221e) = 1 \u2194 r = 1 :="}
{"input": "Statement in natural language:\nFor any element 'x' from the ring 'R', the valuation of the negative of 'x' is equal to the valuation of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_neg (x : R) : v (-x) = v x :="}
{"input": "Statement in natural language:\nThe spectrum of a continuous function 'f' from a topological space 'X' to a field '\ud835\udd5c' is equal to the set of all possible values of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem spectrum_eq_range (f : C(X, \ud835\udd5c)) : spectrum \ud835\udd5c f = Set.range f :="}
{"input": "Statement in natural language:\nThe equivalence class of the negation of an element 'x' in the quotient space 'M / p' is equal to the negation of the equivalence class of 'x' in the same quotient space.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_neg : (mk (-x) : M \u29f8 p) = -(mk x : M \u29f8 p) :="}
{"input": "Statement in natural language:\nThe successor of the negative of the successor of a natural number n is equal to the negative of n.\nTranslate the statement in natural language to Lean:", "output": "theorem succ_neg_nat_succ (n : \u2115) : succ (-Nat.succ n) = -n :="}
{"input": "Statement in natural language:\nThe function 'toSubmonoid', which maps from a subgroup of G to a submonoid of G, is injective. This means that if two subgroups are mapped to the same submonoid by this function, then those two subgroups were originally the same. The proof of this theorem is not shown here.\nTranslate the statement in natural language to Lean:", "output": "theorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G \u2192 Submonoid G) :=\n  -- fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)"}
{"input": "Statement in natural language:\nIf 'x' is a fixed point of a function 'e', then 'x' is also a fixed point of the inverse function of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem equiv_symm (h : IsFixedPt e x) : IsFixedPt e.symm x :="}
{"input": "Statement in natural language:\nFor any nonempty directed set \u03b9, given a morphism F from the direct limit of a system (G, f) to a ring P, and any element x, the value of F at x is equal to the lift of the system (G, f) to P, composed with F, evaluated at x. This holds true for all i and j in \u03b9 such that i is less than or equal to j, and for all elements x, where the function of f is simplified.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_unique [Nonempty \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] (F : DirectLimit G f \u2192+* P) (x) :\n    F x = lift G f P (fun i => F.comp <| of G f i) (fun i j hij x => by simp [of_f]) x :="}
{"input": "Statement in natural language:\nFor any element 'a' and any element 'a'' with a corresponding value 'b'' of type \u03b2, and any associative list 's', 'a' is in the list resulting from inserting 'a'' and 'b'' into 's' if and only if 'a' is equal to 'a'' or 'a' is in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_insert {a a'} {b' : \u03b2 a'} (s : AList \u03b2) : a \u2208 insert a' b' s \u2194 a = a' \u2228 a \u2208 s :="}
{"input": "Statement in natural language:\nFor a given ring homomorphism 'f' from ring 'R' to ring 'S' and a polynomial 'p' with coefficients in 'R', the evaluation of the mapped polynomial at 1 is equal to the mapping of the evaluation of the original polynomial at 1.\nTranslate the statement in natural language to Lean:", "output": "theorem eval_one_map (f : R \u2192+* S) (p : R[X]) : (p.map f).eval 1 = f (p.eval 1) :="}
{"input": "Statement in natural language:\nIf the finite rank of a module V over a field K is equal to one, then the order of the submodule of V over a semiring A is simple. This is under the conditions that A is a semiring, V is a module over A, there is a scalar multiplication operation between K and A, and K, A, V form a scalar tower.\nTranslate the statement in natural language to Lean:", "output": "theorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A]\n    [IsScalarTower K A V] (h : finrank K V = 1) : IsSimpleOrder (Submodule A V) :="}
{"input": "Statement in natural language:\nThe application of the identity algebra homomorphism on a ring R and an algebra A is equal to the identity function.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_id : \u21d1(AlgHom.id R A) = id :="}
{"input": "Statement in natural language:\nFor any nonempty index set, the intersection of a set with the intersection over all sets indexed by the index set is equal to the intersection over all sets of the intersection of the set with each set indexed by the index set.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_iInter [Nonempty \u03b9] (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \u2229 \u22c2 i, t i) = \u22c2 i, s \u2229 t i :="}
{"input": "Statement in natural language:\nFor a countable index set \u03b2 and a function f from \u03b2 to the set of subsets of \u03b1, if every pair of sets in the image of f is disjoint and each set in the image of f is measurable, then the countable union of the sets in the image of f is also measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem has_iUnion {\u03b2} [Countable \u03b2] {f : \u03b2 \u2192 Set \u03b1} (hd : Pairwise (Disjoint on f))\n    (h : \u2200 i, d.Has (f i)) : d.Has (\u22c3 i, f i) :="}
{"input": "Statement in natural language:\nIf for a functor 'F' from category 'C' to category 'D', every object 'X' in 'C' is mapped to a zero object in 'D', then the functor 'F' itself is a zero functor.\nTranslate the statement in natural language to Lean:", "output": "theorem Functor.isZero (F : C \u2964 D) (hF : \u2200 X, IsZero (F.obj X)) : IsZero F :="}
{"input": "Statement in natural language:\nFor a topological space \u03b2, which is also a complete lattice and an order-closed topology with zero, and a measurable space that is an open measurable space, given a function i from natural numbers to \u03b2, a function f from \u03b1 to \u03b2, and an element a of \u03b1, if f is measurable and zero in \u03b2 is the bottom element, then the supremum over n of the application of the approximated function i to f at n and a is equal to the supremum over k of i at k, given that i at k is less than or equal to f at a.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_approx_apply [TopologicalSpace \u03b2] [CompleteLattice \u03b2] [OrderClosedTopology \u03b2] [Zero \u03b2]\n    [MeasurableSpace \u03b2] [OpensMeasurableSpace \u03b2] (i : \u2115 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (hf : Measurable f)\n    (h_zero : (0 : \u03b2) = \u22a5) : (\u2a06 n, (approx i f n : \u03b1 \u2192\u209b \u03b2) a) = \u2a06 (k) (_ : i k \u2264 f a), i k :="}
{"input": "Statement in natural language:\nIf a function 'f' is upper semicontinuous at a point 'x' within a set 's', and if another set 't' is a subset of 's', then the function 'f' is also upper semicontinuous at the point 'x' within the set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem UpperSemicontinuousWithinAt.mono (h : UpperSemicontinuousWithinAt f s x) (hst : t \u2286 s) :\n    UpperSemicontinuousWithinAt f t x :="}
{"input": "Statement in natural language:\nThe range function is monotone.\nTranslate the statement in natural language to Lean:", "output": "theorem range_mono : Monotone range :="}
{"input": "Statement in natural language:\nFor two functions 'f' and 'g' from '\u03b1' to '\u03b2' and a point 'a' in '\u03b1', if 'f' is eventually equal to 'g' in the neighborhood of 'a', then for all points 'y' in the neighborhood of 'a', 'f' is eventually equal to 'g' in the neighborhood of 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.EventuallyEq.eventuallyEq_nhds {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : f =\u1da0[\ud835\udcdd a] g) :\n    \u2200\u1da0 y in \ud835\udcdd a, f =\u1da0[\ud835\udcdd y] g :="}
{"input": "Statement in natural language:\nFor any given relation 'r' on some type '\u03b1' and any multiset 's' of quotients of 'r', there exists a multiset 't' of type '\u03b1' such that 's' is equal to the multiset obtained by mapping the function 'Quot.mk r' over 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_multiset_eq_map_quot_mk {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : Multiset (Quot r)) :\n    \u2203 t : Multiset \u03b1, s = t.map (Quot.mk r) :="}
{"input": "Statement in natural language:\nFor a non-unital non-associative semiring \u03b1, a matrix A with dimensions Fin l by Fin m, and a vector v of dimension Fin m, the right multiplication of the matrix A by the vector v is equal to the multiplication of the matrix A by the vector v.\nTranslate the statement in natural language to Lean:", "output": "theorem mulVec\u1d63_eq [NonUnitalNonAssocSemiring \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1) (v : Fin m \u2192 \u03b1) :\n    mulVec\u1d63 A v = A.mulVec v :="}
{"input": "Statement in natural language:\nIf for all indices 'i' and 'hi', the function 'f' is monotone, then the function 'nfpBFamily' parameterized by 'o' and 'f' is also monotone.\nTranslate the statement in natural language to Lean:", "output": "theorem nfpBFamily_monotone (hf : \u2200 i hi, Monotone (f i hi)) : Monotone (nfpBFamily.{u, v} o f) :="}
{"input": "Statement in natural language:\nFor any nonempty interval 's' of type '\u03b1', the corresponding set 's' of type '\u03b1' is also nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_nonempty (s : NonemptyInterval \u03b1) : (s : Set \u03b1).Nonempty :="}
{"input": "Statement in natural language:\nA set 's' is measurable in the supremum of a collection of measurable spaces (indexed by '\u03b9' and mapped by 'm') if and only if 's' is generated by the collection of sets that are measurable in some measurable space in the collection.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_iSup {\u03b9} {m : \u03b9 \u2192 MeasurableSpace \u03b1} {s : Set \u03b1} :\n    MeasurableSet[iSup m] s \u2194 GenerateMeasurable { s : Set \u03b1 | \u2203 i, MeasurableSet[m i] s } s :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from a module 'M' to itself, if 'f' is a projection on 'm', then the kernel of the codomain restriction of 'f' is equal to the kernel of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem codRestrict_ker {f : M \u2192\u2097[S] M} (h : IsProj m f) : ker h.codRestrict = ker f :="}
{"input": "Statement in natural language:\nIf the first element of a pair (x) is equal to the first element of another pair (y), then the pairs x and y are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_fst_eq_fst (h : (x : \u03b1 \u00d7 \u03b1).fst = (y : \u03b1 \u00d7 \u03b1).fst) : x = y :="}
{"input": "Statement in natural language:\nIn a contravariant class of type \u03b1, if 'a' is not the bottom element and 'a + b' is less than or equal to 'a + c', then 'b' is less than or equal to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_add_le_add_left [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a5)\n    (h : a + b \u2264 a + c) : b \u2264 c :="}
{"input": "Statement in natural language:\nIf 'b' is equivalent to 'a', then 'a' is equivalent to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem bihimp_bihimp_cancel_right : b \u21d4 a \u21d4 a = b :="}
{"input": "Statement in natural language:\nFor a function g from real numbers to a normed space F, and a real number R that is not equal to zero, the function g is integrable if and only if the function that maps x to g(x/R) is integrable.\nTranslate the statement in natural language to Lean:", "output": "theorem integrable_comp_div_iff (g : \u211d \u2192 F) {R : \u211d} (hR : R \u2260 0) :\n    (Integrable fun x => g (x / R)) \u2194 Integrable g :="}
{"input": "Statement in natural language:\nIf 'a' is the greatest lower bound of a set 's' and '\u03b5' is a positive number, then there exists a number 'b' in the set 's' such that 'b' is greater than or equal to 'a' and less than 'a + \u03b5'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsGLB.exists_between_self_add (h : IsGLB s a) (h\u03b5 : 0 < \u03b5) : \u2203 b \u2208 s, a \u2264 b \u2227 b < a + \u03b5 :="}
{"input": "Statement in natural language:\nThe functor \u0393 from some category to C is equal to the composition of the functor forgetToPresheafedSpace.op and the functor PresheafedSpace.\u0393.\nTranslate the statement in natural language to Lean:", "output": "theorem \u0393_def : (\u0393 : _ \u2964 C) = forgetToPresheafedSpace.op \u22d9 PresheafedSpace.\u0393 :="}
{"input": "Statement in natural language:\nIf the product of two filters 'f' and 'g' is not the bottom filter, then 'f' is not the bottom filter.\nTranslate the statement in natural language to Lean:", "output": "theorem NeBot.of_mul_left : (f * g).NeBot \u2192 f.NeBot :="}
{"input": "Statement in natural language:\nFor any given point 'y' in the set 'E' and any real number '\u03b5', the open ball centered at 'y' with radius '\u03b5' is equal to the set of all points 'x' such that the norm of 'x' divided by 'y' is less than '\u03b5'.\nTranslate the statement in natural language to Lean:", "output": "theorem ball_eq' (y : E) (\u03b5 : \u211d) : ball y \u03b5 = { x | \u2016x / y\u2016 < \u03b5 } :="}
{"input": "Statement in natural language:\nApplying the zero derivation (from a ring R to an A-module M) to any element (a) of A results in the zero element of M.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_apply (a : A) : (0 : Derivation R A M) a = 0 :="}
{"input": "Statement in natural language:\nIf we have two types J and K, both of which are categories, and two functors F and G from J and K respectively to a category C, and if the cones over F are isomorphic to the cones over G, then if F has a limit, G also has a limit.\nTranslate the statement in natural language to Lean:", "output": "theorem HasLimit.ofConesIso {J K : Type u\u2081} [Category.{v\u2081} J] [Category.{v\u2082} K] (F : J \u2964 C)\n    (G : K \u2964 C) (h : F.cones \u2245 G.cones) [HasLimit F] : HasLimit G :="}
{"input": "Statement in natural language:\nAn element 'x' belongs to the kernel of the cotangent map of 'I' if and only if this element, considered as an element of 'R', belongs to the square of 'I'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_toCotangent_ker {x : I} : x \u2208 LinearMap.ker I.toCotangent \u2194 (x : R) \u2208 I ^ 2 :="}
{"input": "Statement in natural language:\nFor a given type S, which is a commutative ring and a local ring, and a given ring homomorphism f from R to S, f is a local ring homomorphism if and only if the preimage of the closed point of S under the map f is equal to the closed point of R.\nTranslate the statement in natural language to Lean:", "output": "theorem isLocalRingHom_iff_comap_closedPoint {S : Type v} [CommRing S] [LocalRing S] (f : R \u2192+* S) :\n    IsLocalRingHom f \u2194 PrimeSpectrum.comap f (closedPoint S) = closedPoint R :="}
{"input": "Statement in natural language:\nThe inverse of the fraction formed by two integers 'a' and 'b' is equal to the fraction formed by 'b' and 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_def' {a b : \u2124} : (a /. b)\u207b\u00b9 = b /. a :="}
{"input": "Statement in natural language:\nFor two topological spaces X and Y that are isomorphic, and for presheaves \u2131 on Y and \ud835\udca2 on X, if there is a morphism from \u2131 to the pushforward of \ud835\udca2 along the isomorphism, then the application of the pushforward of the isomorphism and the morphism to an open set U in X is equal to the composition of the application of the morphism to the image of U under the inverse of the isomorphism and the mapping of \ud835\udca2 to the homomorphism induced by the equality of the preimage of the preimage of the open set under the isomorphism and the open set itself.\nTranslate the statement in natural language to Lean:", "output": "theorem pushforwardToOfIso_app {X Y : TopCat} (H\u2081 : X \u2245 Y) {\u2131 : Y.Presheaf C} {\ud835\udca2 : X.Presheaf C}\n    (H\u2082 : \u2131 \u27f6 H\u2081.hom _* \ud835\udca2) (U : (Opens X)\u1d52\u1d56) :\n    (pushforwardToOfIso H\u2081 H\u2082).app U =\n      H\u2082.app (op ((Opens.map H\u2081.inv).obj (unop U))) \u226b\n        \ud835\udca2.map (eqToHom (by simp [Opens.map, Set.preimage_preimage])) :="}
{"input": "Statement in natural language:\nFor a given ideal J of a ring P, where J is prime, and a given ring homomorphism f from ring R to P, the complement of the prime ideal I is less than or equal to the complement of the prime ideal J under the map f if and only if the preimage of J under f is less than or equal to I.\nTranslate the statement in natural language to Lean:", "output": "theorem le_comap_primeCompl_iff {J : Ideal P} [hJ : J.IsPrime] {f : R \u2192+* P} :\n    I.primeCompl \u2264 J.primeCompl.comap f \u2194 J.comap f \u2264 I :="}
{"input": "Statement in natural language:\nFor a given value 'x' in a preordered set '\u03b1' with no maximum order, the set of all elements greater than or equal to some value (atTop) is disjoint from the set of all elements less than or equal to 'x' (\ud835\udcdf (Iic x)).\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_atTop_principal_Iic [Preorder \u03b1] [NoMaxOrder \u03b1] (x : \u03b1) :\n    Disjoint atTop (\ud835\udcdf (Iic x)) :="}
{"input": "Statement in natural language:\nIf 'a' is less than or equal to 'b', then the union of the set of all numbers less than 'a' and the set of all numbers between 'a' and 'b' (inclusive) is equal to the set of all numbers less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Iio_union_Icc_eq_Iic (h : a \u2264 b) : Iio a \u222a Icc a b = Iic b :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set '\u03b1' and any integer 'm', the function 'toIocMod' applied to the sum of 'a' and the scalar product of 'm' and 'p' and 'b' is equal to the sum of the function 'toIocMod' applied to 'a' and 'b' and the scalar product of 'm' and 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem toIocMod_add_zsmul' (a b : \u03b1) (m : \u2124) :\n    toIocMod hp (a + m \u2022 p) b = toIocMod hp a b + m \u2022 p :="}
{"input": "Statement in natural language:\nFor a surjective function 'f' from group G to group H, if N is the kernel of 'f' and N is a torsion group, then group H is a torsion group if and only if group G is a torsion group.\nTranslate the statement in natural language to Lean:", "output": "theorem IsTorsion.quotient_iff {f : G \u2192* H} (hf : Function.Surjective f) (hN : N = f.ker)\n    (tN : IsTorsion N) : IsTorsion H \u2194 IsTorsion G :="}
{"input": "Statement in natural language:\nIn a NoMaxOrder (an ordered set where no maximum element exists), the set of all elements greater than a given element 'a' is connected.\nTranslate the statement in natural language to Lean:", "output": "theorem isConnected_Ioi [NoMaxOrder \u03b1] : IsConnected (Ioi a) :="}
{"input": "Statement in natural language:\nFor a category 'C' that has equalizers, given a set '\ud835\udca2' in 'C', if '\ud835\udca2' is a detecting set, then '\ud835\udca2' is also a separating set.\nTranslate the statement in natural language to Lean:", "output": "theorem IsDetecting.isSeparating [HasEqualizers C] {\ud835\udca2 : Set C} (h\ud835\udca2 : IsDetecting \ud835\udca2) :\n    IsSeparating \ud835\udca2 :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, given that \u03b1 is infinite, the cardinality of the sum of \u03b1 and \u03b2 is equal to the maximum of the cardinalities of \u03b1 and \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem add_mk_eq_max {\u03b1 \u03b2 : Type _} [Infinite \u03b1] : (#\u03b1) + (#\u03b2) = max (#\u03b1) (#\u03b2) :="}
{"input": "Statement in natural language:\nFor two ring homomorphisms 'f' and 'g' from a ring 'R' to a ring 'S', and a set 's' of elements from 'R', if 'f' and 'g' are equal on the set 's', then 'f' and 'g' are also equal on the closure of the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem eqOn_sclosure {f g : R \u2192+* S} {s : Set R} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :="}
{"input": "Statement in natural language:\nFor any three points p1, p2, and p3, where p1 is not equal to p2 and p3 is not equal to p2, the distance from p1 to p3 is equal to the sum of the distance from p1 to p2 and the distance from p3 to p2 if and only if the unoriented angle between p1, p2, and p3 is equal to pi.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_eq_add_dist_iff_angle_eq_pi {p1 p2 p3 : P} (hp1p2 : p1 \u2260 p2) (hp3p2 : p3 \u2260 p2) :\n    dist p1 p3 = dist p1 p2 + dist p3 p2 \u2194 \u2220 p1 p2 p3 = \u03c0 :="}
{"input": "Statement in natural language:\nFor any type G that forms a group, given two group actions f\u2081 and f\u2082 from G to CircleDeg1Lift (a type of group action on the circle), if for all elements g in G the translation number of f\u2081 g equals the translation number of f\u2082 g, then there exists a semiconjugacy F from CircleDeg1Lift such that for all elements g in G, F semiconjugates f\u2081 g to f\u2082 g.\nTranslate the statement in natural language to Lean:", "output": "theorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type _} [Group G]\n    (f\u2081 f\u2082 : G \u2192* CircleDeg1Lift) (h : \u2200 g, \u03c4 (f\u2081 g) = \u03c4 (f\u2082 g)) :\n    \u2203 F : CircleDeg1Lift, \u2200 g, Semiconj F (f\u2081 g) (f\u2082 g) :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from a set '\u03b9' to a set '\u03b1', and a set 's' of '\u03b9' that is finite, if every element 'b' in 's' maps to a null measurable set under 'f' with respect to a measure '\u03bc', then the intersection of all these mapped sets is also a null measurable set with respect to the same measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Set.Finite.nullMeasurableSet_biInter {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b9} (hs : s.Finite)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c2 b \u2208 s, f b) \u03bc :="}
{"input": "Statement in natural language:\nFor all elements x in the union of list 1 and list 2, the property p holds if and only if for all elements x in list 1, the property p holds and for all elements x in list 2, the property p holds.\nTranslate the statement in natural language to Lean:", "output": "theorem forall_mem_union : (\u2200 x \u2208 l\u2081 \u222a l\u2082, p x) \u2194 (\u2200 x \u2208 l\u2081, p x) \u2227 \u2200 x \u2208 l\u2082, p x :="}
{"input": "Statement in natural language:\nThe image of the set of elements greater than 'a' under the embedding of a subtype 'p' is equal to the set of elements greater than 'a' in the finset '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_subtype_embedding_Ioi : (Ioi a).map (Embedding.subtype p) = (Ioi a : Finset \u03b1) :="}
{"input": "Statement in natural language:\nFor a measure \u03bc, a function f that is measurable, another function g, and a set s that is measurable, if for almost every x in the restriction of \u03bc to s, f(x) is less than infinity, then the integral over s of g with respect to the measure with density f is equal to the integral over s of the product of f and g with respect to \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (f_meas : Measurable f) (g : \u03b1 \u2192 \u211d\u22650\u221e) {s : Set \u03b1} (hs : MeasurableSet s)\n    (hf : \u2200\u1d50 x \u2202\u03bc.restrict s, f x < \u221e) :\n    (\u222b\u207b a in s, g a \u2202\u03bc.withDensity f) = \u222b\u207b a in s, (f * g) a \u2202\u03bc :="}
{"input": "Statement in natural language:\nFor any given number 'n', the function that converts a vector to a list (Vector.toList) is computable.\nTranslate the statement in natural language to Lean:", "output": "theorem vector_toList {n} : Computable (@Vector.toList \u03b1 n) :="}
{"input": "Statement in natural language:\nFor a given index set \u03b9, if we have a family of submodules V of an inner product space E over a field \ud835\udd5c, such that this family is orthogonal (meaning that the inner product of any two distinct submodules is zero), and the closure of the union of all submodules in the family is a complete set, then the direct sum of the submodules is an internal direct sum if and only if the orthogonal complement of the closure of the union of all submodules is the zero subspace.\nTranslate the statement in natural language to Lean:", "output": "theorem OrthogonalFamily.isInternal_iff_of_isComplete [DecidableEq \u03b9] {V : \u03b9 \u2192 Submodule \ud835\udd5c E}\n    (hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62)\n    (hc : IsComplete (\u2191(iSup V) : Set E)) : DirectSum.IsInternal V \u2194 (iSup V)\u15ee = \u22a5 :="}
{"input": "Statement in natural language:\nFor any given types R and A, where R is a commutative semiring and A is a semiring with an algebra structure over R, the bottom element of the subalgebra of R in A, when converted to a submodule, is finitely generated.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Subalgebra.fg_bot_toSubmodule {R A : Type _} [CommSemiring R] [Semiring A]\n    [Algebra R A] : (\u22a5 : Subalgebra R A).toSubmodule.FG :="}
{"input": "Statement in natural language:\nFor a property 'p' pertaining to a set of elements of type '\u03b1', if 's' is a subsingleton set (a set with at most one element), and if the property 'p' holds for the empty set and for any set containing exactly one element, then the property 'p' also holds for the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Subsingleton.induction_on {p : Set \u03b1 \u2192 Prop} (hs : s.Subsingleton) (he : p \u2205)\n    (h\u2081 : \u2200 x, p {x}) : p s :="}
{"input": "Statement in natural language:\nIf the rank of a module V over a field K is zero, then the finite dimension (finrank) of V over K is also zero. This is under the condition that V is finite-dimensional over K.\nTranslate the statement in natural language to Lean:", "output": "theorem finrank_eq_zero_of_rank_eq_zero [FiniteDimensional K V] (h : Module.rank K V = 0) :\n    finrank K V = 0 :="}
{"input": "Statement in natural language:\nFor any natural number N and any element \u03b3 of the group Gamma0 N, \u03b3 is an element of the group Gamma1' N if and only if the Gamma0Map of N applied to \u03b3 equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem Gamma1_mem' (N : \u2115) (\u03b3 : Gamma0 N) : \u03b3 \u2208 Gamma1' N \u2194 (Gamma0Map N) \u03b3 = 1 :="}
{"input": "Statement in natural language:\nFor a function 'f' from the lp space with infinity norm, and a natural number 'n', the nth power of the function 'f' is equal to the function 'f' raised to the nth power.\nTranslate the statement in natural language to Lean:", "output": "theorem infty_coeFn_pow (f : lp B \u221e) (n : \u2115) : \u21d1(f ^ n) = (\u21d1f) ^ n :="}
{"input": "Statement in natural language:\nFor any two vertices 'v' and 'w' in a graph 'G', the set of common neighbors of 'v' and 'w' is the same as the set of common neighbors of 'w' and 'v'. In other words, the common neighbors of two vertices in a graph are symmetric with respect to the vertices.\nTranslate the statement in natural language to Lean:", "output": "theorem commonNeighbors_symm (v w : V) : G.commonNeighbors v w = G.commonNeighbors w v :="}
{"input": "Statement in natural language:\nA module 'm' is in the supremum of a chain of submodules 'a' indexed by natural numbers if and only if there exists a natural number 'k' such that 'm' is in the submodule 'a' at index 'k'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_iSup_of_chain (a : \u2115 \u2192o Submodule R M) (m : M) : (m \u2208 \u2a06 k, a k) \u2194 \u2203 k, m \u2208 a k :="}
{"input": "Statement in natural language:\nFor a set 's' of subsets of a type '\u03b1', given a topological space 't' and a second countable topology on '\u03b1', if 't' is generated from 's', then the Borel \u03c3-algebra on '\u03b1' is also generated from 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem borel_eq_generateFrom_of_subbasis {s : Set (Set \u03b1)} [t : TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] (hs : t = .generateFrom s) : borel \u03b1 = .generateFrom s :="}
{"input": "Statement in natural language:\nFor any set s in a normed space E, and any non-negative real numbers \u03b5 and \u03b4, the \u03b5-thickening of the \u03b4-thickening of s is equal to the (\u03b5 + \u03b4)-thickening of s.\nTranslate the statement in natural language to Lean:", "output": "theorem cthickening_cthickening (h\u03b5 : 0 \u2264 \u03b5) (h\u03b4 : 0 \u2264 \u03b4) (s : Set E) :\n    cthickening \u03b5 (cthickening \u03b4 s) = cthickening (\u03b5 + \u03b4) s :="}
{"input": "Statement in natural language:\nFor any element 'x' of type '\u03b1' that is not a member of set 's', and for any finite set 't' of type '\u03b1', the set difference of 's' and the set obtained by inserting 'x' into 't' is equal to the set difference of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem sdiff_insert_of_not_mem {x : \u03b1} (h : x \u2209 s) (t : Finset \u03b1) : s \\ insert x t = s \\ t :="}
{"input": "Statement in natural language:\nA property 'p' holds eventually for all elements 'x' in the supremum (or join) of two filters 'f' and 'g' if and only if the property 'p' holds eventually for all elements 'x' in both filters 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem eventually_sup {p : \u03b1 \u2192 Prop} {f g : Filter \u03b1} :\n    (\u2200\u1da0 x in f \u2294 g, p x) \u2194 (\u2200\u1da0 x in f, p x) \u2227 \u2200\u1da0 x in g, p x :="}
{"input": "Statement in natural language:\nFor any real number x and for any two real numbers y and z, if z divides y, then the result of multiplying x with y and then dividing by z is equal to the result of multiplying x with the result of dividing y by z.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_div_assoc (x : R) {y z : R} (h : z \u2223 y) : x * y / z = x * (y / z) :="}
{"input": "Statement in natural language:\nThe map of a prime number 'p' through a function 'f' is less than or equal to the prime number 'P' raised to the power of the ramification index of the function 'f' at 'p' and 'P'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_pow_ramificationIdx : map f p \u2264 P ^ ramificationIdx f p P :="}
{"input": "Statement in natural language:\nFor any type D that is a category and preadditive, and any functor F from C to D that is additive, the composition of the alternating face map complex of C and the map of the homological complex by F is equal to the composition of the whiskering of the simplicial object from C to D by F and the alternating face map complex of D.\nTranslate the statement in natural language to Lean:", "output": "theorem map_alternatingFaceMapComplex {D : Type _} [Category D] [Preadditive D] (F : C \u2964 D)\n    [F.Additive] :\n    alternatingFaceMapComplex C \u22d9 F.mapHomologicalComplex _ =\n      (SimplicialObject.whiskering C D).obj F \u22d9 alternatingFaceMapComplex D :="}
{"input": "Statement in natural language:\nFor any two affine isometries 'f' and 'g' from 'P' to 'P\u2082', if for every 'x', 'f' at 'x' equals 'g' at 'x', then 'f' equals 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {f g : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082} (h : \u2200 x, f x = g x) : f = g :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from some type '\u03b1' to natural numbers, a function 'g' from '\u03b1' to some type '\u03c3', and a function 'h' from '\u03b1' and natural numbers to '\u03c3', and if all these functions are computable, then the function that takes an element of type '\u03b1' and applies the natural number cases on the result of 'f' applied to that element, with 'g' and 'h' as the case functions, is also computable.\nTranslate the statement in natural language to Lean:", "output": "theorem nat_casesOn {f : \u03b1 \u2192 \u2115} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u2115 \u2192 \u03c3} (hf : Computable f) (hg : Computable g)\n    (hh : Computable\u2082 h) :\n    Computable fun a => Nat.casesOn (motive := fun _ => \u03c3) (f a) (g a) (h a) :="}
{"input": "Statement in natural language:\n'x is inseparable from y' if and only if for every open set 's' in the topological space 'X', 'x' is in 's' if and only if 'y' is in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem inseparable_iff_forall_open : (x ~\u1d62 y) \u2194 \u2200 s : Set X, IsOpen s \u2192 (x \u2208 s \u2194 y \u2208 s) :="}
{"input": "Statement in natural language:\nFor any function from \u03b1 to \u03b2 and any filter on \u03b1, the filter on \u03b1 is less than or equal to the preimage of the top filter under the function.\nTranslate the statement in natural language to Lean:", "output": "theorem le_comap_top (f : \u03b1 \u2192 \u03b2) (l : Filter \u03b1) : l \u2264 comap f \u22a4 :="}
{"input": "Statement in natural language:\nFor a commutative monoid \u03b2 and a function f from the finite set of 3 elements to \u03b2, the product of the function values over all elements in the set is equal to the product of the function values at 0, 1, and 2.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_univ_three [CommMonoid \u03b2] (f : Fin 3 \u2192 \u03b2) : (\u220f i, f i) = f 0 * f 1 * f 2 :="}
{"input": "Statement in natural language:\nFor any operation 'op' on types '\u03b1' and '\u03b2', if 'op' is a symmetric operation, then the flipped operation is equal to the original operation.\nTranslate the statement in natural language to Lean:", "output": "theorem IsSymmOp.flip_eq {\u03b1 \u03b2} (op) [IsSymmOp \u03b1 \u03b2 op] : flip op = op :="}
{"input": "Statement in natural language:\nIf we have a nonempty set 's' in a field 'k' of characteristic zero with a finite type '\u03b9', then the sum of the centroid weights indicators of 's' over all 'i' equals one.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_centroidWeightsIndicator_eq_one_of_nonempty [CharZero k] [Fintype \u03b9] (h : s.Nonempty) :\n    (\u2211 i, s.centroidWeightsIndicator k i) = 1 :="}
{"input": "Statement in natural language:\nFor any element 'a' in group 'G', the inverse of 'a' in 'G' is equal to the inverse of 'a' in quotient group 'Q'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_inv (a : G) : ((a\u207b\u00b9 : G) : Q ) = (a : Q)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor any type \u03b9 that is finite, and any basis b of a module M over a ring R, the range of the evaluation map in the dual space of M is the entire dual space.\nTranslate the statement in natural language to Lean:", "output": "theorem eval_range {\u03b9 : Type _} [Finite \u03b9] (b : Basis \u03b9 R M) :\n    LinearMap.range (Dual.eval R M) = \u22a4 :="}
{"input": "Statement in natural language:\nFor any indexed set of subsets of E (denoted by s), if the set s is directed under the subset relation and each subset in s is convex, then the union of all subsets in s is also convex.\nTranslate the statement in natural language to Lean:", "output": "theorem Directed.convex_iUnion {\u03b9 : Sort _} {s : \u03b9 \u2192 Set E} (hdir : Directed (\u00b7 \u2286 \u00b7) s)\n    (hc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)) : Convex \ud835\udd5c (\u22c3 i, s i) :="}
{"input": "Statement in natural language:\nIf a set 't' is open, then the left division of another set 's' by 't' is also open.\nTranslate the statement in natural language to Lean:", "output": "theorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t) :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the value of one divided by ('n' plus one) is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem one_div_pos_of_nat {n : \u2115} : 0 < 1 / ((n : \u03b1) + 1) :="}
{"input": "Statement in natural language:\nIn an additive zero class with a preorder and a covariant class, for any two elements x and y such that both are greater than or equal to zero, the sum of x and y (with the proof that their sum is nonnegative) is equal to the sum of the elements x and y themselves.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_add_mk [AddZeroClass \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {x y : \u03b1}\n    (hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) + \u27e8y, hy\u27e9 = \u27e8x + y, add_nonneg hx hy\u27e9 :="}
{"input": "Statement in natural language:\nFor a function F from the symmetric square of a type \u03b1 to a type \u03b2, and for any two elements a\u2081 and a\u2082 of type \u03b1, the application of the inverse lift of F to a\u2081 and a\u2082 is equal to the application of F to the unordered pair of a\u2081 and a\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_lift_symm_apply (F : Sym2 \u03b1 \u2192 \u03b2) (a\u2081 a\u2082 : \u03b1) :\n    (lift.symm F : \u03b1 \u2192 \u03b1 \u2192 \u03b2) a\u2081 a\u2082 = F \u27e6(a\u2081, a\u2082)\u27e7 :="}
{"input": "Statement in natural language:\nThe norm of the equivalent real product of a complex number z is less than or equal to the absolute value of z.\nTranslate the statement in natural language to Lean:", "output": "theorem equivRealProd_apply_le (z : \u2102) : \u2016equivRealProd z\u2016 \u2264 abs z :="}
{"input": "Statement in natural language:\nFor a property 'p' that applies to multisets of type '\u03b1', and a multiset 's' of the same type, if the property 'p' holds for the empty multiset, and if for any element 'a' and any multiset 's', the property 'p' holds for all multisets 't' that are less than or equal to 's', then the property 'p' also holds for the multiset 's'. This is a form of strong induction on multisets.\nTranslate the statement in natural language to Lean:", "output": "theorem case_strongInductionOn {p : Multiset \u03b1 \u2192 Prop} (s : Multiset \u03b1) (h\u2080 : p 0)\n    (h\u2081 : \u2200 a s, (\u2200 t \u2264 s, p t) \u2192 p (a ::\u2098 s)) : p s :="}
{"input": "Statement in natural language:\nA singleton set (containing only one element) is a subset of set 's' if and only if that one element is an element of set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem one_subset : (1 : Finset \u03b1) \u2286 s \u2194 (1 : \u03b1) \u2208 s :="}
{"input": "Statement in natural language:\nThe image of the function that negates each element in the set of all elements greater than or equal to a certain value 'a', is equal to the set of all elements less than or equal to the negation of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_neg_Ici : Neg.neg '' Ici a = Iic (-a) :="}
{"input": "Statement in natural language:\nThe image of a parallelepiped under a linear transformation is a parallelepiped. Specifically, if 'f' is a linear transformation from 'E' to 'F', and 'v' is a function that maps from an index set '\u03b9' to 'E', then the image of the parallelepiped defined by 'v' under 'f' is the same as the parallelepiped defined by the composition of 'f' and 'v'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_parallelepiped (f : E \u2192\u2097[\u211d] F) (v : \u03b9 \u2192 E) :\n    f '' parallelepiped v = parallelepiped (f \u2218 v) :="}
{"input": "Statement in natural language:\nFor any real number x, if x is greater than or equal to 0 and less than or equal to 1, then x is less than or equal to the sine of (\u03c0/2 times x).\nTranslate the statement in natural language to Lean:", "output": "theorem le_sin_mul {x : \u211d} (hx : 0 \u2264 x) (hx' : x \u2264 1) : x \u2264 sin (\u03c0 / 2 * x) :="}
{"input": "Statement in natural language:\nFor any type '\u03b1', any function 'g' from 'F \u03b1' to '\u03b1', any 'a' in 'q.P.A', and any function 'f' from 'q.P.B a' to 'q.P.W', the recursive function 'recF' applied to 'g' and the pair '\u27e8a, f\u27e9' is equal to 'g' applied to the absolute value of the functor 'recF g' mapped over the pair '\u27e8a, f\u27e9'.\nTranslate the statement in natural language to Lean:", "output": "theorem recF_eq' {\u03b1 : Type _} (g : F \u03b1 \u2192 \u03b1) (a : q.P.A) (f : q.P.B a \u2192 q.P.W) :\n    recF g \u27e8a, f\u27e9 = g (abs (recF g <$> \u27e8a, f\u27e9)) :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements in field 'K' and a subfield 't' of 'K', the closure of 's' is less than or equal to 't' if and only if 's' is a subset of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_le {s : Set K} {t : Subfield K} : closure s \u2264 t \u2194 s \u2286 t :="}
{"input": "Statement in natural language:\nFor a given Baer module 'h' over a ring 'R' and a quotient ring 'Q', and for any element 'y' of a module 'N' and an element 'r' of the ring 'R' such that 'r' times 'y' is in the domain of the extension of the maximum ideal 'i' by a function 'f', the extension of the ideal 'i' to the Baer module 'h' by the function 'f' at the elements 'y' and 'r' is equal to the linear map to the extension of the maximum ideal 'i' by the function 'f' at the pair consisting of 'r' times 'y' and the fact that 'r' times 'y' is in the domain of the extension.\nTranslate the statement in natural language to Lean:", "output": "theorem ExtensionOfMaxAdjoin.extendIdealTo_eq (h : Module.Baer R Q) {y : N} (r : R)\n    (hr : r \u2022 y \u2208 (extensionOfMax i f).domain) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r =\n    (extensionOfMax i f).toLinearPMap \u27e8r \u2022 y, hr\u27e9 :="}
{"input": "Statement in natural language:\nIf you have four continuous functions A, B, C, and D, each mapping from a set X to matrices of real numbers of different dimensions, then the function that maps each element of X to the block matrix formed by the matrices A(x), B(x), C(x), and D(x) is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.matrix_fromBlocks {A : X \u2192 Matrix n l R} {B : X \u2192 Matrix n m R}\n    {C : X \u2192 Matrix p l R} {D : X \u2192 Matrix p m R} (hA : Continuous A) (hB : Continuous B)\n    (hC : Continuous C) (hD : Continuous D) :\n    Continuous fun x => Matrix.fromBlocks (A x) (B x) (C x) (D x) :="}
{"input": "Statement in natural language:\nThe set of all integers from 'a' inclusive to 'b' exclusive is a subset of the set of all integers less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ico_subset_Iic_self : Ico a b \u2286 Iic b :="}
{"input": "Statement in natural language:\nThe reflection of an algebraic equivalence between A\u2081 and itself is equal to the identity algebraic homomorphism from R to A\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem refl_toAlgHom : \u2191(refl : A\u2081 \u2243\u2090[R] A\u2081) = AlgHom.id R A\u2081 :="}
{"input": "Statement in natural language:\nFor a topological space G\u2080 with a T1 space structure, given two functions f and g from a set \u03b1 to G\u2080, a filter l on \u03b1, and two elements x and y in G\u2080 such that the function g tends towards y under the filter l and y is not equal to zero, the function that maps each element n in \u03b1 to the product of f(n) and g(n) tends towards x*y under the filter l if and only if the function f tends towards x under the filter l.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.tendsto_mul_iff_of_ne_zero [T1Space G\u2080] {f g : \u03b1 \u2192 G\u2080} {l : Filter \u03b1} {x y : G\u2080}\n    (hg : Tendsto g l (\ud835\udcdd y)) (hy : y \u2260 0) :\n    Tendsto (fun n => f n * g n) l (\ud835\udcdd <| x * y) \u2194 Tendsto f l (\ud835\udcdd x) :="}
{"input": "Statement in natural language:\nThe function 'removeNth', which removes the 'i'-th element from a vector of length 'n + 1', is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_removeNth {n : \u2115} {i : Fin (n + 1)} :\n    Continuous (removeNth i : Vector \u03b1 (n + 1) \u2192 Vector \u03b1 n) :="}
{"input": "Statement in natural language:\nFor a list L of transvection structures, the product of the matrices corresponding to the elements in L, when multiplied by the product of the matrices corresponding to the inverse of the elements in the reversed list L, equals the identity matrix.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_mul_reverse_inv_prod (L : List (TransvectionStruct n R)) :\n    (L.map toMatrix).prod \u2b1d (L.reverse.map (toMatrix \u2218 TransvectionStruct.inv)).prod = 1 :="}
{"input": "Statement in natural language:\nThe imaginary part function is an open map.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpenMap_im : IsOpenMap im :="}
{"input": "Statement in natural language:\nFor a given type R, which is a complete linear order, and a function f from \u03b9 to R, if the supremum of f(i) over all i is not in the range of f, then the union of the intervals closed below by f(i) for all i is equal to the interval open above by the supremum of f(i) over all i.\nTranslate the statement in natural language to Lean:", "output": "theorem iUnion_Iic_eq_Iio_iSup {R : Type _} [CompleteLinearOrder R] {f : \u03b9 \u2192 R}\n    (no_greatest_elem : (\u2a06 i, f i) \u2209 range f) : (\u22c3 i : \u03b9, Iic (f i)) = Iio (\u2a06 i, f i) :="}
{"input": "Statement in natural language:\nIf r is not equal to zero, then the single-valued function of a and r is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem single_ne_zero (h : r \u2260 0) : single a r \u2260 0 :="}
{"input": "Statement in natural language:\nThere exists a member 'y' in the target of 'e' such that property 'p' holds for 'y' if and only if there exists a member 'x' in the source of 'e' such that property 'p' holds for the application of 'e' to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_mem_target {p : \u03b2 \u2192 Prop} : (\u2203 y \u2208 e.target, p y) \u2194 \u2203 x \u2208 e.source, p (e x) :="}
{"input": "Statement in natural language:\nIf function f is continuous, function g is continuous, and for all x, either f(x) is not equal to zero or g(x) is greater than zero, then the function that maps x to f(x) raised to the power of g(x) is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.rpow (hf : Continuous f) (hg : Continuous g) (h : \u2200 x, f x \u2260 0 \u2228 0 < g x) :\n    Continuous fun x => f x ^ g x :="}
{"input": "Statement in natural language:\nFor a function 'f' from structure 'M' to structure 'N' in the language 'L', the mapping of 'f' is monotone.\nTranslate the statement in natural language to Lean:", "output": "theorem monotone_map {f : M \u2192[L] N} : Monotone (map f) :="}
{"input": "Statement in natural language:\nFor any path 'p' from point 'a' to point 'b', and for any point 'c' with a path 'q' from 'b' to 'c', the list of the composite path from 'a' to 'c' is equal to the concatenation of the list of path 'q' and the list of path 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem toList_comp (p : Path a b) : \u2200 {c} (q : Path b c), (p.comp q).toList = q.toList ++ p.toList"}
{"input": "Statement in natural language:\nThe topological support of the derivative of a function f is a subset of the topological support of the function f itself.\nTranslate the statement in natural language to Lean:", "output": "theorem tsupport_fderiv_subset : tsupport (fderiv \ud835\udd5c f) \u2286 tsupport f :="}
{"input": "Statement in natural language:\nIf 'a' is the least element in set 's' and 'b' is also the least element in set 's', then 'a' and 'b' must be equal.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLeast.unique (Ha : IsLeast s a) (Hb : IsLeast s b) : a = b :="}
{"input": "Statement in natural language:\nFor any element 'm' from set M and any element 'r' from set R, the right identity of the tensor product of 'm' and 'r' is equal to 'r' scaled by 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem rid_tmul (m : M) (r : R) : (TensorProduct.rid R M) (m \u2297\u209c r) = r \u2022 m :="}
{"input": "Statement in natural language:\nIf \u03bc is left-invariant under multiplication, then the function that takes a pair of elements from group G and divides the first by the second is quasi-measure-preserving with respect to the product measure of \u03bc and \u03bd, and \u03bc itself.\nTranslate the statement in natural language to Lean:", "output": "theorem quasiMeasurePreserving_div [IsMulLeftInvariant \u03bc] :\n    QuasiMeasurePreserving (fun p : G \u00d7 G => p.1 / p.2) (\u03bc.prod \u03bd) \u03bc :="}
{"input": "Statement in natural language:\nIf I and J are submodules of a ring R over a field P, and if both I and J are fractional ideals of a multiplicative set S, then the supremum (or join) of I and J is also a fractional ideal of S.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.IsFractional.sup {I J : Submodule R P} :\n    IsFractional S I \u2192 IsFractional S J \u2192 IsFractional S (I \u2294 J)"}
{"input": "Statement in natural language:\nFor a set 't' of type \u03b1 and an element 'x' of type \u03b1, given that the neighborhood of 'x' is countably generated, if 'x' is the greatest lower bound of 't' and 't' is nonempty, then there exists a sequence 'u' of elements of type \u03b1 such that 'u' is antitone (i.e., it is a decreasing sequence), 'x' is less than or equal to every element of 'u', 'u' tends to 'x' as it approaches infinity, and every element of 'u' belongs to 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsGLB.exists_seq_antitone_tendsto {t : Set \u03b1} {x : \u03b1} [IsCountablyGenerated (\ud835\udcdd x)]\n    (htx : IsGLB t x) (ht : t.Nonempty) :\n    \u2203 u : \u2115 \u2192 \u03b1, Antitone u \u2227 (\u2200 n, x \u2264 u n) \u2227 Tendsto u atTop (\ud835\udcdd x) \u2227 \u2200 n, u n \u2208 t :="}
{"input": "Statement in natural language:\nA space is locally connected if and only if for every point and for every neighborhood of that point, there exists a subset of the neighborhood that is open, contains the point, and is connected.\nTranslate the statement in natural language to Lean:", "output": "theorem locallyConnectedSpace_iff_open_connected_subsets :\n    LocallyConnectedSpace \u03b1 \u2194\n      \u2200 x, \u2200 U \u2208 \ud835\udcdd x, \u2203 V : Set \u03b1, V \u2286 U \u2227 IsOpen V \u2227 x \u2208 V \u2227 IsConnected V :="}
{"input": "Statement in natural language:\nThe function F tends towards the product of p and the principal filter of s, converging to c if and only if F tends uniformly on the function that maps every element to c, with respect to p and s.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_prod_principal_iff {c : \u03b2} :\n    Tendsto (\u21bfF) (p \u00d7\u02e2 \ud835\udcdf s) (\ud835\udcdd c) \u2194 TendstoUniformlyOn F (fun _ => c) p s :="}
{"input": "Statement in natural language:\nFor any list of Sigma types, the function 'dlookup' applied to an element 'a' and the list is 'Some' if and only if 'a' is in the keys of the list.\nTranslate the statement in natural language to Lean:", "output": "theorem dlookup_isSome {a : \u03b1} : \u2200 {l : List (Sigma \u03b2)}, (dlookup a l).isSome \u2194 a \u2208 l.keys"}
{"input": "Statement in natural language:\nApplying the functor of the Karoubi chain complex equivalence to N\u2082 is equivalent to embedding the Karoubi functor category into the opposite Simplex category, then applying N\u2081, the functor of the Karoubi chain complex equivalence to the Karoubi category, and finally applying the inverse of the equivalence between the Karoubi and Karoubi categories to the homological complex functor.\nTranslate the statement in natural language to Lean:", "output": "theorem compatibility_N\u2082_N\u2081_karoubi :\n    N\u2082 \u22d9 (karoubiChainComplexEquivalence C \u2115).functor =\n      karoubiFunctorCategoryEmbedding SimplexCategory\u1d52\u1d56 C \u22d9\n        N\u2081 \u22d9 (karoubiChainComplexEquivalence (Karoubi C) \u2115).functor \u22d9\n            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ :="}
{"input": "Statement in natural language:\nIf a function 'f' from '\u03b1' to '\u03b2' is an embedding, then 'f' is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Embedding.continuous {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) : Continuous f :="}
{"input": "Statement in natural language:\nFor any two additive commutative group categories G and H, the application of the projection map of the cone of the binary product limit cone to the left walking pair equals the first additive monoid homomorphism from G to H.\nTranslate the statement in natural language to Lean:", "output": "theorem binaryProductLimitCone_cone_\u03c0_app_left (G H : AddCommGroupCat.{u}) :\n    (binaryProductLimitCone G H).cone.\u03c0.app \u27e8WalkingPair.left\u27e9 = AddMonoidHom.fst G H :="}
{"input": "Statement in natural language:\nFor a type vector '\u03b1' of length 0 and a function 'ps' from '\u03b1' to a repeated 0-length vector of propositions, the subtype value of 'ps' is equal to the nil function.\nTranslate the statement in natural language to Lean:", "output": "theorem subtypeVal_nil {\u03b1 : TypeVec.{u} 0} (ps : \u03b1 \u27f9 \u00abrepeat\u00bb 0 Prop) :\n    TypeVec.subtypeVal ps = nilFun :="}
{"input": "Statement in natural language:\nFor any non-negative real number x and any non-negative real number y greater than 1, there will eventually be a natural number n such that x to the power of 1/n is less than or equal to y. This will hold true for all sufficiently large n.\nTranslate the statement in natural language to Lean:", "output": "theorem eventually_pow_one_div_le (x : \u211d\u22650) {y : \u211d\u22650} (hy : 1 < y) :\n    \u2200\u1da0 n : \u2115 in atTop, x ^ (1 / n : \u211d) \u2264 y :="}
{"input": "Statement in natural language:\nFor any natural numbers m and n, and any elements x and y of a field K, if the Frobenius endomorphism of K raised to the power of p to the m applied to x equals y, then the equivalence class generated by the pair (n, x) in the perfect closure of K with respect to p is equal to the equivalence class generated by the pair (m + n, y).\nTranslate the statement in natural language to Lean:", "output": "theorem R.sound (m n : \u2115) (x y : K) (H : (frobenius K p^[m]) x = y) :\n    mk K p (n, x) = mk K p (m + n, y) :="}
{"input": "Statement in natural language:\nIf 'a' is less than or equal to 'c', then 'a' is less than or equal to the maximum of 'b' and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_max_of_le_right : a \u2264 c \u2192 a \u2264 max b c :="}
{"input": "Statement in natural language:\nFor two linear maps 'f' and 'g' from a module 'M' to another module 'M\u2082', the sum of 'f' and 'g' applied to an element 'x' from 'M' is equal to the sum of 'f' applied to 'x' and 'g' applied to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem add_apply (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (x : M) : (f + g) x = f x + g x :="}
{"input": "Statement in natural language:\nThe composition of the lift function and the 'of' function applied to 'f' (which is a function from \u03b1 to M) is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_comp_of (f : \u03b1 \u2192 M) : lift f \u2218 of = f :="}
{"input": "Statement in natural language:\nIf set s and set t are both G-delta sets, then the union of set s and set t is also a G-delta set.\nTranslate the statement in natural language to Lean:", "output": "theorem IsG\u03b4.union {s t : Set \u03b1} (hs : IsG\u03b4 s) (ht : IsG\u03b4 t) : IsG\u03b4 (s \u222a t) :="}
{"input": "Statement in natural language:\nFor a given module W over a field K, with W being an additive commutative group, and a natural number n that is not equal to zero, if the rank of module V over K is equal to n times the rank of module W over K, then module V is finite-dimensional over K if and only if module W is finite-dimensional over K.\nTranslate the statement in natural language to Lean:", "output": "theorem finiteDimensional_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module K W] {n : \u2115}\n    (hn : n \u2260 0) (hVW : Module.rank K V = n \u2022 Module.rank K W) :\n    FiniteDimensional K V \u2194 FiniteDimensional K W :="}
{"input": "Statement in natural language:\nFor any given elements 'a' of type \u03b1 and 'b' of type \u03b2(a), and for any given associative lists 's\u2081' and 's\u2082' of type AList \u03b2, if the entries of 's\u2081' are permutations of the entries of 's\u2082', then the entries of the list resulting from replacing 'a' with 'b' in 's\u2081' are also permutations of the entries of the list resulting from replacing 'a' with 'b' in 's\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem perm_replace {a : \u03b1} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} :\n    s\u2081.entries ~ s\u2082.entries \u2192 (replace a b s\u2081).entries ~ (replace a b s\u2082).entries :="}
{"input": "Statement in natural language:\nIf we have a semiring S and a ring homomorphism f from R to S, and if polynomial p is monic, then the polynomial obtained by mapping p through f is also monic.\nTranslate the statement in natural language to Lean:", "output": "theorem Monic.map [Semiring S] (f : R \u2192+* S) (hp : Monic p) : Monic (p.map f) :="}
{"input": "Statement in natural language:\nThe length of a composition 'c' is less than the number of boundaries in 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem length_lt_card_boundaries : c.length < c.boundaries.card :="}
{"input": "Statement in natural language:\nFor a given element 'a' in a semilattice structure '\u03b1', the set 's' is bounded above if and only if the intersection of 's' and the set of all elements 'b' such that 'a' is not less than or equal to 'b' is also bounded above.\nTranslate the statement in natural language to Lean:", "output": "theorem bounded_ge_inter_not_ge [SemilatticeInf \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | \u00aca \u2264 b }) \u2194 Bounded (\u00b7 \u2265 \u00b7) s :="}
{"input": "Statement in natural language:\nFor a property 'p' that applies to a function 'f' (which is a finite direct sum of the functions '\u03b2 i' indexed by 'i'), if 'p' holds for the zero function and if 'p' holds for any function 'f' where 'f i' is zero, 'b' is non-zero, and 'p' holds for 'f', then 'p' also holds for the function that is the sum of the function 'f' and the function that is 'b' at index 'i' and zero elsewhere. This is a form of mathematical induction over the elements of the direct sum.\nTranslate the statement in natural language to Lean:", "output": "theorem induction {p : (\u03a0\u2080 i, \u03b2 i) \u2192 Prop} (f : \u03a0\u2080 i, \u03b2 i) (h0 : p 0)\n    (ha : \u2200 (i b) (f : \u03a0\u2080 i, \u03b2 i), f i = 0 \u2192 b \u2260 0 \u2192 p f \u2192 p (single i b + f)) : p f :="}
{"input": "Statement in natural language:\nFor any two types G and H that are both subtraction-negative-zero monoids, and for any function f from G to H that maps 0 to 0, if for all x and y in G, f of (x - y) equals f of x minus f of y, then for any two functions v\u2081 and v\u2082 from a type \u03b1 to G, the mapRange of f and hf on (v\u2081 - v\u2082) equals the mapRange of f and hf on v\u2081 minus the mapRange of f and hf on v\u2082. Here, mapRange is a function that applies f to the range of a function and hf is the proof that f maps 0 to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem mapRange_sub [SubNegZeroMonoid G] [SubNegZeroMonoid H] {f : G \u2192 H} {hf : f 0 = 0}\n    (hf' : \u2200 x y, f (x - y) = f x - f y) (v\u2081 v\u2082 : \u03b1 \u2192\u2080 G) :\n    mapRange f hf (v\u2081 - v\u2082) = mapRange f hf v\u2081 - mapRange f hf v\u2082 :="}
{"input": "Statement in natural language:\nFor a set 's' of sequences in 'E' that is closed, and for a sequence 'x' not in 's', if the longest prefix of 'x' in 's' is less than a natural number 'n', then 's' and the 'n'-cylinder of 'x' are disjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_cylinder_of_longestPrefix_lt {s : Set (\u2200 n, E n)} (hs : IsClosed s) {x : \u2200 n, E n}\n    (hx : x \u2209 s) {n : \u2115} (hn : longestPrefix x s < n) : Disjoint s (cylinder x n) :="}
{"input": "Statement in natural language:\nThe kernel of a function 'f' when considered as a submodule of 'R' and 'M' is equal to the kernel of the linear map from 'M' to 'N' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_coeSubmodule : (f.ker : Submodule R M) = LinearMap.ker (f : M \u2192\u2097[R] N) :="}
{"input": "Statement in natural language:\nFor a multiset 't' of polynomials, if the product of the leading coefficients of each polynomial in 't' is not zero, then the natural degree of the product of 't' is equal to the sum of the natural degrees of each polynomial in 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_multiset_prod' (h : (t.map fun f => leadingCoeff f).prod \u2260 0) :\n    t.prod.natDegree = (t.map fun f => natDegree f).sum :="}
{"input": "Statement in natural language:\nThe relation of the bottom element in the setoid of any type \u03b1 is equivalent to the equality relation.\nTranslate the statement in natural language to Lean:", "output": "theorem bot_def : (\u22a5 : Setoid \u03b1).Rel = (\u00b7 = \u00b7) :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c in a Heyting algebra, the difference of the supremum of a and b and c is equal to the supremum of the difference of a and c and the difference of b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_sdiff_distrib (a b c : \u03b1) : (a \u2294 b) \\ c = a \\ c \u2294 b \\ c :="}
{"input": "Statement in natural language:\nIf there is an equivalence between two categories C and D, and if category C is well-powered, then category D is also well-powered.\nTranslate the statement in natural language to Lean:", "output": "theorem wellPowered_of_equiv (e : C \u224c D) [WellPowered C] : WellPowered D :="}
{"input": "Statement in natural language:\nFor any three elements x, y, and z from a module M\u2081, the bilinear form B\u2081 of x and the difference of y and z is equal to the difference of the bilinear form B\u2081 of x and y and the bilinear form B\u2081 of x and z.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_right (x y z : M\u2081) : B\u2081 x (y - z) = B\u2081 x y - B\u2081 x z :="}
{"input": "Statement in natural language:\nFor any given list and any element, the last element of the list obtained by appending the given element to the end of the given list is the given element itself.\nTranslate the statement in natural language to Lean:", "output": "theorem getLast_append_singleton {a : \u03b1} (l : List \u03b1) :\n    getLast (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a :="}
{"input": "Statement in natural language:\nFor any real numbers x and y, if the sine of x equals y and x is in the closed interval from negative half pi to half pi, then the arcsine of y equals x.\nTranslate the statement in natural language to Lean:", "output": "theorem arcsin_eq_of_sin_eq {x y : \u211d} (h\u2081 : sin x = y) (h\u2082 : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin y = x :="}
{"input": "Statement in natural language:\nIn the context of a topological space \u03b2, which has a supremum operation and is continuous with respect to this operation, given a filter l and two functions f and g from \u03b9 to \u03b2, and two elements x and y in \u03b2, if f tends to x along l and g tends to y along l, then the function that maps each element i of \u03b9 to the supremum of f(i) and g(i) tends to the supremum of x and y along l.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.sup_right_nhds {\u03b9 \u03b2} [TopologicalSpace \u03b2] [Sup \u03b2] [ContinuousSup \u03b2]\n    {l : Filter \u03b9} {f g : \u03b9 \u2192 \u03b2} {x y : \u03b2} (hf : Tendsto f l (\ud835\udcdd x)) (hg : Tendsto g l (\ud835\udcdd y)) :\n    Tendsto (fun i => f i \u2294 g i) l (\ud835\udcdd (x \u2294 y)) :="}
{"input": "Statement in natural language:\nFor any type \u03b9, any relation r on \u03b9, given that \u03b9 with relation r is a well-ordered set, any ordinal number o, and if the order type of r is o, and any function f from a set of elements less than o to \u03b1, the range of the function 'familyOfBFamily' applied to r, ho, and f is equal to the range of the function brange applied to o and f.\nTranslate the statement in natural language to Lean:", "output": "theorem range_familyOfBFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] {o}\n    (ho : type r = o) (f : \u2200 a < o, \u03b1) : range (familyOfBFamily' r ho f) = brange o f :="}
{"input": "Statement in natural language:\nThe division of a number represented as \"bit1 n\" by a number represented as \"bit0 m\" is equal to the division of n by m.\nTranslate the statement in natural language to Lean:", "output": "theorem bit1_div_bit0 : bit1 n / bit0 m = n / m :="}
{"input": "Statement in natural language:\nThe function obtained by filtering 'f' according to predicate 'p' is equivalent to the indicator function of the set of elements satisfying 'p' in 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem filter_eq_indicator : \u21d1(f.filter p) = Set.indicator { x | p x } f :="}
{"input": "Statement in natural language:\nFor a non-negative real number 'a' and a natural number 'n', the ceiling of the sum of 'a' and 'n' is equal to the sum of the ceiling of 'a' and 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ceil_add_nat (ha : 0 \u2264 a) (n : \u2115) : \u2308a + n\u2309\u208a = \u2308a\u2309\u208a + n :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any two elements 'i' and 'j' of the finite set of size 'n+1', if 'j' is less than 'i', then the cycle range of 'i' and 'j' is equal to 'j + 1'.\nTranslate the statement in natural language to Lean:", "output": "theorem cycleRange_of_lt {n : \u2115} {i j : Fin n.succ} (h : j < i) : cycleRange i j = j + 1 :="}
{"input": "Statement in natural language:\nThe distance between two points x and y in a metric space \u03b3 is greater than zero if and only if x is not equal to y.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_pos {x y : \u03b3} : 0 < dist x y \u2194 x \u2260 y :="}
{"input": "Statement in natural language:\nFor any finite set 's' of elements of type '\u03b2' and any function 'f' from '\u03b2' to '\u03b1' (where '\u03b1' is a type with a generalized Boolean algebra structure), and any element 'a' of type '\u03b1', the supremum (greatest element) of the set obtained by applying the function 'f' to each element of 's' and then subtracting 'a', is equal to the result of subtracting 'a' from the supremum of the set obtained by applying 'f' to each element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_sdiff_right {\u03b1 \u03b2 : Type _} [GeneralizedBooleanAlgebra \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1)\n    (a : \u03b1) : (s.sup fun b => f b \\ a) = s.sup f \\ a :="}
{"input": "Statement in natural language:\nFor a given set 's' of any type '\u03b1', if 's' is finite, then the off-diagonal of 's' is also finite.\nTranslate the statement in natural language to Lean:", "output": "theorem Finite.offDiag {s : Set \u03b1} (hs : s.Finite) : s.offDiag.Finite :="}
{"input": "Statement in natural language:\nFor a given finite set 's' and a function 'f' from 's' to a ring 'R', the square of the sum of the function values over the set 's' is equal to the sum of the squares of the function values over the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_mul_self (s : Finset \u03b9) (f : \u03b9 \u2192 R) :\n    ((\u2211 i in s, f i) * \u2211 i in s, f i) = \u2211 i in s, f i * f i :="}
{"input": "Statement in natural language:\nIf there is an open embedding 'f' and 'F' is a sheaf, then the composition of the functor associated with the open map 'f' and 'F' is also a sheaf.\nTranslate the statement in natural language to Lean:", "output": "theorem TopCat.Presheaf.isSheaf_of_openEmbedding (h : OpenEmbedding f) (hF : F.IsSheaf) :\n    IsSheaf (h.isOpenMap.functor.op \u22d9 F) :="}
{"input": "Statement in natural language:\nThe outer measure of \u03bc\u2081 is less than or equal to the outer measure of \u03bc\u2082 if and only if \u03bc\u2081 is less than or equal to \u03bc\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem toOuterMeasure_le : \u03bc\u2081.toOuterMeasure \u2264 \u03bc\u2082.toOuterMeasure \u2194 \u03bc\u2081 \u2264 \u03bc\u2082 :="}
{"input": "Statement in natural language:\nIf a function 'f' is integrable with respect to a measure '\u03bc', then the function that multiplies 'f' by a constant 'c' is also integrable with respect to the same measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem Integrable.mul_const {f : \u03b1 \u2192 \ud835\udd5c} (h : Integrable f \u03bc) (c : \ud835\udd5c) :\n    Integrable (fun x => f x * c) \u03bc :="}
{"input": "Statement in natural language:\nThe coercion of 'none' from the Option type to the Part type in the context of any type \u03b1, is equal to 'none'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_none : (@Option.none \u03b1 : Part \u03b1) = none :="}
{"input": "Statement in natural language:\nFor a given type \u03b1, if \u03b1 is unique and has an identity element (one), then the default element of \u03b1 is equal to the identity element.\nTranslate the statement in natural language to Lean:", "output": "theorem unique_one {\u03b1 : Type _} [Unique \u03b1] [One \u03b1] : default = (1 : \u03b1) :="}
{"input": "Statement in natural language:\nThe multiplication homomorphism obtained from the top equivalence is equal to the subtype of the top subsemigroup M in the multiplication membership class.\nTranslate the statement in natural language to Lean:", "output": "theorem topEquiv_toMulHom :\n    (topEquiv : _ \u2243* M).toMulHom = MulMemClass.subtype (\u22a4 : Subsemigroup M) :="}
{"input": "Statement in natural language:\nIf a set 's' is nonempty and is bounded above, then the supremum of 's' is the least upper bound of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isLUB_csSup (ne : s.Nonempty) (H : BddAbove s) : IsLUB s (sSup s) :="}
{"input": "Statement in natural language:\nFor a given monoid homomorphism 'f' from 'M' to 'N', and given subsemigroups 'S' of 'M' and 'T' of 'N', the image of 'S' under 'f' is a subset of 'T' if and only if 'S' is a subset of the preimage of 'T' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_le_iff_le_comap {f : M \u2192\u2099* N} {S : Subsemigroup M} {T : Subsemigroup N} :\n    S.map f \u2264 T \u2194 S \u2264 T.comap f :="}
{"input": "Statement in natural language:\nFor any real numbers x, y, and z, if x and y are coprime, then x and the sum of y and the product of z and x are also coprime.\nTranslate the statement in natural language to Lean:", "output": "theorem add_mul_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + z * x) :="}
{"input": "Statement in natural language:\nThe coefficient of the zeroth term in the polynomial P is equal to the discriminant of P.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_eq_d : P.toPoly.coeff 0 = P.d :="}
{"input": "Statement in natural language:\nFor any two additive homomorphisms 'f' and 'g' from the free module over a set '\u03b1' to an additive group 'N', if 'f' and 'g' agree on all singletons, then 'f' and 'g' are equal. This is under the condition that 'N' is an additive group with a zero element.\nTranslate the statement in natural language to Lean:", "output": "theorem addHom_ext [AddZeroClass N] \u2983f g : (\u03b1 \u2192\u2080 M) \u2192+ N\u2984\n    (H : \u2200 x y, f (single x y) = g (single x y)) : f = g :="}
{"input": "Statement in natural language:\nThe lower bounds of the singleton set containing 'a' are equivalent to the set of all elements less than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem lowerBounds_singleton : lowerBounds {a} = Iic a :="}
{"input": "Statement in natural language:\nFor a surjective function 'f' from '\u03b9' to '\u03b9\u2082', and a function 'g' from '\u03b9\u2082' to a set of '\u03b1', the intersection over 'x' of 'g' applied to 'f(x)' is equal to the intersection over 'y' of 'g(y)'.\nTranslate the statement in natural language to Lean:", "output": "theorem iInter_comp {f : \u03b9 \u2192 \u03b9\u2082} (hf : Surjective f) (g : \u03b9\u2082 \u2192 Set \u03b1) : (\u22c2 x, g (f x)) = \u22c2 y, g y :="}
{"input": "Statement in natural language:\nFor a group G, and given elements a, b, c of G, the product of b and a is not equal to the product of c and a if and only if b is not equal to c.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_ne_mul_left (a : G) {b c : G} : b * a \u2260 c * a \u2194 b \u2260 c :="}
{"input": "Statement in natural language:\nFor any complex number z in the unit disc, the square of its norm is less than 1.\nTranslate the statement in natural language to Lean:", "output": "theorem normSq_lt_one (z : \ud835\udd3b) : normSq z < 1 :="}
{"input": "Statement in natural language:\nFor a given element 'g' of group 'G' and a subgroup 'H' of 'G', the set of integer powers of 'g' is a subset of 'H' if and only if 'g' is an element of 'H'.\nTranslate the statement in natural language to Lean:", "output": "theorem zpowers_le {g : G} {H : Subgroup G} : zpowers g \u2264 H \u2194 g \u2208 H :="}
{"input": "Statement in natural language:\nThe \"inl\" (inclusion from the left) of a pushout cocone of two functions f and g is equal to the ring homomorphism of the inclusion on the left in the tensor product of the algebras associated with f and g.\nTranslate the statement in natural language to Lean:", "output": "theorem pushoutCocone_inl :\n    (pushoutCocone f g).inl = by\n      letI := f.toAlgebra\n      letI := g.toAlgebra\n      exact Algebra.TensorProduct.includeLeft.toRingHom :="}
{"input": "Statement in natural language:\nFor any type \u03b1, for any natural number n, and for any list l of type \u03b1, the length of the sublists of l of length n is equal to \"length of l choose n\", where \"choose\" refers to the binomial coefficient.\nTranslate the statement in natural language to Lean:", "output": "theorem length_sublistsLen {\u03b1 : Type _} :\n    \u2200 (n) (l : List \u03b1), length (sublistsLen n l) = Nat.choose (length l) n"}
{"input": "Statement in natural language:\nThe conversion of list 'l' to a finite set is equal to the conversion of list 'l'' to a finite set if and only if the deduplicated version of list 'l' is a permutation of the deduplicated version of list 'l''.\nTranslate the statement in natural language to Lean:", "output": "theorem toFinset_eq_iff_perm_dedup : l.toFinset = l'.toFinset \u2194 l.dedup ~ l'.dedup :="}
{"input": "Statement in natural language:\nFor a measure space \u03bc, if the measure of the set containing only the element 'a' is zero and the measure of the set containing only the element 'b' is zero, then the half-open interval from 'a' to 'b' (including 'a' but excluding 'b') is almost everywhere equal to the half-open interval from 'a' to 'b' (excluding 'a' but including 'b') with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem Ico_ae_eq_Ioc' (ha : \u03bc {a} = 0) (hb : \u03bc {b} = 0) : Ico a b =\u1d50[\u03bc] Ioc a b :="}
{"input": "Statement in natural language:\nFor any group filter basis B of a group G, the neighborhood of the element 1 in B is equal to the filter basis of B.\nTranslate the statement in natural language to Lean:", "output": "theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter :="}
{"input": "Statement in natural language:\nIf a function f has a derivative at a point x, then the function that applies the arctan function to f has a derivative at the same point x. The derivative is given by the formula 1 / (1 + f(x)^2) times the derivative of f at x.\nTranslate the statement in natural language to Lean:", "output": "theorem HasDerivAt.arctan (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun x => arctan (f x)) (1 / (1 + f x ^ 2) * f') x :="}
{"input": "Statement in natural language:\nFor a given linear map '\u03c6' from the tensor product of a family of modules 's i' over a ring 'R' to a module 'E', if this linear map composed with the multilinear map 'PiTensorProduct.tprod R' equals '\u03c6', then '\u03c6' is uniquely determined by the lift of '\u03c6'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift.unique' {\u03c6' : (\u2a02[R] i, s i) \u2192\u2097[R] E}\n    (H : \u03c6'.compMultilinearMap (PiTensorProduct.tprod R) = \u03c6) : \u03c6' = lift \u03c6 :="}
{"input": "Statement in natural language:\nFor all indices 'i', given a Generalized Heyting Algebra on the function '\u03c0 i', for any two functions 'a' and 'b' that map an index to '\u03c0 i', the bi-implication of 'a' and 'b' is equivalent to the function that maps each index 'i' to the bi-implication of 'a i' and 'b i'.\nTranslate the statement in natural language to Lean:", "output": "theorem bihimp_def [\u2200 i, GeneralizedHeytingAlgebra (\u03c0 i)] (a b : \u2200 i, \u03c0 i) :\n    a \u21d4 b = fun i => a i \u21d4 b i :="}
{"input": "Statement in natural language:\nIf 'a' is the least element in set 't', then 'f(a)' is the greatest element in the image of 't' under the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_isLeast : IsLeast t a \u2192 IsGreatest (f '' t) (f a) :="}
{"input": "Statement in natural language:\nFor any quaternion 'q' with real numbers 'R' and complex numbers 'c\u2081' and 'c\u2082', the representation of 'q' in the basis 'basisOneIJK' is equal to the list consisting of the real part of 'q', the coefficient of 'i' in 'q', the coefficient of 'j' in 'q', and the coefficient of 'k' in 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_basisOneIJK_repr (q : \u210d[R,c\u2081,c\u2082]) :\n    \u21d1((basisOneIJK c\u2081 c\u2082).repr q) = ![q.re, q.imI, q.imJ, q.imK] :="}
{"input": "Statement in natural language:\nTwo algebra homomorphisms \u03c6\u2081 and \u03c6\u2082 from algebra A to algebra B over a ring R are equal if and only if they are equal for all elements x in algebra A.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_iff {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B} : \u03c6\u2081 = \u03c6\u2082 \u2194 \u2200 x, \u03c6\u2081 x = \u03c6\u2082 x :="}
{"input": "Statement in natural language:\nFor any element 'x' in the skew-adjoint of 'R', and any element 'z' in 'R', the product of the conjugate of 'z', 'x', and 'z' is also in the skew-adjoint of 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem conjugate' {x : R} (hx : x \u2208 skewAdjoint R) (z : R) : star z * x * z \u2208 skewAdjoint R :="}
{"input": "Statement in natural language:\nFor any element 'x' in the ring 'R' that is self-adjoint, and for any other element 'z' in the same ring, the product of 'z', 'x', and the conjugate of 'z' is also self-adjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem conjugate {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (z * x * star z) :="}
{"input": "Statement in natural language:\nFor any index 'i' and any two elements 'b\u2081' and 'b\u2082' of the set '\u03b2 i', the non-negative distance between the inverse images of 'b\u2081' and 'b\u2082' under the equivalence 'PiLp.equiv p \u03b2' is equal to the non-negative distance between 'b\u2081' and 'b\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem nndist_equiv_symm_single_same (i : \u03b9) (b\u2081 b\u2082 : \u03b2 i) :\n    nndist ((PiLp.equiv p \u03b2).symm (Pi.single i b\u2081)) ((PiLp.equiv p \u03b2).symm (Pi.single i b\u2082)) =\n      nndist b\u2081 b\u2082 :="}
{"input": "Statement in natural language:\nFor any ideal I in the product ring of R and S, I is equal to the product of the ideal in R mapped by the first ring homomorphism and the ideal in S mapped by the second ring homomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem ideal_prod_eq (I : Ideal (R \u00d7 S)) :\n    I = Ideal.prod (map (RingHom.fst R S) I : Ideal R) (map (RingHom.snd R S) I) :="}
{"input": "Statement in natural language:\nIf a real-valued function 'f' is differentiable and its derivative at any point 'x' is less than or equal to zero, then the function 'f' is antitone. An antitone function is one that decreases or remains constant as its input increases.\nTranslate the statement in natural language to Lean:", "output": "theorem antitone_of_deriv_nonpos {f : \u211d \u2192 \u211d} (hf : Differentiable \u211d f) (hf' : \u2200 x, deriv f x \u2264 0) :\n    Antitone f :="}
{"input": "Statement in natural language:\nThe list of cycles generated from a list 'l' is equal to the list of cyclic permutations of 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem lists_coe (l : List \u03b1) : lists (l : Cycle \u03b1) = \u2191l.cyclicPermutations :="}
{"input": "Statement in natural language:\nFor any type \u03b9'' and any finite type \u03b9', given a function b'' from \u03b9'' to M, the product of the matrix representation of b with respect to b' and the matrix representation of b' with respect to b'' is equal to the matrix representation of b with respect to b''.\nTranslate the statement in natural language to Lean:", "output": "theorem Basis.toMatrix_mul_toMatrix {\u03b9'' : Type _} [Fintype \u03b9'] (b'' : \u03b9'' \u2192 M) :\n    b.toMatrix b' \u2b1d b'.toMatrix b'' = b.toMatrix b'' :="}
{"input": "Statement in natural language:\nThe set of all elements greater than zero in the finite set of natural numbers up to n (where n is a successor) is equal to the universal set mapped by the successor embedding function.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioi_zero_eq_map : Ioi (0 : Fin n.succ) = univ.map (Fin.succEmbedding _).toEmbedding :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' defined on a set 's' and any two functions 'f'' and 'g'' defined on the same set, and a function 'h' that takes three arguments - an element from the set, the result of applying 'f' or 'g' to that element, and the result of applying 'f'' or 'g'' to that element - the result of applying 'h' to an element 'x' from the set, the result of applying the piecewise function of 'f' and 'g' to 'x', and the result of applying the piecewise function of 'f'' and 'g'' to 'x', is equal to the result of applying the piecewise function of 'h' applied to 'x', 'f' applied to 'x', and 'f'' applied to 'x' if 'x' is in 's', or 'h' applied to 'x', 'g' applied to 'x', and 'g'' applied to 'x' if 'x' is not in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_piecewise\u2082 {\u03b4' \u03b4'' : \u03b1 \u2192 Sort _} (f' g' : \u2200 i, \u03b4' i) (h : \u2200 i, \u03b4 i \u2192 \u03b4' i \u2192 \u03b4'' i)\n    {x : \u03b1} :\n    h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type '\u03b1' and a sequence 's', the operation of converting the sequence obtained by prepending 'a' to 's' into a list is equivalent to the operation of prepending 'a' to the list obtained by converting 's' into a list.\nTranslate the statement in natural language to Lean:", "output": "theorem toList_cons (a : \u03b1) (s) : toList (cons a s) = (List.cons a <$> toList s).think :="}
{"input": "Statement in natural language:\nIf a polynomial 'p' over a ring 'R' is separable, then the roots of 'p' do not have any duplicates.\nTranslate the statement in natural language to Lean:", "output": "theorem nodup_roots {p : R[X]} (hsep : Separable p) : p.roots.Nodup :="}
{"input": "Statement in natural language:\nFor any real number 'a', the sum of 'a' and 'a' divided by 2 is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem half_add_self (a : R) : (a + a) / 2 = a :="}
{"input": "Statement in natural language:\nIf we have two dominated finite measures additive, T and T', with the same measure \u03bc and constants C and C', and if T equals T', then for any function f from \u03b1 to E, the setToFun of \u03bc, T, hT, and f equals the setToFun of \u03bc, T', hT', and f.\nTranslate the statement in natural language to Lean:", "output": "theorem setToFun_congr_left (hT : DominatedFinMeasAdditive \u03bc T C)\n    (hT' : DominatedFinMeasAdditive \u03bc T' C') (h : T = T') (f : \u03b1 \u2192 E) :\n    setToFun \u03bc T hT f = setToFun \u03bc T' hT' f :="}
{"input": "Statement in natural language:\nFor a monoid with zero homomorphism 'f' from a multiplicative monoid with zero 'M' to another multiplicative monoid with zero 'N', the composition of 'f' with the identity homomorphism on 'M' is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem MonoidWithZeroHom.comp_id [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\n  f.comp (MonoidWithZeroHom.id M) = f :="}
{"input": "Statement in natural language:\nIf we have a semiring R, an additive commutative monoid M, and a module M over R, then if N is a submodule of M and M is Noetherian over R, then N is also Noetherian over R.\nTranslate the statement in natural language to Lean:", "output": "theorem isNoetherian_of_submodule_of_noetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M]\n    (N : Submodule R M) (h : IsNoetherian R M) : IsNoetherian R N :="}
{"input": "Statement in natural language:\nX is codisjoint with the implication from x to y.\nTranslate the statement in natural language to Lean:", "output": "theorem codisjoint_himp_self_right : Codisjoint x (x \u21e8 y) :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c of a set \u03b1, and any two sets s and t of ordered pairs of elements from \u03b1, if the ordered pair (a, c) is in set s and the ordered pair (c, b) is in set t, then the ordered pair (a, b) is in the composite of sets s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_mk_mem_compRel {a b c : \u03b1} {s t : Set (\u03b1 \u00d7 \u03b1)} (h\u2081 : (a, c) \u2208 s) (h\u2082 : (c, b) \u2208 t) :\n    (a, b) \u2208 s \u25cb t :="}
{"input": "Statement in natural language:\nFor a contravariant class of type \u03b1, if b is additively left cancellable, a - b is additively left cancellable, b is less than or equal to a, and c is less than or equal to a, then a - b is less than a - c if and only if c is less than b.\nTranslate the statement in natural language to Lean:", "output": "theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    (hb : AddLECancellable b) (hab : AddLECancellable (a - b)) (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 a) :\n    a - b < a - c \u2194 c < b :="}
{"input": "Statement in natural language:\nThe product of the singleton set containing element 'a' and the singleton set containing element 'b' is equal to the singleton set containing the product of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_mul_singleton (a b : \u03b1) : ({a} : Finset \u03b1) * {b} = {a * b} :="}
{"input": "Statement in natural language:\nFor any natural numbers q and n, the composition of the function (P q).f n with itself is equal to the function (P q).f n. This implies that the function (P q).f n is idempotent.\nTranslate the statement in natural language to Lean:", "output": "theorem P_f_idem (q n : \u2115) : ((P q).f n : X _[n] \u27f6 _) \u226b (P q).f n = (P q).f n :="}
{"input": "Statement in natural language:\nFor any given tree 't', order 'o', and element 'x' of type \u03b1, if 't' is bounded by 'o' and 'x', then all elements in 't' are less than 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem Bounded.mem_lt : \u2200 {t o} {x : \u03b1}, Bounded t o x \u2192 All (\u00b7 < x) t"}
{"input": "Statement in natural language:\nFor any element 'x' from the set 'M', the application of the reflexive property of 'L' on 'M' to 'x' equals 'x' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem refl_apply (x : M) : refl L M x = x :="}
{"input": "Statement in natural language:\nFor any element 'x' of type \u03b1 and any function 'u' from the finite set of size 0 to \u03b1, for all 'i' in the finite set of size 1, the value of the vector constructed from 'x' and 'u' at index 'i' is equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem cons_val_fin_one (x : \u03b1) (u : Fin 0 \u2192 \u03b1) : \u2200 (i : Fin 1), vecCons x u i = x :="}
{"input": "Statement in natural language:\nFor any integer 'd' and any square root of 'd' denoted as 'a', the norm of 'a' is equal to 1 if and only if 'a' is a member of the unitary group of the square root of 'd'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_eq_one_iff_mem_unitary {d : \u2124} {a : \u2124\u221ad} : a.norm = 1 \u2194 a \u2208 unitary (\u2124\u221ad) :="}
{"input": "Statement in natural language:\nFor a given Young Diagram '\u03bc', a natural number 'j', and a pair of natural numbers 'c', 'c' is in the 'j'-th column of '\u03bc' if and only if 'c' is in '\u03bc' and the second element of 'c' is equal to 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_col_iff {\u03bc : YoungDiagram} {j : \u2115} {c : \u2115 \u00d7 \u2115} : c \u2208 \u03bc.col j \u2194 c \u2208 \u03bc \u2227 c.snd = j :="}
{"input": "Statement in natural language:\nIf we have an algebra A over a ring S, and M is a submonoid of A, and S is a localization of M, then if M is less than or equal to the non-zero divisors of A, S is a domain.\nTranslate the statement in natural language to Lean:", "output": "theorem isDomain_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M \u2264 nonZeroDivisors A) : IsDomain S :="}
{"input": "Statement in natural language:\nFor a function 'g' mapping from '\u03b9' to '\u03b1', if for every 'i' there exists an 'i' such that 'f i' is less than or equal to 'g i', then the infimum (greatest lower bound) of 'f' is less than or equal to the infimum of 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_mono' {g : \u03b9' \u2192 \u03b1} (h : \u2200 i', \u2203 i, f i \u2264 g i') : iInf f \u2264 iInf g :="}
{"input": "Statement in natural language:\nIf we have a finite type \u03b9 and a function p from \u03b9 to a point P such that p is affine independent, and if the cardinality of the finite type \u03b9 is n + 1, then the finite rank of the vector span of the set range of p is n.\nTranslate the statement in natural language to Lean:", "output": "theorem AffineIndependent.finrank_vectorSpan [Fintype \u03b9] {p : \u03b9 \u2192 P} (hi : AffineIndependent k p)\n    {n : \u2115} (hc : Fintype.card \u03b9 = n + 1) : finrank k (vectorSpan k (Set.range p)) = n :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't' of a ring 'R', if 's' is a subset of 't', then the centralizer of 't' is less than or equal to the centralizer of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem centralizer_le (s t : Set R) (h : s \u2286 t) : centralizer t \u2264 centralizer s :="}
{"input": "Statement in natural language:\nIf a list 'l' forms a chain with relation 'R' and another list 'l\u2081' is a prefix of 'l', then 'l\u2081' also forms a chain with relation 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem Chain'.infix (h : Chain' R l) (h' : l\u2081 <:+: l) : Chain' R l\u2081 :="}
{"input": "Statement in natural language:\nThe application of the first projection function on the product of two mathematical structures M and N is equal to the first element of the product.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_fst : \u21d1(fst M N) = Prod.fst :="}
{"input": "Statement in natural language:\nIf a function 'u' from real numbers to 'E' is monotone, then 'u' is interval integrable between any two real numbers 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Monotone.intervalIntegrable {u : \u211d \u2192 E} {a b : \u211d} (hu : Monotone u) :\n    IntervalIntegrable u \u03bc a b :="}
{"input": "Statement in natural language:\nFor any two functions 'mab' mapping from type \u03b1 to \u03b2 and 'mba' mapping from type \u03b2 to \u03b1, and any two filters 'f' of type \u03b1 and 'g' of type \u03b2, if the composition of 'mab' and 'mba' is eventually equal to the identity function at filter 'g', and if 'mba' tends to 'f' at 'g', then 'g' is less than or equal to the map of 'mab' at 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_map_of_right_inverse {mab : \u03b1 \u2192 \u03b2} {mba : \u03b2 \u2192 \u03b1} {f : Filter \u03b1} {g : Filter \u03b2}\n    (h\u2081 : mab \u2218 mba =\u1da0[g] id) (h\u2082 : Tendsto mba g f) : g \u2264 map mab f :="}
{"input": "Statement in natural language:\n\"there does not exist an x such that s of x is true\" is equivalent to \"for all x, s of x is not true\".\nTranslate the statement in natural language to Lean:", "output": "theorem not_exists_eq : (\u00ac \u2203 x, s x) = (\u2200 x, \u00ac s x) :="}
{"input": "Statement in natural language:\nIn the context of a linearly ordered field \ud835\udd5c, a topological space E, an additive commutative monoid E, and a module \ud835\udd5c E, for any set s of E, if s is a closed set and strictly convex in \ud835\udd5c, then the frontier of s has the property of AddSalemSpencer. \n\nNote: AddSalemSpencer is a property of a set of points where the sum of any two distinct points in the set is not equal to the sum of any other two distinct points in the set. The frontier of a set is the set of all points that have at least one point in the set and at least one point not in the set in any given neighborhood around them.\nTranslate the statement in natural language to Lean:", "output": "theorem addSalemSpencer_frontier [LinearOrderedField \ud835\udd5c] [TopologicalSpace E] [AddCommMonoid E]\n    [Module \ud835\udd5c E] {s : Set E} (hs\u2080 : IsClosed s) (hs\u2081 : StrictConvex \ud835\udd5c s) :\n    AddSalemSpencer (frontier s) :="}
{"input": "Statement in natural language:\nIf a is equivalent to b modulo n, and c is equivalent to d modulo n, then the sum of a and c is equivalent to the sum of b and d modulo n.\nTranslate the statement in natural language to Lean:", "output": "theorem add (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) : a + c \u2261 b + d [MOD n] :="}
{"input": "Statement in natural language:\nThe uniformity of a metric space \u03b3 is equal to the infimum of the principal set of pairs of points in \u03b3, where the extended distance between each pair of points is less than some positive number \u03b5.\nTranslate the statement in natural language to Lean:", "output": "theorem uniformity_edist : \ud835\udce4 \u03b3 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b3 \u00d7 \u03b3 | edist p.1 p.2 < \u03b5 } :="}
{"input": "Statement in natural language:\nFor a set \ud835\udca2 in the opposite category of C, \ud835\udca2 is codetecting if and only if \ud835\udca2 is detecting.\nTranslate the statement in natural language to Lean:", "output": "theorem isCodetecting_unop_iff {\ud835\udca2 : Set C\u1d52\u1d56} : IsCodetecting \ud835\udca2.unop \u2194 IsDetecting \ud835\udca2 :="}
{"input": "Statement in natural language:\nFor any infinite ring R, the cardinality of the set of quaternions over R is equal to the cardinality of R itself.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_quaternion_of_infinite [Infinite R] : (#\u210d[R]) = (#R) :="}
{"input": "Statement in natural language:\nFor any types \u03b1, \u03b2, and \u03b3, and any element c of type \u03b3, applying the symmetric of the sum association function to the right element of the right sum (inr (inr c)) results in the right element of the sum (inr c).\nTranslate the statement in natural language to Lean:", "output": "theorem sumAssoc_symm_apply_inr_inr {\u03b1 \u03b2 \u03b3} (c) : (sumAssoc \u03b1 \u03b2 \u03b3).symm (inr (inr c)) = inr c :="}
{"input": "Statement in natural language:\nThe bottom subalgebra of A over R is finitely generated.\nTranslate the statement in natural language to Lean:", "output": "theorem fg_bot : (\u22a5 : Subalgebra R A).FG :="}
{"input": "Statement in natural language:\nThe intersection of the set of elements that satisfy a property 'p' and a set 's' is equal to the set of elements in 's' that satisfy the property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem setOf_inter_eq_sep (p : \u03b1 \u2192 Prop) (s : Set \u03b1) : {a | p a} \u2229 s = {a \u2208 s | p a} :="}
{"input": "Statement in natural language:\nFor any three non-negative real numbers a, b, and c, the product of a and the supremum (the least upper bound) of b and c is equal to the supremum of the product of a and b and the product of a and c.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_sup (a b c : \u211d\u22650) : a * (b \u2294 c) = a * b \u2294 a * c :="}
{"input": "Statement in natural language:\nIf the natural degree of polynomial p is less than or equal to the natural degree of polynomial q, and the natural degree of polynomial q is greater than 0, then the natural degree of the polynomial obtained by cancelling the leading terms of p and q is less than the natural degree of polynomial q.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_cancelLeads_lt_of_natDegree_le_natDegree (h : p.natDegree \u2264 q.natDegree)\n    (hq : 0 < q.natDegree) : (p.cancelLeads q).natDegree < q.natDegree :="}
{"input": "Statement in natural language:\nThe distance from point x to point w is less than or equal to the sum of the distance from x to y, the distance from y to z, and the distance from z to w. This is a generalization of the triangle inequality in the context of metric spaces.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_triangle4 (x y z w : \u03b1) : dist x w \u2264 dist x y + dist y z + dist z w :="}
{"input": "Statement in natural language:\nFor a given measure '\u03bc' on a set '\u03b1', which is a probability measure, the measure derived from a probability mass function 'p' is equal to '\u03bc' if and only if 'p' is equal to the probability mass function derived from '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem toMeasure_eq_iff_eq_toPmf (\u03bc : Measure \u03b1) [IsProbabilityMeasure \u03bc] :\n    p.toMeasure = \u03bc \u2194 p = \u03bc.toPmf :="}
{"input": "Statement in natural language:\nFor any list of elements of type \u03b1, the property of the list being a chain under a relation R is equivalent to the property of the list having pairwise relations under R, given that the relation R is transitive over \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem chain'_iff_pairwise [IsTrans \u03b1 R] : \u2200 {l : List \u03b1}, Chain' R l \u2194 Pairwise R l"}
{"input": "Statement in natural language:\nFor a given function 'f' from a field 'F', if the kernel of 'f' is a trivial subspace (i.e., it only contains the zero vector), then the image of a subspace 'p' under 'f' is a subset of the image of another subspace 'p'' under 'f' if and only if 'p' is a subset of 'p''.\nTranslate the statement in natural language to Lean:", "output": "theorem map_le_map_iff' {f : F} (hf : ker f = \u22a5) {p p'} : map f p \u2264 map f p' \u2194 p \u2264 p' :="}
{"input": "Statement in natural language:\nFor any finite set 's', the sum of the cardinality of 's' and the cardinality of the complement of 's' is equal to the cardinality of the set of all natural numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem ncard_add_ncard_compl (s : Set \u03b1) (hs : s.Finite := by toFinite_tac)\n    (hsc : s\u1d9c.Finite := by toFinite_tac) : s.ncard + s\u1d9c.ncard = Nat.card \u03b1 :="}
{"input": "Statement in natural language:\nThe range of a piecewise function, defined by functions f and g over a set s, is equal to the union of the image of f over set s and the image of g over the complement of set s.\nTranslate the statement in natural language to Lean:", "output": "theorem range_piecewise (f g : \u03b1 \u2192 \u03b2) : range (s.piecewise f g) = f '' s \u222a g '' s\u1d9c :="}
{"input": "Statement in natural language:\nFor a given measure \u03bc on a set \u03b2, where \u03bc is a locally finite measure, and a measurable set s, almost everywhere with respect to \u03bc, the function that maps a positive real number r to the ratio of the measure of the intersection of s and the closed ball centered at x with radius r to the measure of the closed ball centered at x with radius r, tends to the indicator function of s at x as r tends to 0 from the right.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_tendsto_measure_inter_div_of_measurableSet (\u03bc : Measure \u03b2) [IsLocallyFiniteMeasure \u03bc]\n    {s : Set \u03b2} (hs : MeasurableSet s) :\n    \u2200\u1d50 x \u2202\u03bc,\n      Tendsto (fun r => \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0)\n        (\ud835\udcdd (s.indicator 1 x)) :="}
{"input": "Statement in natural language:\nFor any two lists 'l' and 'l'' and a natural number 'n', the rotation of list 'l' by 'n' positions is equal to list 'l'' if and only if list 'l' is equal to the rotation of list 'l'' by the difference of the length of 'l'' and the remainder of 'n' divided by the length of 'l''.\nTranslate the statement in natural language to Lean:", "output": "theorem rotate_eq_iff {l l' : List \u03b1} {n : \u2115} :\n    l.rotate n = l' \u2194 l = l'.rotate (l'.length - n % l'.length) :="}
{"input": "Statement in natural language:\nFor two real-valued functions f and g, with their derivatives f' and g', if for every x in the closed interval from a to b, f has a derivative at x equal to f'(x), and g has a derivative at f(x) equal to g'(f(x)), and if f' is continuous on the closed interval from a to b, and g' is continuous, then the integral from a to b of the composition of g' and f, multiplied by f', is equal to the difference of the composition of g and f at b and the composition of g and f at a.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_deriv_comp_mul_deriv {f f' g g' : \u211d \u2192 \u211d}\n    (hf : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (hg : \u2200 x \u2208 uIcc a b, HasDerivAt g (g' (f x)) (f x)) (hf' : ContinuousOn f' (uIcc a b))\n    (hg' : Continuous g') : (\u222b x in a..b, (g' \u2218 f) x * f' x) = (g \u2218 f) b - (g \u2218 f) a :="}
{"input": "Statement in natural language:\nFor a given filter 'l' on a type '\u03b1', a function 'f' from '\u03b1' to a group 'G', and an element 'x' of 'G', if 'f' tends towards 'x' with respect to the filter 'l', then for any integer 'z', the function that maps 'x' to the 'z'-th power of 'f(x)' also tends towards the 'z'-th power of 'x' with respect to the filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.zpow {\u03b1} {l : Filter \u03b1} {f : \u03b1 \u2192 G} {x : G} (hf : Tendsto f l (\ud835\udcdd x))\n    (z : \u2124) : Tendsto (fun x => f x ^ z) l (\ud835\udcdd (x ^ z)) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b', the product of the quotient of 'a' and the quotient of 'b' in the ring quotient 'r' is equal to the quotient of the product of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_quot {a b} : (\u27e8Quot.mk _ a\u27e9 * \u27e8Quot.mk _ b\u27e9 : RingQuot r) = \u27e8Quot.mk _ (a * b)\u27e9 :="}
{"input": "Statement in natural language:\nFor any natural number 'n', rotating an empty list 'n' times results in an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem rotate'_nil (n : \u2115) : ([] : List \u03b1).rotate' n = [] :="}
{"input": "Statement in natural language:\nFor a given polynomial 'p', if 'p' is monic (which means the leading coefficient is 1), then the coefficient of 'p' at its natural degree is 1.\nTranslate the statement in natural language to Lean:", "output": "theorem Monic.coeff_natDegree {p : R[X]} (hp : p.Monic) : p.coeff p.natDegree = 1 :="}
{"input": "Statement in natural language:\nIf set s\u2081 is a subset of set s\u2082 and set t\u2081 is a subset of set t\u2082, then the disjoint sum of s\u2081 and t\u2081 is a subset of the disjoint sum of s\u2082 and t\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem disjSum_mono (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) : s\u2081.disjSum t\u2081 \u2286 s\u2082.disjSum t\u2082 :="}
{"input": "Statement in natural language:\nIf we have a function '\u03bc' from a pair of natural numbers to a natural number, and this function is a covariant class with respect to the swap operation and the less than or equal to relation, and if 'f' is an antitone function, then for any natural number 'm', the function that maps 'n' to 'f' of '\u03bc' of 'n' and 'm' is also an antitone function.\nTranslate the statement in natural language to Lean:", "output": "theorem Antitone.covariant_of_const' {\u03bc : N \u2192 N \u2192 N} [CovariantClass N N (swap \u03bc) (\u00b7 \u2264 \u00b7)]\n    (hf : Antitone f) (m : N) : Antitone fun n \u21a6 f (\u03bc n m) :="}
{"input": "Statement in natural language:\nFor a relation 'r' between elements of type '\u03b2' and a function 'f' from type '\u03b1' to '\u03b2', the condition of 'pairwise' (meaning that every pair of distinct elements satisfies the relation 'r') for the function 'f' applied to elements of a subset 's' is equivalent to the condition of 'pairwise' for the function 'f' applied to the elements of the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem pairwise_subtype_iff_pairwise_finset' (r : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) :\n    Pairwise (r on fun x : s => f x) \u2194 (s : Set \u03b1).Pairwise (r on f) :="}
{"input": "Statement in natural language:\nThe bounded limit inferior (bliminf) of a function 'u' with respect to a filter 'f' for the condition 'p x or q x' is equal to the greatest lower bound (infimum) of the bliminf of 'u' with respect to 'f' for the condition 'p' and the bliminf of 'u' with respect to 'f' for the condition 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem bliminf_or_eq_inf : (bliminf u f fun x => p x \u2228 q x) = bliminf u f p \u2293 bliminf u f q :="}
{"input": "Statement in natural language:\nFor any matrix 'x' with finite dimensions 'm' and 'n', 'x' can be expressed as the sum of standard basis matrices, where each standard basis matrix is scaled by the corresponding element in 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem matrix_eq_sum_std_basis [Fintype m] [Fintype n] (x : Matrix m n \u03b1) :\n    x = \u2211 i : m, \u2211 j : n, stdBasisMatrix i j (x i j) :="}
{"input": "Statement in natural language:\nFor a given basis 'l' with properties 'p' and sets 's', for any element 'x' of type \u03b1, 'x' is in every set 't' in 'l' if and only if for every 'i', if 'p i' holds, then 'x' is in 's i'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : \u03b1} :\n    (\u2200 t \u2208 l, x \u2208 t) \u2194 \u2200 i, p i \u2192 x \u2208 s i :="}
{"input": "Statement in natural language:\nSubtracting any number from the lowest possible number results in the lowest possible number.\nTranslate the statement in natural language to Lean:", "output": "theorem bot_sub : \u22a5 - t = \u22a5 :="}
{"input": "Statement in natural language:\nFor a given element 'a' and a set 's' of elements of type \u03b1, if 's' is in the neighborhood within 'a' (inclusive), then there exists an element 'b' less than or equal to 'a', such that the closed interval from 'b' to 'a' is in the neighborhood within 'a' (inclusive) and this closed interval is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Iic {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd[\u2264] a) :\n    \u2203 b \u2264 a, Icc b a \u2208 \ud835\udcdd[\u2264] a \u2227 Icc b a \u2286 s :="}
{"input": "Statement in natural language:\nFor any multiplication operation on a set \u03b1, and any two elements 'a' and 'b' from the lexicographic order of \u03b1, the lexicographic order of the product of 'a' and 'b' is equal to the product of the lexicographic orders of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofLex_mul [Mul \u03b1] (a b : Lex \u03b1) : ofLex (a * b) = ofLex a * ofLex b :="}
{"input": "Statement in natural language:\nThe sum of the opposites of a sequence of elements (f x) is equal to the opposite of the sum of the sequence.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_op : (\u2211' x, MulOpposite.op (f x)) = MulOpposite.op (\u2211' x, f x) :="}
{"input": "Statement in natural language:\nFor a given convex set 's' in a topological vector space 'E' over a field '\ud835\udd5c', if every pair of distinct points in the boundary of 's' can be connected by a line segment that lies in the interior of 's', then 's' is strictly convex.\nTranslate the statement in natural language to Lean:", "output": "theorem Convex.strictConvex' {s : Set E} (hs : Convex \ud835\udd5c s)\n    (h : (s \\ interior s).Pairwise fun x y => \u2203 c : \ud835\udd5c, lineMap x y c \u2208 interior s) :\n    StrictConvex \ud835\udd5c s :="}
{"input": "Statement in natural language:\nFor any elements 'm' from set M, 'n' from set N, and 'p' from set P, the inverse of the tensor product association of 'm', 'n', and 'p' is equal to the tensor product of 'm', 'n', and 'p' in that order.\nTranslate the statement in natural language to Lean:", "output": "theorem assoc_symm_tmul (m : M) (n : N) (p : P) :\n    (TensorProduct.assoc R M N P).symm (m \u2297\u209c (n \u2297\u209c p)) = m \u2297\u209c n \u2297\u209c p :="}
{"input": "Statement in natural language:\nFor a complex-valued function 'f', a complex number 'c' and 'w', and a real number 'R', the integral of the function ((z - w)\u207b\u00b9 \u2022 (z - w) \u2022 f z) over the circle centered at 'c' with radius 'R' is equal to the integral of the function 'f' over the same circle.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_sub_inv_smul_sub_smul (f : \u2102 \u2192 E) (c w : \u2102) (R : \u211d) :\n    (\u222e z in C(c, R), (z - w)\u207b\u00b9 \u2022 (z - w) \u2022 f z) = \u222e z in C(c, R), f z :="}
{"input": "Statement in natural language:\nThe limit inferior (liminf) of a function that always returns the top element of a set, under any filter, is the top element of the set.\nTranslate the statement in natural language to Lean:", "output": "theorem liminf_const_top {f : Filter \u03b2} : liminf (fun _ : \u03b2 => (\u22a4 : \u03b1)) f = (\u22a4 : \u03b1) :="}
{"input": "Statement in natural language:\nFor any composition 'c' of a number 'n', the length of 'c' when converted to a composition set is equal to the original length of 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem Composition.toCompositionAsSet_length (c : Composition n) :\n    c.toCompositionAsSet.length = c.length :="}
{"input": "Statement in natural language:\nFor a real number 'r' which is greater than 0 and less than 1, the neighborhood of a point 'x' has a basis that is a function of the natural number 'n', where the function is the closed ball centered at 'x' with radius 'r' to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem nhds_basis_closedBall_pow {r : \u211d} (h0 : 0 < r) (h1 : r < 1) :\n    (\ud835\udcdd x).HasBasis (fun _ => True) fun n : \u2115 => closedBall x (r ^ n) :="}
{"input": "Statement in natural language:\nIf 'x' is an irrational number and 'q' is a rational number that is not equal to zero, then the result of dividing 'q' by 'x' is also an irrational number.\nTranslate the statement in natural language to Lean:", "output": "theorem rat_div (h : Irrational x) {q : \u211a} (hq : q \u2260 0) : Irrational (q / x) :="}
{"input": "Statement in natural language:\nThe composition of the factor through the image of a morphism 'f' and the inverse of the isomorphism from the coimage of 'f' to its image is equal to the projection onto the cokernel.\nTranslate the statement in natural language to Lean:", "output": "theorem factorThruImage_comp_coimageIsoImage'_inv :\n    factorThruImage f \u226b (coimageIsoImage' f).inv = cokernel.\u03c0 _ :="}
{"input": "Statement in natural language:\nA linear order \u03b1 is nontrivial if and only if there exist elements x and y in \u03b1 such that x is less than y.\nTranslate the statement in natural language to Lean:", "output": "theorem nontrivial_iff_lt [LinearOrder \u03b1] : Nontrivial \u03b1 \u2194 \u2203 x y : \u03b1, x < y :="}
{"input": "Statement in natural language:\nFor a given order isomorphism 'e' between two ordered sets '\u03b1' and '\u03b2', 'e' is a surjective function. This means that for every element in the set '\u03b2', there is at least one corresponding element in the set '\u03b1' under the function 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem surjective (e : \u03b1 \u2243o \u03b2) : Function.Surjective e :="}
{"input": "Statement in natural language:\nIf a function 'g' is asymptotically dominated by a function 'f' at a limit point 'l' and 'c' is a non-zero real number, then the function 'f' is also asymptotically dominated by the function 'c * g' at the same limit point 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLittleO.const_mul_right' {g : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) (h : f =o[l] g) :\n    f =o[l] fun x => c * g x :="}
{"input": "Statement in natural language:\nFor a multiplicative character \u03c7 from a ring R to another ring R', the inverse of \u03c7 multiplied by \u03c7 equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_mul (\u03c7 : MulChar R R') : \u03c7\u207b\u00b9 * \u03c7 = 1 :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the successor of 'n' doubled is equal to the successor of the successor of 'n' doubled.\nTranslate the statement in natural language to Lean:", "output": "theorem bit0_succ_eq (n : \u2115) : bit0 (succ n) = succ (succ (bit0 n)) :="}
{"input": "Statement in natural language:\nThe set of vertices of the infimum of a function from an index set to subgraphs is equal to the intersection of the set of vertices of each subgraph in the function.\nTranslate the statement in natural language to Lean:", "output": "theorem verts_iInf {f : \u03b9 \u2192 G.Subgraph} : (\u2a05 i, f i).verts = \u22c2 i, (f i).verts :="}
{"input": "Statement in natural language:\nA number 'a' raised to an odd power 'n' is greater than zero if and only if the number 'a' itself is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_bit1_pos_iff : 0 < a ^ bit1 n \u2194 0 < a :="}
{"input": "Statement in natural language:\nIf a square (sq) is an isomorphism, then the composition of the left side of the square with the homomorphism (g.hom) and the inverse of the right side of the square equals the homomorphism of f.\nTranslate the statement in natural language to Lean:", "output": "theorem left_hom_inv_right [IsIso sq] : sq.left \u226b g.hom \u226b inv sq.right = f.hom :="}
{"input": "Statement in natural language:\nIn the context of ring theory, given an algebraic pushout structure (denoted by H) of rings R, S, R', and S', and given two algebra morphisms f from S to A and g from R' to A, for any element x in R', the result of applying the pushout description function (Algebra.pushoutDesc) to S', f, g, H, and the result of applying the algebra map to R' and S' on x, is equal to the result of applying g on x. This holds for any type A that is a semiring and an algebra over R.\nTranslate the statement in natural language to Lean:", "output": "theorem Algebra.pushoutDesc_right [H : Algebra.IsPushout R S R' S'] {A : Type _} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) (x : R') :\n    Algebra.pushoutDesc S' f g H (algebraMap R' S' x) = g x :="}
{"input": "Statement in natural language:\nFor a function '\u03c0' from '\u03b1' to '\u03b2', a set 's' of '\u03b2', a set 't' of '\u03b1', and an element 'a' of '\u03b1' such that 'a' is an element of 't', 't' is open, and 's' is in the neighborhood of '\u03c0(a)' in the coinduced topology, the preimage of 's' under '\u03c0' is in the neighborhood of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_nhds_within_coinduced {\u03c0 : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {t : Set \u03b1} {a : \u03b1} (h : a \u2208 t)\n    (ht : IsOpen t)\n    (hs : s \u2208 @nhds \u03b2 (.coinduced (fun x : t => \u03c0 x) inferInstance) (\u03c0 a)) :\n    \u03c0 \u207b\u00b9' s \u2208 \ud835\udcdd a :="}
{"input": "Statement in natural language:\nFor any two functors F and G from a category J to a category C, and a natural transformation \u03b1 from F to G, the lax limit of the map \u03b1 is equal to the limit of the map \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem limLax_map {F G : J \u2964 C} (\u03b1 : F \u27f6 G) : limLax.map \u03b1 = lim.map \u03b1 :="}
{"input": "Statement in natural language:\nIf we have a measurable function 'f' and a constant 'c' from a measurable multiplication set 'M', then the function that multiplies 'c' with the output of 'f' for any input 'x' is also measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem Measurable.const_mul [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => c * f x :="}
{"input": "Statement in natural language:\nFor a surjective ring homomorphism \u03c4\u2081\u2082, given a linear map f from M to M\u2082 and a proof h, the range of the quotient lift of f with respect to h is equal to the range of f.\nTranslate the statement in natural language to Lean:", "output": "theorem range_liftQ [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) :\n    range (p.liftQ f h) = range f :="}
{"input": "Statement in natural language:\nThe complement of set 's' is less than or equal to the complement of set 't' if and only if set 's' is less than or equal to set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem compl_le_compl : s.compl \u2264 t.compl \u2194 s \u2264 t :="}
{"input": "Statement in natural language:\nA set 's' is bounded below and above if and only if there exist two elements 'a' and 'b' such that 's' is a subset of the closed interval from 'a' to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem bddBelow_bddAbove_iff_subset_Icc : BddBelow s \u2227 BddAbove s \u2194 \u2203 a b, s \u2286 Icc a b :="}
{"input": "Statement in natural language:\nFor any natural number 's', the greatest common divisor of 0 and 's' is 0.\nTranslate the statement in natural language to Lean:", "output": "theorem gcdA_zero_left {s : \u2115} : gcdA 0 s = 0 :="}
{"input": "Statement in natural language:\nFor any two multiplicative structures M and N, if there exists a multiplicative equivalence between M and N, then an element x in M maps to 1 in N if and only if x is 1 in M.\nTranslate the statement in natural language to Lean:", "output": "theorem map_eq_one_iff {M N} [MulOneClass M] [MulOneClass N] (h : M \u2243* N) {x : M} :\n  h x = 1 \u2194 x = 1 :="}
{"input": "Statement in natural language:\nFor a given category with limits of shape J, and two objects i and j in category K, and a functor F from J to K to C, and a morphism f from i to j, the composition of the map of the limit of F with f and the homomorphism of the limit object isomorphic to the limit composed with the evaluation is equal to the composition of the homomorphism of the limit object isomorphic to the limit composed with the evaluation and the limit map of the left whiskered functor with the map of the evaluation with f.\nTranslate the statement in natural language to Lean:", "output": "theorem limit_map_limitObjIsoLimitCompEvaluation_hom [HasLimitsOfShape J C] {i j : K}\n    (F : J \u2964 K \u2964 C) (f : i \u27f6 j) : (limit F).map f \u226b (limitObjIsoLimitCompEvaluation _ _).hom =\n    (limitObjIsoLimitCompEvaluation _ _).hom \u226b limMap (whiskerLeft _ ((evaluation _ _).map f)) :="}
{"input": "Statement in natural language:\nIf 'a' is less than or equal to 'b', then the difference between the closed interval from 'a' to 'b' and the open interval from 'a' to 'b' is the set containing 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_diff_Ioo_self (h : a \u2264 b) : Icc a b \\ Ioo a b = {a, b} :="}
{"input": "Statement in natural language:\nThe set of all elements 'x' from set 'A' that are algebraic over 'R' is countable.\nTranslate the statement in natural language to Lean:", "output": "theorem countable : Set.Countable { x : A | IsAlgebraic R x } :="}
{"input": "Statement in natural language:\nZero is less than a if and only if a is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_lt_iff : 0 < a \u2194 a \u2260 0 :="}
{"input": "Statement in natural language:\nThe norm of the Fourier integral of a function f with respect to a multiplicative function e, a measure \u03bc, a linear map L, and a point w, is less than or equal to the integral of the norm of the function f with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_fourierIntegral_le_integral_norm (e : Multiplicative \ud835\udd5c \u2192* \ud835\udd4a) (\u03bc : Measure V)\n    (L : V \u2192\u2097[\ud835\udd5c] W \u2192\u2097[\ud835\udd5c] \ud835\udd5c) (f : V \u2192 E) (w : W) :\n    \u2016fourierIntegral e \u03bc L f w\u2016 \u2264 \u222b v : V, \u2016f v\u2016 \u2202\u03bc :="}
{"input": "Statement in natural language:\nThe identity element (1) in the submonoid S' is equal to the pair consisting of the identity element and the proof that the identity element is in the submonoid S'.\nTranslate the statement in natural language to Lean:", "output": "theorem one_def : (1 : S') = \u27e81, OneMemClass.one_mem S'\u27e9 :="}
{"input": "Statement in natural language:\nFor any real number p that is greater than or equal to 1, and for any two non-negative real numbers a and b, the pth power of a plus the pth power of b, all raised to the power of 1/p, is less than or equal to the sum of a and b.\nTranslate the statement in natural language to Lean:", "output": "theorem rpow_add_rpow_le_add {p : \u211d} (a b : \u211d\u22650) (hp1 : 1 \u2264 p) :\n    (a ^ p + b ^ p) ^ (1 / p) \u2264 a + b :="}
{"input": "Statement in natural language:\nThe function 'e' is continuous on the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousOn {s} : ContinuousOn e s :="}
{"input": "Statement in natural language:\nFor any linear ordered semiring \u03b1 and any positive numbers m and n, casting m to \u03b1 is less than n if and only if m is less than n.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_lt [LinearOrderedSemiring \u03b1] {m n : PosNum} : (m : \u03b1) < n \u2194 m < n :="}
{"input": "Statement in natural language:\nA monic polynomial p of degree 2 is not irreducible if and only if there exist coefficients c\u2081 and c\u2082 such that the zeroth coefficient of p equals the product of c\u2081 and c\u2082, and the first coefficient of p equals the sum of c\u2081 and c\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem Monic.not_irreducible_iff_exists_add_mul_eq_coeff (hm : p.Monic) (hnd : p.natDegree = 2) :\n    \u00acIrreducible p \u2194 \u2203 c\u2081 c\u2082, p.coeff 0 = c\u2081 * c\u2082 \u2227 p.coeff 1 = c\u2081 + c\u2082 :="}
{"input": "Statement in natural language:\n'a' is the maximum value in the dual order if and only if 'a' is the minimum value in the original order.\nTranslate the statement in natural language to Lean:", "output": "theorem isMax_toDual_iff : IsMax (toDual a) \u2194 IsMin a :="}
{"input": "Statement in natural language:\nFor a linear isometric equivalence 'f' from 'E' to 'F', and for submodules 'U' and 'V' of 'F', the preimage of 'U' under 'f' is orthogonal to the preimage of 'V' under 'f' if and only if 'U' is orthogonal to 'V'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsOrtho.comap_iff (f : E \u2243\u2097\u1d62[\ud835\udd5c] F) {U V : Submodule \ud835\udd5c F} : U.comap f \u27c2 V.comap f \u2194 U \u27c2 V :="}
{"input": "Statement in natural language:\nThe complement of a set 's' equals the universal set if and only if the set 's' is empty.\nTranslate the statement in natural language to Lean:", "output": "theorem compl_univ_iff {s : Set \u03b1} : s\u1d9c = univ \u2194 s = \u2205 :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c in a set \u03b1, the associative property holds for the operation \"infimum\" (denoted by \u2293). In other words, taking the infimum of a and b first and then taking the infimum with c gives the same result as taking the infimum of b and c first and then taking the infimum with a.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_assoc (a b c : \u03b1) : a \u2293 b \u2293 c = a \u2293 (b \u2293 c) :="}
{"input": "Statement in natural language:\nFor any sequence of propositions 'p' indexed by natural numbers, any sequence of sets 's' also indexed by natural numbers, and any sequence of real numbers 'r' indexed by natural numbers, if the sequence 'r' tends to 0 at the top and for almost all 'i' in the top, if 'p i' is true then 'r i' is greater than 0, then the boundary limit superior of the sequence of c-thickenings of the sets 's' by 'r' at the top for 'p' is almost everywhere equal to the boundary limit superior of the sequence of thickenings of the sets 's' by 'r' at the top for 'p' with respect to measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem blimsup_cthickening_ae_eq_blimsup_thickening {p : \u2115 \u2192 Prop} {s : \u2115 \u2192 Set \u03b1} {r : \u2115 \u2192 \u211d}\n    (hr : Tendsto r atTop (\ud835\udcdd 0)) (hr' : \u2200\u1da0 i in atTop, p i \u2192 0 < r i) :\n    (blimsup (fun i => cthickening (r i) (s i)) atTop p : Set \u03b1) =\u1d50[\u03bc]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set \u03b1) :="}
{"input": "Statement in natural language:\nFor a simple function 'f' from set '\u03b1' to 'E' with respect to measure '\u03bc', applying the function 'setToL1S' with zero as the linear map from set '\u03b1' to 'E' to 'F' over the reals, results in zero.\nTranslate the statement in natural language to Lean:", "output": "theorem setToL1S_zero_left (f : \u03b1 \u2192\u2081\u209b[\u03bc] E) : setToL1S (0 : Set \u03b1 \u2192 E \u2192L[\u211d] F) f = 0 :="}
{"input": "Statement in natural language:\nFor a surjective ring homomorphism \u03c4\u2081\u2082 and a function f from field F, the map of the preimage (comap) of a submodule q under function f is equal to the intersection of the range of function f and the submodule q.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Submodule.map_comap_eq [RingHomSurjective \u03c4\u2081\u2082] (f : F) (q : Submodule R\u2082 M\u2082) :\n    map f (comap f q) = range f \u2293 q :="}
{"input": "Statement in natural language:\nA function that takes an input 'x' and produces a pair consisting of the outputs of two functions 'f' and 'g' (i.e., (f x, g x)) is continuous if and only if both 'f' and 'g' are continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_prod_mk {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} :\n    (Continuous fun x => (f x, g x)) \u2194 Continuous f \u2227 Continuous g :="}
{"input": "Statement in natural language:\nIf function f commutes with function g, then for any natural numbers m and n, the m-th iteration of function f commutes with the n-th iteration of function g.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_iterate (h : Commute f g) (m n : \u2115) : Commute (f^[m]) (g^[n]) :="}
{"input": "Statement in natural language:\nFor a given type \u03b9, a continuous linear map 'f' from M\u2081 to M\u2082, a finite set 's' of type \u03b9, and a function 'g' from \u03b9 to M\u2081, the map of the sum of the function 'g' over the set 's' is equal to the sum of the map of the function 'g' over the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_sum {\u03b9 : Type _} (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (s : Finset \u03b9) (g : \u03b9 \u2192 M\u2081) :\n    f (\u2211 i in s, g i) = \u2211 i in s, f (g i) :="}
{"input": "Statement in natural language:\nFor a certain type \u03b9, a function v from \u03b9 to M, and a linear independence i of v, given a set w of M with finite elements, if the range of v is less than or equal to the span of R and w, then the cardinality of \u03b9 is less than or equal to the cardinality of w.\nTranslate the statement in natural language to Lean:", "output": "theorem linearIndependent_le_span' {\u03b9 : Type _} (v : \u03b9 \u2192 M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : range v \u2264 span R w) : (#\u03b9) \u2264 Fintype.card w :="}
{"input": "Statement in natural language:\nIf a function f has a derivative f' at a point x with respect to a filter L, then the function that subtracts a constant c from f also has a derivative f' at the same point x with respect to the same filter L.\nTranslate the statement in natural language to Lean:", "output": "theorem HasDerivAtFilter.sub_const (hf : HasDerivAtFilter f f' x L) (c : F) :\n    HasDerivAtFilter (fun x => f x - c) f' x L :="}
{"input": "Statement in natural language:\nFor a list 'l' with no duplicate elements (Nodup l) and a length of at least 2 (2 \u2264 l.length), the cycle of the formPerm function applied to 'l' and an element 'x' is equal to the formPerm function applied to 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem cycleOf_formPerm (hl : Nodup l) (hn : 2 \u2264 l.length) (x) :\n    cycleOf l.attach.formPerm x = l.attach.formPerm :="}
{"input": "Statement in natural language:\nFor a given isomorphism 'f' from 'N' to 'M' and a submonoid 'K' of 'M', the preimage of 'K' under 'f' is equal to the image of 'K' under the inverse of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_equiv_eq_map_symm (f : N \u2243* M) (K : Submonoid M) :\n    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :="}
{"input": "Statement in natural language:\nThe fractional part of 'm' with respect to 'b' equals the fractional part of 'n' with respect to 'b' if and only if the difference of 'm' and 'n' is an integer multiple of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem fract_eq_fract (m n : E) : fract b m = fract b n \u2194 -m + n \u2208 span \u2124 (Set.range b) :="}
{"input": "Statement in natural language:\nFor two uniform space homeomorphisms 'h' and 'h'' from '\u03b1' to '\u03b2', if for every 'x' in '\u03b1', 'h' at 'x' equals 'h'' at 'x', then 'h' is equal to 'h''.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {h h' : \u03b1 \u2243\u1d64 \u03b2} (H : \u2200 x, h x = h' x) : h = h' :="}
{"input": "Statement in natural language:\nFor a finite dimensional vector space V over a field K, given a type \u03b9 and a function b from \u03b9 to V that is linearly independent, the cardinality of \u03b9 is less than or equal to the finite rank of the vector space V over the field K.\nTranslate the statement in natural language to Lean:", "output": "theorem cardinal_mk_le_finrank_of_linearIndependent [FiniteDimensional K V] {\u03b9 : Type w} {b : \u03b9 \u2192 V}\n    (h : LinearIndependent K b) : (#\u03b9) \u2264 finrank K V :="}
{"input": "Statement in natural language:\nIf F is a sheaf on X (in the category C), then the pushforward of F along some morphism f is also a sheaf.\nTranslate the statement in natural language to Lean:", "output": "theorem pushforward_sheaf_of_sheaf {F : X.Presheaf C} (h : F.IsSheaf) : (f _* F).IsSheaf :="}
{"input": "Statement in natural language:\nFor a given pair of vertices 'p' in a graph 'G' where 'p.1' and 'p.2' are adjacent, the edge of the dart created from 'p' and this adjacency is equivalent to the unordered pair of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem Dart.edge_mk {p : V \u00d7 V} (h : G.Adj p.1 p.2) : (Dart.mk p h).edge = \u27e6p\u27e7 :="}
{"input": "Statement in natural language:\nThe image of the upper bounds of a set under a function is a subset of the upper bounds of the image of the set under the same function.\nTranslate the statement in natural language to Lean:", "output": "theorem image_upperBounds_subset_upperBounds_image : f '' upperBounds s \u2286 upperBounds (f '' s) :="}
{"input": "Statement in natural language:\nA function 'f' has a sum 'a' over a finite set 's' if and only if the function 'f' has a sum of 'a' minus the sum of 'f' over 's' for all elements 'x' not in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Finset.hasSum_iff_compl (s : Finset \u03b2) :\n    HasSum f a \u2194 HasSum (fun x : { x // x \u2209 s } => f x) (a - \u2211 i in s, f i) :="}
{"input": "Statement in natural language:\nIf 'w' is a commutative square with 'fst', 'snd', 'f', and 'g' as its elements, and 'w.cone' is a limit, then 'fst', 'snd', 'f', and 'g' form a pullback.\nTranslate the statement in natural language to Lean:", "output": "theorem of_isLimit' (w : CommSq fst snd f g) (h : Limits.IsLimit w.cone) :\n    IsPullback fst snd f g :="}
{"input": "Statement in natural language:\nFor any two multi-variable polynomials 'p' and 'q', the support of the sum of 'p' and 'q' is a subset of the union of the support of 'p' and the support of 'q'. This is under the condition that there exists a decidable equality for '\u03c3'.\nTranslate the statement in natural language to Lean:", "output": "theorem support_add [DecidableEq \u03c3] : (p + q).support \u2286 p.support \u222a q.support :="}
{"input": "Statement in natural language:\nIf a function 'f' is monotone and the composition of functions 'h' and 'g' is less than or equal to the composition of 'f' and 'h', then for any natural number 'n', the composition of 'h' and the 'n'-th iteration of 'g' is less than or equal to the 'n'-th iteration of 'f' composed with 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_iterate_comp_of_le (hf : Monotone f) (H : h \u2218 g \u2264 f \u2218 h) (n : \u2115) :\n    h \u2218 g^[n] \u2264 f^[n] \u2218 h :="}
{"input": "Statement in natural language:\nA constant function (which always returns the value 'b') is Lipschitz continuous with a Lipschitz constant of 0.\nTranslate the statement in natural language to Lean:", "output": "theorem const (b : \u03b2) : LipschitzWith 0 fun _ : \u03b1 => b :="}
{"input": "Statement in natural language:\nIn the context of algebra, given an algebra structure over rings R and A, and a scalar tower structure over R, A, and B, A is integral over R.\nTranslate the statement in natural language to Lean:", "output": "theorem isIntegral_algebra [Algebra R A] [IsScalarTower R A B] : Algebra.IsIntegral R A :="}
{"input": "Statement in natural language:\nThe exponential function is continuous on the metric ball centered at 0 with radius equal to the radius of the exponential series.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousOn_exp : ContinuousOn (exp \ud835\udd42 : \ud835\udd38 \u2192 \ud835\udd38) (EMetric.ball 0 (expSeries \ud835\udd42 \ud835\udd38).radius) :="}
{"input": "Statement in natural language:\nFor a given property 'p' applicable to a multiset 's' of any type '\u03b1', and a proof 'H' of this property, the result of applying strong induction on 's' with 'H' is equal to the result of applying 'H' to 's' and a function that applies strong induction on any 't' that is a subset of 's' with 'H'.\nTranslate the statement in natural language to Lean:", "output": "theorem strongInductionOn_eq {p : Multiset \u03b1 \u2192 Sort _} (s : Multiset \u03b1) (H) :\n    @strongInductionOn _ p s H = H s fun t _h => @strongInductionOn _ p t H :="}
{"input": "Statement in natural language:\nFor any element 'x' of a Lie algebra 'L', any element 'm' of a module 'M', and any natural number 'k', the 'k'-th iteration of 'x' under the endomorphism 'toEndomorphism' applied to 'm' is an element of the 'k'-th lower central series of the module 'M' over the ring 'R' and the Lie algebra 'L'.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_toEndomorphism_mem_lowerCentralSeries (x : L) (m : M) (k : \u2115) :\n    (toEndomorphism R L M x^[k]) m \u2208 lowerCentralSeries R L M k :="}
{"input": "Statement in natural language:\nThe function 'f' is continuous on the set 's' if and only if for every set 't' in the codomain, if 't' is open, then there exists a set 'u' in the domain such that 'u' is open and the preimage of 't' under 'f' intersected with 's' is equal to 'u' intersected with 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousOn_iff' {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    ContinuousOn f s \u2194 \u2200 t : Set \u03b2, IsOpen t \u2192 \u2203 u, IsOpen u \u2227 f \u207b\u00b9' t \u2229 s = u \u2229 s :="}
{"input": "Statement in natural language:\nFor any element 'x' from the set '\ud835\udd38', the exponential series is summable, where each term in the series is the result of applying the exponential series function to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem expSeries_summable (x : \ud835\udd38) : Summable fun n => expSeries \ud835\udd42 \ud835\udd38 n fun _ => x :="}
{"input": "Statement in natural language:\nA module 'M' quotiented by a submodule 'm' over a ring 'R' is a simple module if and only if 'm' is a coatom.\nTranslate the statement in natural language to Lean:", "output": "theorem isSimpleModule_iff_isCoatom : IsSimpleModule R (M \u29f8 m) \u2194 IsCoatom m :="}
{"input": "Statement in natural language:\nFor any natural number 'a' and its corresponding natural number 'a'', and any natural number 'c', if 'a' is a natural number equivalent to 'a'' and the successor of 'a'' is equal to 'c', then the successor of 'a' is a natural number equivalent to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem isNat_natSucc : {a : \u2115} \u2192 {a' c : \u2115} \u2192\n    IsNat a a' \u2192 Nat.succ a' = c \u2192 IsNat (a.succ) c"}
{"input": "Statement in natural language:\n's' is a lower set if and only if for all 'a', if 'a' is an element of 's', then the set of all elements less than or equal to 'a' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isLowerSet_iff_Iic_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iic a \u2286 s :="}
{"input": "Statement in natural language:\nFor any natural number 'n', when 'n' is cast from lexicographic order to any type '\u03b1' using the natural number casting function, it remains equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofLex_natCast [NatCast \u03b1] (n : \u2115) : (ofLex n : \u03b1) = n :="}
{"input": "Statement in natural language:\nFor a given type \u03b1 that is small, there is no injective function from the set of ordinals to \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem not_injective_of_ordinal_of_small {\u03b1 : Type v} [Small.{u} \u03b1] (f : Ordinal.{u} \u2192 \u03b1) :\n    \u00acInjective f :="}
{"input": "Statement in natural language:\nFor any element 'a' in the dual order, 'a' is the maximum element if and only if 'a' is the minimum element.\nTranslate the statement in natural language to Lean:", "output": "theorem isMax_ofDual_iff {a : \u03b1\u1d52\u1d48} : IsMax (ofDual a) \u2194 IsMin a :="}
{"input": "Statement in natural language:\nFor any two sets s and t, if the neighborhood of s contains boxes of t, then the neighborhood of t also contains boxes of s. This property is symmetric.\nTranslate the statement in natural language to Lean:", "output": "theorem NhdsContainBoxes.symm {s : Set \u03b1} {t : Set \u03b2} :\n    NhdsContainBoxes s t \u2192 NhdsContainBoxes t s :="}
{"input": "Statement in natural language:\nFor any two finite sets s\u2081 and s\u2082 of any type \u03b1, s\u2081 is a subset of s\u2082 as a set of type \u03b1 if and only if s\u2081 is a subset of s\u2082 as a finite set.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_subset {s\u2081 s\u2082 : Finset \u03b1} : (s\u2081 : Set \u03b1) \u2286 s\u2082 \u2194 s\u2081 \u2286 s\u2082 :="}
{"input": "Statement in natural language:\nMapping the range of an additive equivalence that reflects the type M is the same as reflecting an additive equivalence of a function from \u03b1 to M.\nTranslate the statement in natural language to Lean:", "output": "theorem mapRange.addEquiv_refl : mapRange.addEquiv (AddEquiv.refl M) = AddEquiv.refl (\u03b1 \u2192\u2080 M) :="}
{"input": "Statement in natural language:\nFor any ordered semiring \u03b1, and any elements a and b of \u03b1, if a equals 0 and b is less than or equal to 0, then the sum of a and b is less than or equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_eq_of_le {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a = 0) (hb : b \u2264 0) : a + b \u2264 0 :="}
{"input": "Statement in natural language:\nFor any given Boolean value 'b', 'b' is either false or true.\nTranslate the statement in natural language to Lean:", "output": "theorem dichotomy (b : Bool) : b = false \u2228 b = true :="}
{"input": "Statement in natural language:\nIn the context of category theory, for any type 'C' that forms a groupoid, and for any two objects 'X' and 'Y' of type 'C', 'X' is isomorphic to 'Y' if and only if there exists at least one morphism from 'X' to 'Y'.\nTranslate the statement in natural language to Lean:", "output": "theorem Groupoid.isIsomorphic_iff_nonempty_hom {C : Type u} [Groupoid.{v} C] {X Y : C} :\n    IsIsomorphic X Y \u2194 Nonempty (X \u27f6 Y) :="}
{"input": "Statement in natural language:\nAn ordinal number 'a' is less than the predecessor of an ordinal number 'b' if and only if the successor of 'a' is less than 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_pred {a b} : a < pred b \u2194 succ a < b :="}
{"input": "Statement in natural language:\nIf 'a' is the greatest element in set 's', then 'a' is included in the maximal elements of the set 's' with respect to the less than or equal to relation.\nTranslate the statement in natural language to Lean:", "output": "theorem IsGreatest.mem_maximals (h : IsGreatest s a) : a \u2208 maximals (\u00b7 \u2264 \u00b7) s :="}
{"input": "Statement in natural language:\nThe head of a vector, which is a function from the successor of a finite number 'n' to an arbitrary type '\u03b1' and is initialized to zero, is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem head_zero : vecHead (0 : Fin n.succ \u2192 \u03b1) = 0 :="}
{"input": "Statement in natural language:\nThe preimage of the set of real numbers between 'a' and 'b' under the function that casts integers to real numbers is the set of integers between the ceiling of 'a' and the floor of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_Icc {a b : \u03b1} : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Icc a b = Set.Icc \u2308a\u2309 \u230ab\u230b :="}
{"input": "Statement in natural language:\nFor any two objects 'p' and 'q' in the action category of 'M' and 'X', and any morphism 'f' from 'p' to 'q', the map of 'f' under the projection functor '\u03c0' from 'M' to 'X' is equal to the value of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem \u03c0_map (p q : ActionCategory M X) (f : p \u27f6 q) : (\u03c0 M X).map f = f.val :="}
{"input": "Statement in natural language:\nFor any Boolean value 'b' and any element 'a' of any type '\u03b1', the condition that returns 'a' whether 'b' is true or false is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem cond_self.{u} {\u03b1 : Type u} (b : Bool) (a : \u03b1) : cond b a a = a :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any function f from Boolean to \u03b1, the function f is injective if and only if the function f applied to false is not equal to the function f applied to true.\nTranslate the statement in natural language to Lean:", "output": "theorem injective_iff {\u03b1 : Sort _} {f : Bool \u2192 \u03b1} : Function.Injective f \u2194 f false \u2260 f true :="}
{"input": "Statement in natural language:\nFor an ordered type \u03b1, the \"some\" option of a is less than the \"some\" option of b if and only if a is less than b.\nTranslate the statement in natural language to Lean:", "output": "theorem some_lt_some : @LT.lt (WithBot \u03b1) _ (Option.some a) (Option.some b) \u2194 a < b :="}
{"input": "Statement in natural language:\nThe symmetric difference of 'a' and 'b', excluding 'c', is equal to 'a' excluding the union of 'b' and 'c', union 'b' excluding the union of 'a' and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem symmDiff_sdiff : a \u2206 b \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) :="}
{"input": "Statement in natural language:\nThe right take-while operation on a list 'l' with a predicate 'p' equals an empty list if and only if for all non-empty lists 'l', the predicate 'p' applied to the last element of 'l' is not true.\nTranslate the statement in natural language to Lean:", "output": "theorem rtakeWhile_eq_nil_iff : rtakeWhile p l = [] \u2194 \u2200 hl : l \u2260 [], \u00acp (l.getLast hl) :="}
{"input": "Statement in natural language:\nIf a function f has a derivative f' within a set s at a point x, then the function that maps x to the complex sine of f(x) has a derivative within the same set s at the same point x, which is the complex cosine of f(x) times f'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivWithinAt.csin (hf : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (fun x => Complex.sin (f x)) (Complex.cos (f x) \u2022 f') s x :="}
{"input": "Statement in natural language:\nThe factor multiset of 1 is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem factorMultiset_one : factorMultiset 1 = 0 :="}
{"input": "Statement in natural language:\nFor a functor F from category J to the category of topological spaces, the topology of the limit of F is the infimum of the topologies induced by the limit projections from the limit of F to each object in the image of F.\nTranslate the statement in natural language to Lean:", "output": "theorem limit_topology (F : J \u2964 TopCatMax.{v, u}) :\n    (limit F).str = \u2a05 j, (F.obj j).str.induced (limit.\u03c0 F j) :="}
{"input": "Statement in natural language:\nFor two trivializations 'e' and 'e'' of a fiber bundle with projection 'proj', the source of the transformation from the inverse of 'e' to 'e'' is equal to the intersection of the base sets of 'e' and 'e'' cross the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_trans_source_eq (e e' : Trivialization F proj) :\n    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).source = (e.baseSet \u2229 e'.baseSet) \u00d7\u02e2 univ :="}
{"input": "Statement in natural language:\nFor a given set R which is a right transversal of a subset H of a group G, and a given set S such that its closure is the entire group G, the closure of the image of the set resulting from multiplying R and S, under a function that maps each element g to the pair consisting of g multiplied by the inverse of the function applied to g (where this function is guaranteed to map g to an element of G), is also the entire group G. This is under the condition that the identity element of G is in R.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_mul_image_eq_top (hR : R \u2208 rightTransversals (H : Set G)) (hR1 : (1 : G) \u2208 R)\n    (hS : closure S = \u22a4) : closure ((R * S).image fun g =>\n      \u27e8g * (toFun hR g : G)\u207b\u00b9, mul_inv_toFun_mem hR g\u27e9 : Set H) = \u22a4 :="}
{"input": "Statement in natural language:\nThe ordered connected component of 's' at 'a' is in the neighborhood of 'a' if and only if 's' is in the neighborhood of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem ordConnectedComponent_mem_nhds : ordConnectedComponent s a \u2208 \ud835\udcdd a \u2194 s \u2208 \ud835\udcdd a :="}
{"input": "Statement in natural language:\nThe algebraic evaluation of the polynomial 1 with respect to any variable x in the ring R is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem aeval_one : aeval x (1 : R[X]) = 1 :="}
{"input": "Statement in natural language:\nFor a given non-unital subsemiring 's' of 'R', the subsemigroup of 's' when considered as a set of 'R', is equal to 's' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :="}
{"input": "Statement in natural language:\nIf for all x, the preimage of the set of all elements less than x under the function f is a measurable set, then the function f is measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_of_Iio {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iio x)) : Measurable f :="}
{"input": "Statement in natural language:\nThe image of a function 'f' is surjective if and only if the function 'f' itself is surjective.\nTranslate the statement in natural language to Lean:", "output": "theorem image_surjective : Surjective (image f) \u2194 Surjective f :="}
{"input": "Statement in natural language:\nIf for every index i, the value of function f at i is less than or equal to a, then the supremum (least upper bound) of the function f is less than or equal to a.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_le (h : \u2200 i, f i \u2264 a) : iSup f \u2264 a :="}
{"input": "Statement in natural language:\nThe composition of a function 'f' with the range splitting of 'f' is equal to the inclusion function. Here, 'f' is a function from type \u03b1 to type \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_rangeSplitting (f : \u03b1 \u2192 \u03b2) :\n  f \u2218 rangeSplitting f = (\u2191) :="}
{"input": "Statement in natural language:\nIf a function 'a' is differentiable on a set 's' in a field '\ud835\udd5c', then the function that maps 'x' to the 'n'-th power of 'a(x)' is also differentiable on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem DifferentiableOn.pow (ha : DifferentiableOn \ud835\udd5c a s) (n : \u2115) :\n    DifferentiableOn \ud835\udd5c (fun x => a x ^ n) s :="}
{"input": "Statement in natural language:\nThe image of the first element of the antidiagonal divisors of a number n is equal to the divisors of n.\nTranslate the statement in natural language to Lean:", "output": "theorem image_fst_divisorsAntidiagonal : (divisorsAntidiagonal n).image Prod.fst = divisors n :="}
{"input": "Statement in natural language:\nIf U is a closed set in the group G, then the left coset of U with respect to any element x in G is also a closed set.\nTranslate the statement in natural language to Lean:", "output": "theorem IsClosed.leftCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (leftCoset x U) :="}
{"input": "Statement in natural language:\nFor a linear equivalence 'f' between two modules 'M' and 'M\u2081' over a ring 'R', and a submodule 'p' of 'M', the rank of the image of 'p' under 'f' is equal to the rank of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearEquiv.rank_map_eq (f : M \u2243\u2097[R] M\u2081) (p : Submodule R M) :\n    Module.rank R (p.map (f : M \u2192\u2097[R] M\u2081)) = Module.rank R p :="}
{"input": "Statement in natural language:\nFor any type \u03b1 that has a top element (OrderTop \u03b1) and any subtype of \u03b1 that also has a top element (OrderTop (Subtype p)), if the top element of \u03b1 satisfies the property p (htop : p \u22a4), then the top element of the subtype created with this property (mk \u22a4 htop) is equal to the top element of the subtype itself (\u22a4).\nTranslate the statement in natural language to Lean:", "output": "theorem mk_top [OrderTop \u03b1] [OrderTop (Subtype p)] (htop : p \u22a4) : mk \u22a4 htop = \u22a4 :="}
{"input": "Statement in natural language:\nIf a set 's' in a vector space 'E' is star-convex with respect to a point 'x', then the image of this set under an affine transformation 'f' is also star-convex with respect to the image of 'x' under the same transformation.\nTranslate the statement in natural language to Lean:", "output": "theorem StarConvex.affine_image (f : E \u2192\u1d43[\ud835\udd5c] F) {s : Set E} (hs : StarConvex \ud835\udd5c x s) :\n    StarConvex \ud835\udd5c (f x) (f '' s) :="}
{"input": "Statement in natural language:\nFor a non-zero divisor in a ring M' and a function f that is injective, the set of non-zero divisors in M is less than or equal to the preimage of the set of non-zero divisors in M' under the function f.\nTranslate the statement in natural language to Lean:", "output": "theorem nonZeroDivisors_le_comap_nonZeroDivisors_of_injective [NoZeroDivisors M']\n    [MonoidWithZeroHomClass F M M'] (f : F) (hf : Function.Injective f) : M\u2070 \u2264 M'\u2070.comap f :="}
{"input": "Statement in natural language:\nFor any elements 'z' and 'u', 'f.map hy k z' equals 'u' if and only if 'k.toMap' applied to 'g' of the first element of 'f.sec z' equals 'k.toMap' applied to 'g' of the second element of 'f.sec z' multiplied by 'u'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_spec (z u) : f.map hy k z = u \u2194 k.toMap (g (f.sec z).1) = k.toMap (g (f.sec z).2) * u :="}
{"input": "Statement in natural language:\nThe closed interval from a to b, excluding both a and b, is equal to the open interval from a to b.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_diff_both : Icc a b \\ {a, b} = Ioo a b :="}
{"input": "Statement in natural language:\nIf C is preperfect, then the closure of C is perfect. This is under the context of topology.\nTranslate the statement in natural language to Lean:", "output": "theorem Preperfect.perfect_closure (hC : Preperfect C) : Perfect (closure C) :="}
{"input": "Statement in natural language:\nFor a given function 'v' mapping from 'm' to '\u03b1' in a star-ring, the conjugate transpose of a column vector 'v' is equal to the row vector of the star of 'v'.\nTranslate the statement in natural language to Lean:", "output": "theorem conjTranspose_col [Star \u03b1] (v : m \u2192 \u03b1) : (col v)\u1d34 = row (star v) :="}
{"input": "Statement in natural language:\nFor a finite measure \u03bc on a set \u03a9, the mass of \u03bc is not equal to zero if and only if \u03bc is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem mass_nonzero_iff (\u03bc : FiniteMeasure \u03a9) : \u03bc.mass \u2260 0 \u2194 \u03bc \u2260 0 :="}
{"input": "Statement in natural language:\nIf a function 'f' belongs to the space of measurable functions 'Mem\u2112p' for a measure '\u03bc' and a real number 'p', and if 'c' is a non-infinite extended non-negative real number, then 'f' also belongs to the space of measurable functions 'Mem\u2112p' for the measure 'c' times '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem Mem\u2112p.smul_measure {f : \u03b1 \u2192 E} {c : \u211d\u22650\u221e} (hf : Mem\u2112p f p \u03bc) (hc : c \u2260 \u221e) :\n    Mem\u2112p f p (c \u2022 \u03bc) :="}
{"input": "Statement in natural language:\nThe function 'embedProduct M' induces a topology.\nTranslate the statement in natural language to Lean:", "output": "theorem inducing_embedProduct : Inducing (embedProduct M) :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1', the application of the function 'pureOneHom' to 'a' is equal to the application of the function 'pure' to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem pureOneHom_apply (a : \u03b1) : pureOneHom a = pure a :="}
{"input": "Statement in natural language:\nSubtracting any element 'a' from zero results in zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_tsub (a : \u03b1) : 0 - a = 0 :="}
{"input": "Statement in natural language:\nFor any ideal I in a ring R, if I is not equal to the top element, then the characteristic of the quotient ring R/I is zero. Under these conditions, the cast of 1 from the positive natural numbers to the multiplicative group of R is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem pnatCast_one [Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I))] : ((1 : \u2115+) : R\u02e3) = 1 :="}
{"input": "Statement in natural language:\nFor a given cardinal number 'a' and a natural number 'n', the lift of 'a' is less than or equal to 'n' if and only if 'a' is less than or equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_le_nat_iff {a : Cardinal.{u}} {n : \u2115} : lift.{v} a \u2264 n \u2194 a \u2264 n :="}
{"input": "Statement in natural language:\nFor any three games x\u2081, x\u2082, and y, if x\u2081 is equivalent to x\u2082, then the fuzzy relation of x\u2081 and y is equivalent to the fuzzy relation of x\u2082 and y.\nTranslate the statement in natural language to Lean:", "output": "theorem fuzzy_congr_left {x\u2081 x\u2082 y : PGame} (hx : x\u2081 \u2248 x\u2082) : x\u2081 \u2016 y \u2194 x\u2082 \u2016 y :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type \u03b1, the function that takes an element 'b' of type \u03b2 and maps it to the pair (a, b) is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.Prod.mk (a : \u03b1) : Continuous fun b : \u03b2 => (a, b) :="}
{"input": "Statement in natural language:\nFor any two filters 'l\u2081' and 'l\u2082' and any two functions 'Ixx' and 'Ixx'' that map from '\u03b1' to '\u03b1' to a set of '\u03b1', if for all 'a' and 'b', the set 'Ixx' of 'a' and 'b' is a subset of the set 'Ixx'' of 'a' and 'b', and if 'Ixx'' tends to 'Ixx' class from 'l\u2081' to 'l\u2082', then 'Ixx' also tends to 'Ixx' class from 'l\u2081' to 'l\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendstoIxxClass_of_subset {l\u2081 l\u2082 : Filter \u03b1} {Ixx Ixx' : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1}\n    (h : \u2200 a b, Ixx a b \u2286 Ixx' a b) [h' : TendstoIxxClass Ixx' l\u2081 l\u2082] : TendstoIxxClass Ixx l\u2081 l\u2082 :="}
{"input": "Statement in natural language:\nFor any split simplicial object S in a category C, the functor of the identity morphism from S to S is equal to the identity morphism in the category of the object S.X.\nTranslate the statement in natural language to Lean:", "output": "theorem id_F (S : Split C) : (\ud835\udfd9 S : S \u27f6 S).F = \ud835\udfd9 S.X :="}
{"input": "Statement in natural language:\nFor any three integers i, j, and k, the greatest common divisor of i and j divides the greatest common divisor of i and the product of j and k.\nTranslate the statement in natural language to Lean:", "output": "theorem gcd_dvd_gcd_mul_right_right (i j k : \u2124) : gcd i j \u2223 gcd i (j * k) :="}
{"input": "Statement in natural language:\nFor any two elements x and y in a module M, x and y are on the same ray or x and (-y) are on the same ray if and only if x and y are not linearly independent.\nTranslate the statement in natural language to Lean:", "output": "theorem sameRay_or_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y \u2228 SameRay R x (-y) \u2194 \u00acLinearIndependent R ![x, y] :="}
{"input": "Statement in natural language:\nThe difference of the interval from a to b, excluding b, and the set containing only b, is equal to the open interval from a to b.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioc_diff_right : Ioc a b \\ {b} = Ioo a b :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a set '\u03b1', the equivalence class of 'a' is equal to the equivalence class of 'b' if and only if the product of the inverse of 'a' and 'b' is an element of the subset 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq' {a b : \u03b1} : (mk a : \u03b1 \u29f8 s) = mk b \u2194 a\u207b\u00b9 * b \u2208 s :="}
{"input": "Statement in natural language:\nA presheaf P is separated for a sieve R and for every family of elements of P over R, if the family is compatible, then there exists an amalgamation, if and only if P is a sheaf for R.\nTranslate the statement in natural language to Lean:", "output": "theorem isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :\n    (IsSeparatedFor P R \u2227 \u2200 x : FamilyOfElements P R, x.Compatible \u2192 \u2203 t, x.IsAmalgamation t) \u2194\n      IsSheafFor P R :="}
{"input": "Statement in natural language:\nThe evaluation of a singleton list containing an element 'a' in a deterministic finite automaton 'M' is equal to the result of stepping from the start state of 'M' with 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem eval_singleton (a : \u03b1) : M.eval [a] = M.step M.start a :="}
{"input": "Statement in natural language:\nIf for every index i, the value of the function g at i is nonnegative, then the infinite sum of the function g over all indices i is also nonnegative.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_nonneg (h : \u2200 i, 0 \u2264 g i) : 0 \u2264 \u2211' i, g i :="}
{"input": "Statement in natural language:\nFor a given function 'f' from a product of types '\u03b1' and '\u03b4 a' to '\u03b2', a finite set 's' of type '\u03b1', and a function 't' that assigns to each element of '\u03b1' a finite set of type '\u03b4 a', the product over 's' of the sum over 't a' of 'f a b' is equal to the sum over the product set 's.pi t' of the product over 's.attach' of 'f x.1 (p x.1 x.2)'. Here, 's.pi t' is the set of all functions from 's' to the union of 't a' for 'a' in 's', and 's.attach' is the set of all elements of 's' along with their indices.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_sum {\u03b4 : \u03b1 \u2192 Type _} [DecidableEq \u03b1] [\u2200 a, DecidableEq (\u03b4 a)] {s : Finset \u03b1}\n    {t : \u2200 a, Finset (\u03b4 a)} {f : \u2200 a, \u03b4 a \u2192 \u03b2} :\n    (\u220f a in s, \u2211 b in t a, f a b) = \u2211 p in s.pi t, \u220f x in s.attach, f x.1 (p x.1 x.2) :="}
{"input": "Statement in natural language:\nFor any two subsemigroups S and T of a semigroup M, and any two elements x and y from M, if x is an element of S and y is an element of T, then the product of x and y is an element of the union of S and T.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_mem_sup {S T : Subsemigroup M} {x y : M} (hx : x \u2208 S) (hy : y \u2208 T) : x * y \u2208 S \u2294 T :="}
{"input": "Statement in natural language:\nFor a given type S with a commutative ring structure and an algebra structure over a ring R, and a subalgebra S' of this algebra, given a finite set \u03b9' of type \u03b9, and two functions s and l from \u03b9 to S such that the sum of the product of l i and s i over all i in \u03b9' equals 1, and for all i, s i and l i are elements of S', if for a given element x of S, for all i there exists a natural number n such that the n-th power of s i times x is an element of S', then x is an element of S'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_of_finset_sum_eq_one_of_pow_smul_mem {S : Type _} [CommRing S] [Algebra R S]\n    (S' : Subalgebra R S) {\u03b9 : Type _} (\u03b9' : Finset \u03b9) (s : \u03b9 \u2192 S) (l : \u03b9 \u2192 S)\n    (e : (\u2211 i in \u03b9', l i * s i) = 1) (hs : \u2200 i, s i \u2208 S') (hl : \u2200 i, l i \u2208 S') (x : S)\n    (H : \u2200 i, \u2203 n : \u2115, (s i ^ n : S) \u2022 x \u2208 S') : x \u2208 S' :="}
{"input": "Statement in natural language:\nThe cardinality of the set of all elements less than a given boundary 'b' is equal to 'b' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem card_fintypeIio : Fintype.card (Set.Iio b) = b :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from a vector space 'E' to another vector space 'E'', if 'f' preserves the inner product (as specified by 'h'), then the function corresponding to the isometry of 'f' is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearMap.coe_isometryOfInner (f : E \u2192\u2097[\ud835\udd5c] E') (h) : \u21d1(f.isometryOfInner h) = f :="}
{"input": "Statement in natural language:\nFor a multiset t of polynomials with coefficients in a ring R, if the zero polynomial is not an element of t, then the degree of the product of all polynomials in t is equal to the sum of the degrees of all polynomials in t.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_multiset_prod (h : (0 : R[X]) \u2209 t) :\n    natDegree t.prod = (t.map natDegree).sum :="}
{"input": "Statement in natural language:\nFor any complete type 'p' in the language 'L' with variables of type '\u03b1', and any sentence '\u03c6' in this language, either '\u03c6' is in 'p' or the negation of '\u03c6' is in 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_or_not_mem (p : T.CompleteType \u03b1) (\u03c6 : L[[\u03b1]].Sentence) : \u03c6 \u2208 p \u2228 \u03c6.not \u2208 p :="}
{"input": "Statement in natural language:\nIf two angles \u03b8 and \u03c8 are such that twice the angle \u03b8 is equal to twice the angle \u03c8 (in the integer multiples sense), then the tangent of angle \u03b8 is equal to the tangent of angle \u03c8.\nTranslate the statement in natural language to Lean:", "output": "theorem tan_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) : tan \u03b8 = tan \u03c8 :="}
{"input": "Statement in natural language:\nFor a given property 'p' pertaining to a pair of elements from sets '\u03b1' and '\u03b2', the property 'p' holds eventually for all elements in the product of 'f' and 'g' if and only if the property 'p' holds eventually for all elements in the swapped product of 'g' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem eventually_swap_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} :\n    (\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in f \u00d7\u02e2 g, p x) \u2194 \u2200\u1da0 y : \u03b2 \u00d7 \u03b1 in g \u00d7\u02e2 f, p y.swap :="}
{"input": "Statement in natural language:\nA cardinal number 'c' is less than or equal to the rank of a module over a field 'K' and a vector space 'V' if and only if there exists a set 's' of vectors in 'V' such that the cardinality of 's' is 'c' and the function that maps 's' to 'V' is linearly independent.\nTranslate the statement in natural language to Lean:", "output": "theorem le_rank_iff_exists_linearIndependent {c : Cardinal} :\n    c \u2264 Module.rank K V \u2194 \u2203 s : Set V, (#s) = c \u2227 LinearIndependent K ((\u2191) : s \u2192 V) :="}
{"input": "Statement in natural language:\nFor all rational numbers x, the p-adic number representation of the negation of x is equal to the negation of the p-adic number representation of x.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_neg : \u2200 {x : \u211a}, (\u2191(-x) : \u211a_[p]) = -\u2191x :="}
{"input": "Statement in natural language:\nFor a given type \u03b9 and a function v from \u03b9 to E, if v is orthonormal and s is a submodule of E such that every element of v is in s, then the codomain restriction of v to s is also orthonormal.\nTranslate the statement in natural language to Lean:", "output": "theorem Orthonormal.codRestrict {\u03b9 : Type _} {v : \u03b9 \u2192 E} (hv : Orthonormal \ud835\udd5c v) (s : Submodule \ud835\udd5c E)\n    (hvs : \u2200 i, v i \u2208 s) : @Orthonormal \ud835\udd5c s _ _ _ \u03b9 (Set.codRestrict v s hvs) :="}
{"input": "Statement in natural language:\nIf a relation 'r' is reflexive on a set '\u03b1', then 'r' is reflexive.\nTranslate the statement in natural language to Lean:", "output": "theorem IsRefl.reflexive [IsRefl \u03b1 r] : Reflexive r :="}
{"input": "Statement in natural language:\nFor any relation 'p' on elements of type '\u03b1', if for all 'a' and 'b', the relation 'r' from 'a' to 'b' implies the transitive closure of 'p' from 'a' to 'b', then the transitive closure of 'r' from 'a' to 'b' implies the transitive closure of 'p' from 'a' to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem TransGen.closed {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200 a b, r a b \u2192 TransGen p a b) \u2192 TransGen r a b \u2192 TransGen p a b :="}
{"input": "Statement in natural language:\nFor a given affine map 'f' from P\u2081 to P\u2082 and given affine subspaces 's' and 't' of P\u2082, if 's' is a subset of or equal to 't', then the preimage of 's' under 'f' is a subset of or equal to the preimage of 't' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_mono {f : P\u2081 \u2192\u1d43[k] P\u2082} {s t : AffineSubspace k P\u2082} : s \u2264 t \u2192 s.comap f \u2264 t.comap f :="}
{"input": "Statement in natural language:\nIf 'p' is a root of 'x' in a commutative semiring 'R' and 'p' divides 'q', then 'q' is also a root of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsRoot.dvd {R : Type _} [CommSemiring R] {p q : R[X]} {x : R} (h : p.IsRoot x)\n    (hpq : p \u2223 q) : q.IsRoot x :="}
{"input": "Statement in natural language:\nFor any function 'f' that takes an index 'i' and elements from two indexed families of types '\u03b2\u2081 i' and '\u03b2\u2082 i' and returns an element of type '\u03b2 i', and for any two functions 'g\u2081' and 'g\u2082' that are defined for all indices 'i' and return elements of types '\u03b2\u2081 i' and '\u03b2\u2082 i' respectively, if 'f' returns zero when both its arguments are zero, then the support of the function obtained by zipping 'g\u2081' and 'g\u2082' with 'f' is a subset of the union of the supports of 'g\u2081' and 'g\u2082'. Here, the support of a function is the set of indices for which the function does not return zero.\nTranslate the statement in natural language to Lean:", "output": "theorem support_zipWith {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i} {hf : \u2200 i, f i 0 0 = 0} {g\u2081 : \u03a0\u2080 i, \u03b2\u2081 i}\n    {g\u2082 : \u03a0\u2080 i, \u03b2\u2082 i} : (zipWith f hf g\u2081 g\u2082).support \u2286 g\u2081.support \u222a g\u2082.support :="}
{"input": "Statement in natural language:\nFor a given type \u03b9, a finite set t of type \u03b9, and a function f from \u03b9 to the set of E, the set s absorbs the union of the set f(i) for all i in t if and only if for all i in t, the set s absorbs the set f(i).\nTranslate the statement in natural language to Lean:", "output": "theorem absorbs_iUnion_finset {\u03b9 : Type _} {t : Finset \u03b9} {f : \u03b9 \u2192 Set E} :\n    Absorbs \ud835\udd5c s (\u22c3 i \u2208 t, f i) \u2194 \u2200 i \u2208 t, Absorbs \ud835\udd5c s (f i) :="}
{"input": "Statement in natural language:\nThe exponential of a scalar multiple of a number x (where the scalar is a natural number n) is equal to the exponential of x raised to the power of n.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_nsmul (n : \u2115) (x : \ud835\udd38) : exp \ud835\udd42 (n \u2022 x) = exp \ud835\udd42 x ^ n :="}
{"input": "Statement in natural language:\nFor a given element 'a' and a multiset 's' of a certain type '\u03b1', the greatest common divisor (gcd) of the multiset obtained by non-duplicating insertion of 'a' into 's' is equal to the gcd of 'a' and the gcd of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem gcd_ndinsert (a : \u03b1) (s : Multiset \u03b1) : (ndinsert a s).gcd = GCDMonoid.gcd a s.gcd :="}
{"input": "Statement in natural language:\nA relation is directed on the universal set if and only if the relation is directed on the set \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem directedOn_univ_iff : DirectedOn r Set.univ \u2194 IsDirected \u03b1 r :="}
{"input": "Statement in natural language:\nFor a morphism 'f' from object 'X' to 'Y' in a category, given that 'f' has an image, and for another object 'Y'' in the category 'C' and a morphism 'h' from 'Y' to 'Y'' that is an isomorphism, the composition of the homomorphism of the image subobject composition isomorphism of 'f' and 'h' with the arrow of the image subobject of 'f' is equal to the composition of the arrow of the image subobject of the composition of 'f' and 'h' with the inverse of 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem imageSubobjectCompIso_hom_arrow (f : X \u27f6 Y) [HasImage f] {Y' : C} (h : Y \u27f6 Y') [IsIso h] :\n    (imageSubobjectCompIso f h).hom \u226b (imageSubobject f).arrow =\n      (imageSubobject (f \u226b h)).arrow \u226b inv h :="}
{"input": "Statement in natural language:\nTwo sets, s and t, are disjoint if and only if the intersection of s and t is an empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_iff_inter_eq_empty : Disjoint s t \u2194 s \u2229 t = \u2205 :="}
{"input": "Statement in natural language:\nThe exponential of the difference between two numbers (x - y) is equal to the division of the exponential of the first number by the exponential of the second number.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_sub : exp (x - y) = exp x / exp y :="}
{"input": "Statement in natural language:\nFor a nondegenerate bilinear form B on a vector space V over a field K, and a linear map \u03c6 from V to V, the left adjoint of \u03c6 with respect to B is an adjoint pair with \u03c6 under B.\nTranslate the statement in natural language to Lean:", "output": "theorem isAdjointPairLeftAdjointOfNondegenerate (B : BilinForm K V) (b : B.Nondegenerate)\n    (\u03c6 : V \u2192\u2097[K] V) : IsAdjointPair B B (B.leftAdjointOfNondegenerate b \u03c6) \u03c6 :="}
{"input": "Statement in natural language:\nFor any type \u03b9, any filter l on \u03b9, and any function x from \u03b9 to the real numbers, if the limit inferior (liminf) of the function that maps each element of \u03b9 to the non-negative real number equivalent of the absolute value of the function x at that element is not infinite, then there exists a real number R such that, frequently in the filter l, the value of the function x at an element of \u03b9 is less than R.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_frequently_lt_of_liminf_ne_top {\u03b9 : Type _} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n    (hx : liminf (fun n => (Real.nnabs (x n) : \u211d\u22650\u221e)) l \u2260 \u221e) : \u2203 R, \u2203\u1da0 n in l, x n < R :="}
{"input": "Statement in natural language:\nFor any element 'x' from 'L', the application of the function 'lift R f' to '\u03b9 R x' equals the application of the function 'f' to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_\u03b9_apply (x : L) : lift R f (\u03b9 R x) = f x :="}
{"input": "Statement in natural language:\nIf 't' is a lower set, then the product of 's' and 't' is also a lower set.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLowerSet.mul_left (ht : IsLowerSet t) : IsLowerSet (s * t) :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2' that is an ordered monoid homomorphism, the ordered monoid homomorphism of 'f' is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem toOrderMonoidHom_eq_coe (f : \u03b1 \u2192*\u2080o \u03b2) : f.toOrderMonoidHom = f :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the list of its factors is in non-decreasing order.\nTranslate the statement in natural language to Lean:", "output": "theorem factors_chain' (n) : List.Chain' (\u00b7 \u2264 \u00b7) (factors n) :="}
{"input": "Statement in natural language:\n\"a is less than or equal to b implies c\" if and only if \"b is less than or equal to a implies c\".\nTranslate the statement in natural language to Lean:", "output": "theorem le_himp_comm : a \u2264 b \u21e8 c \u2194 b \u2264 a \u21e8 c :="}
{"input": "Statement in natural language:\nWithin a unique differentiable subset 's' at a point 'x' in a field '\ud835\udd5c', the derivative of a linear map 'e' at point 'x' within subset 's' is equal to the value of 'e' at 1.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearMap.derivWithin (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    derivWithin e s x = e 1 :="}
{"input": "Statement in natural language:\nThe norm function, mapping from E to real numbers, is convex on the entire set of real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem convexOn_univ_norm : ConvexOn \u211d univ (norm : E \u2192 \u211d) :="}
{"input": "Statement in natural language:\nIf a relation 'r' on a set 'univ' is an antichain, then the relation 'r' is antisymmetric on the set '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem isAntisymm (h : IsAntichain r univ) : IsAntisymm \u03b1 r :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the mapping of the Chebyshev polynomial of the first kind of degree 'n' in ring 'R' to ring 'S' is equal to the Chebyshev polynomial of the first kind of degree 'n' in ring 'S'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_U (f : R \u2192+* S) : \u2200 n : \u2115, map f (U R n) = U S n"}
{"input": "Statement in natural language:\nIf the function pair f and g is antivariant, then the composition of f and g with another function k is also antivariant.\nTranslate the statement in natural language to Lean:", "output": "theorem Antivary.comp_right (h : Antivary f g) (k : \u03b9' \u2192 \u03b9) : Antivary (f \u2218 k) (g \u2218 k) :="}
{"input": "Statement in natural language:\nFor any type A, the lift operation in the context of a FreeGroup A is equal to the lift operation defined in the FreeGroup.\nTranslate the statement in natural language to Lean:", "output": "theorem lift'_eq_freeGroup_lift {A : Type u} : @lift (FreeGroup A) _ _ H _ = FreeGroup.lift :="}
{"input": "Statement in natural language:\nA sum type (a type that can hold values of either type \u03b1 or type \u03b2) is empty if and only if both type \u03b1 and type \u03b2 are empty.\nTranslate the statement in natural language to Lean:", "output": "theorem isEmpty_sum {\u03b1 \u03b2} : IsEmpty (Sum \u03b1 \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2 :="}
{"input": "Statement in natural language:\nFor any point x in the Euclidean space E, the neighborhood of x has a basis consisting of all open balls centered at x with a positive radius. This basis is characterized by the property that for any real number r, if r is greater than 0, then the corresponding basis element is the open ball centered at x with radius r.\nTranslate the statement in natural language to Lean:", "output": "theorem nhds_basis_ball {x : E} : (\ud835\udcdd x).HasBasis (fun r : \u211d => 0 < r) (ball x) :="}
{"input": "Statement in natural language:\nFor a given prime number 'p', natural numbers 'k' and 'm' (where 'm' is positive), and a multiplicative group element '\u03b6' of a ring 'R' with characteristic 'p', '\u03b6' raised to the power of 'p' to the power of 'k' times 'm' equals 1 if and only if '\u03b6' is a root of unity of order 'm' in the ring 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_rootsOfUnity_prime_pow_mul_iff' (p k : \u2115) (m : \u2115+) [hp : Fact p.Prime] [CharP R p]\n    {\u03b6 : R\u02e3} : \u03b6 ^ (p ^ k * \u2191m) = 1 \u2194 \u03b6 \u2208 rootsOfUnity m R :="}
{"input": "Statement in natural language:\nFor a reflexive relation 'r' on a set, given any two elements 'a' and 'b' from a set '\u03b1' where 'a' is related to 'b' under the relation 'r', the relation 'r' is directed on the set that contains 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem directedOn_pair (h : Reflexive r) {a b : \u03b1} (hab : a \u227c b) : DirectedOn r ({a, b} : Set \u03b1) :="}
{"input": "Statement in natural language:\nFor any type 'R' that has a zero element, a given element 'n' of type 'R' is not non-zero if and only if 'n' is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem not_neZero {R : Type _} [Zero R] {n : R} : \u00acNeZero n \u2194 n = 0 :="}
{"input": "Statement in natural language:\nIf we have two ring homomorphisms, 'f' from ring 'A' to ring 'B' and 'g' from ring 'B' to ring 'C', and if 'f' has a finite presentation, 'g' is surjective, and the kernel of 'g' is finitely generated, then the composition of 'g' and 'f' also has a finite presentation.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_surjective {f : A \u2192+* B} {g : B \u2192+* C} (hf : f.FinitePresentation) (hg : Surjective g)\n    (hker : g.ker.FG) : (g.comp f).FinitePresentation :="}
{"input": "Statement in natural language:\nFor a given multiplication operation 'mul' on the tensor product of A and B over a ring R, if for all elements a\u2081, a\u2082, a\u2083 of A and b\u2081, b\u2082, b\u2083 of B, the multiplication operation satisfies the associative property, then for all elements x, y, z of the tensor product of A and B, the multiplication operation also satisfies the associative property. In other words, the multiplication of x, y, and z in any order will yield the same result.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_assoc' (mul : A \u2297[R] B \u2192\u2097[R] A \u2297[R] B \u2192\u2097[R] A \u2297[R] B)\n    (h :\n      \u2200 (a\u2081 a\u2082 a\u2083 : A) (b\u2081 b\u2082 b\u2083 : B),\n        mul (mul (a\u2081 \u2297\u209c[R] b\u2081) (a\u2082 \u2297\u209c[R] b\u2082)) (a\u2083 \u2297\u209c[R] b\u2083) =\n          mul (a\u2081 \u2297\u209c[R] b\u2081) (mul (a\u2082 \u2297\u209c[R] b\u2082) (a\u2083 \u2297\u209c[R] b\u2083))) :\n    \u2200 x y z : A \u2297[R] B, mul (mul x y) z = mul x (mul y z) :="}
{"input": "Statement in natural language:\nFor a given index 'i' and an element 'y' from the group 'N i', the non-commutative product of the function '\u03d5', the commutativity proof 'hcomm', and the multiplication of the single element 'i' with 'y', is equal to the application of the function '\u03d5' to 'i' and 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem noncommPiCoprod_mulSingle (i : \u03b9) (y : N i) :\n    noncommPiCoprod \u03d5 hcomm (Pi.mulSingle i y) = \u03d5 i y :="}
{"input": "Statement in natural language:\nFor any set 'a', the cardinality of the lift of 'a' is equal to the lift of the cardinality of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_card (a) : Cardinal.lift.{u,v} (card a)= card (lift.{u,v} a) :="}
{"input": "Statement in natural language:\nFor any type \u03b2 that forms a semi-normed additive commutative group, and any function f from \u03b1 to \u03b2 that is almost everywhere strongly measurable with respect to measure \u03bc, the function that maps each element a to the non-negative extended real number norm of f(a) is almost everywhere measurable with respect to measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem ennnorm {\u03b2 : Type _} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : AEStronglyMeasurable f \u03bc) : AEMeasurable (fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)) \u03bc :="}
{"input": "Statement in natural language:\nFor a nonempty index set \u03b9, a function f from \u03b9 to \u03b1, and a value a in \u03b1, if the range of the function f is bounded above, then the supremum of f is less than or equal to a if and only if for all indices i, the value of the function f at i is less than or equal to a.\nTranslate the statement in natural language to Lean:", "output": "theorem ciSup_le_iff [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (hf : BddAbove (range f)) :\n    iSup f \u2264 a \u2194 \u2200 i, f i \u2264 a :="}
{"input": "Statement in natural language:\nThe skew-adjoint part of a continuous module over a ring is also continuous. This is under the conditions that the module has a continuous subtraction operation, a continuous star operation, and a continuous scalar multiplication by a constant.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_skewAdjointPart [ContinuousSub A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    Continuous (@skewAdjointPart R A _ _ _ _ _ _ _ _) :="}
{"input": "Statement in natural language:\nIf 'x' is infinitely negative and 'y' is not infinitesimal and negative, then the product of 'x' and 'y' is infinitely positive.\nTranslate the statement in natural language to Lean:", "output": "theorem infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg {x y : \u211d*} :\n    InfiniteNeg x \u2192 \u00acInfinitesimal y \u2192 y < 0 \u2192 InfinitePos (x * y) :="}
{"input": "Statement in natural language:\nFor a finite set 's' of sets of elements of type \u03b1, the union of 's' is in filter 'f' if and only if there exists a set 't' in 's' that is in filter 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem finite_sUnion_mem_iff {s : Set (Set \u03b1)} (hs : s.Finite) : \u22c3\u2080 s \u2208 f \u2194 \u2203 t \u2208 s, t \u2208 f :="}
{"input": "Statement in natural language:\nFor any two functions 'v' and 'w' from 'n' to 'R', if the dot product of 'v' and any function 'u' is equal to the dot product of 'w' and the same function 'u', then 'v' must be equal to 'w'.\nTranslate the statement in natural language to Lean:", "output": "theorem dotProduct_eq (v w : n \u2192 R) (h : \u2200 u, dotProduct v u = dotProduct w u) : v = w :="}
{"input": "Statement in natural language:\nFor any two hyperreal numbers 'x' and 'y', if 'x' is negatively infinite and 'y' is not infinite, then the sum of 'x' and 'y' is negatively infinite.\nTranslate the statement in natural language to Lean:", "output": "theorem infiniteNeg_add_not_infinite {x y : \u211d*} :\n    InfiniteNeg x \u2192 \u00acInfinite y \u2192 InfiniteNeg (x + y) :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any element 'x' of an ordered additive monoid '\u03b1', if 'x' is nonnegative, then 'n' times the nonnegative element 'x' is equal to the nonnegative element 'n' times 'x', with the nonnegativity of the latter ensured by the property that the n-fold addition of a nonnegative number is nonnegative.\nTranslate the statement in natural language to Lean:", "output": "theorem nsmul_mk [AddMonoid \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (n : \u2115) {x : \u03b1}\n    (hx : 0 \u2264 x) : (n \u2022 (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x })) = \u27e8n \u2022 x, nsmul_nonneg hx n\u27e9 :="}
{"input": "Statement in natural language:\nThe identity function on the centroid homomorphism for a given type \u03b1 is equal to the identity function on the additive monoid for the same type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem toAddMonoidHom_id : (CentroidHom.id \u03b1 : \u03b1 \u2192+ \u03b1) = AddMonoidHom.id \u03b1 :="}
{"input": "Statement in natural language:\nFor a given substructure T of N and a function f from M to N, if the map of S through function f is less than or equal to T, then S is less than or equal to the preimage of T under function f.\nTranslate the statement in natural language to Lean:", "output": "theorem le_comap_of_map_le {T : L.Substructure N} {f : M \u2192[L] N} : S.map f \u2264 T \u2192 S \u2264 T.comap f :="}
{"input": "Statement in natural language:\nIf the generated sieve R is in the Grothendieck topology of the open set U in the topological space X, then the supremum of the covering of the presieve U R is equal to U.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_eq_of_mem_grothendieck (hR : Sieve.generate R \u2208 Opens.grothendieckTopology X U) :\n    iSup (coveringOfPresieve U R) = U :="}
{"input": "Statement in natural language:\nIf for every element 'a' in set 's', there exists an element 'b' in set 't' such that relation 'r' holds between 'a' and 'b', and for every element 'b' in set 't', the set of all elements 'a' in set 's' for which relation 'r' holds with 'b' is a subsingleton (i.e., it contains at most one element), then the cardinality (or size) of set 's' is less than or equal to the cardinality of set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_le_card_of_forall_subsingleton (hs : \u2200 a \u2208 s, \u2203 b, b \u2208 t \u2227 r a b)\n    (ht : \u2200 b \u2208 t, ({ a \u2208 s | r a b } : Set \u03b1).Subsingleton) : s.card \u2264 t.card :="}
{"input": "Statement in natural language:\nThe omega limit of the intersection of a collection of sets (indexed by \u03b9) is a subset of the intersection of the omega limits of each individual set in the collection.\nTranslate the statement in natural language to Lean:", "output": "theorem omegaLimit_iInter (p : \u03b9 \u2192 Set \u03b1) : \u03c9 f \u03d5 (\u22c2 i, p i) \u2286 \u22c2 i, \u03c9 f \u03d5 (p i) :="}
{"input": "Statement in natural language:\nFor a given interval from 'a' to 'b' (inclusive of 'a' and exclusive of 'b'), if 'a' is less than or equal to 'c', then the image of the interval under the function that subtracts each element from 'c' is equal to the interval from 'c + 1 - b' to 'c + 1 - a' (inclusive of 'c + 1 - b' and exclusive of 'c + 1 - a').\nTranslate the statement in natural language to Lean:", "output": "theorem Ico_image_const_sub_eq_Ico (hac : a \u2264 c) :\n    ((Ico a b).image fun x => c - x) = Ico (c + 1 - b) (c + 1 - a) :="}
{"input": "Statement in natural language:\nFor a given function 'f' from '\u03b2' to '\u03b1' in a second-countable topological space, if 'f' is summable and 's' is a set in '\u03b2', then the sum over 's' of 'f' plus the sum over the complement of 's' of 'f' equals the total sum over 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_subtype_add_tsum_subtype_compl [T2Space \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Summable f) (s : Set \u03b2) :\n    ((\u2211' x : s, f x) + \u2211' x : \u2191(s\u1d9c), f x) = \u2211' x, f x :="}
{"input": "Statement in natural language:\nFor any type '\u03b9' with a finite number of elements, a function 'H' from '\u03b9' to some type, a function 'M' from '\u03b9' to some type, where each 'H i' and 'M i' are topological spaces and each 'M i' is a charted space with model 'H i', and a function 'f' from '\u03b9' to 'M i', the chart at 'f' in the product space of 'H' is equal to the product of the charts at 'f i' in each 'H i'.\nTranslate the statement in natural language to Lean:", "output": "theorem piChartedSpace_chartAt {\u03b9 : Type _} [Fintype \u03b9] (H : \u03b9 \u2192 Type _)\n    [\u2200 i, TopologicalSpace (H i)] (M : \u03b9 \u2192 Type _) [\u2200 i, TopologicalSpace (M i)]\n    [\u2200 i, ChartedSpace (H i) (M i)] (f : \u2200 i, M i) :\n    chartAt (H := ModelPi H) f = LocalHomeomorph.pi fun i \u21a6 chartAt (H i) (f i) :="}
{"input": "Statement in natural language:\nFor three continuous functions f, g, and h, where f maps from \u03b3 to \u03b4, g maps from \u03b2 to \u03b3, and h maps from \u03b1 to \u03b2, the composition of f and g, followed by the composition with h, is equal to the composition of f with the composition of g and h. This is the principle of associativity in function composition.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_assoc (f : \u03b3 \u2192CO \u03b4) (g : \u03b2 \u2192CO \u03b3) (h : \u03b1 \u2192CO \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h) :="}
{"input": "Statement in natural language:\nThe reverse of an empty walk (represented as 'nil') in a graph G from a vertex 'u' to itself is also an empty walk.\nTranslate the statement in natural language to Lean:", "output": "theorem reverse_nil {u : V} : (nil : G.Walk u u).reverse = nil :="}
{"input": "Statement in natural language:\nThe bottom filter of a set \u03b1 is not equal to the hyperfilter of the same set \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem bot_ne_hyperfilter : (\u22a5 : Filter \u03b1) \u2260 hyperfilter \u03b1 :="}
{"input": "Statement in natural language:\nA list 'l' is a sublist of a list that replicates an element 'a' 'n' times if and only if there exists a number 'k' less than or equal to 'n' such that 'l' is equal to a list that replicates 'a' 'k' times.\nTranslate the statement in natural language to Lean:", "output": "theorem sublist_replicate_iff {l : List \u03b1} {a : \u03b1} {n : \u2115} :\n    l <+ replicate n a \u2194 \u2203 k \u2264 n, l = replicate k a :="}
{"input": "Statement in natural language:\nFor two functors F and G from category C to category D, both of which are additive, and a natural transformation \u03b1 from F to G, for any natural number n and any object X in category C with a projective resolution P, the application of the n-th left derived functor of \u03b1 to X is equal to the composition of the homomorphism from the n-th left derived object of F with respect to P, the map induced by \u03b1 on the n-th homology group of the complex associated with P, and the inverse of the homomorphism from the n-th left derived object of G with respect to P.\nTranslate the statement in natural language to Lean:", "output": "theorem NatTrans.leftDerived_eq {F G : C \u2964 D} [F.Additive] [G.Additive] (\u03b1 : F \u27f6 G) (n : \u2115) {X : C}\n    (P : ProjectiveResolution X) :\n    (NatTrans.leftDerived \u03b1 n).app X =\n      (F.leftDerivedObjIso n P).hom \u226b\n        (homologyFunctor D _ n).map ((NatTrans.mapHomologicalComplex \u03b1 _).app P.complex) \u226b\n          (G.leftDerivedObjIso n P).inv :="}
{"input": "Statement in natural language:\nA function 'f' maps to a set 't' from the union of sets 's\u2081' and 's\u2082' if and only if 'f' maps to 't' from both 's\u2081' and 's\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem mapsTo_union : MapsTo f (s\u2081 \u222a s\u2082) t \u2194 MapsTo f s\u2081 t \u2227 MapsTo f s\u2082 t :="}
{"input": "Statement in natural language:\nThe cycle type of a permutation \u03c3 is equal to the mapping of the cardinality of the support function over the first element of the cycle factors of \u03c3 in a finite set.\nTranslate the statement in natural language to Lean:", "output": "theorem cycleType_def (\u03c3 : Perm \u03b1) :\n    \u03c3.cycleType = \u03c3.cycleFactorsFinset.1.map (Finset.card \u2218 support) :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b9' to '\u03b1', for any 'i' in '\u03b9', the infimum (greatest lower bound) of 'f' is less than or equal to 'f' at 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem ciInf_le' (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : iInf f \u2264 f i :="}
{"input": "Statement in natural language:\nA set 's' is dense if and only if the closure of the set 's' is dense.\nTranslate the statement in natural language to Lean:", "output": "theorem dense_closure {s : Set \u03b1} : Dense (closure s) \u2194 Dense s :="}
{"input": "Statement in natural language:\nFor any two ideals I and J of a ring R, and any element x of R, x is in the intersection of I and J if and only if x is in I and x is in J.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_inf {I J : Ideal R} {x : R} : x \u2208 I \u2293 J \u2194 x \u2208 I \u2227 x \u2208 J :="}
{"input": "Statement in natural language:\nFor any element 'c' in the set '\u03b1', if 'a + c' is congruent to 'b + c' modulo 'p', then 'a' is congruent to 'b' modulo 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem add_right_cancel' (c : \u03b1) : a + c \u2261 b + c [PMOD p] \u2192 a \u2261 b [PMOD p] :="}
{"input": "Statement in natural language:\nFor a set function T from a set of \u03b1 to the space of continuous linear maps from G' to G'', and a real number C, if T is dominated and finitely additive with respect to measure \u03bc and C, and if for all measurable sets s with finite measure, and for all x greater than or equal to 0, T s x is also greater than or equal to 0, then for any function f from \u03b1 to G' that is integrable with respect to \u03bc and is greater than or equal to 0, the setToL1 of T and f is also greater than or equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem setToL1_nonneg {T : Set \u03b1 \u2192 G' \u2192L[\u211d] G''} {C : \u211d} (hT : DominatedFinMeasAdditive \u03bc T C)\n    (hT_nonneg : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 \u2200 x, 0 \u2264 x \u2192 0 \u2264 T s x) {f : \u03b1 \u2192\u2081[\u03bc] G'}\n    (hf : 0 \u2264 f) : 0 \u2264 setToL1 hT f :="}
{"input": "Statement in natural language:\nThe function 'section\u0393'Bool' is a left inverse of the function 'inclusionBool\u0393''.\nTranslate the statement in natural language to Lean:", "output": "theorem leftInverse_section_inclusion : Function.LeftInverse section\u0393'Bool inclusionBool\u0393' :="}
{"input": "Statement in natural language:\nFor a given element 'a' and a given multiset 's', the count of 'a' in 's' is greater than 0 if and only if 'a' is an element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem count_pos {a : \u03b1} {s : Multiset \u03b1} : 0 < count a s \u2194 a \u2208 s :="}
{"input": "Statement in natural language:\nFor any tropicalized ring R, the untropicalization of zero in the tropical ring R is equal to the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem untrop_zero [Top R] : untrop (0 : Tropical R) = \u22a4 :="}
{"input": "Statement in natural language:\nFor any index 'i', if 'i' does not have a relation with the next index in the complex 'c', then the differential from 'i' in the complex 'C' is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem dFrom_eq_zero {i : \u03b9} (h : \u00acc.Rel i (c.next i)) : C.dFrom i = 0 :="}
{"input": "Statement in natural language:\nFor a finite type \u03c3, the finite dimensional rank of the polynomial ring R over the field K in \u03c3 variables is equal to the cardinality of the set of all functions from \u03c3 to K.\nTranslate the statement in natural language to Lean:", "output": "theorem finrank_R [Fintype \u03c3] : FiniteDimensional.finrank K (R \u03c3 K) = Fintype.card (\u03c3 \u2192 K) :="}
{"input": "Statement in natural language:\nFor a function 'f' from a set '\u03b1' to a group with zero 'G\u2080', and a filter 'l' on '\u03b1', if 'f' tends to a point 'a' in 'G\u2080' under the filter 'l', then for any integer 'm', if 'a' is not zero or 'm' is non-negative, the function 'f' raised to the power 'm' also tends to 'a' raised to the power 'm' under the filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.zpow\u2080 {f : \u03b1 \u2192 G\u2080} {l : Filter \u03b1} {a : G\u2080} (hf : Tendsto f l (\ud835\udcdd a)) (m : \u2124)\n    (h : a \u2260 0 \u2228 0 \u2264 m) : Tendsto (fun x => f x ^ m) l (\ud835\udcdd (a ^ m)) :="}
{"input": "Statement in natural language:\nIf a filtration F is stable and the zeroth term of F is less than or equal to the zeroth term of F', then there exists a non-negative integer n\u2080 such that for all non-negative integers n, the (n + n\u2080)th term of F is less than or equal to the nth term of F'.\nTranslate the statement in natural language to Lean:", "output": "theorem Stable.exists_forall_le (h : F.Stable) (e : F.N 0 \u2264 F'.N 0) :\n    \u2203 n\u2080, \u2200 n, F.N (n + n\u2080) \u2264 F'.N n :="}
{"input": "Statement in natural language:\nIf there is a morphism 'f' from object 'X' to object 'Y' in category 'C', and 'X' is isomorphic to the zero object, then 'f' is a zero morphism.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_of_source_iso_zero {X Y : C} (f : X \u27f6 Y) (i : X \u2245 0) : f = 0 :="}
{"input": "Statement in natural language:\nAn element 'a' is an antichain of a relation 'r' in the set 's' if and only if 's' is an antichain of 'r' and for all elements 'b' in 's', 'a' is not equal to 'b' and 'a' is not related to 'b' in 'r' and 'b' is not related to 'a' in 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.isAntichain_insert :\n    IsAntichain r (insert a s) \u2194 IsAntichain r s \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acr a b \u2227 \u00acr b a :="}
{"input": "Statement in natural language:\nIf an element 'a' belongs to the multiset 's' after the element 'b' has been removed, then 'a' must have originally belonged to the multiset 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_of_mem_erase {a b : \u03b1} {s : Multiset \u03b1} : a \u2208 s.erase b \u2192 a \u2208 s :="}
{"input": "Statement in natural language:\nFor a given pair 'p' consisting of an element and a set of elements, if 'p' is in the index of 'h', then the covering of 'p' by 'h' is in the set of 'v' at the first element of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem covering_mem_family {p : \u03b1 \u00d7 Set \u03b1} (hp : p \u2208 h.index) : h.covering p \u2208 v.setsAt p.1 :="}
{"input": "Statement in natural language:\nFor any two elements 'x' and 'y' in a set 'F' of type '\u03b1', if 'y' is in the connected component in 'F' of 'x', then the connected component in 'F' of 'x' is equal to the connected component in 'F' of 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem connectedComponentIn_eq {x y : \u03b1} {F : Set \u03b1} (h : y \u2208 connectedComponentIn F x) :\n    connectedComponentIn F x = connectedComponentIn F y :="}
{"input": "Statement in natural language:\nThe infimum (greatest lower bound) of the set of all elements i such that the function f applied to i is not the top element, is equal to the infimum of the set of all elements i under the function f.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_ne_top_subtype (f : \u03b9 \u2192 \u03b1) : (\u2a05 i : { i // f i \u2260 \u22a4 }, f i) = \u2a05 i, f i :="}
{"input": "Statement in natural language:\nFor a bilinear form B on a module M over a ring R, and for any two elements x and y of M, x and y are orthogonal with respect to B if and only if the bilinear form B applied to x and y equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem isOrtho_def {B : BilinForm R M} {x y : M} : B.IsOrtho x y \u2194 B x y = 0 :="}
{"input": "Statement in natural language:\nFor any finite type 'n', any monoid 'R', any non-unital non-associative semiring 'S', any distributive multiplication action of 'R' on 'S', and any scalar tower of 'R', 'S', and 'S', given a matrix 'M' of 'n' by 'm' with elements from 'S', a scalar 'b' from 'R', and a vector 'v' from 'n' to 'S', the vector multiplication of 'M' and the scaled vector 'b \u2022 v' is equal to the scaled vector of the vector multiplication of 'M' and 'v' by 'b'. This essentially means that scalar multiplication can be distributed over vector multiplication.\nTranslate the statement in natural language to Lean:", "output": "theorem vecMul_smul [Fintype n] [Monoid R] [NonUnitalNonAssocSemiring S] [DistribMulAction R S]\n    [IsScalarTower R S S] (M : Matrix n m S) (b : R) (v : n \u2192 S) :\n    M.vecMul (b \u2022 v) = b \u2022 M.vecMul v :="}
{"input": "Statement in natural language:\nFor any two multisets 's' and 't', 's' and 't' are disjoint if and only if for any element 'a', if 'a' is in 's' then 'a' is not in 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_left {s t : Multiset \u03b1} : Disjoint s t \u2194 \u2200 {a}, a \u2208 s \u2192 a \u2209 t :="}
{"input": "Statement in natural language:\nFor a given group homomorphism 'f' from group 'G' to group 'N', and given subgroups 'K' of 'G' and 'H' of 'N', the image of 'K' under 'f' is a subgroup of 'H' if and only if 'K' is a subgroup of the preimage of 'H' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_le_iff_le_comap {f : G \u2192* N} {K : Subgroup G} {H : Subgroup N} :\n    K.map f \u2264 H \u2194 K \u2264 H.comap f :="}
{"input": "Statement in natural language:\nFor a given set 's' of type \u03b1, a set 'T' of sets of type \u03b2, and a function 'f' from \u03b1 to \u03b2, if for every subset 't' in 'T', 'f' is surjective on 's' to 't', then 'f' is surjective on 's' to the union of all subsets in 'T'.\nTranslate the statement in natural language to Lean:", "output": "theorem surjOn_sUnion {s : Set \u03b1} {T : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2} (H : \u2200 t \u2208 T, SurjOn f s t) :\n    SurjOn f s (\u22c3\u2080T) :="}
{"input": "Statement in natural language:\nFor a prime number 'p', 'p' does not divide 1.\nTranslate the statement in natural language to Lean:", "output": "theorem Prime.not_dvd_one {p : \u2115} (pp : Prime p) : \u00acp \u2223 1 :="}
{"input": "Statement in natural language:\nIf graph G is a subgraph of graph H, then the set of all n-cliques in graph G is a subset of the set of all n-cliques in graph H.\nTranslate the statement in natural language to Lean:", "output": "theorem cliqueFinset_mono (h : G \u2264 H) : G.cliqueFinset n \u2286 H.cliqueFinset n :="}
{"input": "Statement in natural language:\nFor any two elements x and y of the Centroid Homomorphism of \u03b1, the endomorphism of the product of x and y is equal to the product of the endomorphisms of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem toEnd_mul (x y : CentroidHom \u03b1) : (x * y).toEnd = x.toEnd * y.toEnd :="}
{"input": "Statement in natural language:\nA bilinear form B on a vector space M\u2083 over a field A is non-degenerate if and only if the determinant of the matrix representation of B with respect to a basis b of M\u2083 is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem nondegenerate_iff_det_ne_zero {B : BilinForm A M\u2083} (b : Basis \u03b9 A M\u2083) :\n    B.Nondegenerate \u2194 (toMatrix b B).det \u2260 0 :="}
{"input": "Statement in natural language:\nRescaling by zero is equivalent to composing the ring constant function with the constant coefficient function in the ring R.\nTranslate the statement in natural language to Lean:", "output": "theorem rescale_zero : rescale 0 = (C R).comp (constantCoeff R) :="}
{"input": "Statement in natural language:\nFor any natural number 'p' and 'n', if 'p' is an idempotent element, then 'p' to the power of 'n' is also an idempotent element.\nTranslate the statement in natural language to Lean:", "output": "theorem pow {p : N} (n : \u2115) (h : IsIdempotentElem p) : IsIdempotentElem (p ^ n) :="}
{"input": "Statement in natural language:\nFor any two lists (l\u2081 and l\u2082), the property of having no duplicate elements in the list formed by appending l\u2081 and l\u2082 is equivalent to the property of having no duplicate elements in the list formed by appending l\u2082 and l\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem nodup_append_comm {l\u2081 l\u2082 : List \u03b1} : Nodup (l\u2081 ++ l\u2082) \u2194 Nodup (l\u2082 ++ l\u2081) :="}
{"input": "Statement in natural language:\nIf the image of a set 's' under a function 'm' is an element of a filter 'g', then the intersection of the filter obtained by preimage under 'm' of 'g' and the principal filter generated by 's' is not the bottom filter.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_inf_principal_neBot_of_image_mem (h : m '' s \u2208 g) : (Filter.comap m g \u2293 \ud835\udcdf s).NeBot :="}
{"input": "Statement in natural language:\nFor a given set U of M, if U is an element of B, then there exists a neighborhood V of 0 in R and a set W in B such that the scalar multiplication of V and W is a subset of U.\nTranslate the statement in natural language to Lean:", "output": "theorem smul {U : Set M} (hU : U \u2208 B) : \u2203 V \u2208 \ud835\udcdd (0 : R), \u2203 W \u2208 B, V \u2022 W \u2286 U :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1', 'a' is an element of 'pure a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_pure_self (a : \u03b1) : a \u2208 pure a :="}
{"input": "Statement in natural language:\nIf an element 'a' is a member of list 'l' and the minimum value of list 'l' is 'm', then 'a' is not less than 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem minimum_not_lt_of_mem : a \u2208 l \u2192 (minimum l : WithTop \u03b1) = m \u2192 \u00aca < m :="}
{"input": "Statement in natural language:\nFor any two finite sets 'u' and 'v', if for every element 'x' in 'u', there exists an element 'y' in 'v' such that the set 'u' with 'x' removed is compressed to the set 'v' with 'y' removed within the set family '\ud835\udc9c', then the cardinality of the shadow of the compression of the set family '\ud835\udc9c' with respect to 'u' and 'v' is less than or equal to the cardinality of the shadow of the set family '\ud835\udc9c'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_shadow_compression_le (u v : Finset \u03b1)\n    (huv : \u2200 x \u2208 u, \u2203 y \u2208 v, IsCompressed (u.erase x) (v.erase y) \ud835\udc9c) :\n    ((\u2202 ) (\ud835\udcd2 u v \ud835\udc9c)).card \u2264 ((\u2202 ) \ud835\udc9c).card :="}
{"input": "Statement in natural language:\nThe inverse of 'f' is less than or equal to the inverse of 'g' if and only if 'f' is less than or equal to 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_le_inv_iff : f\u207b\u00b9 \u2264 g\u207b\u00b9 \u2194 f \u2264 g :="}
{"input": "Statement in natural language:\nFor a given natural number 'n', in the context where \u03c3 is a decidable equality and R is nontrivial, the support of the elementary symmetric function 'esymm' of \u03c3, R, and n is equal to the bi-union of the power set of length n of the universal set of \u03c3 and the function that maps each element 't' to the sum of the Finsupp.single function applied to each element 'i' in 't' with the argument 1.\nTranslate the statement in natural language to Lean:", "output": "theorem support_esymm' (n : \u2115) [DecidableEq \u03c3] [Nontrivial R] :\n    (esymm \u03c3 R n).support =\n      (powersetLen n (univ : Finset \u03c3)).biUnion fun t => {\u2211 i : \u03c3 in t, Finsupp.single i 1} :="}
{"input": "Statement in natural language:\nThe preimage of the identity function on a set of elements of type \u03b1 is equal to the identity function itself.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_id_eq : preimage (id : \u03b1 \u2192 \u03b1) = id :="}
{"input": "Statement in natural language:\nThe composition of relation 'r' with the equality relation is equal to relation 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_eq : r \u2218r (\u00b7 = \u00b7) = r :="}
{"input": "Statement in natural language:\nFor a morphism 'f' from 'j' to 'i', the eventual range of 'j' maps to the eventual range of 'i' through the functor 'F' applied to 'f'. This is within the context of a cofiltered system in category theory.\nTranslate the statement in natural language to Lean:", "output": "theorem eventualRange_mapsTo (f : j \u27f6 i) :\n    (F.eventualRange j).MapsTo (F.map f) (F.eventualRange i) :="}
{"input": "Statement in natural language:\nFor a given constant 'b' of type '\u03b2', 'b' is the maximum value on set 's' at point 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem isMaxOn_const {b : \u03b2} : IsMaxOn (fun _ => b) s a :="}
{"input": "Statement in natural language:\nFor any given values of k, n, and r, the function u applied to the sum of the product of k and n and r is less than or equal to the sum of the product of k and the function u applied to n, and the function u applied to r.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_mul_add_le (k n r) : u (k * n + r) \u2264 k * u n + u r :="}
{"input": "Statement in natural language:\nFor a given affine subspace 's' of points 'P' over a ring 'R', and given points 'x', 'y', and 'z', if 'z' is between 'x' and 'y' (denoted by Wbtw R x y z) and 'z' is an element of 's', then 's' is on the same side of 'y' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Wbtw.wSameSide\u2082\u2081 {s : AffineSubspace R P} {x y z : P} (h : Wbtw R x y z)\n    (hz : z \u2208 s) : s.WSameSide y x :="}
{"input": "Statement in natural language:\nFor a given element 'x', the application of the function 'single' with parameters 'a' and 'b' to 'x' belongs to the set that contains only '0' and 'b'. This set is a subset of the set 'M'.\nTranslate the statement in natural language to Lean:", "output": "theorem single_apply_mem (x) : single a b x \u2208 ({0, b} : Set M) :="}
{"input": "Statement in natural language:\nFor a function \"f\" from the set of bounded continuous functions between X and Y, and a real number \"C\", for any element \"x\" in X, the set of all values of \"f\" applied to the pair consisting of \"x\" and any element \"y\" from Y, plus \"C\", is bounded below.\nTranslate the statement in natural language to Lean:", "output": "theorem HD_below_aux1 {f : Cb X Y} (C : \u211d) {x : X} :\n    BddBelow (range fun y : Y => f (inl x, inr y) + C) :="}
{"input": "Statement in natural language:\nThe infimum of the symmetric difference of sets t and u with set s is a subset of the symmetric difference of the infimum of set t with set s and the infimum of set u with set s.\nTranslate the statement in natural language to Lean:", "output": "theorem infs_sups_subset_right : (t \u22bb u) \u22bc s \u2286 t \u22bc s \u22bb u \u22bc s :="}
{"input": "Statement in natural language:\nFor any x in the open interval between 0 and 1 (not including 0 and 1), the value of x is greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_pos (x : Ioc (0 : \u03b1) 1) : 0 < (x : \u03b1) :="}
{"input": "Statement in natural language:\nIf for every pair of distinct elements 'a' and 'b' in a multiset 's', the relation 'r' holds between 'a' and 'b', and if 's' has no duplicate elements, then 's' is pairwise related by 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem Nodup.pairwise : (\u2200 a \u2208 s, \u2200 b \u2208 s, a \u2260 b \u2192 r a b) \u2192 Nodup s \u2192 Pairwise r s :="}
{"input": "Statement in natural language:\nThe cosine of the angle between two vectors x and y is equal to the inner product of x and y divided by the product of the magnitudes of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem cos_angle (x y : V) : Real.cos (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016) :="}
{"input": "Statement in natural language:\nFor any integer 'n', the function that maps any element of type '\u03b1' to 'n' in the continuous functions from '\u03b1' to '\u03b2' (where '\u03b2' has an integer cast), is equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_int_cast [IntCast \u03b2] (n : \u2124) : ((n : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = n :="}
{"input": "Statement in natural language:\nFor a topological homomorphism 'f' from '\u03b2' to '\u03b3', another topological homomorphism 'g' from '\u03b1' to '\u03b2', and an element 'a' from '\u03b1', the composition of 'f' and 'g' applied to 'a' is equal to 'f' applied to 'g' of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_apply (f : TopHom \u03b2 \u03b3) (g : TopHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a) :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c of a group G, the result of multiplying a and b, then dividing by the result of dividing a by c, is equal to the result of multiplying b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_div_div_cancel (a b c : G) : a * b / (a / c) = b * c :="}
{"input": "Statement in natural language:\nIf 's' is a compact set and 't' is an open set such that 's' is a subset of 't', then there exists a positive real number '\u03b4' such that the '\u03b4'-thickening of 's' is a subset of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.IsCompact.exists_cthickening_subset_open (hs : IsCompact s) (ht : IsOpen t)\n    (hst : s \u2286 t) :\n    \u2203 \u03b4, 0 < \u03b4 \u2227 cthickening \u03b4 s \u2286 t :="}
{"input": "Statement in natural language:\nFor a zero element in set M and an additive commutative monoid in set N, given a function 'f' mapping from \u03b1 to M and another function 'h' mapping from \u03b1 and M to a multiset of N, the sum of the multiset resulting from the sum of function 'f' applied to function 'h' is equal to the sum of function 'f' applied to a function that takes two arguments 'a' and 'b' and returns the sum of the multiset resulting from applying function 'h' to 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem multiset_sum_sum [Zero M] [AddCommMonoid N] {f : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 Multiset N} :\n    Multiset.sum (f.sum h) = f.sum fun a b => Multiset.sum (h a b) :="}
{"input": "Statement in natural language:\nFor any element 'a' of a group with zero 'G\u2080' and any integer 'n' that is not equal to zero, 'a' raised to the power of 'n' equals zero if and only if 'a' equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_eq_zero_iff {a : G\u2080} {n : \u2124} (hn : n \u2260 0) : a ^ n = 0 \u2194 a = 0 :="}
{"input": "Statement in natural language:\nIn a right rigid category V, the right dual of object X in V is equal to the right dual of the object X in V.\nTranslate the statement in natural language to Lean:", "output": "theorem rightDual_v [RightRigidCategory V] : X\u1601.V = X.V\u1601 :="}
{"input": "Statement in natural language:\nZero is less than or equal to a positional game 'x' if and only if there exists a move 'i' such that zero is less than or equal to the game 'x' after making the left move 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_lf_le {x : PGame} : 0 \u29cf x \u2194 \u2203 i, 0 \u2264 x.moveLeft i :="}
{"input": "Statement in natural language:\nFor any function 'f' from an index set '\u03b9' to a set '\u03b1', any index 'i' in '\u03b9', and any element 'b' in '\u03b1', the image of the function 'f' updated at index 'i' with value 'b' over the interval from 'f i' to 'b' (not including 'b') is equal to the interval from 'f' to the updated function 'f' at index 'i' with value 'b' (not including the updated function 'f' at index 'i' with value 'b').\nTranslate the statement in natural language to Lean:", "output": "theorem image_update_Ico_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Ico (f i) b = Ico f (update f i b) :="}
{"input": "Statement in natural language:\nIf the conjunction (logical \"and\") of two propositions 'a' and 'b' is true, then the proposition 'b' is also true.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_true_of_and_eq_true_right {a b : Prop} (h : (a \u2227 b) = True) : b = True :="}
{"input": "Statement in natural language:\nThe trailing degree of the polynomial 1 in the ring R[X] is greater than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem trailingDegree_one_le : (0 : \u2115\u221e) \u2264 trailingDegree (1 : R[X]) :="}
{"input": "Statement in natural language:\nFor any finite set 's' of type '\u03b2' and any function 'f' from '\u03b2' to the set of subsets of '\u03b1', if every subset 'f i' for 'i' in 's' is both closed and open (clopen), then the intersection of all such subsets 'f i' is also clopen.\nTranslate the statement in natural language to Lean:", "output": "theorem isClopen_biInter_finset {\u03b2 : Type _} {s : Finset \u03b2} {f : \u03b2 \u2192 Set \u03b1}\n    (h : \u2200 i \u2208 s, IsClopen (f i)) : IsClopen (\u22c2 i \u2208 s, f i) :="}
{"input": "Statement in natural language:\nIf G is a full subcategory and H is a cover dense for categories K and G, then the cover is locally dense for categories K and G.\nTranslate the statement in natural language to Lean:", "output": "theorem CoverDense.locallyCoverDense [Full G] (H : CoverDense K G) : LocallyCoverDense K G :="}
{"input": "Statement in natural language:\nFor any structured arrow 'f' from 'S' to 'T', mapping the identity morphism of 'S' to 'f' results in 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem map_id {f : StructuredArrow S T} : (map (\ud835\udfd9 S)).obj f = f :="}
{"input": "Statement in natural language:\nThe exponential function is measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_exp : Measurable exp :="}
{"input": "Statement in natural language:\nFor a given element 'x' of set 'M', the application of the inverse function of 'ofTop p h' to 'x' is equal to the pair consisting of 'x' and the trivial proof that 'x' belongs to the preimage of 'p' under 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofTop_symm_apply {h} (x : M) : (ofTop p h).symm x = \u27e8x, h.symm \u25b8 trivial\u27e9 :="}
{"input": "Statement in natural language:\nFor two linear maps 'f' and 'g', the matrix representation of the product of 'f' and 'g' is equal to the product of the matrix representation of 'f' and the matrix representation of 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearMap.toMatrix_mul (f g : M\u2081 \u2192\u2097[R] M\u2081) :\n    LinearMap.toMatrix v\u2081 v\u2081 (f * g) = LinearMap.toMatrix v\u2081 v\u2081 f \u2b1d LinearMap.toMatrix v\u2081 v\u2081 g :="}
{"input": "Statement in natural language:\nFor any function 'f' from a measurable space '\u03b1' to a topological space '\u03b2', 'f' is almost everywhere strongly measurable with respect to the zero measure on '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem aestronglyMeasurable_zero_measure [MeasurableSpace \u03b1] [TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    AEStronglyMeasurable f (0 : Measure \u03b1) :="}
{"input": "Statement in natural language:\nThe transpose of the adjugate of a matrix A is equal to the adjugate of the transpose of matrix A.\nTranslate the statement in natural language to Lean:", "output": "theorem adjugate_transpose (A : Matrix n n \u03b1) : (adjugate A)\u1d40 = adjugate A\u1d40 :="}
{"input": "Statement in natural language:\nFor a given multiplicative equivalence 'e' between two mathematical structures M and N, and for any element 'y' from N, applying 'e' to the inverse of 'y' under 'e' gives 'y' back.\nTranslate the statement in natural language to Lean:", "output": "theorem apply_symm_apply (e : M \u2243* N) (y : N) : e (e.symm y) = y :="}
{"input": "Statement in natural language:\nFor a probability mass function 'p' and an element 'a', the probability of 'a' under 'p' is less than or equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_le_one (p : Pmf \u03b1) (a : \u03b1) : p a \u2264 1 :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type \u03b1, a submonoid 'S' of M, and an element 'x' of M, 'x' is in the set resulting from the operation of 'a\u207b\u00b9' (the inverse of 'a') on 'S' if and only if the result of the operation of 'a' on 'x' is in 'S'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_inv_pointwise_smul_iff {a : \u03b1} {S : Submonoid M} {x : M} : x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S :="}
{"input": "Statement in natural language:\nThe derivative of the polynomial function (X - C), where C is a constant, is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem derivative_X_sub_C (c : R) : derivative (X - C c) = 1 :="}
{"input": "Statement in natural language:\nIf we have a pregroupoid PG on a topological space H, and for all pairs of local homeomorphisms e and e' from the atlas of M to H, the property of PG holds for the composition of the inverse of e and e' on the source of this composition, then M has the groupoid associated with PG.\nTranslate the statement in natural language to Lean:", "output": "theorem hasGroupoid_of_pregroupoid (PG : Pregroupoid H) (h : \u2200 {e e' : LocalHomeomorph M H},\n      e \u2208 atlas H M \u2192 e' \u2208 atlas H M \u2192 PG.property (e.symm \u226b\u2095 e') (e.symm \u226b\u2095 e').source) :\n    HasGroupoid M PG.groupoid :="}
{"input": "Statement in natural language:\nIf a function 'f' tends to a value 'a' as it approaches infinity, then the extended distance between the function at 0 and 'a' is less than or equal to 'C' divided by (1 - 'r').\nTranslate the statement in natural language to Lean:", "output": "theorem edist_le_of_edist_le_geometric_of_tendsto\u2080 {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\n    edist (f 0) a \u2264 C / (1 - r) :="}
{"input": "Statement in natural language:\nFor a given function M mapping from \u039b to Stmt\u2081, a finite set S of \u039b, and a statement q of type Stmt\u2081, if M supports S, then if some statement q is in the statements of M and S, S supports the statement q.\nTranslate the statement in natural language to Lean:", "output": "theorem stmts_supportsStmt {M : \u039b \u2192 Stmt\u2081} {S : Finset \u039b} {q : Stmt\u2081} (ss : Supports M S) :\n    some q \u2208 stmts M S \u2192 SupportsStmt S q :="}
{"input": "Statement in natural language:\nFor any two finite sets s and t, the union of s with the union of s and t is equal to the union of s and t. This is essentially saying that adding s to the union of s and t doesn't change the result, which is the union of s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem union_left_idem (s t : Finset \u03b1) : s \u222a (s \u222a t) = s \u222a t :="}
{"input": "Statement in natural language:\nFor all indices i, if each element a i is in set t i, then the image of the function that maps each index i to the pair (i, a i) over set s is a subset of the Cartesian product of set s and set t.\nTranslate the statement in natural language to Lean:", "output": "theorem image_sigmaMk_subset_sigma_left {a : \u2200 i, \u03b1 i} (ha : \u2200 i, a i \u2208 t i) :\n    (fun i \u21a6 Sigma.mk i (a i)) '' s \u2286 s.Sigma t :="}
{"input": "Statement in natural language:\nIf 's' is an antichain with respect to relation 'r', then 's' is also an antichain with respect to the swapped relation 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem swap (hs : IsAntichain r s) : IsAntichain (swap r) s :="}
{"input": "Statement in natural language:\nFor any two lists (l\u2081 and l\u2082), taking the initial elements from the combined list (l\u2081 ++ l\u2082) up to the length of the first list (l\u2081) will result in the first list (l\u2081).\nTranslate the statement in natural language to Lean:", "output": "theorem takeI_left (l\u2081 l\u2082 : List \u03b1) : takeI (length l\u2081) (l\u2081 ++ l\u2082) = l\u2081 :="}
{"input": "Statement in natural language:\nFor a list of elements of type M, if every element in the list is equal to a specific element m, then the product of all elements in the list is equal to m raised to the power of the length of the list.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_eq_pow_card (l : List M) (m : M) (h : \u2200 x \u2208 l, x = m) : l.prod = m ^ l.length :="}
{"input": "Statement in natural language:\nThe equivalence of the finite successor of a multivariate polynomial in ring R and natural number n with the polynomial of variable 0 is equal to the polynomial of variable X.\nTranslate the statement in natural language to Lean:", "output": "theorem finSuccEquiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X :="}
{"input": "Statement in natural language:\nFor any element 'a' of a group 'M' and any natural number 'n', the power of 'a' to the 'n + 1' is equal to 'a' multiplied by the power of 'a' to the 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_succ (a : M) (n : \u2115) : a ^ (n + 1) = a * a ^ n :="}
{"input": "Statement in natural language:\nFor a given filter 'l' of type \u03b2, a function 'f' from \u03b2 to a product type \u03c0 indexed by i, and a point 'x' of the same product type, if 'f' tends to 'x' along 'l', then for any index 'i', the function that maps each element 'a' of the domain to the 'i'-th component of 'f(a)' also tends to the 'i'-th component of 'x' along 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.apply {l : Filter \u03b2} {f : \u03b2 \u2192 \u2200 i, \u03c0 i} {x : \u2200 i, \u03c0 i}\n    (h : Tendsto f l (\ud835\udcdd x)) (i : \u03b9) : Tendsto (fun a => f a i) l (\ud835\udcdd <| x i) :="}
{"input": "Statement in natural language:\nFor any two types indexed by \u03b9\u2081 and \u03b9\u2082 respectively, and a property p that relates an element of the first type, an index of the first type, an element of the second type, and an index of the second type, the existence of such elements and indices that satisfy the property is commutative. That is, it doesn't matter in which order we consider the elements and indices from the two types, the existence of such elements and indices that satisfy the property remains the same.\nTranslate the statement in natural language to Lean:", "output": "theorem exists\u2082_comm {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort _} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort _} {p : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Prop} :\n    (\u2203 i\u2081 j\u2081 i\u2082 j\u2082, p i\u2081 j\u2081 i\u2082 j\u2082) \u2194 \u2203 i\u2082 j\u2082 i\u2081 j\u2081, p i\u2081 j\u2081 i\u2082 j\u2082 :="}
{"input": "Statement in natural language:\nFor a group with zero, if x is not equal to zero, then the function that multiplies y by x is injective. This means that for any two different values of y, their products with x will also be different.\nTranslate the statement in natural language to Lean:", "output": "theorem GroupWithZero.mul_right_injective (h : x \u2260 0) :\n    Function.Injective fun y => y * x :="}
{"input": "Statement in natural language:\nIf 'b' is less than 'b'' and 'r' is greater than 0, then the line map of 'a', 'b', and 'r' is less than the line map of 'a', 'b'', and 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem lineMap_strict_mono_right (hb : b < b') (hr : 0 < r) : lineMap a b r < lineMap a b' r :="}
{"input": "Statement in natural language:\nFor a non-zero number 'a' and two natural numbers 'm' and 'n' such that 'n' is less than or equal to 'm', the inverse of 'a' raised to the power of the difference between 'm' and 'n' is equal to the inverse of 'a' raised to the power of 'm' multiplied by 'a' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_pow_sub\u2080 (ha : a \u2260 0) (h : n \u2264 m) : a\u207b\u00b9 ^ (m - n) = (a ^ m)\u207b\u00b9 * a ^ n :="}
{"input": "Statement in natural language:\nThe maximum value obtained by folding function 'f' over set 's' starting with 'b' is less than 'c' if and only if 'b' is less than 'c' and for all elements 'x' in set 's', the function 'f' of 'x' is less than 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem fold_max_lt : s.fold max b f < c \u2194 b < c \u2227 \u2200 x \u2208 s, f x < c :="}
{"input": "Statement in natural language:\nThe exponent of a group G is equal to 0 if there exists an element g in G such that the order of g is 0. Otherwise, the exponent of G is the supremum of the order of all elements g in G.\nTranslate the statement in natural language to Lean:", "output": "theorem exponent_eq_iSup_orderOf' :\n    exponent G = if \u2203 g : G, orderOf g = 0 then 0 else \u2a06 g : G, orderOf g :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a certain type '\u03b1', and any integer 'm', the function 'toIcoDiv' applied to 'hp', 'a - m' times 'p', and 'b' is equal to the function 'toIcoDiv' applied to 'hp', 'a', and 'b' plus 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem toIcoDiv_sub_zsmul' (a b : \u03b1) (m : \u2124) : toIcoDiv hp (a - m \u2022 p) b = toIcoDiv hp a b + m :="}
{"input": "Statement in natural language:\nFor any set 's' that is closed, the interior of the frontier of 's' is an empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem interior_frontier {s : Set \u03b1} (h : IsClosed s) : interior (frontier s) = \u2205 :="}
{"input": "Statement in natural language:\nFor any two supremum-preserving functions 'f' and 'g' from a partially ordered set '\u03b1' to another partially ordered set '\u03b2', and for any element 'a' in '\u03b1', the supremum of the images of 'a' under 'f' and 'g' is equal to the image of 'a' under the supremum of 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_apply (f g : SupHom \u03b1 \u03b2) (a : \u03b1) : (f \u2294 g) a = f a \u2294 g a :="}
{"input": "Statement in natural language:\nIn a nontrivial ring R, if the function p from the finite set of size 2 to R is such that p(0) and p(1) are coprime, then p cannot be the zero function.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCoprime.ne_zero [Nontrivial R] {p : Fin 2 \u2192 R} (h : IsCoprime (p 0) (p 1)) : p \u2260 0 :="}
{"input": "Statement in natural language:\nA set 's' is open if and only if for every element 'a' in 's', 's' is an element of the neighborhood of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpen_iff_mem_nhds {s : Set \u03b1} : IsOpen s \u2194 \u2200 a \u2208 s, s \u2208 \ud835\udcdd a :="}
{"input": "Statement in natural language:\nFor any type F that is a monoid, and any function c from F to the transformation of M to M, if c applied to 1 equals the identity function, and for all elements f and g in F, c applied to the product of f and g equals the composition of c applied to f and c applied to g, then for any element f in F, for all natural numbers n, c applied to f raised to the power of n equals the nth iterate of c applied to f.\nTranslate the statement in natural language to Lean:", "output": "theorem hom_coe_pow {F : Type _} [Monoid F] (c : F \u2192 M \u2192 M) (h1 : c 1 = id)\n    (hmul : \u2200 f g, c (f * g) = c f \u2218 c g) (f : F) : \u2200 n, c (f ^ n) = c f^[n]"}
{"input": "Statement in natural language:\nFor any rational number 'q' and any absolute value function 'abv' on the rational numbers, the function 'ofRat' applied to 'q' is equal to 'q' considered as a Cauchy sequence with respect to the absolute value 'abv'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofRat_rat {abv : \u211a \u2192 \u211a} [IsAbsoluteValue abv] (q : \u211a) :\n    ofRat (q : \u211a) = (q : Cauchy abv) :="}
{"input": "Statement in natural language:\nGiven two distinct elements 'a' and 'b' and a function 'f' such that 'f' of 'a' equals 1, the multinomial of the set containing 'a' and 'b' with respect to function 'f' equals the successor of 'f' of 'b'. Here, the successor of a number is the next number following it.\nTranslate the statement in natural language to Lean:", "output": "theorem binomial_one [DecidableEq \u03b1] (h : a \u2260 b) (h\u2081 : f a = 1) :\n    multinomial {a, b} f = (f b).succ :="}
{"input": "Statement in natural language:\nFor a prime number p and a finite Sylow p-subgroup P of a group G, if an element x belongs to the centralizer of P and the element obtained by conjugating x by the inverse of another element g also belongs to the centralizer of P, then there exists an element n in the normalizer of P such that the element obtained by conjugating x by the inverse of g is equal to the element obtained by conjugating x by n.\nTranslate the statement in natural language to Lean:", "output": "theorem Sylow.conj_eq_normalizer_conj_of_mem_centralizer [Fact p.Prime] [Finite (Sylow p G)]\n    (P : Sylow p G) (x g : G) (hx : x \u2208 (P : Subgroup G).centralizer)\n    (hy : g\u207b\u00b9 * x * g \u2208 (P : Subgroup G).centralizer) :\n    \u2203 n \u2208 (P : Subgroup G).normalizer, g\u207b\u00b9 * x * g = n\u207b\u00b9 * x * n :="}
{"input": "Statement in natural language:\nI is continuous in the context of smooth manifolds with corners.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous : Continuous I :="}
{"input": "Statement in natural language:\nThe basic open set of the product of two elements f and g from a ring R is a subset of or equal to the basic open set of the element f.\nTranslate the statement in natural language to Lean:", "output": "theorem basicOpen_mul_le_left (f g : R) : basicOpen (f * g) \u2264 basicOpen f :="}
{"input": "Statement in natural language:\nIf for a given measurable space '\u03b1' with measures 'm' and 'm0', and a measure '\u03bc' on '\u03b1', if 'm' is less than or equal to 'm0' and a function 'f' from '\u03b1' to '\u03b2' is almost everywhere strongly measurable with respect to the trimmed measure '\u03bc.trim hm', then 'f' is also almost everywhere strongly measurable with respect to the measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.aestronglyMeasurable_of_aestronglyMeasurable_trim {\u03b1} {m m0 : MeasurableSpace \u03b1}\n    {\u03bc : Measure \u03b1} (hm : m \u2264 m0) {f : \u03b1 \u2192 \u03b2} (hf : AEStronglyMeasurable f (\u03bc.trim hm)) :\n    AEStronglyMeasurable f \u03bc :="}
{"input": "Statement in natural language:\nFor a property Q that applies to Laurent polynomials over a ring R, and for any Laurent polynomial f, if for all polynomials f in R[X] and for all natural numbers n, the property Q holds for the product of the Laurent polynomial conversion of f and the negation of T raised to the power of n, then the property Q holds for the Laurent polynomial f.\nTranslate the statement in natural language to Lean:", "output": "theorem induction_on_mul_T {Q : R[T;T\u207b\u00b9] \u2192 Prop} (f : R[T;T\u207b\u00b9])\n    (Qf : \u2200 {f : R[X]} {n : \u2115}, Q (toLaurent f * T (-n))) : Q f :="}
{"input": "Statement in natural language:\nThe composition of the lift of the kernel of g with respect to f and w, and \u03c0' of f, g, and w, equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem condition_\u03c0' : kernel.lift g f w \u226b \u03c0' f g w = 0 :="}
{"input": "Statement in natural language:\nIf we have a pairwise relation 'r', and for all pairs 'i' and 'j', if 'r' applies to 'i' and 'j' then 'p' also applies to 'i' and 'j', then 'p' is also a pairwise relation.\nTranslate the statement in natural language to Lean:", "output": "theorem Pairwise.mono (hr : Pairwise r) (h : \u2200 \u2983i j\u2984, r i j \u2192 p i j) : Pairwise p :="}
{"input": "Statement in natural language:\nThe function 'fromRel' applied to a relation that is symmetric and always false (represented by the bottom symbol '\u22a5') for any elements x, y, and z of a type \u03b1, results in an empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem fromRel_bot : fromRel (fun (x y : \u03b1) z => z : Symmetric \u22a5) = \u2205 :="}
{"input": "Statement in natural language:\nFor a linear map T from a vector space E to itself, if T is positive, then the real part of the inner product of T applied to a vector x and x itself is nonnegative.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPositive.inner_nonneg_left {T : E \u2192L[\ud835\udd5c] E} (hT : IsPositive T) (x : E) :\n    0 \u2264 re \u27eaT x, x\u27eb :="}
{"input": "Statement in natural language:\nIf S is a subalgebra of a ring A over a ring R, and if this subalgebra is Noetherian as a submodule over R, then any element x in S is integral over R.\nTranslate the statement in natural language to Lean:", "output": "theorem isIntegral_of_submodule_noetherian (S : Subalgebra R A)\n    (H : IsNoetherian R (Subalgebra.toSubmodule S)) (x : A) (hx : x \u2208 S) : IsIntegral R x :="}
{"input": "Statement in natural language:\nFor a set 's' with a decidable predicate, the function of the order embedding of the set 's' is equal to the composition of the coercion function and the subtype of natural numbers in the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_orderEmbeddingOfSet [DecidablePred (\u00b7 \u2208 s)] :\n    \u21d1(orderEmbeddingOfSet s) = (\u2191) \u2218 Subtype.ofNat s :="}
{"input": "Statement in natural language:\nIf we have two algebraic structures, g and f, such that g maps from B to C and f maps from A to B over a ring R, and both g and f are finite, then the composition of g and f (g composed with f) is also finite.\nTranslate the statement in natural language to Lean:", "output": "theorem comp {g : B \u2192\u2090[R] C} {f : A \u2192\u2090[R] B} (hg : g.Finite) (hf : f.Finite) : (g.comp f).Finite :="}
{"input": "Statement in natural language:\nFor any two extended real numbers x and y, if neither x nor y is equal to positive infinity, then the sum of x and y is less than positive infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem add_lt_top {x y : EReal} (hx : x \u2260 \u22a4) (hy : y \u2260 \u22a4) : x + y < \u22a4 :="}
{"input": "Statement in natural language:\nFor a function 'g' mapping from two variables '\u03b2' and '\u03b3' to '\u03b4', if 'g' is continuous when its arguments are uncurried, and there are two measurable functions 'f\u2081' and 'f\u2082' mapping from '\u03b1' to '\u03b2' and '\u03b3' respectively with respect to a measure '\u03bc', then the composition of 'g' with 'f\u2081' and 'f\u2082' is equal to the composition of 'g' with the pair of 'f\u2081' and 'f\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp\u2082_eq_pair (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : comp\u2082 g hg f\u2081 f\u2082 = comp _ hg (f\u2081.pair f\u2082) :="}
{"input": "Statement in natural language:\nFor a given submodule U of an inner product space E over a field \ud835\udd5c, assuming U is a complete space, the norm of the difference between a vector y in E and its orthogonal projection in U is equal to the infimum of the norm of the difference between y and any vector x in U.\nTranslate the statement in natural language to Lean:", "output": "theorem orthogonalProjection_minimal {U : Submodule \ud835\udd5c E} [CompleteSpace U] (y : E) :\n    \u2016y - orthogonalProjection U y\u2016 = \u2a05 x : U, \u2016y - x\u2016 :="}
{"input": "Statement in natural language:\nIf infinity is not an element of set s, then set s is open if and only if the preimage of set s under the embedding function is an open set in X.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpen_iff_of_not_mem (h : \u221e \u2209 s) : IsOpen s \u2194 IsOpen ((\u2191) \u207b\u00b9' s : Set X) :="}
{"input": "Statement in natural language:\nIf 'x' is a generic point of 'S' and 'f' is a continuous function, then the image of 'x' under 'f' is a generic point of the closure of the image of 'S' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem image (h : IsGenericPoint x S) {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) :\n    IsGenericPoint (f x) (closure (f '' S)) :="}
{"input": "Statement in natural language:\nFor a given seminorm 'p' on a vector space 'E\u2082' over a field '\ud835\udd5c\u2082', and a given linear map 'f' from a vector space 'E' to 'E\u2082', the composition of 'p' and 'f' applied to a vector 'x' in 'E' is equal to 'p' applied to the image of 'x' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_apply (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (x : E) : (p.comp f) x = p (f x) :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't', if for every element 'b', there is a Galois connection between the composition of 'toDual' and 'l\u2081 b' and the composition of 'swap u b' and 'ofDual', and for every element 'a', there is a Galois connection between the composition of 'toDual' and 'l\u2082 a' and the composition of 'u a' and 'ofDual', then the infimum of the image of the function 'u' over the Cartesian product of 's' and 't' is equal to the value of the function 'u' at the supremum of 's' and the supremum of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem sInf_image2_eq_sSup_sSup (h\u2081 : \u2200 b, GaloisConnection (toDual \u2218 l\u2081 b) (swap u b \u2218 ofDual))\n    (h\u2082 : \u2200 a, GaloisConnection (toDual \u2218 l\u2082 a) (u a \u2218 ofDual)) :\n    sInf (image2 u s t) = u (sSup s) (sSup t) :="}
{"input": "Statement in natural language:\nIf A is an adjacency matrix (as indicated by 'IsAdjMatrix A'), then the complement of A (denoted by 'A.compl') is also an adjacency matrix. This is true under the conditions that \u03b1 is a set that includes zero and one.\nTranslate the statement in natural language to Lean:", "output": "theorem compl [Zero \u03b1] [One \u03b1] (h : IsAdjMatrix A) : IsAdjMatrix A.compl :="}
{"input": "Statement in natural language:\nIf the cokernel of a morphism 'f' is zero, then 'f' is an epimorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem epi_of_cokernel_\u03c0_eq_zero (h : cokernel.\u03c0 f = 0) : Epi f :="}
{"input": "Statement in natural language:\nThe empty set is a member of the powerset of any given finite set.\nTranslate the statement in natural language to Lean:", "output": "theorem empty_mem_powerset (s : Finset \u03b1) : \u2205 \u2208 powerset s :="}
{"input": "Statement in natural language:\nThe evaluation tower with the identity algebra homomorphism from S to S is equal to the algebra evaluation function, which maps a function from \u03c3 to S and a multivariate polynomial over \u03c3 and S to an algebra homomorphism from S to S.\nTranslate the statement in natural language to Lean:", "output": "theorem aevalTower_id :\n    aevalTower (AlgHom.id S S) = (aeval : (\u03c3 \u2192 S) \u2192 MvPolynomial \u03c3 S \u2192\u2090[S] S) :="}
{"input": "Statement in natural language:\nThe double symmetry of 'e' is equal to 'e' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_symm : e.symm.symm = e :="}
{"input": "Statement in natural language:\nIf a matrix A represents a linear transformation f with respect to a basis b, and another matrix A' represents a different linear transformation f' with respect to the same basis b, then the matrix obtained by adding A and A' represents the linear transformation obtained by adding f and f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Matrix.Represents.add {A A' : Matrix \u03b9 \u03b9 R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : Matrix.Represents b A' f') : (A + A').Represents b (f + f') :="}
{"input": "Statement in natural language:\nIn a T2 space and compact space X, which is also a totally disconnected space, for any two elements x and y of X, if for every discrete quotient Q of X, the projection of x equals the projection of y, then x equals y.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_forall_proj_eq [T2Space X] [CompactSpace X] [disc : TotallyDisconnectedSpace X]\n    {x y : X} (h : \u2200 Q : DiscreteQuotient X, Q.proj x = Q.proj y) : x = y :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from a strict convex space 'PF' to 'PE', if 'f' is an isometry, then applying the affine isometry of the strict convex space to a point 'p' in 'PF' is equivalent to applying the function 'f' to the point 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem affineIsometryOfStrictConvexSpace_apply {f : PF \u2192 PE} (hi : Isometry f) (p : PF) :\n    hi.affineIsometryOfStrictConvexSpace p = f p :="}
{"input": "Statement in natural language:\nThere exists a non-negative constant C such that for all elements x in the set \u03b1, the distance between the function values f(x) and g(x) is less than or equal to C.\nTranslate the statement in natural language to Lean:", "output": "theorem dist_set_exists : \u2203 C, 0 \u2264 C \u2227 \u2200 x : \u03b1, dist (f x) (g x) \u2264 C :="}
{"input": "Statement in natural language:\nFor a relation 'r' between indices and a relation 's' for each index between elements of type '\u03b1', and for two functions 'a' and 'b' from indices to elements of type '\u03b1', 'a' is lexicographically less than 'b' (according to 'r' and 's') if and only if there exists an index 'j' such that for all indices 'd', if 'd' is related to 'j' by 'r', then 'a' at 'd' equals 'b' at 'd', and 'a' at 'j' is related to 'b' at 'j' by 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem lex_def {r : \u03b9 \u2192 \u03b9 \u2192 Prop} {s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop} {a b : \u03a0\u2080 i, \u03b1 i} :\n    Dfinsupp.Lex r s a b \u2194 \u2203 j, (\u2200 d, r d j \u2192 a d = b d) \u2227 s j (a j) (b j) :="}
{"input": "Statement in natural language:\nIf a set 't' is order-connected in the non-negative real numbers, then the image of 't' under the function that maps each element to its corresponding element in the extended non-negative real numbers is also order-connected.\nTranslate the statement in natural language to Lean:", "output": "theorem image_coe_nnreal_ennreal (h : t.OrdConnected) : ((\u2191) '' t : Set \u211d\u22650\u221e).OrdConnected :="}
{"input": "Statement in natural language:\nA pair (a, b) is in the intersection of edges r, s, and t if and only if a is in s, b is in t, and r is an edge connecting a and b.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_mem_interedges_iff : (a, b) \u2208 interedges r s t \u2194 a \u2208 s \u2227 b \u2208 t \u2227 r a b :="}
{"input": "Statement in natural language:\nFor a local homeomorphism 'e' between two sets \u03b1 and \u03b2, a point 'b' in the target set of 'e', and two functions 'f' and 'g' from \u03b2 to E and F respectively, and a real number 'C', the function 'f' is Big O of 'g' at 'b' with constant 'C' if and only if the function 'f' composed with the inverse of 'e' is Big O of the function 'g' composed with the inverse of 'e' at the inverse image of 'b' under 'e', with the same constant 'C'. \n\nHere, 'Big O' refers to the concept of asymptotic upper bound from the field of asymptotic analysis.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigOWith_congr (e : LocalHomeomorph \u03b1 \u03b2) {b : \u03b2} (hb : b \u2208 e.target) {f : \u03b2 \u2192 E}\n    {g : \u03b2 \u2192 F} {C : \u211d} : IsBigOWith C (\ud835\udcdd b) f g \u2194 IsBigOWith C (\ud835\udcdd (e.symm b)) (f \u2218 e) (g \u2218 e) :="}
{"input": "Statement in natural language:\nIf an ideal I in a ring \u03b1 is maximal, then I is also prime.\nTranslate the statement in natural language to Lean:", "output": "theorem IsMaximal.isPrime {I : Ideal \u03b1} (H : I.IsMaximal) : I.IsPrime :="}
{"input": "Statement in natural language:\nFor two functions 'f' and 'g' from a normed space 'E' to another normed space 'A', and a natural number 'N' (possibly infinite), if 'f' and 'g' are continuously differentiable on a subset 's' of 'E' up to order 'N', and 's' has unique derivatives, then for any point 'x' in 's' and any natural number 'n' less than or equal to 'N', the norm of the 'n'-th derivative of the function 'f*y*g*y' at 'x' is less than or equal to the sum, over all 'i' in the range from 0 to 'n', of the binomial coefficient 'n choose i' times the norm of the 'i'-th derivative of 'f' at 'x' times the norm of the '(n-i)'-th derivative of 'g' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_iteratedFDerivWithin_mul_le {f : E \u2192 A} {g : E \u2192 A} {N : \u2115\u221e} (hf : ContDiffOn \ud835\udd5c N f s)\n    (hg : ContDiffOn \ud835\udd5c N g s) (hs : UniqueDiffOn \ud835\udd5c s) {x : E} (hx : x \u2208 s) {n : \u2115}\n    (hn : (n : \u2115\u221e) \u2264 N) : \u2016iteratedFDerivWithin \ud835\udd5c n (fun y => f y * g y) s x\u2016 \u2264\n      \u2211 i in Finset.range (n + 1), (n.choose i : \u211d) * \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 *\n        \u2016iteratedFDerivWithin \ud835\udd5c (n - i) g s x\u2016 :="}
{"input": "Statement in natural language:\nFor a measurable space \u03b1, a countable set \u03b1, a measurable space \u03b2, and a function f from \u03b2 to \u03b1, if for every element y, the preimage of the set {f y} under f is a measurable set, then the function f is measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_to_countable [MeasurableSpace \u03b1] [Countable \u03b1] [MeasurableSpace \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (h : \u2200 y, MeasurableSet (f \u207b\u00b9' {f y})) : Measurable f :="}
{"input": "Statement in natural language:\nIf we have a morphism 'f' from presheaf P to Q, and a family of elements 'x' of P that is compatible, then the composition of 'x' with the presheaf map 'f' is also compatible.\nTranslate the statement in natural language to Lean:", "output": "theorem FamilyOfElements.Compatible.compPresheafMap (f : P \u27f6 Q) {x : FamilyOfElements P R}\n    (h : x.Compatible) : (x.compPresheafMap f).Compatible :="}
{"input": "Statement in natural language:\nA presheaf F satisfies the sheaf condition with respect to a cover of open sets if and only if it satisfies the sheaf condition with respect to pairwise intersections of open sets.\nTranslate the statement in natural language to Lean:", "output": "theorem isSheafOpensLeCover_iff_isSheafPairwiseIntersections :\n    F.IsSheafOpensLeCover \u2194 F.IsSheafPairwiseIntersections :="}
{"input": "Statement in natural language:\nFor a polynomial 'f' over a ring 'R' and for any two elements 'x' and 'y' of 'R', the evaluation of 'f' at the sum of 'x' and 'y' is equal to the sum of three terms: \n\n1. The sum over all terms of 'f', where each term is the product of its coefficient 'a' and 'x' raised to the power of its exponent 'e'. \n\n2. The sum over all terms of 'f', where each term is the product of its coefficient 'a', its exponent 'e', 'x' raised to the power of 'e - 1', and 'y'. \n\n3. The sum over all terms of 'f', where each term is the product of its coefficient 'a', the value of the function 'polyBinomAux1' applied to 'x', 'y', 'e', and 'a', and 'y' squared.\nTranslate the statement in natural language to Lean:", "output": "theorem poly_binom_aux3 (f : R[X]) (x y : R) :\n    f.eval (x + y) =\n      ((f.sum fun e a => a * x ^ e) + f.sum fun e a => a * e * x ^ (e - 1) * y) +\n        f.sum fun e a => a * (polyBinomAux1 x y e a).val * y ^ 2 :="}
{"input": "Statement in natural language:\nFor a non-zero ideal I and an element x from field K, x is in the inverse of I if and only if for all elements y in I, the product of x and y is in the unit fractional ideal of the field K.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_inv_iff (hI : I \u2260 0) {x : K} : x \u2208 I\u207b\u00b9 \u2194 \u2200 y \u2208 I, x * y \u2208 (1 : FractionalIdeal R\u2081\u2070 K) :="}
{"input": "Statement in natural language:\nIf a set 's' is convex in a real vector space 'R', and for every element 'i' in a set 't', the weight 'w i' is greater than or equal to zero, and the sum of the weights 'w i' over all 'i' in 't' equals 1, and for every 'i' in 't', 'z i' is an element of 's', then the weighted sum of 'z i' over all 'i' in 't' is an element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Convex.sum_mem (hs : Convex R s) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i) (h\u2081 : (\u2211 i in t, w i) = 1)\n    (hz : \u2200 i \u2208 t, z i \u2208 s) : (\u2211 i in t, w i \u2022 z i) \u2208 s :="}
{"input": "Statement in natural language:\nA function that maps the sum of two functions, f and g, is continuous if and only if both f and g are continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} :\n    Continuous (Sum.map f g) \u2194 Continuous f \u2227 Continuous g :="}
{"input": "Statement in natural language:\nFor any two elements x and y from the unit interval I, the product of x and y is less than or equal to y.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_le_right {x y : I} : x * y \u2264 y :="}
{"input": "Statement in natural language:\nFor a linear map 'g' from 'P' to 'Q', the lift of the composition of 'f' and 'g' is equal to the composition of 'g' and the lift of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_compr\u2082 (g : P \u2192\u2097[R] Q) : lift (f.compr\u2082 g) = g.comp (lift f) :="}
{"input": "Statement in natural language:\nFor any two Lie Ideals I\u2081 and I\u2082 of a Lie algebra L over a commutative ring R, if I\u2081 is a subset of or equal to I\u2082, then the function 'homOfLe' that maps I\u2081 to I\u2082 is injective. In other words, if two elements in I\u2081 are mapped to the same element in I\u2082 by 'homOfLe', then those two elements were originally the same in I\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem homOfLe_injective {I\u2081 I\u2082 : LieIdeal R L} (h : I\u2081 \u2264 I\u2082) : Function.Injective (homOfLe h) :="}
{"input": "Statement in natural language:\nFor an infinite set \u03b1, the cardinality of \u03b1 when converted to a partial extended natural number equals the greatest element in the set of all partial extended natural numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_toPartENat_of_infinite [h : Infinite \u03b1] : toPartENat (#\u03b1) = \u22a4 :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c in a set \u03b1, subtracting the sum of b and c from a is equal to subtracting c from a and then subtracting b.\nTranslate the statement in natural language to Lean:", "output": "theorem tsub_add_eq_tsub_tsub_swap (a b c : \u03b1) : a - (b + c) = a - c - b :="}
{"input": "Statement in natural language:\nThe measure with zero density is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem withDensity_zero : \u03bc.withDensity 0 = 0 :="}
{"input": "Statement in natural language:\nFor any two lists of elements (l and l'), the set of elements x such that the product of swapping elements in l and l' at position x does not equal x, is a subset of the union of the finite sets of l and l'.\nTranslate the statement in natural language to Lean:", "output": "theorem zipWith_swap_prod_support' (l l' : List \u03b1) :\n    { x | (zipWith swap l l').prod x \u2260 x } \u2264 l.toFinset \u2294 l'.toFinset :="}
{"input": "Statement in natural language:\nFor any property 'p' pertaining to an element of type '\u03b1', an element 'a' of type '\u03b1', and a lazy list 'l' of elements of type '\u03b1', the property 'p' holds for every element in the lazy list that is constructed by adding 'a' to 'l' if and only if the property 'p' holds for 'a' and for every element in 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem forall_mem_cons {\u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : Thunk (LazyList \u03b1)} :\n    (\u2200 x \u2208 @LazyList.cons _ a l, p x) \u2194 p a \u2227 \u2200 x \u2208 l.get, p x :="}
{"input": "Statement in natural language:\nFor any type '\u03b1' and any natural number 'k', given that '\u03b1' and 'Sym \u03b1 k' are finite types, the cardinality of 'Sym \u03b1 k' is equal to the multichoose of the cardinality of '\u03b1' and 'k'.\nTranslate the statement in natural language to Lean:", "output": "theorem card_sym_eq_multichoose (\u03b1 : Type _) (k : \u2115) [Fintype \u03b1] [Fintype (Sym \u03b1 k)] :\n    card (Sym \u03b1 k) = multichoose (card \u03b1) k :="}
{"input": "Statement in natural language:\nFor a given point 'x' and two points 'y' and 'z', 'x' is between 'y' and 'z' and 'x' is between 'z' and 'y' if and only if 'y' is equal to 'z'. This is under the condition that there are no zero scalar multiplication or division operations in the real number space 'R' and the vector space 'V'.\nTranslate the statement in natural language to Lean:", "output": "theorem wbtw_swap_right_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} :\n    Wbtw R x y z \u2227 Wbtw R x z y \u2194 y = z :="}
{"input": "Statement in natural language:\nThe function which takes a pair of points in \u03b1 and returns the non-negative distance between them is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_nndist : Continuous fun p : \u03b1 \u00d7 \u03b1 => nndist p.1 p.2 :="}
{"input": "Statement in natural language:\nThe integral function, which takes a function from \u03b1 to E (with respect to measure \u03bc) and returns its integral, is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_integral : Continuous fun f : \u03b1 \u2192\u2081[\u03bc] E => \u222b a, f a \u2202\u03bc :="}
{"input": "Statement in natural language:\nIf a tree 't' of order '\u03b1' is valid within the bounds 'o\u2081' and 'o\u2082', and if 'x' is bounded by 'o\u2081' and nil, and all elements of 't' are less than 'x', then 't' is valid within the bounds 'o\u2081' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem Valid'.of_lt {t : Ordnode \u03b1} {x : \u03b1} {o\u2081 o\u2082} (H : Valid' o\u2081 t o\u2082) (h\u2081 : Bounded nil o\u2081 x)\n    (h\u2082 : All (\u00b7 < x) t) : Valid' o\u2081 t x :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2' that is almost everywhere measurable with respect to measure '\u03bc', and for a measurable set 's', 's' is in the almost everywhere measure of the map of 'f' with respect to '\u03bc' if and only if the preimage of 's' under 'f' is in the almost everywhere measure of '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_ae_map_iff {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {s : Set \u03b2} (hs : MeasurableSet s) :\n    s \u2208 (\u03bc.map f).ae \u2194 f \u207b\u00b9' s \u2208 \u03bc.ae :="}
{"input": "Statement in natural language:\nFor a nontrivial ring R and a subset M that is a subset of the non-zero divisors of R, if an element x from R is in the non-zero divisors of R, then the algebraic mapping of x from R to another ring S is not zero.\nTranslate the statement in natural language to Lean:", "output": "theorem to_map_ne_zero_of_mem_nonZeroDivisors [Nontrivial R] (hM : M \u2264 nonZeroDivisors R)\n    {x : R} (hx : x \u2208 nonZeroDivisors R) : algebraMap R S x \u2260 0 :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'a' and 'b', if 'a' is greater than or equal to 2 and 'b' is strictly greater than 2, then the value of the expression '(a to the power of b plus 1) divided by (a plus 1)' is always greater than or equal to 2.\nTranslate the statement in natural language to Lean:", "output": "theorem b_id_helper {a b : \u2115} (ha : 2 \u2264 a) (hb : 2 < b) : 2 \u2264 (a ^ b + 1) / (a + 1) :="}
{"input": "Statement in natural language:\nThe cardinality (or the number of elements) of a pair, consisting of elements 'a' and 'b' of any type '\u03b1', is equal to 2.\nTranslate the statement in natural language to Lean:", "output": "theorem card_pair (a b : \u03b1) : card {a, b} = 2 :="}
{"input": "Statement in natural language:\nIf 'f' is a compact operator from a module 'M\u2082' over a ring 'R\u2082' to a module 'M\u2083', and 'g' is a continuous linear map from a module 'M\u2081' to 'M\u2082', then the composition of 'f' and 'g' is also a compact operator.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCompactOperator.comp_clm [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] {f : M\u2082 \u2192 M\u2083}\n    (hf : IsCompactOperator f) (g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : IsCompactOperator (f \u2218 g) :="}
{"input": "Statement in natural language:\n\"a is less than the supremum of a and b if and only if b is not less than or equal to a.\"\nTranslate the statement in natural language to Lean:", "output": "theorem left_lt_sup : a < a \u2294 b \u2194 \u00acb \u2264 a :="}
{"input": "Statement in natural language:\nIf a function 'f' has a local minimum at a point 'a' in a set 's', and if 'f' is eventually equal to another function 'g' at 'a' within the set 's', and if 'a' is an element of 's', then 'g' also has a local minimum at 'a' in the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLocalMinOn.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalMinOn f s a)\n    (heq : f =\u1da0[\ud835\udcdd[s] a] g) (hmem : a \u2208 s) : IsLocalMinOn g s a :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b2' to '\u03b1' and a measure '\u03bc' on '\u03b2', if 'f' is almost everywhere measurable with respect to '\u03bc', then the function that maps each element 'a' to the extended non-negative real number equivalent of the norm of 'f(a)' is also almost everywhere measurable with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem AEMeasurable.ennnorm {f : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)) \u03bc :="}
{"input": "Statement in natural language:\nIf 'snd' and 'f' are isomorphisms, then for a commutative square 'sq' with 'fst', 'snd', 'f', and 'g', the square is a pullback.\nTranslate the statement in natural language to Lean:", "output": "theorem of_vert_isIso [IsIso snd] [IsIso f] (sq : CommSq fst snd f g) : IsPullback fst snd f g :="}
{"input": "Statement in natural language:\n\"x is within \u03b5 distance of y in a closed ball if and only if y is within \u03b5 distance of x in a closed ball\".\nTranslate the statement in natural language to Lean:", "output": "theorem mem_closedBall_comm : x \u2208 closedBall y \u03b5 \u2194 y \u2208 closedBall x \u03b5 :="}
{"input": "Statement in natural language:\nIf X is a type with a topological space structure, a T1 space structure, and is finite, then X has a discrete topology structure.\nTranslate the statement in natural language to Lean:", "output": "theorem discrete_of_t1_of_finite {X : Type _} [TopologicalSpace X] [T1Space X] [Finite X] :\n    DiscreteTopology X :="}
{"input": "Statement in natural language:\nFor any integer 'n', in the context of an additive group with one element (\u03b1) that has characteristic zero, 'n' being equal to zero in \u03b1 is equivalent to 'n' being zero in the integers.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_eq_zero [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) = 0 \u2194 n = 0 :="}
{"input": "Statement in natural language:\nThe preimage of the product set 's' and 't' under the function that pairs each element 'a' with 'b', is equal to 's' if 'b' is an element of 't', otherwise it is an empty set. This is under the condition that whether an element belongs to 't' is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_preimage_prod_left_eq_if [DecidablePred (\u00b7 \u2208 t)] :\n    (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = if b \u2208 t then s else \u2205 :="}
{"input": "Statement in natural language:\nFor a function 'f' mapping from '\u03b1' and '\u03b3' to '\u03b4', and another function 'g' mapping from '\u03b2' to '\u03b3', mapping 'f' with 'a' and the result of mapping 'g' with 'b' is equivalent to mapping a function that takes 'a' and 'b' and applies 'f' to 'a' and 'g' to 'b', with 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_map_right (f : \u03b1 \u2192 \u03b3 \u2192 \u03b4) (g : \u03b2 \u2192 \u03b3) :\n    map\u2082 f a (b.map g) = map\u2082 (fun a b => f a (g b)) a b :="}
{"input": "Statement in natural language:\nIf a function 'f' is strictly monotonic (meaning it either consistently increases or decreases), and if 'a' is less than 'b', then 'f(a)' is less than 'f(b)'.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictMono.imp (hf : StrictMono f) (h : a < b) : f a < f b :="}
{"input": "Statement in natural language:\nFor a pretrivialization 'e' of a fiber bundle with projection '\u03c0 E', if a base 'b' is not in the base set of 'e', then the inverse of 'e' at 'b' is equal to zero when viewed as a function from the fiber 'F' to the fiber over 'b' in 'E'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_symm_of_not_mem (e : Pretrivialization F (\u03c0 E)) {b : B} (hb : b \u2209 e.baseSet) :\n    (e.symm b : F \u2192 E b) = 0 :="}
{"input": "Statement in natural language:\nIf the field E over the scalar field \ud835\udd5c is not finite-dimensional, then there exists a real number R and a sequence of elements in E such that R is greater than 1, the norm of each element in the sequence is less than or equal to R, and for any two distinct elements in the sequence, the norm of their difference is greater than or equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_seq_norm_le_one_le_norm_sub (h : \u00acFiniteDimensional \ud835\udd5c E) :\n    \u2203 (R : \u211d)(f : \u2115 \u2192 E), 1 < R \u2227 (\u2200 n, \u2016f n\u2016 \u2264 R) \u2227 \u2200 m n, m \u2260 n \u2192 1 \u2264 \u2016f m - f n\u2016 :="}
{"input": "Statement in natural language:\nIf there is a function G from \u03b2 to \u03b3 that is Lipschitz continuous with a constant C, then the composition of G and H is also continuous. This composition is a function from the set of bounded continuous functions from \u03b1 to \u03b2 to the set of bounded continuous functions from \u03b1 to \u03b3.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_comp {G : \u03b2 \u2192 \u03b3} {C : \u211d\u22650} (H : LipschitzWith C G) :\n    Continuous (comp G H : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b3) :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c, if a is less than or equal to b and b is less than or equal to c, then a is less than or equal to c.\nTranslate the statement in natural language to Lean:", "output": "theorem le_trans : \u2200 {a b c : \u03b1}, a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c :="}
{"input": "Statement in natural language:\nFor a set 's' in the space '\u03b2' and a function 't' mapping from '\u03b9' to the set of '\u03b2', the vector difference of 's' and the intersection of all 't i' is a subset of the intersection of all vector differences of 's' and 't i'.\nTranslate the statement in natural language to Lean:", "output": "theorem vsub_iInter_subset (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s -\u1d65 \u22c2 i, t i) \u2286 \u22c2 i, s -\u1d65 t i :="}
{"input": "Statement in natural language:\nThere is a Galois connection between the set of subsets of R and the set of subsets of the prime spectrum of R. This connection is established through the functions 'zeroLocus' and 'vanishingIdeal'. The 'zeroLocus' function takes a subset of R and returns the set of prime ideals where the elements of the subset vanish. The 'vanishingIdeal' function takes a subset of the prime spectrum of R and returns the ideal generated by the elements that vanish on the subset.\nTranslate the statement in natural language to Lean:", "output": "theorem gc_set :\n    @GaloisConnection (Set R) (Set (PrimeSpectrum R))\u1d52\u1d48 _ _ (fun s => zeroLocus s) fun t =>\n      vanishingIdeal t :="}
{"input": "Statement in natural language:\nFor any natural number 'n', 9 divides 'n' if and only if 9 divides the sum of the digits of 'n' when 'n' is expressed in base 10.\nTranslate the statement in natural language to Lean:", "output": "theorem nine_dvd_iff (n : \u2115) : 9 \u2223 n \u2194 9 \u2223 (digits 10 n).sum :="}
{"input": "Statement in natural language:\nIf the cardinality of set t is less than the cardinality of set s, and there exists a function f that maps every element of set s to set t, then there exist two distinct elements x and y in set s such that f(x) equals f(y).\nTranslate the statement in natural language to Lean:", "output": "theorem exists_ne_map_eq_of_ncard_lt_of_maps_to {t : Set \u03b2} (hc : t.ncard < s.ncard) {f : \u03b1 \u2192 \u03b2}\n  (hf : \u2200 a \u2208 s, f a \u2208 t) (ht : t.Finite := by toFinite_tac) :\n    \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 f x = f y :="}
{"input": "Statement in natural language:\nFor any unit 'u' in the set of associates of '\u03b1', 'u' is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem units_eq_one (u : (Associates \u03b1)\u02e3) : u = 1 :="}
{"input": "Statement in natural language:\nFor any function 'f' from a type '\u03b1' to the same type '\u03b1', 'f' commutes with itself.\nTranslate the statement in natural language to Lean:", "output": "theorem refl (f : \u03b1 \u2192 \u03b1) : Commute f f :="}
{"input": "Statement in natural language:\nIf function 'f' reaches its maximum at point 'a' within set 's' and function 'g' reaches its minimum at the same point 'a' within the same set 's', then the function defined as the difference between 'f' and 'g' will also reach its maximum at point 'a' within set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsMaxOn.sub (hf : IsMaxOn f s a) (hg : IsMinOn g s a) : IsMaxOn (fun x => f x - g x) s a :="}
{"input": "Statement in natural language:\nFor two functions 'f' and 'g' from sets '\u03b1' and '\u03b2' to a set 'M', if there exists a bijective function 'e' from '\u03b1' to '\u03b2' such that for every element 'x' in '\u03b1', 'f(x)' equals 'g(e(x))', then the infinite product of 'f' over all elements in '\u03b1' equals the infinite product of 'g' over all elements in '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem finprod_eq_of_bijective {f : \u03b1 \u2192 M} {g : \u03b2 \u2192 M} (e : \u03b1 \u2192 \u03b2) (he\u2080 : Bijective e)\n    (he\u2081 : \u2200 x, f x = g (e x)) : (\u220f\u1da0 i, f i) = \u220f\u1da0 j, g j :="}
{"input": "Statement in natural language:\nFor a given topological space '\u03b1' and a set 's' within this space, if 's' is compact, and there is a function 'f' that is continuous on 's', then there exists a constant 'C' such that for all elements 'x' in 's', the norm of 'f(x)' is less than or equal to 'C'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCompact.exists_bound_of_continuous_on' [TopologicalSpace \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    {f : \u03b1 \u2192 E} (hf : ContinuousOn f s) : \u2203 C, \u2200 x \u2208 s, \u2016f x\u2016 \u2264 C :="}
{"input": "Statement in natural language:\nFor any two types \u0393 and \u0393' that are inhabited, given a pointed map 'f' from \u0393 to \u0393', and a list 'l' of type \u0393 that is blank, the head of the list 'l' mapped by 'f' is equal to the result of 'f' applied to the head of the list 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem ListBlank.head_map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393')\n    (l : ListBlank \u0393) : (l.map f).head = f l.head :="}
{"input": "Statement in natural language:\nFor any non-negative real number 'r', the representation of 'r' as a non-negative extended real number is equal to the non-negative extended real number obtained from 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_nnreal_eq (r : \u211d\u22650) : (r : \u211d\u22650\u221e) = ENNReal.ofReal r :="}
{"input": "Statement in natural language:\nFor any type M with structures L and L', and any expansion \u03d5 on M, for any function f from L with arity n and any function x from the finite set of size n to M, the function map of the expansion of f on x is equal to the function map of f on x.\nTranslate the statement in natural language to Lean:", "output": "theorem map_onFunction {M : Type _} [L.Structure M] [L'.Structure M] [\u03d5.IsExpansionOn M] {n}\n    (f : L.Functions n) (x : Fin n \u2192 M) : funMap (\u03d5.onFunction f) x = funMap f x :="}
{"input": "Statement in natural language:\nFor a bilinear form B over a ring R\u2082 and a function from n to R\u2082, converting the bilinear form to a matrix and then back to a bilinear form will yield the original bilinear form B.\nTranslate the statement in natural language to Lean:", "output": "theorem Matrix.toBilin'_toMatrix' (B : BilinForm R\u2082 (n \u2192 R\u2082)) :\n    Matrix.toBilin' (BilinForm.toMatrix' B) = B :="}
{"input": "Statement in natural language:\nIf the series of function f is summable and the series of function g is also summable, then the series of the function that subtracts g from f for each input b is also summable.\nTranslate the statement in natural language to Lean:", "output": "theorem Summable.sub (hf : Summable f) (hg : Summable g) : Summable fun b => f b - g b :="}
{"input": "Statement in natural language:\nFor any affine subspace Q of a vector space E over a field \ud835\udd5c, Q is a convex set in E.\nTranslate the statement in natural language to Lean:", "output": "theorem AffineSubspace.convex (Q : AffineSubspace \ud835\udd5c E) : Convex \ud835\udd5c (Q : Set E) :="}
{"input": "Statement in natural language:\nIf we have an algebra from A to B and a scalar tower from R to A to B, then if A is of finite type over R and B is of finite type over A, it follows that B is of finite type over R.\nTranslate the statement in natural language to Lean:", "output": "theorem trans [Algebra A B] [IsScalarTower R A B] (hRA : FiniteType R A) (hAB : FiniteType A B) :\n    FiniteType R B :="}
{"input": "Statement in natural language:\nFor a given set 's' of subobjects of an object 'A' in category 'C', and a subobject 'f' that belongs to 's', the infimum (greatest lower bound) of 's' is less than or equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem sInf_le {A : C} (s : Set (Subobject A)) (f) (hf : f \u2208 s) : sInf s \u2264 f :="}
{"input": "Statement in natural language:\nThe rank of the module K with a finite function from natural number n to K is equal to n.\nTranslate the statement in natural language to Lean:", "output": "theorem rank_fin_fun (n : \u2115) : Module.rank K (Fin n \u2192 K) = n :="}
{"input": "Statement in natural language:\nFor a set 's' of elements of type 'A', if the zero element of 'A' is in 's' and for any two elements 'a' and 'b' of 'A' that are in 's', the result of 'a' subtracted by 'b' is also in 's', then 's' is an additive subgroup.\nTranslate the statement in natural language to Lean:", "output": "theorem IsAddSubgroup.of_sub (s : Set A) (zero_mem : (0 : A) \u2208 s)\n    (sub_mem : \u2200 {a b : A}, a \u2208 s \u2192 b \u2208 s \u2192 a - b \u2208 s) : IsAddSubgroup s :="}
{"input": "Statement in natural language:\nIf x is an element of the closed interval box I, then the single box partition of I at x is a Henstock partition.\nTranslate the statement in natural language to Lean:", "output": "theorem isHenstock_single (h : x \u2208 Box.Icc I) : IsHenstock (single I I le_rfl x h) :="}
{"input": "Statement in natural language:\nIf we have a transitive relation R on a type \u03b1, and a list l\u2082 forms a chain with respect to R starting from an element a, then if list l\u2081 is a sublist of l\u2082, l\u2081 also forms a chain with respect to R starting from the same element a.\nTranslate the statement in natural language to Lean:", "output": "theorem Chain.sublist [IsTrans \u03b1 R] (hl : l\u2082.Chain R a) (h : l\u2081 <+ l\u2082) :\n    l\u2081.Chain R a :="}
{"input": "Statement in natural language:\nIf you reflect a point 'p' in a subspace 'K' twice, you will get back the original point 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem reflection_reflection (p : E) : reflection K (reflection K p) = p :="}
{"input": "Statement in natural language:\nIf a function g from the Cartesian product of E\u2081 and E\u2082 to G is continuously differentiable, and if two functions f\u2081 and f\u2082 from F to E\u2081 and E\u2082 respectively are continuously differentiable on a set s, then the function that maps x in s to g of the pair (f\u2081 of x, f\u2082 of x) is also continuously differentiable on the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiff.comp_contDiff_on\u2082 {g : E\u2081 \u00d7 E\u2082 \u2192 G} {f\u2081 : F \u2192 E\u2081} {f\u2082 : F \u2192 E\u2082} {s : Set F}\n    (hg : ContDiff \ud835\udd5c n g) (hf\u2081 : ContDiffOn \ud835\udd5c n f\u2081 s) (hf\u2082 : ContDiffOn \ud835\udd5c n f\u2082 s) :\n    ContDiffOn \ud835\udd5c n (fun x => g (f\u2081 x, f\u2082 x)) s :="}
{"input": "Statement in natural language:\nFor a set C of subsets of \u03b1, if the initial measure m0 is generated from C, and C is a pi system, and \u03bc is a finite measure, and for all subsets s in C, the measure \u03bc of s is equal to the measure \u03bd of s, and the measure \u03bc of the universal set is equal to the measure \u03bd of the universal set, then the measure \u03bc is equal to the measure \u03bd.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_of_generate_finite (C : Set (Set \u03b1)) (hA : m0 = generateFrom C) (hC : IsPiSystem C)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u2200 s \u2208 C, \u03bc s = \u03bd s) (h_univ : \u03bc univ = \u03bd univ) : \u03bc = \u03bd :="}
{"input": "Statement in natural language:\nFor a special linear group of order 2 over the real numbers, denoted as SL(2, R), the inverse of a matrix A in this group is given by a 2x2 matrix where the elements are determined by the elements of A. Specifically, the first row of the inverse matrix consists of the element at the second row and second column of A, and the negative of the element at the first row and second column of A. The second row of the inverse matrix consists of the negative of the element at the second row and first column of A, and the element at the first row and first column of A. The determinant of this inverse matrix is given by the function SL2_inv_expl_det applied to A.\nTranslate the statement in natural language to Lean:", "output": "theorem SL2_inv_expl (A : SL(2, R)) :\n    A\u207b\u00b9 = \u27e8![![A.1 1 1, -A.1 0 1], ![-A.1 1 0, A.1 0 0]], SL2_inv_expl_det A\u27e9 :="}
{"input": "Statement in natural language:\nFor any two finite maps 's' and 't' of some type '\u03b2', 's' and 't' are equal if and only if their entries are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem ext_iff {s t : Finmap \u03b2} : s.entries = t.entries \u2194 s = t :="}
{"input": "Statement in natural language:\nFor a simple function 'f' from '\u03b1' to 'E' that belongs to the space of measurable functions 'Mem\u2112p' with norm 'p' and measure '\u03bc', the norm of the function 'f' when it is transformed to 'Lp' space is equal to the real part of the essential supremum norm of 'f' with respect to 'p' and '\u03bc'. This is true when 'p' is greater than or equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_toLp [Fact (1 \u2264 p)] (f : \u03b1 \u2192\u209b E) (hf : Mem\u2112p f p \u03bc) :\n    \u2016toLp f hf\u2016 = ENNReal.toReal (snorm f p \u03bc) :="}
{"input": "Statement in natural language:\nIf you first apply the function 'I.fst' to 'a' and then apply 'K.\u03c0' to the result of 'I.fstFrom a', it is equal to first applying the function 'I.snd' to 'a' and then applying 'K.\u03c0' to the result of 'I.sndFrom a'.\nTranslate the statement in natural language to Lean:", "output": "theorem condition (a) : I.fst a \u226b K.\u03c0 (I.fstFrom a) = I.snd a \u226b K.\u03c0 (I.sndFrom a) :="}
{"input": "Statement in natural language:\nIf function f\u2081 is less than or equal to function f\u2082, and function g\u2081 is less than or equal to function g\u2082, then the product of function f\u2081 and function g\u2081 is less than or equal to the product of function f\u2082 and function g\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_le_smul : f\u2081 \u2264 f\u2082 \u2192 g\u2081 \u2264 g\u2082 \u2192 f\u2081 \u2022 g\u2081 \u2264 f\u2082 \u2022 g\u2082 :="}
{"input": "Statement in natural language:\nIf x is homeomorphic to y, then the neighborhood of x is equal to the neighborhood of y.\nTranslate the statement in natural language to Lean:", "output": "theorem nhds_eq (h : x ~\u1d62 y) : \ud835\udcdd x = \ud835\udcdd y :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b', 'a' is equal to 'b' if and only if the injection of 'a' into the right component of the sum type is equal to the injection of 'b' into the right component of the sum type.\nTranslate the statement in natural language to Lean:", "output": "theorem inr.inj_iff {a b} : (inr a : Sum \u03b1 \u03b2) = inr b \u2194 a = b :="}
{"input": "Statement in natural language:\nIf for all x in set s, f is differentiable at x, and the norm of the derivative of f at x minus \u03c6 is less than or equal to C, and if s is a convex set, and x and y are elements of s, then the norm of f(y) minus f(x) minus \u03c6 applied to (y - x) is less than or equal to C times the norm of (y - x).\nTranslate the statement in natural language to Lean:", "output": "theorem norm_image_sub_le_of_norm_fderiv_le' (hf : \u2200 x \u2208 s, DifferentiableAt \ud835\udd5c f x)\n    (bound : \u2200 x \u2208 s, \u2016fderiv \ud835\udd5c f x - \u03c6\u2016 \u2264 C) (hs : Convex \u211d s) (xs : x \u2208 s) (ys : y \u2208 s) :\n    \u2016f y - f x - \u03c6 (y - x)\u2016 \u2264 C * \u2016y - x\u2016 :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any two semilattice infimum structures A and B on \u03b1, if for all x and y of type \u03b1, x is less than or equal to y in A if and only if x is less than or equal to y, then for any x and y of type \u03b1, the infimum of x and y in A is equal to the infimum of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem SemilatticeInf.ext_inf {\u03b1} {A B : SemilatticeInf \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y)\n    (x y : \u03b1) :\n    (haveI := A; x \u2293 y) = x \u2293 y :="}
{"input": "Statement in natural language:\nThe unit of the Free Monoidal Category is equal to the identity of the functor applied to the category C.\nTranslate the statement in natural language to Lean:", "output": "theorem unit_eq_unit : FreeMonoidalCategory.Unit = \ud835\udfd9_ (F C) :="}
{"input": "Statement in natural language:\nFor any set 's' of pairs of elements from two sets '\u03b1' and '\u03b2' that have an infimum, the first element of the infimum of 's' is equal to the infimum of the set of all first elements of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_sInf [InfSet \u03b1] [InfSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sInf s).fst = sInf (Prod.fst '' s) :="}
{"input": "Statement in natural language:\nIf 'a' and 'b' are codisjoint, then the images of 'a' and 'b' under a function 'f' are also codisjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem Codisjoint.map (h : Codisjoint a b) : Codisjoint (f a) (f b) :="}
{"input": "Statement in natural language:\nFor a given ring \u03b1, if a function f is periodic with period c, then the value of the function at any integer multiple of the period is equal to the value of the function at zero.\nTranslate the statement in natural language to Lean:", "output": "theorem Periodic.int_mul_eq [Ring \u03b1] (h : Periodic f c) (n : \u2124) : f (n * c) = f 0 :="}
{"input": "Statement in natural language:\nFor a continuous linear map 'f' from 'F' to 'G' and a formal multilinear series 'p' from '\ud835\udd5c' to 'E' to 'F', the composition of 'f' with the 'n'-th term of the formal multilinear series 'p' is equal to the composition of 'f' with the 'n'-th continuous multilinear map of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem compFormalMultilinearSeries_apply (f : F \u2192L[\ud835\udd5c] G) (p : FormalMultilinearSeries \ud835\udd5c E F)\n    (n : \u2115) : (f.compFormalMultilinearSeries p) n = f.compContinuousMultilinearMap (p n) :="}
{"input": "Statement in natural language:\nThe complement of a singleton set {x} is dense if and only if the singleton set {x} is not open.\nTranslate the statement in natural language to Lean:", "output": "theorem dense_compl_singleton_iff_not_open {x : \u03b1} :\n    Dense ({x}\u1d9c : Set \u03b1) \u2194 \u00acIsOpen ({x} : Set \u03b1) :="}
{"input": "Statement in natural language:\n'b' is an element of the closed interval from 'a' to 'b' if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem right_mem_Icc : b \u2208 Icc a b \u2194 a \u2264 b :="}
{"input": "Statement in natural language:\nFor an element 'b' not in set 's', the infimum (greatest lower bound) of the function 'f' over the set obtained by adding 'b' to 's' is equal to the infimum of 'f' at 'b' and the infimum of 'f' over 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_cons {b : \u03b2} (h : b \u2209 s) : (cons b s h).inf f = f b \u2293 s.inf f :="}
{"input": "Statement in natural language:\nFor a given real number 'a' and another real number 'c' which is greater than zero, the preimage of the function that multiplies 'x' by 'c' in the interval of all real numbers less than 'a' is equal to the interval of all real numbers less than 'a' divided by 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_mul_const_Iio (a : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Iio a = Iio (a / c) :="}
{"input": "Statement in natural language:\nFor any two elements x and y from a set R, the inverse action of x applied to y is equal to the inverse of the action of x on y.\nTranslate the statement in natural language to Lean:", "output": "theorem invAct_apply (x y : R) : (act' x)\u207b\u00b9 y = x \u25c3\u207b\u00b9 y :="}
{"input": "Statement in natural language:\nFor a property P that applies to integers, and a given integer m, if P holds for m, and for any integer n that is less than or equal to m, if P holds for n then P also holds for n minus 1, then for any integer n that is less than or equal to m, P holds for n. This is a form of induction going downwards from m.\nTranslate the statement in natural language to Lean:", "output": "theorem le_induction_down {P : \u2124 \u2192 Prop} {m : \u2124} (h0 : P m)\n    (h1 : \u2200 n : \u2124, n \u2264 m \u2192 P n \u2192 P (n - 1)) (n : \u2124) : n \u2264 m \u2192 P n :="}
{"input": "Statement in natural language:\nThe half-open interval from 'a' to 'b' is totally bounded.\nTranslate the statement in natural language to Lean:", "output": "theorem totallyBounded_Ico (a b : \u03b1) : TotallyBounded (Ico a b) :="}
{"input": "Statement in natural language:\nThe composition of the total function with the representation function of a linearly independent vector is equal to the subtype of a submodule.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearIndependent.total_comp_repr :\n    (Finsupp.total \u03b9 M R v).comp hv.repr = Submodule.subtype _ :="}
{"input": "Statement in natural language:\nAn open interval from a point 'a' to the same point 'a' is an empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioo_self (a : \u03b1) : Ioo a a = \u2205 :="}
{"input": "Statement in natural language:\nFor a continuous function 'f' from '\u03b1' to '\u03b2' and a set 't' in '\u03b2', the closure of the preimage of 't' under 'f' is a subset of the preimage of the closure of 't' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.closure_preimage_subset {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (t : Set \u03b2) :\n    closure (f \u207b\u00b9' t) \u2286 f \u207b\u00b9' closure t :="}
{"input": "Statement in natural language:\nIf the function pair f and g is anti-variant on a set s, then the composition of f and g with another function k is also anti-variant on the preimage of set s under function k.\nTranslate the statement in natural language to Lean:", "output": "theorem AntivaryOn.comp_right (h : AntivaryOn f g s) (k : \u03b9' \u2192 \u03b9) :\n    AntivaryOn (f \u2218 k) (g \u2218 k) (k \u207b\u00b9' s) :="}
{"input": "Statement in natural language:\nThe set of points where a linear map 'f' from a module 'M' to another module 'M\u2082' equals itself is the entire space.\nTranslate the statement in natural language to Lean:", "output": "theorem eqLocus_same (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : f.eqLocus f = \u22a4 :="}
{"input": "Statement in natural language:\nThe application of the outer measure to a set 't' from a uniform distribution of a finite set 's' is equal to the ratio of the cardinality of the set 's' filtered by the elements in 't' to the cardinality of the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem toOuterMeasure_uniformOfFinset_apply :\n    (uniformOfFinset s hs).toOuterMeasure t = (s.filter (\u00b7 \u2208 t)).card / s.card :="}
{"input": "Statement in natural language:\nFor any two finite sets 's' and 't', and any two functions 'f' and 'g', the supremum (or greatest lower bound) of the infimum (or least upper bound) of 'f' over 's' and the infimum of 'g' over 't' is equal to the infimum over the Cartesian product of 's' and 't' of the supremum of 'f' applied to the first element of the pair and 'g' applied to the second element of the pair.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_sup_inf (s : Finset \u03b9) (t : Finset \u03ba) (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    s.inf f \u2294 t.inf g = (s \u00d7\u02e2 t).inf fun i => f i.1 \u2294 g i.2 :="}
{"input": "Statement in natural language:\nIf x is irrational, then its negative, -x, is also irrational.\nTranslate the statement in natural language to Lean:", "output": "theorem neg (h : Irrational x) : Irrational (-x) :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements in E, the balanced core of 's' with respect to the field \ud835\udd5c is balanced.\nTranslate the statement in natural language to Lean:", "output": "theorem balancedCore_balanced (s : Set E) : Balanced \ud835\udd5c (balancedCore \ud835\udd5c s) :="}
{"input": "Statement in natural language:\nFor any function 'f' that maps each element of type '\u03b1 i' to an element of type '\u03b2 i', the Cartesian product of the universal set 'Set \u03b9' and the range of 'f i' is equal to the range of a function that maps each element 'x' of the Cartesian product of '\u03b9' and '\u03b1 i' to a pair consisting of the first element of 'x' and the image of the second element of 'x' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem sigma_univ_range_eq {f : \u2200 i, \u03b1 i \u2192 \u03b2 i} :\n    ((univ : Set \u03b9).Sigma fun i \u21a6 range (f i)) = range fun x : \u03a3i, \u03b1 i \u21a6 \u27e8x.1, f _ x.2\u27e9 :="}
{"input": "Statement in natural language:\nFor a given finite set 'S' and a function 'f' mapping from 'S' to the free module 'N', the sum over 'S' of the function 'f' applied to each element in 'S' is equal to the sum over 'S' of the function 'f' applied to each element in 'S' and then mapped to the free module 'N'. This is under the condition that 'N' is an additive commutative monoid.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_finset_sum [AddCommMonoid N] (S : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u2080 N) :\n    \u21d1(\u2211 i in S, f i) = \u2211 i in S, \u21d1(f i) :="}
{"input": "Statement in natural language:\nFor any index 'i', and any elements 'a' from the zeroth component of the direct sum and 'b' from the 'i'th component of the direct sum, the direct sum of the scalar multiplication of 'a' and 'b' is equal to the product of the direct sum of 'a' and the direct sum of 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem of_zero_smul {i} (a : A 0) (b : A i) : of _ _ (a \u2022 b) = of _ _ a * of _ _ b :="}
{"input": "Statement in natural language:\nFor a given type \u03b2 with decidable equality, a value x of type \u03b2, a function e that is an equivalence between the option of type \u03b1 and \u03b2 such that e applied to none equals x, a value a of type \u03b1, and a proof h, the application of the function optionSubtype with arguments x, e, and a equals a pair consisting of the application of e to a and the proof h.\nTranslate the statement in natural language to Lean:", "output": "theorem optionSubtype_apply_apply\n    [DecidableEq \u03b2] (x : \u03b2)\n    (e : { e : Option \u03b1 \u2243 \u03b2 // e none = x })\n    (a : \u03b1)\n    (h) : optionSubtype x e a = \u27e8(e : Option \u03b1 \u2243 \u03b2) a, h\u27e9 :="}
{"input": "Statement in natural language:\nFor any real number 'x', the function 'untrop' applied to the function 'trop' of 'x' equals 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem untrop_trop (x : R) : untrop (trop x) = x :="}
{"input": "Statement in natural language:\nIn a monoid structure \u03b1, given an irreducible element p and two elements a and b such that p equals the product of a and b, either a or b is a unit.\nTranslate the statement in natural language to Lean:", "output": "theorem isUnit_or_isUnit [Monoid \u03b1] {p : \u03b1} (hp : Irreducible p) {a b : \u03b1} (h : p = a * b) :\n    IsUnit a \u2228 IsUnit b :="}
{"input": "Statement in natural language:\nFor any given tree 't' and objects 'o\u2081' and 'o\u2082', if 't' is valid with respect to 'o\u2081' and 'o\u2082', then 't' is valid.\nTranslate the statement in natural language to Lean:", "output": "theorem Valid'.valid {t o\u2081 o\u2082} (h : @Valid' \u03b1 _ o\u2081 t o\u2082) : Valid t :="}
{"input": "Statement in natural language:\nFor a given point 'c' in an affine space 'P1', the coercion of the homothety affine map of 'c' is equal to the homothety of 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_homothetyAffine (c : P1) : \u21d1(homothetyAffine c : k \u2192\u1d43[k] _) = homothety c :="}
{"input": "Statement in natural language:\nFor a given injective function 'f' from model 'M' to model 'N' in the language 'L', the function 'f' when converted to a homomorphism (using 'toHom') from 'M' to 'N' is still the same function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_toHom {f : M \u21aa[L] N} : (f.toHom : M \u2192 N) = f :="}
{"input": "Statement in natural language:\nThe preimage of the set of real numbers between 'a' and 'b' (including 'a' but excluding 'b') under the function that casts natural numbers to real numbers, is equal to the set of natural numbers between the ceiling of 'a' and the ceiling of 'b' (including the ceiling of 'a' but excluding the ceiling of 'b').\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_Ico {a b : \u03b1} : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ico a b = Set.Ico \u2308a\u2309\u208a \u2308b\u2309\u208a :="}
{"input": "Statement in natural language:\nIf the algebraic mapping of R to A is continuous, then the scalar multiplication of R and A is also continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousSMul_of_algebraMap (h : Continuous (algebraMap R A)) : ContinuousSMul R A :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and an element 'a' of the integers modulo 'n', the value of 'a' is equal to zero if and only if 'a' itself is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem val_eq_zero : \u2200 {n : \u2115} (a : ZMod n), a.val = 0 \u2194 a = 0"}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, where \u03b2 is a preorder, and any two functions f and g from \u03b1 to \u03b2, and any element a of type \u03b1 and any filter l on \u03b1, if g is eventually less than or equal to f at filter l, and f at a equals g at a, and if f is a maximum filter at a with respect to l, then g is also a maximum filter at a with respect to l.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.EventuallyLE.isMaxFilter {\u03b1 \u03b2 : Type _} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n    {l : Filter \u03b1} (hle : g \u2264\u1da0[l] f) (hfga : f a = g a) (h : IsMaxFilter f l a) :\n    IsMaxFilter g l a :="}
{"input": "Statement in natural language:\nThe object 'zero' in the operation 'walkingParallelPairOp' is equal to the operation 'one' applied to its opposite.\nTranslate the statement in natural language to Lean:", "output": "theorem walkingParallelPairOp_zero : walkingParallelPairOp.obj zero = op one :="}
{"input": "Statement in natural language:\nIf a function F tends uniformly towards another function f on a set \u03c6 within a thickening of \u03b4 around a set K, and if \u03b4 is greater than 0, and if the function F is continuous on the thickening of \u03b4 around K for all eventually n in \u03c6, then the complex derivative of F tends uniformly towards the complex derivative of f on the set K.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.TendstoUniformlyOn.cderiv (hF : TendstoUniformlyOn F f \u03c6 (cthickening \u03b4 K))\n    (h\u03b4 : 0 < \u03b4) (hFn : \u2200\u1da0 n in \u03c6, ContinuousOn (F n) (cthickening \u03b4 K)) :\n    TendstoUniformlyOn (cderiv \u03b4 \u2218 F) (cderiv \u03b4 f) \u03c6 K :="}
{"input": "Statement in natural language:\nA multivariate polynomial 'p' is equal to zero if and only if the coefficient of 'p' for any degree 'd' is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_zero_iff {p : MvPolynomial \u03c3 R} : p = 0 \u2194 \u2200 d, coeff d p = 0 :="}
{"input": "Statement in natural language:\nFor any two objects Y and Z in category C, and a morphism f from Z to Y, if I is an injective resolution of Y and J is an injective resolution of Z, then the composition of J's augmentation morphism and the descendent of f with respect to I and J is equal to the composition of the map of f in the zeroth cochain complex of C and I's augmentation morphism.\nTranslate the statement in natural language to Lean:", "output": "theorem desc_commutes {Y Z : C} (f : Z \u27f6 Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) : J.\u03b9 \u226b desc f I J = (CochainComplex.single\u2080 C).map f \u226b I.\u03b9 :="}
{"input": "Statement in natural language:\nThe product of sets s and t is a subset of set u if and only if for every element b in set t, the scalar multiplication of b and set s is a subset of set u.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_subset_iff_right : s * t \u2286 u \u2194 \u2200 b \u2208 t, op b \u2022 s \u2286 u :="}
{"input": "Statement in natural language:\nFor any list 'l', 'l' is a sub-permutation of itself.\nTranslate the statement in natural language to Lean:", "output": "theorem Subperm.refl (l : List \u03b1) : l <+~ l :="}
{"input": "Statement in natural language:\nFor a simple graph G with vertex set V, the simple graph derived from the structure of G is equal to G itself.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.SimpleGraph.simpleGraphOfStructure (G : SimpleGraph V) :\n    @simpleGraphOfStructure V G.structure _ = G :="}
{"input": "Statement in natural language:\nThe set s is balanced in the field \ud835\udd5c if and only if for all elements a in \ud835\udd5c such that the norm of a is less than or equal to 1, and for all elements x in the vector space E, if x is in s then the scalar multiplication of a and x is in s.\nTranslate the statement in natural language to Lean:", "output": "theorem balanced_iff_smul_mem : Balanced \ud835\udd5c s \u2194 \u2200 \u2983a : \ud835\udd5c\u2984, \u2016a\u2016 \u2264 1 \u2192 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 a \u2022 x \u2208 s :="}
{"input": "Statement in natural language:\nIf sets 'a' and 'b' are disjoint, then set 'c' is less than or equal to the symmetric difference of 'a' and 'c' union the symmetric difference of 'b' and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem Disjoint.le_symmDiff_sup_symmDiff_left (h : Disjoint a b) : c \u2264 a \u2206 c \u2294 b \u2206 c :="}
{"input": "Statement in natural language:\nThe function which adds two extended real numbers is continuous at any point (a, b) in the extended real plane.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousAt_add_coe_coe (a b : \u211d) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (a, b) :="}
{"input": "Statement in natural language:\nFor a given element 'a' of type \u03b1 and given subgroups 'S' and 'T' of type A, 'a' multiplied by 'S' is less than or equal to 'T' if and only if 'S' is less than or equal to the inverse of 'a' multiplied by 'T'.\nTranslate the statement in natural language to Lean:", "output": "theorem pointwise_smul_le_iff {a : \u03b1} {S T : AddSubgroup A} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T :="}
{"input": "Statement in natural language:\nFor any two nonempty compact subsets x and y of a metric space \u03b1, the distance between x and y is equal to the Hausdorff distance between the set x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem NonemptyCompacts.dist_eq {x y : NonemptyCompacts \u03b1} :\n    dist x y = hausdorffDist (x : Set \u03b1) y :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', if the set 's' is finite and the image of 's' under 'f' is also finite, then the conversion of the image of 's' under 'f' to a finite set is equal to the image of the conversion of 's' to a finite set under 'f'. This is under the condition that '\u03b2' has decidable equality.\nTranslate the statement in natural language to Lean:", "output": "theorem toFinset_image [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (hs : s.Finite) (h : (f '' s).Finite) :\n    h.toFinset = hs.toFinset.image f :="}
{"input": "Statement in natural language:\nIf a function f has a derivative at a point x, and a constant c is greater than 0, then the derivative of the function that raises c to the power of f(x) at the point x is equal to the product of c raised to the power of f(x), the natural logarithm of c, and the derivative of f at x.\nTranslate the statement in natural language to Lean:", "output": "theorem HasFDerivAt.const_rpow (hf : HasFDerivAt f f' x) (hc : 0 < c) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Real.log c) \u2022 f') x :="}
{"input": "Statement in natural language:\nIf a point x is a member of a set s, then the infimum (greatest lower bound) of the extended distance between x and s is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem infEdist_zero_of_mem (h : x \u2208 s) : infEdist x s = 0 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type \u03b1, the infimum (greatest lower bound) of the application of 'a' to the functions 'f' and 'g' is equal to the infimum of the results of applying 'a' to 'f' and 'g' separately.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_apply (a : \u03b1) : (f \u2293 g) a = f a \u2293 g a :="}
{"input": "Statement in natural language:\nThe seminorm of the negation of a function 'f' is equal to the seminorm of the function 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem snorm'_neg {f : \u03b1 \u2192 F} : snorm' (-f) q \u03bc = snorm' f q \u03bc :="}
{"input": "Statement in natural language:\nThe frontier (the boundary between the interior and the closure) of the set of complex numbers 'z' such that the real part of 'z' is greater than or equal to a real number 'a', is equal to the set of complex numbers 'z' where the real part of 'z' is exactly equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem frontier_setOf_le_re (a : \u211d) : frontier { z : \u2102 | a \u2264 z.re } = { z | z.re = a } :="}
{"input": "Statement in natural language:\nThe closed interval from 'a' to 'b' is equal to the range from 'a' to 'b + 1 - a', where the list does not contain any duplicate elements.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_eq_range' : Icc a b = \u27e8List.range' a (b + 1 - a), List.nodup_range' _ _\u27e9 :="}
{"input": "Statement in natural language:\nIn a division ring R, for any elements a, b, c, and d of R, if the inverse of b is equal to c and the product of a and c is equal to d, then the result of dividing a by b is equal to d.\nTranslate the statement in natural language to Lean:", "output": "theorem div_pf {R} [DivisionRing R] {a b c d : R}\n    (_ : b\u207b\u00b9 = c) (_ : a * c = d) : a / b = d :="}
{"input": "Statement in natural language:\nFor any integer n and any element a of a normed group, the non-negative norm of a raised to the power of n is less than or equal to the product of the non-negative norm of n and the non-negative norm of a.\nTranslate the statement in natural language to Lean:", "output": "theorem nnnorm_zpow_le_mul_norm (n : \u2124) (a : \u03b1) : \u2016a ^ n\u2016\u208a \u2264 \u2016n\u2016\u208a * \u2016a\u2016\u208a :="}
{"input": "Statement in natural language:\nThe infimum (greatest lower bound) of any element 'a' and the top element is 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_top_eq : a \u2293 \u22a4 = a :="}
{"input": "Statement in natural language:\nIf J is an element of \u03c0, then J is a subset of the union of \u03c0.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_iUnion (h : J \u2208 \u03c0) : \u2191J \u2286 \u03c0.iUnion :="}
{"input": "Statement in natural language:\nMapping an equivalence in the ring of multivariate polynomials with the reflection operation on the ring R is equivalent to the reflection operation on the ring of multivariate polynomials.\nTranslate the statement in natural language to Lean:", "output": "theorem mapEquiv_refl : mapEquiv \u03c3 (RingEquiv.refl R) = RingEquiv.refl _ :="}
{"input": "Statement in natural language:\nIf the product of two sets 's' and 't' is bounded and the set 's' is nonempty, then the set 't' is also bounded.\nTranslate the statement in natural language to Lean:", "output": "theorem IsBounded.snd_of_prod (h : IsBounded (s \u00d7\u02e2 t)) (hs : s.Nonempty) : IsBounded t :="}
{"input": "Statement in natural language:\nIf for every element 'b', there is a Galois connection between 'l\u2081 b' and the swapped version of 'u b', and for every element 'a', there is a Galois connection between 'l\u2082 a' and 'u a', then if 's' is nonempty and bounded below, and 't' is also nonempty and bounded below, the infimum of the image of the function 'u' over the sets 's' and 't' is equal to the value of 'u' at the infimum of 's' and the infimum of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem csInf_image2_eq_csInf_csInf (h\u2081 : \u2200 b, GaloisConnection (l\u2081 b) (swap u b))\n    (h\u2082 : \u2200 a, GaloisConnection (l\u2082 a) (u a)) :\n    s.Nonempty \u2192 BddBelow s \u2192 t.Nonempty \u2192 BddBelow t \u2192 sInf (image2 u s t) = u (sInf s) (sInf t) :="}
{"input": "Statement in natural language:\nFor a given element 'x' of type \u03b1, the greatest fixed point of the infimum of the constant function at 'x' and a function 'f' is less than or equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem gfp_const_inf_le (x : \u03b1) : gfp (const \u03b1 x \u2293 f) \u2264 x :="}
{"input": "Statement in natural language:\nIf m is less than or equal to n, then the product of the function f(i) for all i in the interval from m to n+1, divided by f(n), is equal to the product of the function f(i) for all i in the interval from m to n.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_Ico_succ_div_top (hmn : m \u2264 n) :\n    (\u220f i in Ico m (n + 1), f i) / f n = \u220f i in Ico m n, f i :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of type \u03b1, a function 'f' from \u03b1 to M, and elements 'hf' and 'a', applying the function 'onFinset' to 's', 'f', 'hf', and 'a' is equal to applying the function 'f' to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem onFinset_apply {s : Finset \u03b1} {f : \u03b1 \u2192 M} {hf a} : (onFinset s f hf : \u03b1 \u2192\u2080 M) a = f a :="}
{"input": "Statement in natural language:\nFor a polynomial 'p' with coefficients in a ring 'R', a polynomial 'q' in the PolynomialModule with coefficients in 'R' and values in a module 'M', and an element 'r' of 'R', the evaluation of the composition of 'p' and 'q' at 'r' is equal to the evaluation of 'q' at the evaluation of 'p' at 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_eval (p : R[X]) (q : PolynomialModule R M) (r : R) :\n    eval r (comp p q) = eval (p.eval r) q :="}
{"input": "Statement in natural language:\nFor a given type S, which is a semiring and nontrivial, and a given ring homomorphism f from R to S, if a polynomial p is monic and the map of p under f equals 1, then the polynomial p must be equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_one_of_map_eq_one {S : Type _} [Semiring S] [Nontrivial S] (f : R \u2192+* S) (hp : p.Monic)\n    (map_eq : p.map f = 1) : p = 1 :="}
{"input": "Statement in natural language:\nThe composition of the difference of two morphisms (f and f') and another morphism g is equal to the difference of the compositions of f and g and f' and g.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_comp : (f - f') \u226b g = f \u226b g - f' \u226b g :="}
{"input": "Statement in natural language:\nThe inverse of the right multiplication E-transform of 'e' and 'x' is equal to the swap of the swap of the left multiplication E-transform of 'e' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem mulEtransformRight_inv : mulEtransformRight e\u207b\u00b9 x = (mulEtransformLeft e x.swap).swap :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any stream 's', taking the first 'n+1' elements from the stream that starts with 'a' and is followed by 's', is equivalent to having 'a' followed by the first 'n' elements of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem take_succ_cons (n : Nat) (s : Stream' \u03b1) : take (n+1) (a::s) = a :: take n s :="}
{"input": "Statement in natural language:\nThe division of set 's' by the singleton set containing element 'a' is equal to the image of set 's' under the operation of division by 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem div_singleton (a : \u03b1) : s / {a} = s.image (\u00b7 / a) :="}
{"input": "Statement in natural language:\nThe Lie span (in the context of Lie algebras) of the union of a set of subsets (indexed by \u03b9) is equal to the supremum of the Lie spans of the individual subsets.\nTranslate the statement in natural language to Lean:", "output": "theorem span_iUnion {\u03b9} (s : \u03b9 \u2192 Set L) : lieSpan R L (\u22c3 i, s i) = \u2a06 i, lieSpan R L (s i) :="}
{"input": "Statement in natural language:\nIn a complete space E, for a function v mapping real numbers to E, given real numbers tMin, t\u2080, tMax, an element x\u2080 of E, and real numbers C, R, and a non-negative real number L, if the function v satisfies the Picard-Lindelof condition with these parameters, then there exists a function f mapping real numbers to E such that f at t\u2080 equals x\u2080 and for all t in the closed interval from tMin to tMax, the derivative of f at t within this interval equals v of t applied to f of t.\nTranslate the statement in natural language to Lean:", "output": "theorem IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq [CompleteSpace E] {v : \u211d \u2192 E \u2192 E}\n    {tMin t\u2080 tMax : \u211d} (x\u2080 : E) {C R : \u211d} {L : \u211d\u22650}\n    (hpl : IsPicardLindelof v tMin t\u2080 tMax x\u2080 L R C) :\n    \u2203 f : \u211d \u2192 E, f t\u2080 = x\u2080 \u2227\n      \u2200 t \u2208 Icc tMin tMax, HasDerivWithinAt f (v t (f t)) (Icc tMin tMax) t :="}
{"input": "Statement in natural language:\nFor any given condition 'h' which is either 'b' or 'for all x, p x', for any 'x', the condition 'b or p x' holds true.\nTranslate the statement in natural language to Lean:", "output": "theorem forall_or_of_or_forall (h : b \u2228 \u2200 x, p x) (x) : b \u2228 p x :="}
{"input": "Statement in natural language:\nIn the context of an ordered ring, if b is less than or equal to c and a is non-negative (greater than or equal to 0), then the product of b and a is less than or equal to the product of c and a.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_le_mul_of_nonneg_right [MulPosMono \u03b1] (h : b \u2264 c) (a0 : 0 \u2264 a) : b * a \u2264 c * a :="}
{"input": "Statement in natural language:\nThe composition of the function \"ZMod.lift n f\" and the function that coverts integers to another type is equal to the function \"f\".\nTranslate the statement in natural language to Lean:", "output": "theorem lift_comp_coe : ZMod.lift n f \u2218 ((\u2191) : \u2124 \u2192 _) = f :="}
{"input": "Statement in natural language:\nIf 'f' is a monoid homomorphism from a multiplicative monoid '\u03b1' to another multiplicative monoid '\u03b2', then 'f' is also an additive monoid homomorphism from the additive monoid corresponding to '\u03b1' to the additive monoid corresponding to '\u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem Additive.isAddMonoidHom [MulOneClass \u03b1] [MulOneClass \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : IsMonoidHom f) : @IsAddMonoidHom (Additive \u03b1) (Additive \u03b2) _ _ f :="}
{"input": "Statement in natural language:\nAn element 'x' is in the span of a set containing 'y' multiplied by a set 'P' if and only if there exists an element 'z' in 'P' such that 'y' multiplied by 'z' equals 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_span_singleton_mul {x y : A} : x \u2208 span R {y} * P \u2194 \u2203 z \u2208 P, y * z = x :="}
{"input": "Statement in natural language:\nA function f has a Taylor series up to order n on the entire domain if and only if the function f has a Taylor series up to order n.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFTaylorSeriesUpToOn_univ_iff :\n    HasFTaylorSeriesUpToOn n f p univ \u2194 HasFTaylorSeriesUpTo n f p :="}
{"input": "Statement in natural language:\nThe vector from any point 'p' to the midpoint of points 'p\u2081' and 'p\u2082' is equal to the sum of half the vector from 'p' to 'p\u2081' and half the vector from 'p' to 'p\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem midpoint_vsub (p\u2081 p\u2082 p : P) :\n    midpoint R p\u2081 p\u2082 -\u1d65 p = (\u215f 2 : R) \u2022 (p\u2081 -\u1d65 p) + (\u215f 2 : R) \u2022 (p\u2082 -\u1d65 p) :="}
{"input": "Statement in natural language:\nThe division of p by q is equal to p minus 1.\nTranslate the statement in natural language to Lean:", "output": "theorem div_conj_eq_sub_one : p / q = p - 1 :="}
{"input": "Statement in natural language:\nThe space P, under the structure of an Additive Torsor, is a connected space.\nTranslate the statement in natural language to Lean:", "output": "theorem AddTorsor.connectedSpace : ConnectedSpace P :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, and any two sets f (which is a set of functions from \u03b1 to \u03b2) and s (which is a set of \u03b1), if both f and s are finite, then the set resulting from applying each function in f to each element in s (denoted as f <*> s) is also finite.\nTranslate the statement in natural language to Lean:", "output": "theorem Finite.seq' {\u03b1 \u03b2 : Type u} {f : Set (\u03b1 \u2192 \u03b2)} {s : Set \u03b1} (hf : f.Finite) (hs : s.Finite) :\n    (f <*> s).Finite :="}
{"input": "Statement in natural language:\nThe inverse of the dual of the identity function under the infimum-top homomorphism is equal to the identity function under the infimum-top homomorphism in the context of a given type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_dual_id : InfTopHom.dual.symm (SupBotHom.id _) = InfTopHom.id \u03b1 :="}
{"input": "Statement in natural language:\nFor a given set T of elements in a field extension E, the field obtained by first adjoining a set S to a field F and then adjoining T to the result, when restricted to scalars from F, is equal to the field obtained by first adjoining T to F and then adjoining S to the result, when also restricted to scalars from F.\nTranslate the statement in natural language to Lean:", "output": "theorem adjoin_adjoin_comm (T : Set E) :\n    (adjoin (adjoin F S) T).restrictScalars F = (adjoin (adjoin F T) S).restrictScalars F :="}
{"input": "Statement in natural language:\nFor any function 'f' that maps any ordinal number 'a' less than zero to another ordinal number, the result of the function 'blsub' with zero and 'f' as arguments is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem blsub_zero (f : \u2200 a < (0 : Ordinal), Ordinal) : blsub 0 f = 0 :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to 'E', if 'f' belongs to the space of 'p'-integrable functions with respect to measure '\u03bc', then the 'p'-seminorm of 'f' with respect to measure '\u03bc' is less than infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem Mem\u2112p.snorm_lt_top {f : \u03b1 \u2192 E} (hfp : Mem\u2112p f p \u03bc) : snorm f p \u03bc < \u221e :="}
{"input": "Statement in natural language:\nIf we have a cocompact map 'f' from '\u03b1' to '\u03b2', and another function 'f'' from '\u03b1' to '\u03b2' that is equal to 'f', then copying 'f' to 'f'' results in 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem copy_eq (f : CocompactMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f :="}
{"input": "Statement in natural language:\nFor two sets T and T' of type \u03b1 mapped to E and then linearly mapped to F, with real numbers C and C' such that T is dominated and finitely additive with respect to measure \u03bc and C, and T' is dominated and finitely additive with respect to measure \u03bc and C'. If for all subsets s, s is a measurable set and the measure of s is less than infinity implies that T of s equals T' of s, then for any function f from \u03b1 to E with respect to measure \u03bc, the setToL1 of T and f equals the setToL1 of T' and f.\nTranslate the statement in natural language to Lean:", "output": "theorem setToL1_congr_left' (T T' : Set \u03b1 \u2192 E \u2192L[\u211d] F) {C C' : \u211d}\n    (hT : DominatedFinMeasAdditive \u03bc T C) (hT' : DominatedFinMeasAdditive \u03bc T' C')\n    (h : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 T s = T' s) (f : \u03b1 \u2192\u2081[\u03bc] E) :\n    setToL1 hT f = setToL1 hT' f :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2' that is uniformly continuous, and another function 'g' from the separation quotient of '\u03b1' to the separation quotient of '\u03b2' such that the composition of the quotient map and 'f' equals the composition of 'g' and the quotient map, then the map of 'f' equals 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_unique {f : \u03b1 \u2192 \u03b2} (hf : UniformContinuous f)\n    {g : SeparationQuotient \u03b1 \u2192 SeparationQuotient \u03b2}\n    (comm : Quotient.mk _ \u2218 f = g \u2218 Quotient.mk _) : map f = g :="}
{"input": "Statement in natural language:\nFor a non-zero scalar 'a', the scalar multiplication of the difference of two sets 's' and 't' is equal to the difference of the scalar multiplication of set 's' and the scalar multiplication of set 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_set_sdiff\u2080 (ha : a \u2260 0) : a \u2022 (s \\ t) = a \u2022 s \\ a \u2022 t :="}
{"input": "Statement in natural language:\nFor any natural number 'b' that is less than or equal to 1 and any real number 'r', the common logarithm of 'r' with base 'b' is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem clog_of_left_le_one {b : \u2115} (hb : b \u2264 1) (r : R) : clog b r = 0 :="}
{"input": "Statement in natural language:\nFor any additive monoid 'A', and any endomorphism 'f' of 'A', and any natural number 'n', the nth power of 'f' under function composition is equal to the nth iterate of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem AddMonoid.End.coe_pow {A} [AddMonoid A] (f : AddMonoid.End A) (n : \u2115) : \u21d1(f ^ n) = f^[n] :="}
{"input": "Statement in natural language:\nThere exists a linear equivalence between two vector spaces V and V\u2081 if and only if the rank of vector space V over field K is equal to the rank of vector space V\u2081 over field K.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearEquiv.nonempty_equiv_iff_rank_eq :\n    Nonempty (V \u2243\u2097[K] V\u2081) \u2194 Module.rank K V = Module.rank K V\u2081 :="}
{"input": "Statement in natural language:\nIf I and J are fractional ideals in a field K over a ring R\u2081\u2070, and the product of I and J equals 1, then I cannot be zero.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_zero_of_mul_eq_one (I J : FractionalIdeal R\u2081\u2070 K) (h : I * J = 1) : I \u2260 0 :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to 'E' and a filter 'l' on '\u03b1', 'f' is Big O of itself with a constant factor of 1.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigOWith_refl (f : \u03b1 \u2192 E) (l : Filter \u03b1) : IsBigOWith 1 l f f :="}
{"input": "Statement in natural language:\nIf there is a left inverse function 'f\u2081' for function 'f' on set 's', then function 'f' is injective on set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem LeftInvOn.injOn (h : LeftInvOn f\u2081' f s) : InjOn f s :="}
{"input": "Statement in natural language:\nThe cardinality of the set of all propositions is 2.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_Prop : (#Prop) = 2 :="}
{"input": "Statement in natural language:\nThe range of a function 'f' from '\u03b1' to '\u03b2' is equal to a set 's' if and only if for every element 'a', 'f(a)' is an element of 's' and for every element 'b' in 's', there exists an element 'a' such that 'f(a)' is equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem range_eq_iff (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) :\n    range f = s \u2194 (\u2200 a, f a \u2208 s) \u2227 \u2200 b \u2208 s, \u2203 a, f a = b :="}
{"input": "Statement in natural language:\nFor a given square matrix A, if all elements in a row i are zero (for any i), then the determinant of matrix A is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : \u2200 j, A i j = 0) : det A = 0 :="}
{"input": "Statement in natural language:\nFor any non-zero elements 'a', 'b', and 'c' of a ring 'R', if no prime factor 'd' divides both 'a' and 'b', then if 'a' divides the product of 'b' and 'c', 'a' must also divide 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_of_dvd_mul_right_of_no_prime_factors {a b c : R} (ha : a \u2260 0)\n    (no_factors : \u2200 {d}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) : a \u2223 b * c \u2192 a \u2223 c :="}
{"input": "Statement in natural language:\nIf there is an embedding function 'f' from a simple graph 'G' to another simple graph 'G'', and if 'G'' is 'n'-colorable, then 'G' is also 'n'-colorable.\nTranslate the statement in natural language to Lean:", "output": "theorem Colorable.of_embedding {V' : Type _} {G' : SimpleGraph V'} (f : G \u21aag G') {n : \u2115}\n    (h : G'.Colorable n) : G.Colorable n :="}
{"input": "Statement in natural language:\nThe sign of the angle \u03c0 (pi) is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem sign_coe_pi : (\u03c0 : Angle).sign = 0 :="}
{"input": "Statement in natural language:\nFor a given Young Diagram '\u03bc' and a semistandard Young tableau 'T' of '\u03bc', if we have two natural numbers 'i1' and 'i2' such that 'i1' is less than 'i2', and a pair '(i2, j)' that belongs to '\u03bc', then the value of 'T' at 'i1, j' is less than the value of 'T' at 'i2, j'.\nTranslate the statement in natural language to Lean:", "output": "theorem col_strict {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i1 i2 j : \u2115} (hi : i1 < i2)\n    (hcell : (i2, j) \u2208 \u03bc) : T i1 j < T i2 j :="}
{"input": "Statement in natural language:\nFor any set S of real numbers, if every element x in S is less than or equal to zero, then the greatest lower bound (infimum) of S is also less than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sInf_nonpos (S : Set \u211d) (hS : \u2200 x \u2208 S, x \u2264 (0 : \u211d)) : sInf S \u2264 0 :="}
{"input": "Statement in natural language:\nFor a given filter 'f' and a set 's' of type '\u03b1', the infimum (greatest lower bound) of 'f' and the principal filter generated by 's' is the bottom element if and only if the complement of 's' is in 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_principal_eq_bot {f : Filter \u03b1} {s : Set \u03b1} : f \u2293 \ud835\udcdf s = \u22a5 \u2194 s\u1d9c \u2208 f :="}
{"input": "Statement in natural language:\nFor any given vertex 'v' in a graph 'G', the degree of 'v' (i.e., the number of edges connected to 'v') is less than the total number of vertices in the graph 'G'. This is assuming that whether two vertices in 'G' are adjacent is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_lt_card_verts [DecidableRel G.Adj] (v : V) : G.degree v < Fintype.card V :="}
{"input": "Statement in natural language:\nIf 'b' is not the minimum, then the interval of all numbers greater than 'a' and less than or equal to the predecessor of 'b' is equal to the interval of all numbers strictly between 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioc_pred_right_of_not_isMin (ha : \u00acIsMin b) : Ioc a (pred b) = Ioo a b :="}
{"input": "Statement in natural language:\nIf x is not equal to y, then the natural degree of the basis divisor of x and y is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem natDegree_basisDivisor_of_ne (hxy : x \u2260 y) : (basisDivisor x y).natDegree = 1 :="}
{"input": "Statement in natural language:\nFor a given element 'a' from set M and a pair 'x' from the Cartesian product of sets \u03b1 and \u03b2, the scalar multiplication of 'a' and 'x' is equal to the pair formed by the scalar multiplication of 'a' and each element of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_def (a : M) (x : \u03b1 \u00d7 \u03b2) : a \u2022 x = (a \u2022 x.1, a \u2022 x.2) :="}
{"input": "Statement in natural language:\nFor any elements x, y, and z of a ring R, if x and y are coprime, then the sum of x and the product of y and z is also coprime with y.\nTranslate the statement in natural language to Lean:", "output": "theorem add_mul_left_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (x + y * z) y :="}
{"input": "Statement in natural language:\nThe identity matrix (denoted by 1) is a diagonal matrix. This is true for any size of the matrix (n by n) and any type of elements (\u03b1) in the matrix, given that zero and one are defined for the type of elements, and equality can be decided for the size of the matrix.\nTranslate the statement in natural language to Lean:", "output": "theorem isDiag_one [DecidableEq n] [Zero \u03b1] [One \u03b1] : (1 : Matrix n n \u03b1).IsDiag :="}
{"input": "Statement in natural language:\nIf a function f is integrable at a filter l with respect to a measure \u03bc, then for all eventually occurring small sets s in l, the function f is integrable on s with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem IntegrableAtFilter.eventually (h : IntegrableAtFilter f l \u03bc) :\n    \u2200\u1da0 s in l.smallSets, IntegrableOn f s \u03bc :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b9' to the filter of '\u03b1', given that '\u03b9' is nonempty and 'f' is directed by the greater than or equal to relation, the greatest lower bound of 'f' is not the bottom element if and only if for all 'i', 'f(i)' is not the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_neBot_iff_of_directed' {f : \u03b9 \u2192 Filter \u03b1} [Nonempty \u03b9] (hd : Directed (\u00b7 \u2265 \u00b7) f) :\n    NeBot (iInf f) \u2194 \u2200 i, NeBot (f i) :="}
{"input": "Statement in natural language:\nFor a type G that is a group and a topological space, if the following conditions are met:\n\n1. The function that multiplies two elements of G tends to 1 as both elements tend to 1.\n2. The function that takes the inverse of an element of G tends to 1 as the element tends to 1.\n3. For every element in G, the neighborhood of that element is the image of the neighborhood of 1 under the function that multiplies the element by 1.\n4. For every element in G, the neighborhood of that element is the image of the neighborhood of 1 under the function that multiplies 1 by the element.\n\nThen G is a topological group.\nTranslate the statement in natural language to Lean:", "output": "theorem TopologicalGroup.of_nhds_one' {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : G \u2192 G \u2192 G)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n    (hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n    (hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1))\n    (hright : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)) : TopologicalGroup G :="}
{"input": "Statement in natural language:\nIf 'f' is a bounded linear map over a field '\ud835\udd5c', then the scalar multiplication of 'f' by a scalar 'c' from the same field '\ud835\udd5c' is also a bounded linear map over '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul (c : \ud835\udd5c) (hf : IsBoundedLinearMap \ud835\udd5c f) : IsBoundedLinearMap \ud835\udd5c (c \u2022 f) :="}
{"input": "Statement in natural language:\nThe function of casting from rational numbers to a type K is monotone.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_mono : Monotone ((\u2191) : \u211a \u2192 K) :="}
{"input": "Statement in natural language:\nFor any projective resolution P of an object Z in a category C and any natural number n, the composition of the differential maps d from (n + 2) to (n + 1) and from (n + 1) to n in the complex of P is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem complex_d_succ_comp {Z : C} (P : ProjectiveResolution Z) (n : \u2115) :\n    P.complex.d (n + 2) (n + 1) \u226b P.complex.d (n + 1) n = 0 :="}
{"input": "Statement in natural language:\nIf the total variation of a signed measure 's' over a set 'i' is zero, then the value of the signed measure 's' over the set 'i' is also zero.\nTranslate the statement in natural language to Lean:", "output": "theorem null_of_totalVariation_zero (s : SignedMeasure \u03b1) {i : Set \u03b1}\n    (hs : s.totalVariation i = 0) : s i = 0 :="}
{"input": "Statement in natural language:\nFor a function \u03c6 from \u03b1 to a sort v, given two elements a and a' of \u03b1, and two proofs p\u2081 of \u03c6 a and p\u2082 of \u03c6 a', if a equals a' (denoted by e) and the equality is recursively defined (denoted by h\u2082) such that p\u2081 equals p\u2082 when a equals a', then p\u2081 is definitionally equal to p\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem heq_of_eq_rec_left {\u03c6 : \u03b1 \u2192 Sort v} {a a' : \u03b1} {p\u2081 : \u03c6 a} {p\u2082 : \u03c6 a'} :\n    (e : a = a') \u2192 (h\u2082 : Eq.rec (motive := fun a _ \u21a6 \u03c6 a) p\u2081 e = p\u2082) \u2192 HEq p\u2081 p\u2082"}
{"input": "Statement in natural language:\nFor any object 'W' in category 'C', and any two morphisms 'i' and 'j' from the multicoequalizer of 'I' to 'W', if for all objects 'b', the composition of the projection from the multicoequalizer of 'I' to 'b' and 'i' is equal to the composition of the projection from the multicoequalizer of 'I' to 'b' and 'j', then 'i' is equal to 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem hom_ext {W : C} (i j : multicoequalizer I \u27f6 W)\n    (h : \u2200 b, Multicoequalizer.\u03c0 I b \u226b i = Multicoequalizer.\u03c0 I b \u226b j) : i = j :="}
{"input": "Statement in natural language:\nFor a given commutative monoid N, a function f from \u03b1 to \u03b2, a function s from \u03b1 to M where M is a finite subset of \u03b1, and a function h from \u03b2 to M to N, if the function f is injective, then the product of the mapDomain of s and f, and h is equal to the product of s and the function that takes a and b and returns h of f of a and b.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_mapDomain_index_inj [CommMonoid N] {f : \u03b1 \u2192 \u03b2} {s : \u03b1 \u2192\u2080 M} {h : \u03b2 \u2192 M \u2192 N}\n    (hf : Function.Injective f) : (s.mapDomain f).prod h = s.prod fun a b => h (f a) b :="}
{"input": "Statement in natural language:\nFor any type '\u03b1' and a property 'p' that applies to '\u03b1', the cardinality of the subtype for which 'p' holds is less than or equal to the cardinality of '\u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_subtype_le {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) : (#Subtype p) \u2264 (#\u03b1) :="}
{"input": "Statement in natural language:\nFor any object X in category C, the morphism component of the isomorphism 'zeroProdIso X' is equal to the second projection of the product.\nTranslate the statement in natural language to Lean:", "output": "theorem zeroProdIso_hom (X : C) : (zeroProdIso X).hom = prod.snd :="}
{"input": "Statement in natural language:\nIf for all eventually occurring elements 'x' in a filter 'l', the function 'f' applied to 'x' is less than or equal to zero, and if the function 'g' tends to negative infinity as 'x' tends to 'l', then the function that adds the results of 'f' and 'g' also tends to negative infinity as 'x' tends to 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_atBot_add_nonpos_left' (hf : \u2200\u1da0 x in l, f x \u2264 0) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot :="}
{"input": "Statement in natural language:\nFor a given CU structure 'c' on a topological space 'X', a natural number 'n', and a point 'x' in 'X' that does not belong to the set 'U' of 'c', the 'n'-th approximation of 'x' in 'c' equals 1.\nTranslate the statement in natural language to Lean:", "output": "theorem approx_of_nmem_U (c : CU X) (n : \u2115) {x : X} (hx : x \u2209 c.U) : c.approx n x = 1 :="}
{"input": "Statement in natural language:\nA function 'f' that takes two inputs of types '\u03b1' and '\u03b2' and returns an output of type '\u03c3' is primitive recursive if and only if the function that takes the same inputs and returns the output of 'f' wrapped in 'some' is also primitive recursive.\nTranslate the statement in natural language to Lean:", "output": "theorem option_some_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} : (Primrec\u2082 fun a b => some (f a b)) \u2194 Primrec\u2082 f :="}
{"input": "Statement in natural language:\nFor an equivalence 'e' between two types '\u03b1' and '\u03b2', '\u03b1' is infinite if and only if '\u03b2' is infinite.\nTranslate the statement in natural language to Lean:", "output": "theorem Equiv.infinite_iff (e : \u03b1 \u2243 \u03b2) : Infinite \u03b1 \u2194 Infinite \u03b2 :="}
{"input": "Statement in natural language:\nIf x is greater than or equal to 0, y is greater than 0, and the natural logarithm of x is less than z times the natural logarithm of y, then x is less than y raised to the power of z.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_rpow_of_log_lt (hx : 0 \u2264 x) (hy : 0 < y) (h : Real.log x < z * Real.log y) :\n    x < y ^ z :="}
{"input": "Statement in natural language:\nThe infimum (greatest lower bound) of 'a' and the infimum of 'a' and 'b' is equal to the infimum of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_left_idem : a \u2293 (a \u2293 b) = a \u2293 b :="}
{"input": "Statement in natural language:\nThere exists a subset 'b' of 't', such that the span of 'b' over the field 'K' is equal to the span of 't' over 'K', and 'b' is linearly independent over 'K'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_linearIndependent :\n    \u2203 (b : _)(_ : b \u2286 t), span K b = span K t \u2227 LinearIndependent K ((\u2191) : b \u2192 V) :="}
{"input": "Statement in natural language:\nGiven a set 's' of elements of type 'E' and a function 'v' that is continuously differentiable on 's', and given that 's' is in the neighborhood of 'x\u2080', there exists a real number '\u03b5' greater than zero, and a function 'f' from real numbers to 'E' such that 'f' at 't\u2080' equals 'x\u2080' and for all 't' in the open interval from 't\u2080 - \u03b5' to 't\u2080 + \u03b5', 'f' at 't' is in 's' and 'f' has a derivative at 't' equal to 'v' at 'f' at 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_forall_deriv_at_Ioo_eq_of_contDiffOn_nhds {s : Set E} (hv : ContDiffOn \u211d 1 v s)\n    (hs : s \u2208 \ud835\udcdd x\u2080) :\n    \u2203 \u03b5 > (0 : \u211d),\n      \u2203 f : \u211d \u2192 E, f t\u2080 = x\u2080 \u2227 \u2200 t \u2208 Ioo (t\u2080 - \u03b5) (t\u2080 + \u03b5), f t \u2208 s \u2227 HasDerivAt f (v (f t)) t :="}
{"input": "Statement in natural language:\nFor a function 'f' from 'J' to 'C' that has a biproduct, and for any object 'Z' in 'C', if two morphisms 'g' and 'h' from 'Z' to the biproduct of 'f' satisfy the condition that for all 'j', the composition of 'g' and the projection of the biproduct of 'f' at 'j' is equal to the composition of 'h' and the same projection, then 'g' is equal to 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem biproduct.hom_ext {f : J \u2192 C} [HasBiproduct f] {Z : C} (g h : Z \u27f6 \u2a01 f)\n    (w : \u2200 j, g \u226b biproduct.\u03c0 f j = h \u226b biproduct.\u03c0 f j) : g = h :="}
{"input": "Statement in natural language:\nA set 's' with elements of type '\u03b1' is countable if and only if the set resulting from inserting an element 'a' of type '\u03b1' into 's' is also countable.\nTranslate the statement in natural language to Lean:", "output": "theorem countable_insert {s : Set \u03b1} {a : \u03b1} : (insert a s).Countable \u2194 s.Countable :="}
{"input": "Statement in natural language:\nFor any vertex 'v' in a graph 'G', if there is a path 'p' from 'v' to itself, then this path 'p' is equivalent to a path with no edges (Path.nil).\nTranslate the statement in natural language to Lean:", "output": "theorem loop_eq {v : V} (p : G.Path v v) : p = Path.nil :="}
{"input": "Statement in natural language:\nFor any two objects A and B in category T, and any two morphisms f and g from A to B, the arrow constructed from f is equal to the arrow constructed from g if and only if f is equal to g.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_inj (A B : T) {f g : A \u27f6 B} : Arrow.mk f = Arrow.mk g \u2194 f = g :="}
{"input": "Statement in natural language:\nIn the context of a Boolean algebra with elements of type \u03b1, for any element 't' and any set 'S' of type \u03b1, 't' is in the complement image of 'S' if and only if the complement of 't' is in 'S'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_compl_image [BooleanAlgebra \u03b1] (t : \u03b1) (S : Set \u03b1) :\n  t \u2208 HasCompl.compl '' S \u2194 t\u1d9c \u2208 S :="}
{"input": "Statement in natural language:\nFor any two sets s and t of elements of type \u03b1, if s is a subset of t, then the image of s under function f is a subset of the image of t under function f.\nTranslate the statement in natural language to Lean:", "output": "theorem image_mono {s t : Set \u03b1} (h : s \u2286 t) : f.image s \u2286 f.image t :="}
{"input": "Statement in natural language:\nThe division of 'a' by the product of 'b' and 'c' is equal to the division of 'a' by 'c' and then dividing the result by 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem div_mul_eq_div_div_swap : a / (b * c) = a / c / b :="}
{"input": "Statement in natural language:\nFor any list 'l' and any composition 'ns', the length of the list obtained by splitting 'l' with respect to the composition 'ns' is equal to the length of 'ns'.\nTranslate the statement in natural language to Lean:", "output": "theorem length_splitWrtCompositionAux (l : List \u03b1) (ns) :\n    length (l.splitWrtCompositionAux ns) = ns.length :="}
{"input": "Statement in natural language:\nThe function f has a dense range if and only if the closure of the range of f equals the universe.\nTranslate the statement in natural language to Lean:", "output": "theorem denseRange_iff_closure_range : DenseRange f \u2194 closure (range f) = univ :="}
{"input": "Statement in natural language:\nFor a given element 'b' of type \u03b2, if 'b' is an element of set 's' and 'f' of 'b' is less than or equal to 'a', then the infimum (greatest lower bound) of the set 's' under the function 'f' is less than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_le_of_le {b : \u03b2} (hb : b \u2208 s) (h : f b \u2264 a) : s.inf f \u2264 a :="}
{"input": "Statement in natural language:\nFor a given element 'x' of type 'X' and a type 'I' in a topological space, if 'f' evenly covers 'x' in 'I', then 'f' also evenly covers 'x' in the preimage of 'x' under 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem to_isEvenlyCovered_preimage {x : X} {I : Type _} [TopologicalSpace I]\n    (h : IsEvenlyCovered f x I) : IsEvenlyCovered f x (f \u207b\u00b9' {x}) :="}
{"input": "Statement in natural language:\nFor any two additive valuations v\u2081 and v\u2082 on a ring R with values in an ordered abelian group \u0393\u2080, if for every element r in R, the valuation of r under v\u2081 is equal to the valuation of r under v\u2082, then v\u2081 is equal to v\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :="}
{"input": "Statement in natural language:\nFor a function 'f' from an optional \u03b2 to \u03b1, the supremum (or least upper bound) over all options 'o' of 'f' is equal to the supremum of 'f' applied to 'none' and the supremum over all 'b' of 'f' applied to 'some b'.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_option (f : Option \u03b2 \u2192 \u03b1) : (\u2a06 o, f o) = f none \u2294 \u2a06 b, f (Option.some b) :="}
{"input": "Statement in natural language:\nFor any semiring R and natural numbers n and k, the coefficient of the k-th term in the polynomial (X + 1) raised to the power of n is equal to the binomial coefficient \"n choose k\" in the semiring R.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_X_add_one_pow (R : Type _) [Semiring R] (n k : \u2115) :\n    ((X + 1) ^ n).coeff k = (n.choose k : R) :="}
{"input": "Statement in natural language:\nFor a natural number 'n' for which property 'P' holds, the smallest natural number satisfying property 'P' is less than or equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem find_le (n : \u2115) (h : P n) : find P \u2264 n :="}
{"input": "Statement in natural language:\nFor any two subalgebras S and T of an algebra A over a ring R, the submodule corresponding to the intersection of S and T is equal to the intersection of the submodules corresponding to S and T.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_toSubmodule (S T : Subalgebra R A) :\n    toSubmodule (S \u2293 T) = toSubmodule S \u2293 toSubmodule T :="}
{"input": "Statement in natural language:\nA constant function with value 'a' is less than or equal to a constant function with value 'b' if and only if 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem const_le_const : const \u03b2 a \u2264 const \u03b2 b \u2194 a \u2264 b :="}
{"input": "Statement in natural language:\nFor a function f mapping from any index to a type \u03b1, the preimage of the product of sets s and t under this function is equal to the set of all functions from the universal set to the function that constructs a finite list with s and t as its elements, where the function finZeroElim is used to handle the case when the list is empty.\nTranslate the statement in natural language to Lean:", "output": "theorem Fin.preimage_apply_01_prod {\u03b1 : Fin 2 \u2192 Type u} (s : Set (\u03b1 0)) (t : Set (\u03b1 1)) :\n    (fun f : \u2200 i, \u03b1 i => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) :="}
{"input": "Statement in natural language:\nFor any two types '\u03b1' and '\u03b2' where '\u03b1' is finite, and any two sets 's' of type '\u03b1' and 't' of type '\u03b2', if the cardinality of '\u03b1' lifted to the maximum of 'v' and 'w' is equal to the cardinality of '\u03b2' lifted to the maximum of 'u' and 'w', and the cardinality of 's' lifted to the maximum of 'v' and 'w' is equal to the cardinality of 't' lifted to the maximum of 'u' and 'w', then the cardinality of the complement of 's' lifted to the maximum of 'v' and 'w' is equal to the cardinality of the complement of 't' lifted to the maximum of 'u' and 'w'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_compl_eq_mk_compl_finite_lift {\u03b1 : Type u} {\u03b2 : Type v} [Finite \u03b1] {s : Set \u03b1}\n    {t : Set \u03b2} (h1 : (lift.{max v w, u} (#\u03b1)) = (lift.{max u w, v} (#\u03b2)))\n    (h2 : lift.{max v w, u} (#s) = lift.{max u w, v} (#t)) :\n    lift.{max v w} (#(s\u1d9c : Set \u03b1)) = lift.{max u w} (#(t\u1d9c : Set \u03b2)) :="}
{"input": "Statement in natural language:\nThe square of the norm of the sum of two vectors x and y is equal to the sum of the squares of the norms of x and y if and only if the angle between x and y is \u03c0/2 (or 90 degrees).\nTranslate the statement in natural language to Lean:", "output": "theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n    \u2016x + y\u2016 * \u2016x + y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 \u2194 angle x y = \u03c0 / 2 :="}
{"input": "Statement in natural language:\nFor a given multiset 's' and any two elements 'a' and 'b', erasing 'a' from 's' and then erasing 'b' from the result is the same as erasing 'b' from 's' and then erasing 'a' from the result. In other words, the order of erasing elements does not affect the final result.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_comm (s : Multiset \u03b1) (a b : \u03b1) : (s.erase a).erase b = (s.erase b).erase a :="}
{"input": "Statement in natural language:\nAn integer m raised to the power of a natural number n is odd if and only if m is odd or n equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem odd_pow {n : \u2115} : Odd (m ^ n) \u2194 Odd m \u2228 n = 0 :="}
{"input": "Statement in natural language:\nThe intersection of sets s and t is nonempty if and only if there exists an element x in set t that is also in set s.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_nonempty_iff_exists_right : (s \u2229 t).Nonempty \u2194 \u2203 x \u2208 t, x \u2208 s :="}
{"input": "Statement in natural language:\nFor any type \u03b2 with a topological space structure, any set s of type \u03b1 that is an analytic set, and any function f from \u03b1 to \u03b2 that is continuous, the image of the set s under the function f is also an analytic set.\nTranslate the statement in natural language to Lean:", "output": "theorem AnalyticSet.image_of_continuous {\u03b2 : Type _} [TopologicalSpace \u03b2] {s : Set \u03b1}\n    (hs : AnalyticSet s) {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) : AnalyticSet (f '' s) :="}
{"input": "Statement in natural language:\nFor any non-negative extended real number 'x' and any natural number 'n', the nth power of 'x' when converted to an extended real number is equal to the nth power of 'x' as an extended real number.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_ennreal_pow (x : \u211d\u22650\u221e) (n : \u2115) : (\u2191(x ^ n) : EReal) = (x : EReal) ^ n :="}
{"input": "Statement in natural language:\nFor any element 'x' in the field 'K', the algebraic mapping of the numerator of 'x' in ring 'A' divided by the algebraic mapping of the denominator of 'x' in ring 'A' is equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk'_num_den' (x : K) : algebraMap A K (num A x) / algebraMap A K (den A x) = x :="}
{"input": "Statement in natural language:\nIf there exists a unique element 'a' in list 'l' that satisfies property 'p', then the chosen element that satisfies property 'p' in list 'l' is indeed in list 'l' and satisfies property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem choose_spec (hp : \u2203! a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l \u2227 p (choose p l hp) :="}
{"input": "Statement in natural language:\nFor any ordered node 'l' and any element 'x', the left rotation of 'l' and 'x' with an empty node results in a new node with 'l' and 'x' and an empty node.\nTranslate the statement in natural language to Lean:", "output": "theorem rotateL_nil (l : Ordnode \u03b1) (x : \u03b1) : rotateL l x nil = node' l x nil :="}
{"input": "Statement in natural language:\nFor any index 'i' and any two functions 'f\u2081' and 'f\u2082', erasing the element at index 'i' from the sum of 'f\u2081' and 'f\u2082' is equal to the sum of the result of erasing the element at index 'i' from 'f\u2081' and 'f\u2082' respectively.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_add (i : \u03b9) (f\u2081 f\u2082 : \u03a0\u2080 i, \u03b2 i) : erase i (f\u2081 + f\u2082) = erase i f\u2081 + erase i f\u2082 :="}
{"input": "Statement in natural language:\nFor any additive commutative monoid G, and any elements r of type k and x of type G, the operation of applying the ring equivalence to the opposite of the single element x with coefficient r in the monoid algebra is equal to the single element x with the opposite of the coefficient r.\nTranslate the statement in natural language to Lean:", "output": "theorem opRingEquiv_single [AddCommMonoid G] (r : k) (x : G) :\n    AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) :="}
{"input": "Statement in natural language:\nThe Lp space representation of the zero function in the simple function space is equal to the zero element in the Lp space of simple functions.\nTranslate the statement in natural language to Lean:", "output": "theorem toLp_zero : toLp (0 : \u03b1 \u2192\u209b E) zero_mem\u2112p = (0 : Lp.simpleFunc E p \u03bc) :="}
{"input": "Statement in natural language:\nFor a T2 topological space B and a star subalgebra S of R and A, if we have two star algebra homomorphisms \u03c6 and \u03c8 from the topological closure of S to B, and both \u03c6 and \u03c8 are continuous, then if the composition of \u03c6 and the inclusion of the topological closure of S is equal to the composition of \u03c8 and the inclusion of the topological closure of S, then \u03c6 is equal to \u03c8.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.StarAlgHom.ext_topologicalClosure [T2Space B] {S : StarSubalgebra R A}\n    {\u03c6 \u03c8 : S.topologicalClosure \u2192\u22c6\u2090[R] B} (h\u03c6 : Continuous \u03c6) (h\u03c8 : Continuous \u03c8)\n    (h :\n      \u03c6.comp (inclusion (le_topologicalClosure S)) = \u03c8.comp (inclusion (le_topologicalClosure S))) :\n    \u03c6 = \u03c8 :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1', applying the function 'ofDual' to the result of 'toDual' applied to 'a' gives back 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofDual_toDual (a : \u03b1) : ofDual (toDual a) = a :="}
{"input": "Statement in natural language:\nFor any two elements x and y in the subsemigroup S', the product of the elements x and y (denoted as \u27e8x, hx\u27e9 * \u27e8y, hy\u27e9) is equal to the element that is the product of x and y in S' (denoted as \u27e8x * y, mul_mem hx hy\u27e9).\nTranslate the statement in natural language to Lean:", "output": "theorem mk_mul_mk (x y : M) (hx : x \u2208 S') (hy : y \u2208 S') :\n    (\u27e8x, hx\u27e9 : S') * \u27e8y, hy\u27e9 = \u27e8x * y, mul_mem hx hy\u27e9 :="}
{"input": "Statement in natural language:\nIf 'f' reaches its maximum at 'a' in the set 's' and 'g' also reaches its maximum at 'a' in the set 's', then the function that is the sum of 'f' and 'g' also reaches its maximum at 'a' in the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsMaxOn.add (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x + g x) s a :="}
{"input": "Statement in natural language:\nFor any natural numbers 'n' and 'x', if 'x' is in the range of 'n', then 'x' is less than or equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_range_le {n x : \u2115} (hx : x \u2208 range n) : x \u2264 n :="}
{"input": "Statement in natural language:\nFor a given relation 'r' and an element 'a' such that 'a' is accessible by 'r', the rank of 'a' is equal to the supremum of the successor of the rank of 'b' for all 'b' such that 'b' is related to 'a' by 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem rank_eq (h : Acc r a) :\n    h.rank = Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ (h.inv b.2).rank :="}
{"input": "Statement in natural language:\nFor any natural number 'p', if the Lucas-Lehmer residue of 'p + 2' is zero, then the '\u03c9' (a certain element in the field X of the polynomial ring over the finite field with 'q(p' + 2)' elements) raised to the power of '2' to the power of 'p + 2' equals one.\nTranslate the statement in natural language to Lean:", "output": "theorem \u03c9_pow_eq_one (p' : \u2115) (h : lucasLehmerResidue (p' + 2) = 0) :\n    (\u03c9 : X (q (p' + 2))) ^ 2 ^ (p' + 2) = 1 :="}
{"input": "Statement in natural language:\nIf measure \u03bc is less than or equal to measure \u03bd, then almost everywhere (ae) with respect to measure \u03bc is less than or equal to almost everywhere (ae) with respect to measure \u03bd.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_mono (h : \u03bc \u2264 \u03bd) : \u03bc.ae \u2264 \u03bd.ae :="}
{"input": "Statement in natural language:\nFor a continuous affine map 'f' from 'P' to 'Q', the continuous linear part of 'f' is equal to the linear part of 'f' when 'f' is considered as an affine map from 'P' to 'Q'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_contLinear_eq_linear (f : P \u2192A[R] Q) :\n    (f.contLinear : V \u2192\u2097[R] W) = (f : P \u2192\u1d43[R] Q).linear :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'a' and 'b', if you pair them and then unpair them, you will get back the original pair '(a, b)'.\nTranslate the statement in natural language to Lean:", "output": "theorem unpair_pair (a b : \u2115) : unpair (pair a b) = (a, b) :="}
{"input": "Statement in natural language:\nIn group theory, for any group G and any element x of G, the order of x divides the cardinality of the group G.\nTranslate the statement in natural language to Lean:", "output": "theorem orderOf_dvd_nat_card {G : Type _} [Group G] {x : G} : orderOf x \u2223 Nat.card G :="}
{"input": "Statement in natural language:\nFor a ring homomorphism 'f' from a ring 'R' to itself, a natural number 'p' that is a prime number, and a characteristic 'p' of the ring 'R', for any natural number 'n', the 'n'-th iteration of 'f' applied to the Frobenius endomorphism of 'R' at 'p' applied to 'x' is equal to the Frobenius endomorphism of 'R' at 'p' applied to the 'n'-th iteration of 'f' applied to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem RingHom.iterate_map_frobenius (f : R \u2192+* R) (p : \u2115) [Fact p.Prime] [CharP R p] (n : \u2115) :\n    (f^[n]) (frobenius R p x) = frobenius R p ((f^[n]) x) :="}
{"input": "Statement in natural language:\nThe set of integers greater than 'a' is a subset of the union of the set of integers greater than or equal to 'a' and less than or equal to 'b', and the set of integers greater than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Ioi_subset_Ioc_union_Ici : Ioi a \u2286 Ioc a b \u222a Ici b :="}
{"input": "Statement in natural language:\n'not (a implies b)' is equivalent to 'a and not b'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_imp : \u00ac(a \u2192 b) \u2194 a \u2227 \u00acb :="}
{"input": "Statement in natural language:\nThe order of the rotation by one unit in the Dihedral Group of order n is n.\nTranslate the statement in natural language to Lean:", "output": "theorem orderOf_r_one : orderOf (r 1 : DihedralGroup n) = n :="}
{"input": "Statement in natural language:\nThe image of the intersection of two sets, t\u2081 and t\u2082, under a function s is a subset of the intersection of the images of the two sets under the same function.\nTranslate the statement in natural language to Lean:", "output": "theorem disjSups_inter_subset_right : s \u25cb (t\u2081 \u2229 t\u2082) \u2286 s \u25cb t\u2081 \u2229 s \u25cb t\u2082 :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the antidiagonal of 'n + 2' is equal to the list that starts with the pair (0, n + 2), followed by the antidiagonal of 'n' where both elements of each pair are incremented by one, and ends with the pair (n + 2, 0).\nTranslate the statement in natural language to Lean:", "output": "theorem antidiagonal_succ_succ' {n : \u2115} :\n    antidiagonal (n + 2) =\n      (0, n + 2) :: (antidiagonal n).map (Prod.map Nat.succ Nat.succ) ++ [(n + 2, 0)] :="}
{"input": "Statement in natural language:\nFor any real number r, the ball centered at zero with radius r in the seminorm space p is balanced over the field \ud835\udd5c.\nTranslate the statement in natural language to Lean:", "output": "theorem balanced_ball_zero (r : \u211d) : Balanced \ud835\udd5c (ball p 0 r) :="}
{"input": "Statement in natural language:\nIf 'c' is a unit, then the function that multiplies 'c' with the output of function 'f' is continuous within a set 's' at a point 'b' if and only if the function 'f' itself is continuous within the set 's' at the point 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousWithinAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousWithinAt (fun x => c \u2022 f x) s b \u2194 ContinuousWithinAt f s b :="}
{"input": "Statement in natural language:\nFor a given filter 'l' on a set '\u03b2' and a function 'f' from a set '\u03b1' to the set of subsets of '\u03b2', the comap (the inverse image function) of 'f' and the small sets of 'l' is equal to the lift' (a function that lifts a function to a filter) of 'l' and the composition of the preimage function of 'f' and the powerset function.\nTranslate the statement in natural language to Lean:", "output": "theorem comap_smallSets (l : Filter \u03b2) (f : \u03b1 \u2192 Set \u03b2) :\n    comap f l.smallSets = l.lift' (preimage f \u2218 powerset) :="}
{"input": "Statement in natural language:\nA set \u03b1 is not finite if and only if it is infinite.\nTranslate the statement in natural language to Lean:", "output": "theorem not_finite_iff_infinite : \u00acFinite \u03b1 \u2194 Infinite \u03b1 :="}
{"input": "Statement in natural language:\nThe preimage of the closed ball in real numbers with center x and radius r under the function that maps integers to real numbers, is equal to the closed ball in integers with center x and radius r.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_closedBall (x : \u2124) (r : \u211d) : (\u2191) \u207b\u00b9' closedBall (x : \u211d) r = closedBall x r :="}
{"input": "Statement in natural language:\nThe polynomial constant function C applied to a equals the polynomial constant function C applied to b if and only if a equals b.\nTranslate the statement in natural language to Lean:", "output": "theorem C_inj : C a = C b \u2194 a = b :="}
{"input": "Statement in natural language:\nThe equality locus of a ring homomorphism function 'f' from ring 'R' to ring 'S' is equal to the top element, or the whole set.\nTranslate the statement in natural language to Lean:", "output": "theorem eqLocus_same (f : R \u2192+* S) : f.eqLocus f = \u22a4 :="}
{"input": "Statement in natural language:\nIn the context of a GCD Monoid structure on a set \u03b1, for any three elements a, b, and c in \u03b1, the greatest common divisor of the product of a and b and the product of a and c is associated with the product of a and the greatest common divisor of b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem gcd_mul_left' [GCDMonoid \u03b1] (a b c : \u03b1) :\n    Associated (gcd (a * b) (a * c)) (a * gcd b c) :="}
{"input": "Statement in natural language:\nFor two linear maps 'f' from M to M\u2082 and 'g' from M\u2082 to M\u2083, the kernel of 'g' is less than or equal to the range of 'f' if and only if the composition of the quotient by the range of 'f' and the subtype of the kernel of 'g' equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_le_range_iff {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} :\n    ker g \u2264 range f \u2194 f.range.mkQ.comp g.ker.subtype = 0 :="}
{"input": "Statement in natural language:\nFor any two linear maps 'f' from M\u2082 to M\u2083 and 'g' from M\u2081 to M\u2082, the matrix representation of the composition of 'f' and 'g' is equal to the product of the matrix representation of 'f' and the matrix representation of 'g'. This is under the conditions that 'l' is a finite type and 'm' is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearMap.toMatrix_comp [Fintype l] [DecidableEq m] (f : M\u2082 \u2192\u2097[R] M\u2083) (g : M\u2081 \u2192\u2097[R] M\u2082) :\n    LinearMap.toMatrix v\u2081 v\u2083 (f.comp g) =\n    LinearMap.toMatrix v\u2082 v\u2083 f \u2b1d LinearMap.toMatrix v\u2081 v\u2082 g :="}
{"input": "Statement in natural language:\nIf a function 'f' is antitone on a set 's' and the image of 's' under 'f' is both bounded below and above, then there exists a function 'g' that is antitone and equals 'f' on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem AntitoneOn.exists_antitone_extension (h : AntitoneOn f s) (hl : BddBelow (f '' s))\n    (hu : BddAbove (f '' s)) : \u2203 g : \u03b1 \u2192 \u03b2, Antitone g \u2227 EqOn f g s :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03c3' to '\u03c4', a function 'd' from '\u03c3' to non-negative integers '\u2115', and a real number 'r', renaming 'f' in the monomial 'd' and 'r' is equal to the monomial of 'd' mapped to the domain 'f' and 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem rename_monomial (f : \u03c3 \u2192 \u03c4) (d : \u03c3 \u2192\u2080 \u2115) (r : R) :\n    rename f (monomial d r) = monomial (d.mapDomain f) r :="}
{"input": "Statement in natural language:\nIf 'b' is a unit, then 'a' divided by 'b' equals one if and only if 'a' equals 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem div_eq_one_iff_eq (h : IsUnit b) : a / b = 1 \u2194 a = b :="}
{"input": "Statement in natural language:\nFor a given finite group G and a subgroup s of G, the cardinality (or size) of the preimage of a set t under the quotient group mapping is equal to the product of the cardinality of the subgroup s and the cardinality of the set t.\nTranslate the statement in natural language to Lean:", "output": "theorem QuotientGroup.card_preimage_mk [Fintype G] (s : Subgroup G) (t : Set (G \u29f8 s)) :\n    Fintype.card (QuotientGroup.mk \u207b\u00b9' t) = Fintype.card s * Fintype.card t :="}
{"input": "Statement in natural language:\nFor any two vertices 'v' and 'w' in a graph 'G', if 'w' is a neighbor of 'v', then the other vertex of any edge incident to 'v' (that is, connected to 'v') is 'w'. This is proven by applying the property that a vertex is a neighbor of another if and only if there is an edge between them.\nTranslate the statement in natural language to Lean:", "output": "theorem incidence_other_neighbor_edge {v w : V} (h : w \u2208 G.neighborSet v) :\n    G.otherVertexOfIncident (G.mem_incidence_iff_neighbor.mpr h) = w :="}
{"input": "Statement in natural language:\nThe closed ball in a metric space, centered at a point 'x' with radius '\u03b5', is a measurable set.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x \u03b5) :="}
{"input": "Statement in natural language:\nA function 's.piecewise f f'' is equal to a function 'g' on a set 't' if and only if the function 'f' is equal to 'g' on the intersection of 't' and 's', and the function 'f'' is equal to 'g' on the intersection of 't' and the complement of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem eqOn_piecewise {f f' g : \u03b1 \u2192 \u03b2} {t} :\n    EqOn (s.piecewise f f') g t \u2194 EqOn f g (t \u2229 s) \u2227 EqOn f' g (t \u2229 s\u1d9c) :="}
{"input": "Statement in natural language:\nFor a seminormed add commutative group \u03b2, where p is not equal to infinity and \u03b2 has an element 1, the nonnegative norm of the inverse of the equivalence of p and the function from \u03b9 to \u03b2 applied to 1 is equal to the nonnegative real number obtained by raising the cardinality of the finite type \u03b9 to the power of the reciprocal of p, multiplied by the nonnegative norm of 1 in \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem nnnorm_equiv_symm_one {\u03b2} [SeminormedAddCommGroup \u03b2] (hp : p \u2260 \u221e) [One \u03b2] :\n    \u2016(PiLp.equiv p fun _ : \u03b9 => \u03b2).symm 1\u2016\u208a =\n      (Fintype.card \u03b9 : \u211d\u22650) ^ (1 / p).toReal * \u2016(1 : \u03b2)\u2016\u208a :="}
{"input": "Statement in natural language:\nThe successor of a natural number 'n' when cast as an ordinal is equal to the successor of 'n' as an ordinal.\nTranslate the statement in natural language to Lean:", "output": "theorem nat_cast_succ (n : \u2115) : \u2191n.succ = succ (n : Ordinal) :="}
{"input": "Statement in natural language:\nThe conjugate of a complex number 'z' is equal to 'z' if and only if there exists a real number 'r' such that 'z' is equal to the complex number representation of 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem conj_eq_iff_real {z : K} : conj z = z \u2194 \u2203 r : \u211d, z = (r : K) :="}
{"input": "Statement in natural language:\nFor any element 'm' of set 'X', the quotient of 'm' by the relation 'FreeAlgebra.Rel R X' is equal to the application of the function '\u03b9 R' to 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem quot_mk_eq_\u03b9 (m : X) : Quot.mk (FreeAlgebra.Rel R X) m = \u03b9 R m :="}
{"input": "Statement in natural language:\nThe operation m\u2082 is commutative.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_comm : IsCommutative _ m\u2082 :="}
{"input": "Statement in natural language:\nThe set of all elements 'x' such that 'x' is greater than or equal to 'a' and less than or equal to 'b' is equal to the closed interval between 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_def (a b : \u03b1) : { x | a \u2264 x \u2227 x \u2264 b } = Icc a b :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from 'N\u2097' to 'P\u2097', another linear map 'g' from 'M' to 'N\u2097', and an element 'x' from 'M', the left-left composition of 'f' and 'g' at 'x' is equal to 'f' applied to 'g' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem llcomp_apply (f : N\u2097 \u2192\u2097[R] P\u2097) (g : M \u2192\u2097[R] N\u2097) (x : M) :\n    llcomp R M N\u2097 P\u2097 f g x = f (g x) :="}
{"input": "Statement in natural language:\n\"a is congruent to b modulo 0 if and only if a is equal to b.\"\nTranslate the statement in natural language to Lean:", "output": "theorem modEq_zero : a \u2261 b [PMOD 0] \u2194 a = b :="}
{"input": "Statement in natural language:\nFor any sort 'P' and any polynomials 'p' and 'q' in the field of rational functions 'K[X]', given a function 'f' that maps any two polynomials to 'P' and a condition 'f0' that 'f' of any polynomial and 0 equals 'f' of 0 and 1, if for any polynomials 'p', 'q', and 'a' such that 'q' and 'a' are not zero, 'f' of 'a' times 'p' and 'a' times 'q' equals 'f' of 'p' and 'q', then the liftOn' of the rational function made by 'p' and 'q' on 'f' with respect to 'H' equals 'f' of 'p' and 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem liftOn'_mk {P : Sort v} (p q : K[X]) (f : \u2200 _p _q : K[X], P) (f0 : \u2200 p, f p 0 = f 0 1)\n    (H : \u2200 {p q a} (_hq : q \u2260 0) (_ha : a \u2260 0), f (a * p) (a * q) = f p q) :\n    (RatFunc.mk p q).liftOn' f @H = f p q :="}
{"input": "Statement in natural language:\nIf an element 'x' belongs to a singleton set that only contains 'y' in a finite set of elements of type '\u03b1', then 'x' is equal to 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_mem_singleton {x y : \u03b1} (h : x \u2208 ({y} : Finset \u03b1)) : x = y :="}
{"input": "Statement in natural language:\nFor any two preordered sets \u03b1 and \u03b2, and an order isomorphism 'e' between them, and a filter 'l' on a set \u03b3, and a function 'u' from \u03b3 to \u03b1, the function 'u' is bounded under the filter 'l' if and only if the composition of 'e' and 'u' is also bounded under the filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.OrderIso.isBoundedUnder_le_comp [Preorder \u03b1] [Preorder \u03b2] (e : \u03b1 \u2243o \u03b2) {l : Filter \u03b3}\n    {u : \u03b3 \u2192 \u03b1} : (IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => e (u x)) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l u :="}
{"input": "Statement in natural language:\nA multiset 's' has no duplicate elements in its powerset if and only if the multiset 's' itself has no duplicate elements.\nTranslate the statement in natural language to Lean:", "output": "theorem nodup_powerset {s : Multiset \u03b1} : Nodup (powerset s) \u2194 Nodup s :="}
{"input": "Statement in natural language:\nThe empty set is convex in the field \ud835\udd5c for any set E.\nTranslate the statement in natural language to Lean:", "output": "theorem convex_empty : Convex \ud835\udd5c (\u2205 : Set E) :="}
{"input": "Statement in natural language:\nFor a non-zero element 'c' in a group with zero, the inverse of the right multiplication by 'c' homeomorphism is the same as right multiplication by the inverse of 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem mulRight\u2080_symm_apply (c : \u03b1) (hc : c \u2260 0) :\n    ((Homeomorph.mulRight\u2080 c hc).symm : \u03b1 \u2192 \u03b1) = (\u00b7 * c\u207b\u00b9) :="}
{"input": "Statement in natural language:\nIf a set 's' is infinite, then it is not bounded above.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Set.Infinite.not_bddAbove {s : Set \u03b1} : s.Infinite \u2192 \u00acBddAbove s :="}
{"input": "Statement in natural language:\nFor a given filter 'l' on a normed space 'E', the function 'f' is Big O of the identity function (i.e., the function that maps each element to itself) with respect to the filter 'l' and the norm of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigOWith_id (l : Filter E) : IsBigOWith \u2016f\u2016 l f fun x => x :="}
{"input": "Statement in natural language:\nFor a trivialization 'e' of a vector bundle with fiber 'F' and projection '\u03c0 E', given that 'e' is linear over a ring 'R', for any element 'b' in the base set of 'e' and any element 'y' in 'F', the linear map at 'b' applied to the inverse linear map at 'b' applied to 'y' equals 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem linearMapAt_symm\u2097 (e : Trivialization F (\u03c0 E)) [e.IsLinear R] {b : B} (hb : b \u2208 e.baseSet)\n    (y : F) : e.linearMapAt R b (e.symm\u2097 R b y) = y :="}
{"input": "Statement in natural language:\nA set 's' of elements of type \u0393\u2080 is open if and only if either the element '0' of type \u0393\u2080 is not in 's', or there exists an element '\u03b3' such that '\u03b3' is not equal to '0' and the set of all elements less than '\u03b3' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isOpen_iff {s : Set \u0393\u2080} : IsOpen s \u2194 (0 : \u0393\u2080) \u2209 s \u2228 \u2203 \u03b3, \u03b3 \u2260 0 \u2227 Iio \u03b3 \u2286 s :="}
{"input": "Statement in natural language:\nFor a linear recurrence E of a certain order, and for any initial condition 'init' of that order, the solution generated by 'init' at any point 'n' within that order is equal to the initial condition at 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem mkSol_eq_init (init : Fin E.order \u2192 \u03b1) : \u2200 n : Fin E.order, E.mkSol init n = init n :="}
{"input": "Statement in natural language:\nFor a function 'm' mapping from \u03b3 to \u03b2 to \u03b4 and a function 'n' mapping from \u03b1 to \u03b3, mapping 'm' over the result of mapping 'n' over 'f' and then applying 'g' is equivalent to mapping a function that applies 'm' to the result of applying 'n' to 'a' and 'b' over 'f' and 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_map_left (m : \u03b3 \u2192 \u03b2 \u2192 \u03b4) (n : \u03b1 \u2192 \u03b3) :\n    map\u2082 m (f.map n) g = map\u2082 (fun a b => m (n a) b) f g :="}
{"input": "Statement in natural language:\nIf a function 'f' maps from a module 'M' to another module 'M\u2082' in a surjective ring homomorphism '\u03c3\u2081\u2082', and if 'f' applied to an element 'x' of 'M' does not belong to the span of the image of a set 's' under 'f' in the ring 'R\u2082', then 'x' does not belong to the span of 's' in the ring 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_mem_span_of_apply_not_mem_span_image [RingHomSurjective \u03c3\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {x : M}\n    {s : Set M} (h : f x \u2209 Submodule.span R\u2082 (f '' s)) : x \u2209 Submodule.span R s :="}
{"input": "Statement in natural language:\nFor a given substructure 'T' of 'N' and a function 'f' from 'M' to 'N', if 'S' is less than or equal to the preimage of 'T' under 'f', then the image of 'S' under 'f' is less than or equal to 'T'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_le_of_le_comap {T : L.Substructure N} {f : M \u2192[L] N} : S \u2264 T.comap f \u2192 S.map f \u2264 T :="}
{"input": "Statement in natural language:\nSubmonoid S is equal to the top element if and only if for every element x in monoid M, x is an element of S.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_top_iff' : S = \u22a4 \u2194 \u2200 x : M, x \u2208 S :="}
{"input": "Statement in natural language:\nFor any additive commutative group M, M is a torsion additive monoid if and only if M is a torsion module over the integers.\nTranslate the statement in natural language to Lean:", "output": "theorem isTorsion_iff_isTorsion_int [AddCommGroup M] :\n    AddMonoid.IsTorsion M \u2194 Module.IsTorsion \u2124 M :="}
{"input": "Statement in natural language:\nFor any index 'i', any element 'a' of a group 'G' at index 'i', and any function 'f' from the lp space 'G' with p=2, the inner product of 'f' and the single element at index 'i' with value 'a' in the lp space is equal to the inner product of the value of 'f' at index 'i' and 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem inner_single_right (i : \u03b9) (a : G i) (f : lp G 2) : \u27eaf, lp.single 2 i a\u27eb = \u27eaf i, a\u27eb :="}
{"input": "Statement in natural language:\nIf function f has a derivative f' at point x with respect to a filter L, and function g has a derivative g' at the same point x with respect to the same filter L, then the function that is the sum of f and g has a derivative that is the sum of f' and g' at point x with respect to filter L.\nTranslate the statement in natural language to Lean:", "output": "theorem HasDerivAtFilter.add (hf : HasDerivAtFilter f f' x L)\n    (hg : HasDerivAtFilter g g' x L) : HasDerivAtFilter (fun y => f y + g y) (f' + g') x L :="}
{"input": "Statement in natural language:\nIf the set \u03b1 is empty, then the cardinality (or the number of elements) of \u03b1 is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem card_eq_zero [IsEmpty \u03b1] : card \u03b1 = 0 :="}
{"input": "Statement in natural language:\nFor any given natural number 'n' and any two bit vectors 'v\u2080' and 'v\u2081' of length 'n', if 'v\u2080' is less than or equal to 'v\u2081', then the conversion of 'v\u2080' to a finite number is also less than or equal to the conversion of 'v\u2081' to a finite number.\nTranslate the statement in natural language to Lean:", "output": "theorem toFin_le_toFin_of_le {n} {v\u2080 v\u2081 : Bitvec n} (h : v\u2080 \u2264 v\u2081) : v\u2080.toFin \u2264 v\u2081.toFin :="}
{"input": "Statement in natural language:\nFor a relation R between \u03b1 and \u03b2, swapping the order of the LiftRel function and the relation R is equivalent to applying the LiftRel function to the swapped relation R.\nTranslate the statement in natural language to Lean:", "output": "theorem LiftRel.swap (R : \u03b1 \u2192 \u03b2 \u2192 Prop) : swap (LiftRel R) = LiftRel (swap R) :="}
{"input": "Statement in natural language:\nFor any two elements 'x' and 'y' of a set '\u03b1', the list obtained by applying the function 'toList' to the permutation formed by the singleton list containing 'x', when evaluated at 'y', is an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem toList_formPerm_singleton (x y : \u03b1) : toList (formPerm [x]) y = [] :="}
{"input": "Statement in natural language:\nUnder the conditions of a second countable topology on either \u03b1 or E, a fact that p is greater than or equal to 1, p is not equal to infinity, and \u03bc is weakly regular, the topological closure of the set of bounded continuous functions from E to p with respect to measure \u03bc is equal to the entire space.\nTranslate the statement in natural language to Lean:", "output": "theorem boundedContinuousFunction_dense [SecondCountableTopologyEither \u03b1 E] [_i : Fact (1 \u2264 p)]\n    (hp : p \u2260 \u221e) [\u03bc.WeaklyRegular] : (boundedContinuousFunction E p \u03bc).topologicalClosure = \u22a4 :="}
{"input": "Statement in natural language:\nA is a Noetherian ring.\nTranslate the statement in natural language to Lean:", "output": "theorem isNoetherianRing : IsNoetherianRing A :="}
{"input": "Statement in natural language:\nGiven three conditions: the first power of 'a' raised to 'b\u2081' equals 'c\u2081', the second power of 'a' raised to 'b\u2082' equals 'c\u2082', and the product of 'c\u2081' and 'c\u2082' equals 'd', then for any real number 'a', 'a' raised to the power of the sum of 'b\u2081' and 'b\u2082' equals 'd'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_add (_ : a ^ b\u2081 = c\u2081) (_ : a ^ b\u2082 = c\u2082) (_ : c\u2081 * c\u2082 = d) :\n  (a : R) ^ (b\u2081 + b\u2082) = d :="}
{"input": "Statement in natural language:\nIf we have three preordered sets \u03b1, \u03b2, and \u03b3, and two functions g : \u03b2 \u2192 \u03b3 and f : \u03b1 \u2192 \u03b2, along with two sets s and t, such that g is strictly decreasing on t, f is strictly decreasing on s, and f maps s to t, then the composition of g and f is strictly increasing on s.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictAntiOn.comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    {t : Set \u03b2} (hg : StrictAntiOn g t) (hf : StrictAntiOn f s) (hs : Set.MapsTo f s t) :\n    StrictMonoOn (g \u2218 f) s :="}
{"input": "Statement in natural language:\nFor a given field 'k' and a ring homomorphism 'f' from 'R' to 'k', a polynomial 'p' is a unit under the map 'f' if and only if 'p' is a unit itself.\nTranslate the statement in natural language to Lean:", "output": "theorem isUnit_map [Field k] (f : R \u2192+* k) : IsUnit (p.map f) \u2194 IsUnit p :="}
{"input": "Statement in natural language:\nThe non-negative distance between the point obtained by applying the line map to points p\u2081 and p\u2082 with a coefficient c, and point p\u2082, is equal to the product of the non-negative norm of 1 minus c and the non-negative distance between p\u2081 and p\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem nndist_lineMap_right (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist (lineMap p\u2081 p\u2082 c) p\u2082 = \u20161 - c\u2016\u208a * nndist p\u2081 p\u2082 :="}
{"input": "Statement in natural language:\nFor any nonempty interval 's' of type \u03b1, applying the function 'toDualProd' to 's' results in a pair consisting of the dual of the first element of 's' and the second element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem toDualProd_apply (s : NonemptyInterval \u03b1) : s.toDualProd = (toDual s.fst, s.snd) :="}
{"input": "Statement in natural language:\nFor a given equivalence 'e' between two types '\u03b9' and '\u03b9'', and given two functions 'f' and 'g' from '\u03b9'' and '\u03b9' to 'M' respectively, if 'f' composed with 'e' equals 'g', then 'g' is linearly independent if and only if 'f' is linearly independent.\nTranslate the statement in natural language to Lean:", "output": "theorem linearIndependent_equiv' (e : \u03b9 \u2243 \u03b9') {f : \u03b9' \u2192 M} {g : \u03b9 \u2192 M} (h : f \u2218 e = g) :\n    LinearIndependent R g \u2194 LinearIndependent R f :="}
{"input": "Statement in natural language:\nFor any element x from a set R, the least common multiple of x and 0 is 0.\nTranslate the statement in natural language to Lean:", "output": "theorem lcm_zero_right (x : R) : lcm x 0 = 0 :="}
{"input": "Statement in natural language:\nIf set s is a subset of set t, then the tangent cone at point x of set s is also a subset of the tangent cone at point x of set t.\nTranslate the statement in natural language to Lean:", "output": "theorem tangentCone_mono (h : s \u2286 t) : tangentConeAt \ud835\udd5c s x \u2286 tangentConeAt \ud835\udd5c t x :="}
{"input": "Statement in natural language:\nFor any two structured arrows X and Y in the categories S and T respectively, if there is a morphism f from X to Y, then the left component of f is equal to the identity morphism.\nTranslate the statement in natural language to Lean:", "output": "theorem left_eq_id {X Y : StructuredArrow S T} (f : X \u27f6 Y) :\n  f.left = \ud835\udfd9 _ :="}
{"input": "Statement in natural language:\nFor two trivializations 'e' and 'e'' of a fiber bundle with projection 'proj', the target of the transformation from the inverse of 'e' to 'e'' is equal to the intersection of the base sets of 'e' and 'e'' cross the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_trans_target_eq (e e' : Trivialization F proj) :\n    (e.toLocalEquiv.symm.trans e'.toLocalEquiv).target = (e.baseSet \u2229 e'.baseSet) \u00d7\u02e2 univ :="}
{"input": "Statement in natural language:\nIf a lattice \u03b1 is atomic, complemented, and modular, then it is also coatomic.\nTranslate the statement in natural language to Lean:", "output": "theorem isCoatomic_of_isAtomic_of_complementedLattice_of_isModular [IsAtomic \u03b1] :\n    IsCoatomic \u03b1 :="}
{"input": "Statement in natural language:\nFor any two star subalgebras S and T of a ring R over an algebra A, and for any element x in A, x is in the intersection of S and T if and only if x is in S and x is in T.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_inf {S T : StarSubalgebra R A} {x : A} : x \u2208 S \u2293 T \u2194 x \u2208 S \u2227 x \u2208 T :="}
{"input": "Statement in natural language:\nFor a given order with a bottom element, the bottom element is the least element of a set if and only if the bottom element is in the set.\nTranslate the statement in natural language to Lean:", "output": "theorem isLeast_bot_iff [OrderBot \u03b1] : IsLeast s \u22a5 \u2194 \u22a5 \u2208 s :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the cast of the negative successor of 'n' to a real number 'R' is equal to the negative of the cast of 'n + 1' to a real number.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_negSucc (n : \u2115) : (-[n+1] : R) = -(n + 1 : \u2115) :="}
{"input": "Statement in natural language:\nThe primitive part of a polynomial p is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem primPart_ne_zero (p : R[X]) : p.primPart \u2260 0 :="}
{"input": "Statement in natural language:\nThe sine of the difference between pi and any complex number x is equal to the sine of x.\nTranslate the statement in natural language to Lean:", "output": "theorem sin_pi_sub (x : \u2102) : sin (\u03c0 - x) = sin x :="}
{"input": "Statement in natural language:\nFor two affine transformations, one from P\u2081 to P\u2082 (denoted as e) and another from P\u2082 to P\u2083 (denoted as e'), the composition of these transformations (e followed by e') is the same as applying the transformation e' after e.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_trans (e : P\u2081 \u2243\u1d43[k] P\u2082) (e' : P\u2082 \u2243\u1d43[k] P\u2083) : \u21d1(e.trans e') = e' \u2218 e :="}
{"input": "Statement in natural language:\nThe non-empty locus of the difference between two functions 'f' and 'g' subtracted from 'f' is equal to the support of 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem neLocus_self_sub_left : neLocus (f - g) f = g.support :="}
{"input": "Statement in natural language:\nFor any property 'p' pertaining to an element '\u03b1', if 'x' is an element of an empty set of '\u03b1', then 'p' is true. This is logically equivalent to 'True', because there are no elements in an empty set, so any statement about elements of an empty set is vacuously true.\nTranslate the statement in natural language to Lean:", "output": "theorem forall_mem_empty_iff (p : \u03b1 \u2192 Prop) : (\u2200 x, x \u2208 (\u2205 : Finset \u03b1) \u2192 p x) \u2194 True :="}
{"input": "Statement in natural language:\nFor any element 'x' of type '\u03b2', swapping the right injection of 'x' into the sum of '\u03b1' and '\u03b2' results in the left injection of 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem swap_inr (x : \u03b2) : swap (inr x : Sum \u03b1 \u03b2) = inl x :="}
{"input": "Statement in natural language:\nFor any element 'x' of the type 'WithBot \u03b1', '\u22a5' is less than 'x' if and only if 'x' is not equal to '\u22a5'.\nTranslate the statement in natural language to Lean:", "output": "theorem bot_lt_iff_ne_bot : \u2200 {x : WithBot \u03b1}, \u22a5 < x \u2194 x \u2260 \u22a5"}
{"input": "Statement in natural language:\nFor any objects X and Y in category C, if for any object Z in C and any morphism g from Z to X, the composition of g and f equals zero implies that g equals zero, then f is a monomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem mono_of_cancel_zero {X Y : C} (f : X \u27f6 Y)\n    (hf : \u2200 (Z : C) (g : Z \u27f6 X) (_ : g \u226b f = 0), g = 0) : Mono f :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuous from a topological space 't' to another topological space 't'', then the coinduced topology on 't' by 'f' is less than or equal to the topology 't''.\nTranslate the statement in natural language to Lean:", "output": "theorem Continuous.coinduced_le (h : Continuous[t, t'] f) : t.coinduced f \u2264 t' :="}
{"input": "Statement in natural language:\nFor a given symbol 's' of type 'Sym \u03b1 n' and an element 'x' that belongs to 's', 'x' is also an element of 's.attach'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_attach (s : Sym \u03b1 n) (x : { x // x \u2208 s }) : x \u2208 s.attach :="}
{"input": "Statement in natural language:\nThe absolute value of the distance between two points a and b is equal to the distance between a and b.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_dist {a b : \u03b1} : |dist a b| = dist a b :="}
{"input": "Statement in natural language:\nThe polynomial constant of the sum of two numbers (a and b) is equal to the sum of the polynomial constants of each number separately.\nTranslate the statement in natural language to Lean:", "output": "theorem C_add : C (a + b) = C a + C b :="}
{"input": "Statement in natural language:\n\"A Lie Submodule is a singleton if and only if the module M is a singleton.\"\nTranslate the statement in natural language to Lean:", "output": "theorem subsingleton_iff : Subsingleton (LieSubmodule R L M) \u2194 Subsingleton M :="}
{"input": "Statement in natural language:\nIf function 'f' attains its maximum at 'a' over the set 's', and if function 'g' is monotone, then the composition of 'g' and 'f' (g \u2218 f) also attains its maximum at 'a' over the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsMaxOn.comp_mono (hf : IsMaxOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsMaxOn (g \u2218 f) s a :="}
{"input": "Statement in natural language:\nFor an invertible matrix A, the inverse of the inverse of A is equal to A itself.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_inv_of_invertible [Invertible A] : A\u207b\u00b9\u207b\u00b9 = A :="}
{"input": "Statement in natural language:\nFor a multiplicative equivalence 'f' between two structures 'M' and 'N', the inverse of 'f' when considered as a plain equivalence (not necessarily multiplicative) between 'M' and 'N' is the same as the multiplicative inverse of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_toEquiv_symm (f : M \u2243* N) : ((f : M \u2243 N).symm : N \u2192 M) = f.symm :="}
{"input": "Statement in natural language:\nFor a bilinear map B from E to F to G, and two functions f from D to E and g from D to F, if both f and g are continuously differentiable up to order N, then the norm of the n-th derivative of the function that maps y to B applied to f of y and g of y at a point x, is less than or equal to the norm of B times the sum over i from 0 to n of the binomial coefficient \"n choose i\" times the norm of the i-th derivative of f at x times the norm of the (n-i)-th derivative of g at x, where n is a natural number less than or equal to N.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) {f : D \u2192 E}\n    {g : D \u2192 F} {N : \u2115\u221e} (hf : ContDiff \ud835\udd5c N f) (hg : ContDiff \ud835\udd5c N g) (x : D) {n : \u2115}\n    (hn : (n : \u2115\u221e) \u2264 N) :\n    \u2016iteratedFDeriv \ud835\udd5c n (fun y => B (f y) (g y)) x\u2016 \u2264 \u2016B\u2016 * \u2211 i in Finset.range (n + 1),\n      (n.choose i : \u211d) * \u2016iteratedFDeriv \ud835\udd5c i f x\u2016 * \u2016iteratedFDeriv \ud835\udd5c (n - i) g x\u2016 :="}
{"input": "Statement in natural language:\nAn integer 'x' is a unit if and only if the absolute value of 'x' is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem isUnit_iff_abs_eq {x : \u2124} : IsUnit x \u2194 abs x = 1 :="}
{"input": "Statement in natural language:\nFor any function 'f' that maps from type '\u03b1' to type '\u03b2', and for any sequence 'S', mapping 'f' over the joined sequence 'S' is equivalent to joining the sequence obtained by mapping 'f' over each element of 'S'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_join (f : \u03b1 \u2192 \u03b2) : \u2200 S, map f (join S) = join (map (map f) S)"}
{"input": "Statement in natural language:\nGiven an affine subspace 's' of real numbers in a point set 'P' with a finite dimensional direction and a finrank of 2, and given two spheres 's\u2081' and 's\u2082' in 'P', and three points 'p\u2081', 'p\u2082', and 'p' in 'P', if the center of 's\u2081' and 's\u2082' are in 's', and 'p\u2081', 'p\u2082', and 'p' are in 's', and 's\u2081' is not equal to 's\u2082', and 'p\u2081' is not equal to 'p\u2082', and 'p\u2081', 'p\u2082', and 'p' are in 's\u2081', and 'p\u2081', 'p\u2082', and 'p' are in 's\u2082', then 'p' is either equal to 'p\u2081' or 'p\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two {s : AffineSubspace \u211d P}\n    [FiniteDimensional \u211d s.direction] (hd : finrank \u211d s.direction = 2) {s\u2081 s\u2082 : Sphere P}\n    {p\u2081 p\u2082 p : P} (hs\u2081 : s\u2081.center \u2208 s) (hs\u2082 : s\u2082.center \u2208 s) (hp\u2081s : p\u2081 \u2208 s) (hp\u2082s : p\u2082 \u2208 s)\n    (hps : p \u2208 s) (hs : s\u2081 \u2260 s\u2082) (hp : p\u2081 \u2260 p\u2082) (hp\u2081s\u2081 : p\u2081 \u2208 s\u2081) (hp\u2082s\u2081 : p\u2082 \u2208 s\u2081) (hps\u2081 : p \u2208 s\u2081)\n    (hp\u2081s\u2082 : p\u2081 \u2208 s\u2082) (hp\u2082s\u2082 : p\u2082 \u2208 s\u2082) (hps\u2082 : p \u2208 s\u2082) : p = p\u2081 \u2228 p = p\u2082 :="}
{"input": "Statement in natural language:\nThe square root of a natural number 'n' is greater than 0 if and only if 'n' is greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem sqrt_pos {n : \u2115} : 0 < sqrt n \u2194 0 < n :="}
{"input": "Statement in natural language:\nIf a function T is dominated and finitely additive with respect to a measure \u03bc and a constant C, and if two functions f and g are almost everywhere equal with respect to the measure \u03bc, then the setToFun of f and g with respect to \u03bc, T, and hT are equal.\nTranslate the statement in natural language to Lean:", "output": "theorem setToFun_congr_ae (hT : DominatedFinMeasAdditive \u03bc T C) (h : f =\u1d50[\u03bc] g) :\n    setToFun \u03bc T hT f = setToFun \u03bc T hT g :="}
{"input": "Statement in natural language:\nFor a given set S of a certain type \u03b1, under the conditions that \u03b1 is a conditionally complete linear order, \u03b1 has a topological space, \u03b1 has an order topology, \u03b1 has a first countable topology, S is nonempty, and S is bounded above, there exists a sequence u (a function from natural numbers to \u03b1) such that u is monotone, u tends to the supremum of S, and every element of the sequence u is in S.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_seq_tendsto_sSup {\u03b1 : Type _} [ConditionallyCompleteLinearOrder \u03b1]\n    [TopologicalSpace \u03b1] [OrderTopology \u03b1] [FirstCountableTopology \u03b1] {S : Set \u03b1} (hS : S.Nonempty)\n    (hS' : BddAbove S) : \u2203 u : \u2115 \u2192 \u03b1, Monotone u \u2227 Tendsto u atTop (\ud835\udcdd (sSup S)) \u2227 \u2200 n, u n \u2208 S :="}
{"input": "Statement in natural language:\nThe range of the inclusion of N is equal to N itself.\nTranslate the statement in natural language to Lean:", "output": "theorem range_incl : N.incl.range = N :="}
{"input": "Statement in natural language:\nFor a given matrix A and two matrices B\u2081 and B\u2082, the Kronecker product of A with the sum of B\u2081 and B\u2082 is equal to the sum of the Kronecker product of A with B\u2081 and the Kronecker product of A with B\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem kroneckerTMul_add (A : Matrix l m \u03b1) (B\u2081 B\u2082 : Matrix n p \u03b1) :\n    A \u2297\u2096\u209c[R] (B\u2081 + B\u2082) = A \u2297\u2096\u209c B\u2081 + A \u2297\u2096\u209c B\u2082 :="}
{"input": "Statement in natural language:\nSubtracting one from p does not result in zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_one_ne_zero : p - 1 \u2260 0 :="}
{"input": "Statement in natural language:\nFor any objects Y and Z in category C, and any morphism f from Y to Z, given projective resolutions P of Y and Q of Z, the composition of the lift of f with respect to P and Q at index 1 and the differential of Q at indices 1 and 0 is equal to the composition of the differential of P at indices 1 and 0 and the lift of f with respect to P and Q at index 0.\nTranslate the statement in natural language to Lean:", "output": "theorem liftOne_zero_comm {Y Z : C} (f : Y \u27f6 Z) (P : ProjectiveResolution Y)\n    (Q : ProjectiveResolution Z) :\n    liftOne f P Q \u226b Q.complex.d 1 0 = P.complex.d 1 0 \u226b liftZero f P Q :="}
{"input": "Statement in natural language:\nA space is locally connected if and only if for every point in the space, for every neighborhood of that point, there exists a preconnected subset within the neighborhood of that point which is also a subset of the original neighborhood.\nTranslate the statement in natural language to Lean:", "output": "theorem locallyConnectedSpace_iff_connected_subsets :\n    LocallyConnectedSpace \u03b1 \u2194 \u2200 (x : \u03b1), \u2200 U \u2208 \ud835\udcdd x, \u2203 V \u2208 \ud835\udcdd x, IsPreconnected V \u2227 V \u2286 U :="}
{"input": "Statement in natural language:\nFor any types m, n, and k, and for any properties p, q, and r defined on m, n, and k respectively, and for any matrices A and B with elements from a ring R, the block transformation of the product of A and B is equal to the sum of the products of the block transformations of A and B, where the blocks are defined by the properties p, q, and r, and their negations.\nTranslate the statement in natural language to Lean:", "output": "theorem toBlock_mul_eq_add {m n k : Type _} [Fintype n] (p : m \u2192 Prop) (q : n \u2192 Prop)\n    [DecidablePred q] (r : k \u2192 Prop) (A : Matrix m n R) (B : Matrix n k R) : (A \u2b1d B).toBlock p r =\n    A.toBlock p q \u2b1d B.toBlock q r + (A.toBlock p fun i => \u00acq i) \u2b1d B.toBlock (fun i => \u00acq i) r :="}
{"input": "Statement in natural language:\nThe extension of function 'f' with respect to 'I' is equal to the composition of 'I' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem extend_coe : \u21d1(f.extend I) = I \u2218 f :="}
{"input": "Statement in natural language:\nFor a bounded linear map \u03c6 from a normed vector space E to another normed vector space F, and a non-negative real number M, if for all vectors x in E, the norm of \u03c6x is less than or equal to M times the norm of x, and for all non-negative real numbers N, if the norm of \u03c6x is less than or equal to N times the norm of x then M is less than or equal to N, then the operator norm of \u03c6 is equal to M.\nTranslate the statement in natural language to Lean:", "output": "theorem op_norm_eq_of_bounds {\u03c6 : E \u2192SL[\u03c3\u2081\u2082] F} {M : \u211d} (M_nonneg : 0 \u2264 M)\n    (h_above : \u2200 x, \u2016\u03c6 x\u2016 \u2264 M * \u2016x\u2016) (h_below : \u2200 N \u2265 0, (\u2200 x, \u2016\u03c6 x\u2016 \u2264 N * \u2016x\u2016) \u2192 M \u2264 N) :\n    \u2016\u03c6\u2016 = M :="}
{"input": "Statement in natural language:\nApplying the inverse of the function 'zpowersMulHom' from group G to a function 'f' is equal to applying function 'f' to the multiplicative of the additive identity (1).\nTranslate the statement in natural language to Lean:", "output": "theorem zpowersMulHom_symm_apply [CommGroup G] (f : Multiplicative \u2124 \u2192* G) :\n    (zpowersMulHom G).symm f = f (Multiplicative.ofAdd 1) :="}
{"input": "Statement in natural language:\nFor any type \u03b3 and any property P that relates an element of \u03b3 to a set of \u03b3, if for every finite set t of \u03b3 there exists an element c of \u03b3 such that P holds for c and t, then there exists a sequence u of elements of \u03b3 (indexed by natural numbers) such that for every natural number n, P holds for the nth element of u and the set of all elements of u less than n.\nTranslate the statement in natural language to Lean:", "output": "theorem seq_of_forall_finite_exists {\u03b3 : Type _} {P : \u03b3 \u2192 Set \u03b3 \u2192 Prop}\n    (h : \u2200 t : Set \u03b3, t.Finite \u2192 \u2203 c, P c t) : \u2203 u : \u2115 \u2192 \u03b3, \u2200 n, P (u n) (u '' Iio n) :="}
{"input": "Statement in natural language:\nFor two locally constant functions 'f' and 'g' from 'X' to 'Y', 'f' is equal to 'g' if and only if 'f' is equal to 'g'. This means that the function mapping is injective, i.e., distinct inputs produce distinct outputs.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_inj {f g : LocallyConstant X Y} : (f : X \u2192 Y) = g \u2194 f = g :="}
{"input": "Statement in natural language:\nThe function that converts extended non-negative real numbers to non-negative real numbers is measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem measurable_toNNReal : Measurable ENNReal.toNNReal :="}
{"input": "Statement in natural language:\nFiltering an empty multiset with any predicate results in an empty multiset.\nTranslate the statement in natural language to Lean:", "output": "theorem filter_zero : filter p 0 = 0 :="}
{"input": "Statement in natural language:\nFor any three finite sets s\u2081, s\u2082, and s\u2083, the intersection of s\u2081 with the intersection of s\u2082 and s\u2083 is equal to the intersection of s\u2082 with the intersection of s\u2081 and s\u2083. This is a statement of the commutative property of intersection for finite sets.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_left_comm (s\u2081 s\u2082 s\u2083 : Finset \u03b1) : s\u2081 \u2229 (s\u2082 \u2229 s\u2083) = s\u2082 \u2229 (s\u2081 \u2229 s\u2083) :="}
{"input": "Statement in natural language:\nThe composition of function 'f' and the homomorphism of 'i' is exactly the inverse of the composition of 'i' and function 'g' if and only if 'f' and 'g' are exact.\nTranslate the statement in natural language to Lean:", "output": "theorem exact_comp_hom_inv_comp_iff (i : B \u2245 D) : Exact (f \u226b i.hom) (i.inv \u226b g) \u2194 Exact f g :="}
{"input": "Statement in natural language:\nFor any two lists, l\u2081 and l\u2082, if for every element in l\u2081, the count of that element in l\u2081 is less than or equal to the count of that element in l\u2082, then the list formed by appending l\u2082 (minus the elements in l\u2081) to l\u2081 is a permutation of l\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem subperm_append_diff_self_of_count_le {l\u2081 l\u2082 : List \u03b1}\n    (h : \u2200 x \u2208 l\u2081, count x l\u2081 \u2264 count x l\u2082) : l\u2081 ++ l\u2082.diff l\u2081 ~ l\u2082 :="}
{"input": "Statement in natural language:\nIf a linear map 'A' from a vector space 'E' to itself over a field '\ud835\udd5c' is symmetric, then 'A' is self-adjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.LinearMap.IsSymmetric.isSelfAdjoint {A : E \u2192L[\ud835\udd5c] E}\n    (hA : (A : E \u2192\u2097[\ud835\udd5c] E).IsSymmetric) : IsSelfAdjoint A :="}
{"input": "Statement in natural language:\nFor a given left cancel semigroup R, any element g of R is left regular.\nTranslate the statement in natural language to Lean:", "output": "theorem isLeftRegular_of_leftCancelSemigroup [LeftCancelSemigroup R]\n    (g : R) : IsLeftRegular g :="}
{"input": "Statement in natural language:\nFor a morphism 'f' from object 'X' to object 'Y' that is monic, and for a morphism 'g' from object 'X' to itself, 'g' followed by 'f' is equal to 'f' if and only if 'g' is the identity on 'X'.\nTranslate the statement in natural language to Lean:", "output": "theorem cancel_mono_id (f : X \u27f6 Y) [Mono f] {g : X \u27f6 X} : g \u226b f = f \u2194 g = \ud835\udfd9 X :="}
{"input": "Statement in natural language:\nIf 'a' is less than or equal to 'c' and 'b' is less than or equal to 'c', then the supremum (or least upper bound) of 'a' and 'b' is less than or equal to 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_le : a \u2264 c \u2192 b \u2264 c \u2192 a \u2294 b \u2264 c :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the number 'bit1 n' (which represents an odd number) is not even.\nTranslate the statement in natural language to Lean:", "output": "theorem not_even_bit1 (n : \u2115) : \u00acEven (bit1 n) :="}
{"input": "Statement in natural language:\nFor any two multisets s and t, s is less than or equal to the sum of s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem le_add_right (s t : Multiset \u03b1) : s \u2264 s + t :="}
{"input": "Statement in natural language:\nFor a given multiset 's' of any type '\u03b1', the sum of the count of each element 'a' in the finset converted from 's' is equal to the cardinality of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem toFinset_sum_count_eq (s : Multiset \u03b1) : (\u2211 a in s.toFinset, s.count a) = card s :="}
{"input": "Statement in natural language:\nFor any presheafed spaces X and Y over a category C, a morphism \u03b1 from X to Y, and an open subset U of Y, the composition of the germ of the presheaf of Y at the point \u03b1.base x.1 with the stalk map of \u03b1 at the point x is equal to the composition of the application of the structure morphism \u03b1.c at the open subset U with the germ of the presheaf of X at the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 : X \u27f6 Y) (U : Opens Y)\n    (x : (Opens.map \u03b1.base).obj U) :\n    Y.presheaf.germ \u27e8\u03b1.base x.1, x.2\u27e9 \u226b stalkMap \u03b1 \u2191x = \u03b1.c.app (op U) \u226b X.presheaf.germ x :="}
{"input": "Statement in natural language:\nThe intersection of the coercions of K and K' to a submodule of R in L is equal to the intersection of K and K' as submodules of R in L.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_coe_to_submodule :\n    (\u2191(K \u2293 K') : Submodule R L) = (K : Submodule R L) \u2293 (K' : Submodule R L) :="}
{"input": "Statement in natural language:\nThe natural sum of b and c is less than or equal to a if and only if for all b' less than b, the natural sum of b' and c is less than a, and for all c' less than c, the natural sum of b and c' is less than a.\nTranslate the statement in natural language to Lean:", "output": "theorem nadd_le_iff : b \u266f c \u2264 a \u2194 (\u2200 b' < b, b' \u266f c < a) \u2227 \u2200 c' < c, b \u266f c' < a :="}
{"input": "Statement in natural language:\nIn the context of a module M over a ring R, given a linearly independent set of vectors v, if the scalar multiplication of a non-zero scalar c and a vector v[i] equals the scalar multiplication of another scalar d and a vector v[j], then the indices i and j must be the same.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type _} [AddCommGroup M] [Module R M]\n    {v : \u03b9 \u2192 M} (li : LinearIndependent R v) (c d : R) (i j : \u03b9) (hc : c \u2260 0)\n    (h : c \u2022 v i = d \u2022 v j) : i = j :="}
{"input": "Statement in natural language:\nFor a non-zero vector x, the norm function is injective on the set of all vectors y that are on the same ray as x in the real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_injOn_ray_left (hx : x \u2260 0) : { y | SameRay \u211d x y }.InjOn norm :="}
{"input": "Statement in natural language:\nFor three matrices M, N, and K in a category C, and two morphisms f from M to N and g from N to K, the composition of f and g is equal to the function that takes two indices i and k and returns the sum over all indices j of N, of the composition of the element of f at i and j and the element of g at j and k.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_def {M N K : Mat_ C} (f : M \u27f6 N) (g : N \u27f6 K) :\n    f \u226b g = fun i k => \u2211 j : N.\u03b9, f i j \u226b g j k :="}
{"input": "Statement in natural language:\nThe closure of the closure of a set s is equal to the closure of the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_closure {s : Set \u03b1} : closure (closure s) = closure s :="}
{"input": "Statement in natural language:\nFor two functions `n` mapping from \u03b3 to \u03b4 and `m'` mapping from \u03b2' to \u03b1' to \u03b4, and two other functions `n\u2081` mapping from \u03b2 to \u03b2' and `n\u2082` mapping from \u03b1 to \u03b1', if for all `a` and `b`, `n` applied to `m` of `a` and `b` equals `m'` applied to `n\u2081` of `b` and `n\u2082` of `a`, then the map of `n` applied to the map of `m` with `f` and `g` equals the map of `m'` with the map of `g` with `n\u2081` and the map of `f` with `n\u2082`.\nTranslate the statement in natural language to Lean:", "output": "theorem map_map\u2082_antidistrib {n : \u03b3 \u2192 \u03b4} {m' : \u03b2' \u2192 \u03b1' \u2192 \u03b4} {n\u2081 : \u03b2 \u2192 \u03b2'} {n\u2082 : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, n (m a b) = m' (n\u2081 b) (n\u2082 a)) :\n    (map\u2082 m f g).map n = map\u2082 m' (g.map n\u2081) (f.map n\u2082) :="}
{"input": "Statement in natural language:\nFor a function from \u03b1 to \u03b2 and two sets of \u03b1, the image of the intersection of the two sets under the function is a subset of the intersection of the images of the two sets under the function.\nTranslate the statement in natural language to Lean:", "output": "theorem image_inter_subset (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b1) : f '' (s \u2229 t) \u2286 f '' s \u2229 f '' t :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any type '\u03b1' that is denumerable (i.e., can be put into a one-to-one correspondence with the set of natural numbers), decoding 'n' in the context of '\u03b1' is equivalent to some 'ofNat' function applied to '\u03b1' and 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem decode_eq_ofNat (\u03b1) [Denumerable \u03b1] (n : \u2115) : decode (\u03b1 := \u03b1) n = some (ofNat \u03b1 n) :="}
{"input": "Statement in natural language:\nFor a function 'f' that takes inputs from two lists of types '\u03b1' and '\u03b2' and produces an output of type '\u03b3', and given two pairs of lists 'l' and 'la' of type '\u03b1', and 'l'' and 'lb' of type '\u03b2', if the length of list 'l' is equal to the length of list 'l'', then applying the function 'f' to the concatenation of 'l' and 'la', and 'l'' and 'lb', is equal to the concatenation of applying the function 'f' to 'l' and 'l'', and 'la' and 'lb'.\nTranslate the statement in natural language to Lean:", "output": "theorem zipWith_append (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l la : List \u03b1) (l' lb : List \u03b2)\n    (h : l.length = l'.length) :\n    zipWith f (l ++ la) (l' ++ lb) = zipWith f l l' ++ zipWith f la lb :="}
{"input": "Statement in natural language:\nIf 'hT' is a dominated finite measure additive function 'T' with a constant 'C', then the function 'setToL1' applied to 'hT' is Lipschitz continuous with a Lipschitz constant equal to the non-negative real number representation of 'C'.\nTranslate the statement in natural language to Lean:", "output": "theorem setToL1_lipschitz (hT : DominatedFinMeasAdditive \u03bc T C) :\n    LipschitzWith (Real.toNNReal C) (setToL1 hT) :="}
{"input": "Statement in natural language:\nIf c is not equal to zero, then the integral from a to b of the function f at c times x is equal to the reciprocal of c times the integral from c times a to c times b of the function f at x.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_comp_mul_left (hc : c \u2260 0) :\n    (\u222b x in a..b, f (c * x)) = c\u207b\u00b9 \u2022 \u222b x in c * a..c * b, f x :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any function f from \u03b1 to non-negative extended real numbers, if the sum of the function f over all i does not equal infinity, then the function obtained by applying the conversion from extended non-negative real numbers to non-negative real numbers to f is summable.\nTranslate the statement in natural language to Lean:", "output": "theorem summable_toNNReal_of_tsum_ne_top {\u03b1 : Type _} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : (\u2211' i, f i) \u2260 \u221e) :\n    Summable (ENNReal.toNNReal \u2218 f) :="}
{"input": "Statement in natural language:\nIf p is a prime number that divides the difference between x and y, and p does not divide x or n, then p does not divide the sum of the series where each term is x raised to the power of i times y raised to the power of n minus 1 minus i, for all i in the range of n.\nTranslate the statement in natural language to Lean:", "output": "theorem not_dvd_geom_sum\u2082 {p : R} (hp : Prime p) (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) (hn : \u00acp \u2223 n) :\n    \u00acp \u2223 \u2211 i in range n, x ^ i * y ^ (n - 1 - i) :="}
{"input": "Statement in natural language:\nThe element x belongs to the closed ball centered at x with radius \u03b5.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_closedBall_self : x \u2208 closedBall x \u03b5 :="}
{"input": "Statement in natural language:\nIf a function 'f' is strictly monotonic, then 'f' is also monotonic.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictMono.monotone (hf : StrictMono f) : Monotone f :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't' of functions from an index set to another set '\u03b1', if 's' is a subset of 't', then the premeasure of 's' is less than or equal to the premeasure of 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem piPremeasure_pi_mono {s t : Set (\u2200 i, \u03b1 i)} (h : s \u2286 t) :\n    piPremeasure m s \u2264 piPremeasure m t :="}
{"input": "Statement in natural language:\nFor a given finite set S of lambda expressions, a direction d, and a statement q, the support of the statement \"move in direction d then execute statement q\" within the set S is equivalent to the support of the statement q within the set S.\nTranslate the statement in natural language to Lean:", "output": "theorem supportsStmt_move {S : Finset \u039b'\u2081} {d : Dir} {q : Stmt'\u2081} :\n    SupportsStmt S (move\u2099 d q) = SupportsStmt S q :="}
{"input": "Statement in natural language:\nIf function f commutes with function g, then the minimal period of the composition of f and g at point x divides the least common multiple of the minimal periods of f at x and g at x.\nTranslate the statement in natural language to Lean:", "output": "theorem Commute.minimalPeriod_of_comp_dvd_lcm {g : \u03b1 \u2192 \u03b1} (h : Function.Commute f g) :\n    minimalPeriod (f \u2218 g) x \u2223 Nat.lcm (minimalPeriod f x) (minimalPeriod g x) :="}
{"input": "Statement in natural language:\nIf the 'a' coefficient of a polynomial P is not zero, then the polynomial P itself cannot be zero.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_zero_of_a_ne_zero (ha : P.a \u2260 0) : P.toPoly \u2260 0 :="}
{"input": "Statement in natural language:\nFor any given list of elements of type \u03b1, if an element x is in the last element of the list, then x is also in the last element of the list when another element y is added to the front of the list.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_getLast?_cons {x y : \u03b1} : \u2200 {l : List \u03b1}, x \u2208 l.getLast? \u2192 x \u2208 (y :: l).getLast?"}
{"input": "Statement in natural language:\nFor any element 'a' and any two finite sets of sets '\ud835\udc9c' and '\u212c', the subfamily of the union of '\ud835\udc9c' and '\u212c' that does not contain 'a' is equal to the union of the subfamily of '\ud835\udc9c' that does not contain 'a' and the subfamily of '\u212c' that does not contain 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem nonMemberSubfamily_union (a : \u03b1) (\ud835\udc9c \u212c : Finset (Finset \u03b1)) :\n    (\ud835\udc9c \u222a \u212c).nonMemberSubfamily a = \ud835\udc9c.nonMemberSubfamily a \u222a \u212c.nonMemberSubfamily a :="}
{"input": "Statement in natural language:\nIf function f tends to uniformly on filter g with respect to filters l and l', and function f' tends to uniformly on filter g' with respect to filters l and l', then the product of functions f and f' tends to uniformly on the product of filters g and g' with respect to filters l and l'.\nTranslate the statement in natural language to Lean:", "output": "theorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l' :="}
{"input": "Statement in natural language:\nFor any natural number 'n' and any element 'r' from the ring 'R', the conversion of the monomial 'n r' to a Finsupp representation is equal to a Finsupp single representation with 'n' and 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem toFinsupp_monomial (n : \u2115) (r : R) : (monomial n r).toFinsupp = Finsupp.single n r :="}
{"input": "Statement in natural language:\nThe successor of any element 'a' is not the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem succ_ne_bot (a : \u03b1) : succ a \u2260 \u22a5 :="}
{"input": "Statement in natural language:\nAt a given point x, the function 'iso' is differentiable over the field \ud835\udd5c.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableAt : DifferentiableAt \ud835\udd5c iso x :="}
{"input": "Statement in natural language:\nFor any natural numbers 'c' and 'd', and any integers 'x' and 'y', the property of 'Nonnegg c d x y' is equivalent to the property of 'Nonnegg d c y x'. Here, 'Nonnegg' is a property or condition that is not explicitly defined in the given context.\nTranslate the statement in natural language to Lean:", "output": "theorem nonnegg_comm {c d : \u2115} {x y : \u2124} : Nonnegg c d x y = Nonnegg d c y x :="}
{"input": "Statement in natural language:\nFor a given decidable equality on \u03b9, a graded monoid A, a graded module M over A, and any indices i and j, the application of the scalar multiplication additive monoid homomorphism to the direct sum of A at index i with element x, and the graded module M at index j with element y, is equal to the graded module M at the index of the sum of i and j, with the graded scalar multiplication of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem smulAddMonoidHom_apply_of_of [DecidableEq \u03b9] [GMonoid A] [Gmodule A M] {i j} (x : A i)\n    (y : M j) :\n    smulAddMonoidHom A M (DirectSum.of A i x) (of M j y) = of M (i + j) (GSmul.smul x y) :="}
{"input": "Statement in natural language:\nFor a given irreflexive relation 'r' on a type '\u03b1', the expansion of 'r' by cuts is less than or equal to the inverse image of the lexicographic order on finite support functions, where the lexicographic order is defined by the complement of 'r' intersected with the inequality relation, and the less than relation.\nTranslate the statement in natural language to Lean:", "output": "theorem cutExpand_le_invImage_lex [IsIrrefl \u03b1 r] :\n    CutExpand r \u2264 InvImage (Finsupp.Lex (r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) (\u00b7 < \u00b7)) toFinsupp :="}
{"input": "Statement in natural language:\nIf a is covered by b (denoted as a \u2a7f b) and c is less than b, then c is less than or equal to a.\nTranslate the statement in natural language to Lean:", "output": "theorem Wcovby.le_of_lt (hab : a \u2a7f b) (hcb : c < b) : c \u2264 a :="}
{"input": "Statement in natural language:\nThe determinant of a matrix M is equal to the determinant of the matrix formed by four blocks, where each block is a submatrix of M. The submatrices are determined by a predicate p: the first block contains the elements of M for which both row and column indices satisfy p, the second block contains the elements for which the row index satisfies p and the column index does not, the third block contains the elements for which the row index does not satisfy p and the column index does, and the fourth block contains the elements for which neither the row nor the column index satisfies p.\nTranslate the statement in natural language to Lean:", "output": "theorem det_toBlock (M : Matrix m m R) (p : m \u2192 Prop) [DecidablePred p] :\n    M.det =\n      (fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p) <|\n          toBlock M (fun j => \u00acp j) fun j => \u00acp j).det :="}
{"input": "Statement in natural language:\nFor a given predicate 'p' on a type '\u03b1', a given finite set 's' of type '\u03b1', and a condition 'h' that for all elements 'x' in 's', 'p' holds true, the map of the subtype of 's' satisfying 'p' under the embedding of the subtype equals 's' itself. This essentially means that if all elements of a set satisfy a certain property, then mapping the subtype of elements satisfying that property back to the original set gives us the original set.\nTranslate the statement in natural language to Lean:", "output": "theorem subtype_map_of_mem {p : \u03b1 \u2192 Prop} [DecidablePred p] {s : Finset \u03b1} (h : \u2200 x \u2208 s, p x) :\n    (s.subtype p).map (Embedding.subtype _) = s :="}
{"input": "Statement in natural language:\nFor any natural numbers 'b' and 'b'', and any integer 'c', if 'b' divides 'b'' minus 'c', then 'b' divides 'n' if and only if 'b' divides the integer representation of the digits of 'n' in base 'b'' with coefficient 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem dvd_iff_dvd_ofDigits (b b' : \u2115) (c : \u2124) (h : (b : \u2124) \u2223 (b' : \u2124) - c) (n : \u2115) :\n    b \u2223 n \u2194 (b : \u2124) \u2223 ofDigits c (digits b' n) :="}
{"input": "Statement in natural language:\nIf there exists a unique element 'a' in list 'l' that satisfies property 'p', then the element chosen by the function 'choose' from list 'l' based on property 'p' also satisfies property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem choose_property (hp : \u2203! a, a \u2208 l \u2227 p a) : p (choose p l hp) :="}
{"input": "Statement in natural language:\nFor any topological spaces Y and Z, and for any morphisms f from X to Y and g from Y to Z, the inverse of the composition of f and g applied to a set U is equal to the identity.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_inv_app {Y Z : TopCat.{w}} (f : X \u27f6 Y) (g : Y \u27f6 Z) (U) :\n    (comp \u2131 f g).inv.app U = \ud835\udfd9 _ :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from M to N and another linear map 'g' from N to P, the left composition of 'f' and 'g' applied to an element 'x' from M is equal to 'g' applied to the result of 'f' applied to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem lcomp\u209b\u2097_apply (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N) (g : N \u2192\u209b\u2097[\u03c3\u2082\u2083] P) (x : M) :\n    lcomp\u209b\u2097 P \u03c3\u2082\u2083 f g x = g (f x) :="}
{"input": "Statement in natural language:\nFor any compact space 'X' and any set 'A' within 'X', the closure of the closure of 'A' is a subset of the closure of 'A'.\nTranslate the statement in natural language to Lean:", "output": "theorem cl_cl {X : Compactum} (A : Set X) : cl (cl A) \u2286 cl A :="}
{"input": "Statement in natural language:\nFor an orthonormal basis 'b' of a vector space 'E' over a field '\ud835\udd5c' indexed by '\u03b9', the function that converts 'b' to a basis and then to an equivalent function is the same as the function that represents 'b' as a linear equivalent.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_toBasis_repr (b : OrthonormalBasis \u03b9 \ud835\udd5c E) :\n    b.toBasis.equivFun = b.repr.toLinearEquiv :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' from an index set '\u03b9' to a group 'M' with addition, the difference of 'f' and 'g' converted to a dependent function with finite support is equal to the difference of 'f' converted to a dependent function with finite support and 'g' converted to a dependent function with finite support.\nTranslate the statement in natural language to Lean:", "output": "theorem toDfinsupp_sub [AddGroup M] (f g : \u03b9 \u2192\u2080 M) :\n    (f - g).toDfinsupp = f.toDfinsupp - g.toDfinsupp :="}
{"input": "Statement in natural language:\nThe double of a number 'x' in the set '\u03b1', when considered as an element of the set 'WithTop \u03b1', is equal to the double of 'x' considered directly in the set 'WithTop \u03b1'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_bit0 : ((bit0 x : \u03b1) : WithTop \u03b1) = (bit0 x : WithTop \u03b1) :="}
{"input": "Statement in natural language:\nA pair (p) belongs to the product of sets s and t if and only if the first element of the pair belongs to set s and the second element of the pair belongs to set t.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_product {p : \u03b1 \u00d7 \u03b2} : p \u2208 s \u00d7\u02e2 t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t :="}
{"input": "Statement in natural language:\nThe coe function applied to an empty Sym of any type \u03b1 is equal to an empty Multiset of the same type \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_nil : \u2191(@Sym.nil \u03b1) = (0 : Multiset \u03b1) :="}
{"input": "Statement in natural language:\nFor any element 'a' of a set '\u03b1', if the product of 'a' and 'u' equals 1, then the inverse of 'u' is equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_eq_of_mul_eq_one_left {a : \u03b1} (h : a * u = 1) : \u2191u\u207b\u00b9 = a :="}
{"input": "Statement in natural language:\nThe square of the cotangent ideal of any ideal I in a ring R is equal to the bottom element, often representing the zero ideal.\nTranslate the statement in natural language to Lean:", "output": "theorem cotangentIdeal_square (I : Ideal R) : I.cotangentIdeal ^ 2 = \u22a5 :="}
{"input": "Statement in natural language:\nFor any subring 's' of ring 'R' and any subring 't' of ring 'S', the supremum of the product of 's' and the bottom element and the product of the bottom element and 't' is equal to the product of 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_bot_sup_bot_prod (s : Subring R) (t : Subring S) : s.prod \u22a5 \u2294 prod \u22a5 t = s.prod t :="}
{"input": "Statement in natural language:\nIf a is not equal to zero, then the degree of the polynomial represented by the constant b is less than the degree of the polynomial represented by the constant a multiplied by the variable X.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_C_lt_degree_C_mul_X (ha : a \u2260 0) : degree (C b) < degree (C a * X) :="}
{"input": "Statement in natural language:\nFor any four objects W, X, Y, Z in a braided monoidal category C, the following equality holds:\n\nThe composition of the homomorphism of the braiding of W and X tensor the identity on Y tensor Z, followed by the homomorphism of the associator of X, W, and Y tensor Z, followed by the identity on X tensor the inverse of the associator of W, Y, and Z, followed by the identity on X tensor the homomorphism of the braiding of W tensor Y and Z, followed by the identity on X tensor the inverse of the associator of Z, W, and Y,\n\nis equal to \n\nthe composition of the identity on W tensor X tensor the homomorphism of the braiding of Y and Z, followed by the inverse of the associator of W tensor X, Z, and Y, followed by the homomorphism of the associator of W, X, and Z tensor the identity on Y, followed by the homomorphism of the braiding of W and X tensor Z tensor the identity on Y, followed by the homomorphism of the associator of X, Z, and W tensor the identity on Y, followed by the homomorphism of\nTranslate the statement in natural language to Lean:", "output": "theorem tensor_associativity_aux (W X Y Z : C) :\n    ((\u03b2_ W X).hom \u2297 \ud835\udfd9 (Y \u2297 Z)) \u226b\n        (\u03b1_ X W (Y \u2297 Z)).hom \u226b\n          (\ud835\udfd9 X \u2297 (\u03b1_ W Y Z).inv) \u226b (\ud835\udfd9 X \u2297 (\u03b2_ (W \u2297 Y) Z).hom) \u226b (\ud835\udfd9 X \u2297 (\u03b1_ Z W Y).inv) =\n      (\ud835\udfd9 (W \u2297 X) \u2297 (\u03b2_ Y Z).hom) \u226b\n        (\u03b1_ (W \u2297 X) Z Y).inv \u226b\n          ((\u03b1_ W X Z).hom \u2297 \ud835\udfd9 Y) \u226b\n            ((\u03b2_ W (X \u2297 Z)).hom \u2297 \ud835\udfd9 Y) \u226b ((\u03b1_ X Z W).hom \u2297 \ud835\udfd9 Y) \u226b (\u03b1_ X (Z \u2297 W) Y).hom :="}
{"input": "Statement in natural language:\nFor any semiring \u03b1, any element 'a' of \u03b1, and any vertex 'v', the result of multiplying the adjacency matrix of a graph 'G' with a constant function of 'a', applied to 'v', is equal to the degree of the vertex 'v' in the graph 'G' multiplied by 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem adjMatrix_mulVec_const_apply [Semiring \u03b1] {a : \u03b1} {v : V} :\n    (G.adjMatrix \u03b1).mulVec (Function.const _ a) v = G.degree v * a :="}
{"input": "Statement in natural language:\nIf the index of group H is not zero and the index of group K is not zero, then the index of the intersection of groups H and K is also not zero.\nTranslate the statement in natural language to Lean:", "output": "theorem index_inf_ne_zero (hH : H.index \u2260 0) (hK : K.index \u2260 0) : (H \u2293 K).index \u2260 0 :="}
{"input": "Statement in natural language:\nThe set of fixed points for the identity function on any set \u03b1 is the entire set \u03b1 itself.\nTranslate the statement in natural language to Lean:", "output": "theorem fixedPoints_id : fixedPoints (@id \u03b1) = Set.univ :="}
{"input": "Statement in natural language:\nFor any type 'R' that forms a Rack and any element 'a' of the PreEnveloping Group of 'R', the PreEnveloping Group Relation of 'R' is reflexive for 'a'. This means that 'a' is related to itself in the PreEnveloping Group Relation of 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem PreEnvelGroupRel.refl {R : Type u} [Rack R] {a : PreEnvelGroup R} :\n    PreEnvelGroupRel R a a :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any two relations r and s on \u03b1, if for all x and y, r x y implies s x y, then the composition of the factor function from r to s with the quotient set constructor function for r equals the quotient set constructor function for s.\nTranslate the statement in natural language to Lean:", "output": "theorem factor_mk_eq {\u03b1 : Type _} (r s : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 x y, r x y \u2192 s x y) :\n    factor r s h \u2218 Quot.mk _ = Quot.mk _ :="}
{"input": "Statement in natural language:\nThe image of the function that adds a constant 'a' to a variable 'x', when applied to all elements greater than or equal to 'b', is equal to all elements greater than or equal to 'a + b'.\nTranslate the statement in natural language to Lean:", "output": "theorem image_const_add_Ici : (fun x => a + x) '' Ici b = Ici (a + b) :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b3', if 'f' is upper semicontinuous, then the preimage of the set of all elements greater than or equal to 'y' under 'f' is a closed set.\nTranslate the statement in natural language to Lean:", "output": "theorem UpperSemicontinuous.isClosed_preimage {f : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuous f) (y : \u03b3) :\n    IsClosed (f \u207b\u00b9' Ici y) :="}
{"input": "Statement in natural language:\nIf a set 's' has a minimum value 'b', and there is a value 'a' that is less than 'b', then 'a' is not a member of the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_mem_of_lt_min {s : Finset \u03b1} {a b : \u03b1} (h\u2081 : a < b) (h\u2082 : s.min = \u2191b) : a \u2209 s :="}
{"input": "Statement in natural language:\nFor any two types \u03b9 and \u03b9' and any two functions f and g from these types to a complete Boolean algebra \u03b1, the infimum (greatest lower bound) of the supremum (least upper bound) of f over all elements of \u03b9 and the supremum of g over all elements of \u03b9' is equal to the supremum over all pairs of elements from \u03b9 and \u03b9' of the infimum of f applied to the first element of the pair and g applied to the second element of the pair.\nTranslate the statement in natural language to Lean:", "output": "theorem iSup_inf_iSup {\u03b9 \u03b9' : Type _} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} :\n    ((\u2a06 i, f i) \u2293 \u2a06 j, g j) = \u2a06 i : \u03b9 \u00d7 \u03b9', f i.1 \u2293 g i.2 :="}
{"input": "Statement in natural language:\nIf for every Cauchy sequence of elements in \u03b1 there exists a limit point 'a' such that the sequence tends towards 'a', then \u03b1 is a complete space.\nTranslate the statement in natural language to Lean:", "output": "theorem complete_of_cauchySeq_tendsto :\n    (\u2200 u : \u2115 \u2192 \u03b1, CauchySeq u \u2192 \u2203 a, Tendsto u atTop (\ud835\udcdd a)) \u2192 CompleteSpace \u03b1 :="}
{"input": "Statement in natural language:\nThe lift of the root of a function f by the homomorphism liftHom, given f, a, and hfx, equals a.\nTranslate the statement in natural language to Lean:", "output": "theorem liftHom_root : liftHom f a hfx (root f) = a :="}
{"input": "Statement in natural language:\n'toMulBot a' is less than 'toMulBot b' if and only if 'a' is less than 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem toMulBot_lt : toMulBot a < toMulBot b \u2194 a < b :="}
{"input": "Statement in natural language:\nPi is less than 3.15.\nTranslate the statement in natural language to Lean:", "output": "theorem pi_lt_315 : \u03c0 < 3.15 :="}
{"input": "Statement in natural language:\nFor a set 's' of absolutely convex open sets in a vector space 'E' over a field '\ud835\udd5c', 's' is also a convex set in the real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_convex (s : AbsConvexOpenSets \ud835\udd5c E) : Convex \u211d (s : Set E) :="}
{"input": "Statement in natural language:\nFor any monoid object M in a monoidal category C, the composition of the tensor product of the multiplication map of M and the right unitor of the monoidal unit with the right unitor of M is equal to the composition of the tensor product of two right unitors of M with the multiplication map of M.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_rightUnitor {M : Mon_ C} :\n    (tensor_\u03bc C (M.X, \ud835\udfd9_ C) (M.X, \ud835\udfd9_ C) \u226b (M.mul \u2297 (\u03bb_ (\ud835\udfd9_ C)).hom)) \u226b (\u03c1_ M.X).hom =\n      ((\u03c1_ M.X).hom \u2297 (\u03c1_ M.X).hom) \u226b M.mul :="}
{"input": "Statement in natural language:\nFor any two ideals I and J of a ring \u03b1, if for every element x, x is in I if and only if x is in J, then I is equal to J.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {I J : Ideal \u03b1} (h : \u2200 x, x \u2208 I \u2194 x \u2208 J) : I = J :="}
{"input": "Statement in natural language:\nFor any equivalence between two sets n and m, and any square matrix A with elements from set m, the determinant of the submatrix of A defined by the equivalence is equal to the determinant of A itself.\nTranslate the statement in natural language to Lean:", "output": "theorem det_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A :="}
{"input": "Statement in natural language:\nIf a statement q\u2081 is an element of the set of statements generated by q\u2082, and if the set S supports the statement q\u2082, then the set S also supports the statement q\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem stmts\u2081_supportsStmt_mono {S : Finset \u039b} {q\u2081 q\u2082 : Stmt\u2082} (h : q\u2081 \u2208 stmts\u2081 q\u2082)\n    (hs : SupportsStmt S q\u2082) : SupportsStmt S q\u2081 :="}
{"input": "Statement in natural language:\nThe dependent product index of an empty list, when mapped with any function from \u03b1 to \u03b9, is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem List.dProdIndex_nil (f\u03b9 : \u03b1 \u2192 \u03b9) : ([] : List \u03b1).dProdIndex f\u03b9 = 0 :="}
{"input": "Statement in natural language:\nFor any natural number 'p' in a nontrivial ring 'R' with characteristic 'p', if 'p' is not equal to 2, then -1 is a primitive root of order 2.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_one (p : \u2115) [Nontrivial R] [h : CharP R p] (hp : p \u2260 2) :\n    IsPrimitiveRoot (-1 : R) 2 :="}
{"input": "Statement in natural language:\nFor a natural number 'm', the p-adic norm of 'm' is less than one if and only if 'p' divides 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem nat_lt_one_iff (m : \u2115) : padicNorm p m < 1 \u2194 p \u2223 m :="}
{"input": "Statement in natural language:\nFor a given binary bicone 'b' of 'X' and 'Y', if 'b' is a bilimit, then it is a pullback of the zero morphisms from '0' to 'X' and '0' to 'Y' along 'b.inl' and 'b.inr'.\nTranslate the statement in natural language to Lean:", "output": "theorem of_is_bilimit' {b : BinaryBicone X Y} (h : b.IsBilimit) :\n    IsPullback (0 : 0 \u27f6 X) (0 : 0 \u27f6 Y) b.inl b.inr :="}
{"input": "Statement in natural language:\nFor any non-zero extended non-negative real number 'a', there exists a natural number 'n' such that the inverse of 'n' (considered as an extended non-negative real number) is less than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_inv_nat_lt {a : \u211d\u22650\u221e} (h : a \u2260 0) : \u2203 n : \u2115, (n : \u211d\u22650\u221e)\u207b\u00b9 < a :="}
{"input": "Statement in natural language:\nFor a bilinear form B on a module M over a ring R and a linear map r from M to M, the composition of B with the identity linear map on the left and r on the right is equal to the right composition of B with r.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_id_left (B : BilinForm R M) (r : M \u2192\u2097[R] M) :\n    B.comp LinearMap.id r = B.compRight r :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and c of a Euclidean domain R, if b is not equal to zero and the product of a and b equals c, then a is equal to c divided by b.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_div_of_mul_eq_left {a b c : R} (hb : b \u2260 0) (h : a * b = c) : a = c / b :="}
{"input": "Statement in natural language:\nFor any natural number 'n', casting 'n' to a rational number and then to an arbitrary type '\u03b1' is equal to the original natural number 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_coe_nat (n : \u2115) : ((n : \u211a) : \u03b1) = n :="}
{"input": "Statement in natural language:\nFor any scalar 'c' from the ring 'R' and any element 'x' from the restriction of scalars from 'S' to 'M' over 'R', the application of the addition equivalence on the scalar multiplication of 'c' and 'x' is equal to the scalar multiplication of the algebraic mapping of 'c' from 'R' to 'S' and the application of the addition equivalence on 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem RestrictScalars.addEquiv_map_smul (c : R) (x : RestrictScalars R S M) :\n    RestrictScalars.addEquiv R S M (c \u2022 x) = algebraMap R S c \u2022 RestrictScalars.addEquiv R S M x :="}
{"input": "Statement in natural language:\nFor a given multiset of matrices 's' with elements from an additive commutative monoid '\u03b1' that also forms a star-additive monoid, the conjugate transpose of the sum of the matrices in 's' is equal to the sum of the conjugate transposes of the matrices in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem conjTranspose_multiset_sum [AddCommMonoid \u03b1] [StarAddMonoid \u03b1]\n    (s : Multiset (Matrix m n \u03b1)) : s.sum\u1d34 = (s.map conjTranspose).sum :="}
{"input": "Statement in natural language:\nFor a preorder set of elements \u03b1, which has no minimum order, any element x from \u03b1 is disjoint from the set of all elements that are less than any given element in \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_pure_atBot [Preorder \u03b1] [NoMinOrder \u03b1] (x : \u03b1) : Disjoint (pure x) atBot :="}
{"input": "Statement in natural language:\nFor any two ordinals 'a' and 'b', the product of 'a' and the successor of 'b' is equal to the sum of the product of 'a' and 'b' and 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_succ (a b : Ordinal) : a * succ b = a * b + a :="}
{"input": "Statement in natural language:\nFor any two points x and y, y is between x and y itself in the relation R.\nTranslate the statement in natural language to Lean:", "output": "theorem wbtw_self_right (x y : P) : Wbtw R x y y :="}
{"input": "Statement in natural language:\nIn a complete space, if a sequence is Cauchy, then there exists a limit point such that the sequence tends to this limit point.\nTranslate the statement in natural language to Lean:", "output": "theorem cauchySeq_tendsto_of_complete [SemilatticeSup \u03b2] [CompleteSpace \u03b1] {u : \u03b2 \u2192 \u03b1}\n    (H : CauchySeq u) : \u2203 x, Tendsto u atTop (\ud835\udcdd x) :="}
{"input": "Statement in natural language:\nFor any two real numbers 'a' and 'b', if the functions 'f' and 'g' are equal on the interval from 'a' to 'b', then the integral of 'f' from 'a' to 'b' is equal to the integral of 'g' from 'a' to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_congr {a b : \u211d} (h : EqOn f g [[a, b]]) :\n    (\u222b x in a..b, f x \u2202\u03bc) = \u222b x in a..b, g x \u2202\u03bc :="}
{"input": "Statement in natural language:\nFor a given Ctop structure 'F' on a set '\u03b1' with a topology '\u03c3', a set 's' is in the neighborhood of a point 'a' in the topological space derived from 'F' if and only if there exists a 'b' such that 'a' is in 'F' of 'b' and 'F' of 'b' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_nhds_toTopsp (F : Ctop \u03b1 \u03c3) {s : Set \u03b1} {a : \u03b1} :\n    s \u2208 @nhds _ F.toTopsp a \u2194 \u2203 b, a \u2208 F b \u2227 F b \u2286 s :="}
{"input": "Statement in natural language:\nIf we have a second countable topology on X and the quotient map is an open map, then the quotient space also has a second countable topology.\nTranslate the statement in natural language to Lean:", "output": "theorem Quotient.secondCountableTopology [SecondCountableTopology X]\n    (h : IsOpenMap (Quotient.mk' : X \u2192 Quotient S)) : SecondCountableTopology (Quotient S) :="}
{"input": "Statement in natural language:\nFor every number 'n', the pre-previous value of 'n' when converted to a natural number is equal to the natural number pre-previous of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ppred_to_nat : \u2200 n : Num, (\u2191) <$> ppred n = Nat.ppred n"}
{"input": "Statement in natural language:\nIf a\u2082 is not equal to zero, then the condition that the series of the terms f(i) divided by a\u2082 has a sum of a\u2081 divided by a\u2082 is equivalent to the condition that the series of the terms f has a sum of a\u2081.\nTranslate the statement in natural language to Lean:", "output": "theorem hasSum_div_const_iff (h : a\u2082 \u2260 0) : HasSum (fun i => f i / a\u2082) (a\u2081 / a\u2082) \u2194 HasSum f a\u2081 :="}
{"input": "Statement in natural language:\nIf b and c are non-negative numbers, and a is less than or equal to the product of c and b, then the quotient of a and b is less than or equal to c.\nTranslate the statement in natural language to Lean:", "output": "theorem div_le_of_nonneg_of_le_mul (hb : 0 \u2264 b) (hc : 0 \u2264 c) (h : a \u2264 c * b) : a / b \u2264 c :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from a ring 'A' to a ring 'B', and another function 'g' from ring 'B' to ring 'C', and if the composition of 'g' and 'f' has a finite presentation, and 'f' is of finite type, then 'g' also has a finite presentation.\nTranslate the statement in natural language to Lean:", "output": "theorem of_comp_finiteType (f : A \u2192+* B) {g : B \u2192+* C} (hg : (g.comp f).FinitePresentation)\n    (hf : f.FiniteType) : g.FinitePresentation :=\n  -- Porting note : need to specify some instances"}
{"input": "Statement in natural language:\nIf 'f' is a linear map from 'F' to 'E' and 'f' is a surjective function (meaning every element of 'E' is the image of at least one element of 'F' under 'f'), then 'f' is an open map (meaning the image of an open set under 'f' is also an open set).\nTranslate the statement in natural language to Lean:", "output": "theorem isOpenMap_of_finiteDimensional (f : F \u2192\u2097[\ud835\udd5c] E) (hf : Function.Surjective f) :\n    IsOpenMap f :="}
{"input": "Statement in natural language:\nIf a filter l has a basis defined by a predicate p and a set function s, then the filter l intersected with the principal filter of a set t is not the bottom filter if and only if for all elements i that satisfy the predicate p, the intersection of the set s(i) and t is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem HasBasis.inf_principal_neBot_iff (hl : l.HasBasis p s) {t : Set \u03b1} :\n    NeBot (l \u2293 \ud835\udcdf t) \u2194 \u2200 \u2983i\u2984, p i \u2192 (s i \u2229 t).Nonempty :="}
{"input": "Statement in natural language:\nThe predecessor of a number 'o' equals 'o' if and only if there does not exist a number 'a' such that 'o' is the successor of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem pred_eq_iff_not_succ {o} : pred o = o \u2194 \u00ac\u2203 a, o = succ a :="}
{"input": "Statement in natural language:\nThe set of all walks from vertex 'u' to vertex 'v' in a simple graph 'G' with length 'n+1' is equal to the union over all vertices 'w' adjacent to 'u' of the set of walks from 'w' to 'v' with length 'n', each extended by one step from 'u' to 'w'.\nTranslate the statement in natural language to Lean:", "output": "theorem set_walk_length_succ_eq (u v : V) (n : \u2115) :\n    {p : G.Walk u v | p.length = n.succ} =\n      \u22c3 (w : V) (h : G.Adj u w), Walk.cons h '' {p' : G.Walk w v | p'.length = n} :="}
{"input": "Statement in natural language:\nFor a function 'f' that takes an element of type \u03b1 and an element of type \u03b2 and returns an element of type \u03b2, a value 'H', a value 'b', and a value 'a', the result of folding the function 'f' over the multiset containing only 'a' with 'b' as the initial value is equal to the result of applying the function 'f' to 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem foldr_singleton (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H b a) : foldr f H b ({a} : Multiset \u03b1) = f a b :="}
{"input": "Statement in natural language:\nFor a set 's' of type '\u03b4' and a function 't' that maps each element 'i' of type '\u03b4' to a set of type '\u03c0 i', if 's' is countable and for every element 'i' in 's', the set 't i' is measurable, then the Cartesian product of 's' and 't', denoted as 's.pi t', is also measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasurableSet.pi {s : Set \u03b4} {t : \u2200 i : \u03b4, Set (\u03c0 i)} (hs : s.Countable)\n    (ht : \u2200 i \u2208 s, MeasurableSet (t i)) : MeasurableSet (s.pi t) :="}
{"input": "Statement in natural language:\nFor a measure '\u03bc' on a set '\u03b1' that is sigma-finite (meaning it can be partitioned into a countable union of measurable sets with finite measure), and a function 'f' that is non-negative and measurable, the Lebesgue integral of the function 'f' with respect to the measure '\u03bc' is equal to the Lebesgue integral over the interval (0, \u221e) of the measure of the set of elements 'a' in '\u03b1' for which 't' is less than 'f(a)'.\nTranslate the statement in natural language to Lean:", "output": "theorem lintegral_eq_lintegral_meas_lt (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (f_nn : 0 \u2264 f)\n    (f_mble : Measurable f) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (f \u03c9) \u2202\u03bc) = \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t < f a} :="}
{"input": "Statement in natural language:\nFor any object 'U' in the opposite category 'C', and any section 's' of 'F' at 'U', the family of elements of 'G' corresponding to the section 's' is compatible.\nTranslate the statement in natural language to Lean:", "output": "theorem Subpresheaf.family_of_elements_compatible {U : C\u1d52\u1d56} (s : F.obj U) :\n    (G.familyOfElementsOfSection s).Compatible :="}
{"input": "Statement in natural language:\nFor any two lists, l\u2081 of type \u03b1 and l\u2082 of type \u03b2, if the length of l\u2082 is less than or equal to the length of l\u2081, then the second element of the pair resulting from unzipping the zipped pair of l\u2081 and l\u2082 is equal to l\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem unzip_zip_right {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} (h : length l\u2082 \u2264 length l\u2081) :\n    (unzip (zip l\u2081 l\u2082)).2 = l\u2082 :="}
{"input": "Statement in natural language:\nThe product of 'a' and 'b' is less than zero if and only if either 'a' is greater than zero and 'b' is less than zero, or 'a' is less than zero and 'b' is greater than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_neg_iff : a * b < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b :="}
{"input": "Statement in natural language:\nFor two measurable functions 'f' and 'g' from a set '\u03b1' to sets '\u03b2' and '\u03b3' respectively, with respect to a measure '\u03bc', the pair function of 'f' and 'g' is almost everywhere equal to a function that maps each element 'x' in '\u03b1' to the pair consisting of the image of 'x' under 'f' and the image of 'x' under 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem coeFn_pair (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : f.pair g =\u1d50[\u03bc] fun x => (f x, g x) :="}
{"input": "Statement in natural language:\nFor a set 's' of pairs of elements from sets '\u03b1' and '\u03b2', if 's' is a measurable set and the product measure of 's' with respect to measures '\u03bc' and '\u03bd' is not infinite, then the function that maps each element 'x' from '\u03b1' to the real number representation of the measure of the preimage of 's' under the function 'Prod.mk x' with respect to '\u03bd' is integrable with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem integrable_measure_prod_mk_left {s : Set (\u03b1 \u00d7 \u03b2)} (hs : MeasurableSet s)\n    (h2s : (\u03bc.prod \u03bd) s \u2260 \u221e) : Integrable (fun x => (\u03bd (Prod.mk x \u207b\u00b9' s)).toReal) \u03bc :="}
{"input": "Statement in natural language:\nThe function 'f' is differentiable on the entire domain if and only if 'f' is differentiable.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableOn_univ : DifferentiableOn \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f :="}
{"input": "Statement in natural language:\nFor any semiring \u03b1 and any natural number n, for any two functions v and w from the finite set of size n to \u03b1, the product of the circulant matrix of v and the circulant matrix of w equals the circulant matrix of the product of the circulant matrix of v and w.\nTranslate the statement in natural language to Lean:", "output": "theorem Fin.circulant_mul [Semiring \u03b1] :\n    \u2200 {n} (v w : Fin n \u2192 \u03b1), circulant v \u2b1d circulant w = circulant (mulVec (circulant v) w)"}
{"input": "Statement in natural language:\nThe zeroth term of the lower central series of a Lie module M over an ideal I is the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem lcs_zero : I.lcs M 0 = \u22a4 :="}
{"input": "Statement in natural language:\nFor any two elements 'x' and 'y', the equivalence class of the sum of 'x' and 'y' under the relation 'Setoid.r' is equal to the sum of the equivalence classes of 'x' and 'y' in the colimit type 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem quot_add (x y) :\n    Quot.mk Setoid.r (add x y) = (ColimitType.mk x + ColimitType.mk y : ColimitType F) :="}
{"input": "Statement in natural language:\nFor any real number x, one raised to the power of x equals one.\nTranslate the statement in natural language to Lean:", "output": "theorem one_rpow (x : \u211d) : (1 : \u211d\u22650\u221e) ^ x = 1 :="}
{"input": "Statement in natural language:\nFor a given finite type \u03c3 and a list x that is accepted by a machine M, if the cardinality of \u03c3 is less than or equal to the length of the list x, then there exist lists a, b, and c such that x is the concatenation of a, b, and c, the sum of the lengths of a and b is less than or equal to the cardinality of \u03c3, b is not an empty list, and the set of all possible concatenations of a, any number of repetitions of b, and c is a subset of the set of lists accepted by the machine M.\nTranslate the statement in natural language to Lean:", "output": "theorem pumping_lemma [Fintype \u03c3] {x : List \u03b1} (hx : x \u2208 M.accepts)\n    (hlen : Fintype.card \u03c3 \u2264 List.length x) :\n    \u2203 a b c,\n      x = a ++ b ++ c \u2227\n        a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 {a} * {b}\u2217 * {c} \u2264 M.accepts :="}
{"input": "Statement in natural language:\nFor any two types \u03b9 and \u03b9' and any two functions f and g from these types to a complete Boolean algebra \u03b1, the supremum (or join) of the infimum (or meet) of f over all elements of \u03b9 and the infimum of g over all elements of \u03b9' is equal to the infimum over all pairs of elements from \u03b9 and \u03b9' of the supremum of f applied to the first element of the pair and g applied to the second element of the pair.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_sup_iInf {\u03b9 \u03b9' : Type _} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} :\n    ((\u2a05 i, f i) \u2294 \u2a05 i, g i) = \u2a05 i : \u03b9 \u00d7 \u03b9', f i.1 \u2294 g i.2 :="}
{"input": "Statement in natural language:\nFor any box 'I' and any finite set 's' of pairs of '\u03b9' and real numbers, the function 'splitMany' applied to 'I' and 's' results in a partition.\nTranslate the statement in natural language to Lean:", "output": "theorem isPartition_splitMany (I : Box \u03b9) (s : Finset (\u03b9 \u00d7 \u211d)) : IsPartition (splitMany I s) :="}
{"input": "Statement in natural language:\n'a' is the minimum value of the function 'f' under the filter 'l' in the dual order if and only if 'a' is the maximum value of the function 'f' under the filter 'l' in the original order.\nTranslate the statement in natural language to Lean:", "output": "theorem isMinFilter_dual_iff : IsMinFilter (toDual \u2218 f) l a \u2194 IsMaxFilter f l a :="}
{"input": "Statement in natural language:\nThe grade of 'a' is equal to the grade of 'b' if and only if 'a' is equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem grade_eq_grade_iff : grade \ud835\udd46 a = grade \ud835\udd46 b \u2194 a = b :="}
{"input": "Statement in natural language:\nFor any element 's' in set 'S', the function 'mk'' with parameters 'f' and '0' and 's' equals to '0'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk'_zero (s : S) : mk' f 0 s = 0 :="}
{"input": "Statement in natural language:\nIf a function 'f' is strictly decreasing (StrictAnti f), and a constant 'a' is greater than zero (0 < a), then the function that multiplies 'a' with the output of 'f' for any input 'x' (fun x => a * f x) is also strictly decreasing (StrictAnti).\nTranslate the statement in natural language to Lean:", "output": "theorem StrictAnti.const_mul (hf : StrictAnti f) (ha : 0 < a) : StrictAnti fun x => a * f x :="}
{"input": "Statement in natural language:\nA vertex 'v' is in the component complement 'C' of a graph 'G' and a set 'K' if and only if there exists a condition where 'v' is not in 'K' and the component complement of 'G' with respect to this condition equals 'C'.\nTranslate the statement in natural language to Lean:", "output": "theorem ComponentCompl.mem_supp_iff {v : V} {C : ComponentCompl G K} :\n    v \u2208 C \u2194 \u2203 vK : v \u2209 K, G.componentComplMk vK = C :="}
{"input": "Statement in natural language:\nFor any two structure-preserving functions 'f' from M to N and 'g' from N to P, the range of the composition of 'g' and 'f' (from M to P) is equal to the image of the range of 'f' under 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem range_comp (f : M \u2192[L] N) (g : N \u2192[L] P) : range (g.comp f : M \u2192[L] P) = map g (range f) :="}
{"input": "Statement in natural language:\nFor any additive monoid A, any element x of A, and any natural number n, the application of the multiples homomorphism on x and n is equal to n times x.\nTranslate the statement in natural language to Lean:", "output": "theorem multiplesHom_apply [AddMonoid A] (x : A) (n : \u2115) : multiplesHom A x n = n \u2022 x :="}
{"input": "Statement in natural language:\nFor any objects X and Y in category C, and any subobject P of Y, if P factors through the sum of two morphisms f and g from X to Y, and P also factors through each of f and g individually, then the morphism factoring P through the sum of f and g is equal to the sum of the morphisms factoring P through f and g individually.\nTranslate the statement in natural language to Lean:", "output": "theorem factorThru_add {X Y : C} {P : Subobject Y} (f g : X \u27f6 Y) (w : P.Factors (f + g))\n    (wf : P.Factors f) (wg : P.Factors g) :\n    P.factorThru (f + g) w = P.factorThru f wf + P.factorThru g wg :="}
{"input": "Statement in natural language:\nFor any set 's' of type '\u03b9', and any two functions 'f' and 'g' from '\u03b9' to '\u03b1' and '\u03b2' respectively, if '\u03b9' is a subsingleton (i.e., a set with at most one element), then 'f' and 'g' are monovariant on 's'. This means that the order of the values of 'f' and 'g' is preserved when applied to any two elements in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem Subsingleton.monovaryOn [Subsingleton \u03b9] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) (s : Set \u03b9) :\n    MonovaryOn f g s :="}
{"input": "Statement in natural language:\nThe second element of the homological complex created by the function 'mk' with inputs X\u2080, X\u2081, X\u2082, d\u2080, d\u2081, s, and succ is equal to X\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_X_2 : (mk X\u2080 X\u2081 X\u2082 d\u2080 d\u2081 s succ).X 2 = X\u2082 :="}
{"input": "Statement in natural language:\nFor any three types \u03b1, \u03b2, and \u03b3 that are primcodable, and for any properties p of \u03b1, q of \u03b2, and r of \u03b3, if p and q are one-one equivalent, then p is one-one equivalent to r if and only if q is one-one equivalent to r.\nTranslate the statement in natural language to Lean:", "output": "theorem OneOneEquiv.congr_left {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : OneOneEquiv p q) :\n    OneOneEquiv p r \u2194 OneOneEquiv q r :="}
{"input": "Statement in natural language:\nFor a measure \u03bc on a set \u03b1, where \u03bc is a finite measure, and a non-negative real number r, the signed measure of r times \u03bc is equal to r times the signed measure of \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem toSignedMeasure_smul (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (r : \u211d\u22650) :\n    (r \u2022 \u03bc).toSignedMeasure = r \u2022 \u03bc.toSignedMeasure :="}
{"input": "Statement in natural language:\nFor a monic polynomial 'g' and a finite sequence 'c' of coefficients in a ring 'R', the inverse representation of the power basis of 'g' applied to 'c' is equal to the polynomial 'g' constructed from the sum of monomials with coefficients from 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem powerBasisAux'_repr_symm_apply (hg : g.Monic) (c : Fin g.natDegree \u2192\u2080 R) :\n    (powerBasisAux' hg).repr.symm c = mk g (\u2211 i : Fin _, monomial i (c i)) :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, given a function 'g' from \u03b1 to \u03b2, a function 'q' from a finite set of size 'n' to \u03b1, and an element 'y' of type \u03b1, the composition of 'g' and the function 'snoc q y' (which appends 'y' to the end of the sequence defined by 'q') is equal to the function 'snoc (g \u2218 q) (g y)' (which appends 'g y' to the end of the sequence defined by 'g \u2218 q').\nTranslate the statement in natural language to Lean:", "output": "theorem comp_snoc {\u03b1 : Type _} {\u03b2 : Type _} (g : \u03b1 \u2192 \u03b2) (q : Fin n \u2192 \u03b1) (y : \u03b1) :\n    g \u2218 snoc q y = snoc (g \u2218 q) (g y) :="}
{"input": "Statement in natural language:\nFor a given condition where a\u2081 is less than b\u2081, the closed interval from a\u2081 to b\u2081 is a subset of the closed interval from a\u2082 to b\u2082 if and only if a\u2082 is less than or equal to a\u2081 and b\u2081 is less than or equal to b\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem Ico_subset_Ico_iff (h\u2081 : a\u2081 < b\u2081) : Ico a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082 :="}
{"input": "Statement in natural language:\nFor any non-zero element 'a' in a group with zero 'G\u2080', the function that multiplies 'a' to any element 'g' in the group is surjective. This means that for every element in the group, there is at least one element 'g' such that when 'g' is multiplied by 'a', that element is obtained.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_right_surjective\u2080 {a : G\u2080} (h : a \u2260 0) : Surjective fun g => g * a :="}
{"input": "Statement in natural language:\nThe restriction of the zero polynomial in the ring of polynomials over R is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem restriction_zero : restriction (0 : R[X]) = 0 :="}
{"input": "Statement in natural language:\nThe integral of a function f over a circle with radius zero centered at a complex number c is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_radius_zero (f : \u2102 \u2192 E) (c : \u2102) : (\u222e z in C(c, 0), f z) = 0 :="}
{"input": "Statement in natural language:\nFor any power series \u03c6 over a ring R, \u03c6 is equal to the product of a new power series (whose coefficients are the coefficients of \u03c6 shifted by one index) and the variable X, plus the constant term of \u03c6.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_shift_mul_X_add_const (\u03c6 : PowerSeries R) :\n    \u03c6 = (mk fun p => coeff R (p + 1) \u03c6) * X + C R (constantCoeff R \u03c6) :="}
{"input": "Statement in natural language:\nFor a given multi-index 'n', the coefficient of the multivariate power series of the ring 'R' at 'n' for the series '\u03c6' when coerced is equal to the coefficient of '\u03c6' at 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_coe (n : \u03c3 \u2192\u2080 \u2115) : MvPowerSeries.coeff R n \u2191\u03c6 = coeff n \u03c6 :="}
{"input": "Statement in natural language:\nFor any given type F, if R and S are rings, S is a domain, and F is a class of ring homomorphisms from R to S, then for any ring homomorphism f from R to S, the kernel of f is a prime ideal.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_isPrime {F : Type _} [Ring R] [Ring S] [IsDomain S] [RingHomClass F R S] (f : F) :\n    (ker f).IsPrime :="}
{"input": "Statement in natural language:\nFor a bilinear map B from n-dimensional vectors to m-dimensional vectors over a ring R, and a matrix M with m rows and m' columns over the ring R, the matrix multiplication of the matrix representation of B and M is equal to the matrix representation of the composition of B and the linear map represented by M.\nTranslate the statement in natural language to Lean:", "output": "theorem LinearMap.toMatrix\u2082'_mul (B : (n \u2192 R) \u2192\u2097[R] (m \u2192 R) \u2192\u2097[R] R) (M : Matrix m m' R) :\n    toMatrix\u2082' B \u2b1d M = toMatrix\u2082' (B.compl\u2082 <| toLin' M) :="}
{"input": "Statement in natural language:\nFor any centroid homomorphism 'f' of a type '\u03b1', the composition of 'f' with the identity centroid homomorphism of '\u03b1' is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_id (f : CentroidHom \u03b1) : f.comp (CentroidHom.id \u03b1) = f :="}
{"input": "Statement in natural language:\nFor a given element 'a' in a topological space, if there exists an element 'b' that is less than 'a', then the neighborhood within the set of all elements less than 'a' has a basis consisting of the open intervals (\u00b7, a) where the left endpoint is less than 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem nhdsWithin_Iio_basis' {a : \u03b1} (h : \u2203 b, b < a) : (\ud835\udcdd[<] a).HasBasis (\u00b7 < a) (Ioo \u00b7 a) :="}
{"input": "Statement in natural language:\nThe intersection of the set of all numbers greater than 'a' and the set of all numbers less than 'b' is equal to the set of all numbers between 'a' and 'b' (exclusive).\nTranslate the statement in natural language to Lean:", "output": "theorem Ioi_inter_Iio : Ioi a \u2229 Iio b = Ioo a b :="}
{"input": "Statement in natural language:\nThe rounded value of the negative reciprocal of 2 is equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem round_neg_two_inv : round (-2\u207b\u00b9 : \u03b1) = 0 :="}
{"input": "Statement in natural language:\nIf 'a' is less than 'b' and 'b' is less than 'c', then the union of the interval from 'a' to 'b' (inclusive of 'b' and exclusive of 'a') and the interval from 'b' to 'c' (inclusive of 'b' and exclusive of 'c') is equal to the interval from 'a' to 'c' (exclusive of both 'a' and 'c').\nTranslate the statement in natural language to Lean:", "output": "theorem Ioc_union_Ico_eq_Ioo (h\u2081 : a < b) (h\u2082 : b < c) : Ioc a b \u222a Ico b c = Ioo a c :="}
{"input": "Statement in natural language:\nIf graph G is preconnected and graph H is preconnected, then the Cartesian product of G and H (denoted as G \u25a1 H) is also preconnected.\nTranslate the statement in natural language to Lean:", "output": "theorem Preconnected.boxProd (hG : G.Preconnected) (hH : H.Preconnected) :\n    (G \u25a1 H).Preconnected :="}
{"input": "Statement in natural language:\nThe norm of the adjoint auxiliary of a linear map A from E to F is equal to the norm of A itself.\nTranslate the statement in natural language to Lean:", "output": "theorem adjointAux_norm (A : E \u2192L[\ud835\udd5c] F) : \u2016adjointAux A\u2016 = \u2016A\u2016 :="}
{"input": "Statement in natural language:\nThe function that maps each element of a set \u03b1 to its connected component is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_coe : Continuous (mk : \u03b1 \u2192 ConnectedComponents \u03b1) :="}
{"input": "Statement in natural language:\nThere exists a sequence of rational numbers that converges to a Cauchy sequence under the p-adic norm.\nTranslate the statement in natural language to Lean:", "output": "theorem exi_rat_seq_conv_cauchy : IsCauSeq (padicNorm p) (limSeq f) :="}
{"input": "Statement in natural language:\nFor any three partial natural numbers x, y, and z, where z is not infinity, x plus z is less than y plus z if and only if x is less than y.\nTranslate the statement in natural language to Lean:", "output": "theorem add_lt_add_iff_right {x y z : PartENat} (hz : z \u2260 \u22a4) : x + z < y + z \u2194 x < y :="}
{"input": "Statement in natural language:\nFor any list of elements of type \u03b1 and any binary relation r on \u03b1, if r is reflexive (meaning that every element is related to itself) and for all distinct elements a and b in the list, a is related to b by r, then the list is pairwise related by r.\nTranslate the statement in natural language to Lean:", "output": "theorem pairwise_of_reflexive_of_forall_ne {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r)\n    (h : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2260 b \u2192 r a b) : l.Pairwise r :="}
{"input": "Statement in natural language:\nFor two functions 'f' and 'g' that are equivalences between two types '\u03b1' and '\u03b2', if 'f' is equal to 'g', then the result of applying 'f' to any element 'x' of type '\u03b1' is equal to the result of applying 'g' to the same 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem congr_fun {f g : Equiv \u03b1 \u03b2} (h : f = g) (x : \u03b1) : f x = g x :="}
{"input": "Statement in natural language:\nFor any ordinal number 'o', the ordinal of the aleph function of 'o' is a limit ordinal.\nTranslate the statement in natural language to Lean:", "output": "theorem ord_aleph_isLimit (o : Ordinal) : (aleph o).ord.IsLimit :="}
{"input": "Statement in natural language:\nFor any topological space E that is also a T1 space, if x is not equal to y, then there exists a continuous linear map f from E to the real numbers such that f(x) is less than f(y).\nTranslate the statement in natural language to Lean:", "output": "theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x \u2260 y) :\n    \u2203 f : E \u2192L[\u211d] \u211d, f x < f y :="}
{"input": "Statement in natural language:\nThe transformation of a bilinear form to a matrix using the basis function in the domain R\u2082 with dimension n is equal to the transformation of the bilinear form to a matrix using the prime transformation.\nTranslate the statement in natural language to Lean:", "output": "theorem BilinForm.toMatrix_basisFun :\n    BilinForm.toMatrix (Pi.basisFun R\u2082 n) = BilinForm.toMatrix' :="}
{"input": "Statement in natural language:\nIf there is a function 'f' that is surjective (or onto, meaning every element in the range is mapped to by at least one element in the domain) and the domain '\u03b1' is a subsingleton (a set with at most one element), then the range '\u03b2' is also a subsingleton.\nTranslate the statement in natural language to Lean:", "output": "theorem Surjective.subsingleton [Subsingleton \u03b1] (hf : Surjective f) : Subsingleton \u03b2 :="}
{"input": "Statement in natural language:\nFor any two kernels \u03ba and \u03b7, the function application of their sum is equal to their sum.\nTranslate the statement in natural language to Lean:", "output": "theorem coeFn_add (\u03ba \u03b7 : kernel \u03b1 \u03b2) : \u21d1(\u03ba + \u03b7) = \u03ba + \u03b7 :="}
{"input": "Statement in natural language:\nFor any dual number of a quaternion over a ring R, the second imaginary part of the inverse of the dual number equivalence of the dual number is equal to the second imaginary part of the second part of the dual number.\nTranslate the statement in natural language to Lean:", "output": "theorem snd_imK_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imK.snd = d.snd.imK :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2', if 'f' is injective (meaning it never maps distinct elements of '\u03b1' to the same element of '\u03b2'), then the function that maps a set 's' to its preimage under 'f' is monotone (meaning that if 's' is a subset of 't', then the preimage of 's' under 'f' is a subset of the preimage of 't' under 'f').\nTranslate the statement in natural language to Lean:", "output": "theorem monotone_preimage {f : \u03b1 \u2192 \u03b2} (h : Injective f) :\n    Monotone fun s => preimage s f (h.injOn _) :="}
{"input": "Statement in natural language:\nFor a given Baer module 'h' over a ring 'R' and a field 'Q', and for any element 'y' of a set 'N', if 'x' is a supremum extension of the maximum singleton 'i' and a function 'f' at 'y', and 'a' is an element of the domain of the extension of the maximum 'i' and function 'f', and 'r' is an element of the ring 'R', and if the element 'x' is equal to the element 'a' plus the scalar multiplication of 'r' and 'y', then the extension to function of the maximum adjoin 'i' and function 'f' at 'x' is equal to the linear map of the extension of the maximum 'i' and function 'f' at 'a' plus the extension of the ideal to the maximum adjoin 'i' and function 'f' at 'y' and 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem ExtensionOfMaxAdjoin.extensionToFun_wd (h : Module.Baer R Q) {y : N}\n    (x : supExtensionOfMaxSingleton i f y) (a : (extensionOfMax i f).domain)\n    (r : R) (eq1 : \u2191x = \u2191a + r \u2022 y) :\n    ExtensionOfMaxAdjoin.extensionToFun i f h x =\n      (extensionOfMax i f).toLinearPMap a + ExtensionOfMaxAdjoin.extendIdealTo i f h y r :="}
{"input": "Statement in natural language:\nIf a function F, which maps from a set X to a set \u03b1, tends to a function f under a filter l, and if F is equicontinuous at a point x\u2080 in X, then the function f is continuous at the point x\u2080. This theorem assumes that the filter l is not the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.continuousAt_of_equicontinuousAt {l : Filter \u03b9} [l.NeBot] {F : \u03b9 \u2192 X \u2192 \u03b1}\n    {f : X \u2192 \u03b1} {x\u2080 : X} (h\u2081 : Tendsto F l (\ud835\udcdd f)) (h\u2082 : EquicontinuousAt F x\u2080) :\n    ContinuousAt f x\u2080 :="}
{"input": "Statement in natural language:\nFor a ring homomorphism 'f' from ring 'R' to ring 'S\u2082', and a multivariate polynomial 'p' over the ring 'R' and variables '\u03c3', the evaluation of 'p' at zero using 'f' is equal to the application of 'f' to the constant coefficient of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem eval\u2082_zero_apply (f : R \u2192+* S\u2082) (p : MvPolynomial \u03c3 R) :\n    eval\u2082 f (0 : \u03c3 \u2192 S\u2082) p = f (constantCoeff p) :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from set R to set S, and this function is monotone (meaning it either always increases or always decreases), and we have a sequence 'a' in set R, and the function 'f' is continuous at the least upper bound of the sequence 'a', then the value of the function 'f' at the least upper bound of the sequence 'a' is equal to the least upper bound of the sequence obtained by applying the function 'f' to each element of the sequence 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem Monotone.map_limsup_of_continuousAt {f : R \u2192 S} (f_incr : Monotone f) (a : \u03b9 \u2192 R)\n    (f_cont : ContinuousAt f (F.limsup a)) : f (F.limsup a) = F.limsup (f \u2218 a) :="}
{"input": "Statement in natural language:\nIf we have a finite measure \u03bc, a real number p that is greater than or equal to 1 and not infinity, a sequence of strongly measurable functions f indexed by natural numbers, and a strongly measurable function g such that g belongs to Lp space and the sequence of functions f is uniformly integrable with respect to p and \u03bc. Moreover, for almost every x with respect to the measure \u03bc, the sequence of functions f evaluated at x tends to the function g evaluated at x. Then, the sequence of the pth power norm of the difference between the functions f and g tends to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e)\n    {f : \u2115 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2} (hf : \u2200 n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)\n    (hg' : Mem\u2112p g p \u03bc) (hui : UnifIntegrable f p \u03bc)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) :\n    Tendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nFor a given permutation 'f' and any two elements 'x' and 'y', the operation of swapping 'x' and 'y' and then applying 'f' is equivalent to applying 'f' first and then swapping the images of 'x' and 'y' under the inverse of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem swap_mul_eq_mul_swap (f : Perm \u03b1) (x y : \u03b1) : swap x y * f = f * swap (f\u207b\u00b9 x) (f\u207b\u00b9 y) :="}
{"input": "Statement in natural language:\nFor any function 'f' from a set '\u03b1' to a set '\u03b2', where '\u03b2' has a preorder and a zero element, and 'f' is almost everywhere measurable with respect to a measure '\u03bc', and 'f' is nonnegative almost everywhere with respect to '\u03bc', there exists a function 'g' that is measurable, nonnegative, and equal to 'f' almost everywhere with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_measurable_nonneg {\u03b2} [Preorder \u03b2] [Zero \u03b2] {m\u03b2 : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (hf : AEMeasurable f \u03bc) (f_nn : \u2200\u1d50 t \u2202\u03bc, 0 \u2264 f t) : \u2203 g, Measurable g \u2227 0 \u2264 g \u2227 f =\u1d50[\u03bc] g :="}
{"input": "Statement in natural language:\nFor a given natural number 'n', a real number '\u03b5' greater than 0, and a non-zero polynomial 'b' over a finite field 'Fq', and a function 'A' mapping from 'n' finite elements to polynomials over 'Fq', there exists a function 't' mapping from 'n' finite elements to finite elements of the cardinality of 'Fq' raised to the ceiling of the negative logarithm of '\u03b5' divided by the logarithm of the cardinality of 'Fq'. For this function 't', for any two finite elements 'i\u2080' and 'i\u2081' of 'n', 't' of 'i\u2080' equals 't' of 'i\u2081' if and only if the real number representation of the degree of the polynomial obtained by subtracting the remainder of 'A' of 'i\u2080' divided by 'b' from the remainder of 'A' of 'i\u2081' divided by 'b', raised to the power of the cardinality of 'Fq', is less than the degree of 'b' raised to the power of the cardinality of 'Fq' multiplied by '\u03b5'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_partition_polynomial_aux (n : \u2115) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : Fq[X]} (hb : b \u2260 0)\n    (A : Fin n \u2192 Fq[X]) : \u2203 t : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log (Fintype.card Fq)\u2309\u208a),\n      \u2200 i\u2080 i\u2081 : Fin n, t i\u2080 = t i\u2081 \u2194\n        (cardPowDegree (A i\u2081 % b - A i\u2080 % b) : \u211d) < cardPowDegree b \u2022 \u03b5 :="}
{"input": "Statement in natural language:\nFor a countable index set \u03b9, if every set f(b) indexed by b is measurable, then the intersection of all these sets f(b) is also measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem MeasurableSet.iInter [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} (h : \u2200 b, MeasurableSet (f b)) :\n    MeasurableSet (\u22c2 b, f b) :="}
{"input": "Statement in natural language:\nThe map of the inclusion of N into the preimage (under the inclusion of N) of N' is equal to the intersection of N and N'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_comap_incl : map N.incl (comap N.incl N') = N \u2293 N' :="}
{"input": "Statement in natural language:\nFor a given value 'x' in the field '\ud835\udd5c', the function 'aeval x q' has a derivative within the set 's' at the point 'x'. The derivative is given by the function 'smulRight' applied to the number 1 (considered as a continuous linear map from '\ud835\udd5c' to '\ud835\udd5c') and the result of applying 'aeval x' to the derivative of 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFDerivWithinAt_aeval (x : \ud835\udd5c) :\n    HasFDerivWithinAt (fun x => aeval x q) (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c)\n      (aeval x (derivative q))) s x :="}
{"input": "Statement in natural language:\nFor any integer n, the open intervals from b to the power of n to b to the power of n+1 are pairwise disjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem pairwise_disjoint_Ioo_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ioo (b ^ n) (b ^ (n + 1))) :="}
{"input": "Statement in natural language:\nFor a functor 'F' from category 'C' to category 'D' and an object 'X' in category 'C', the mapping of the identity isomorphism of 'X' under 'F' is equal to the identity isomorphism of the image of 'X' under 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem mapIso_refl (F : C \u2964 D) (X : C) : F.mapIso (Iso.refl X) = Iso.refl (F.obj X) :="}
{"input": "Statement in natural language:\nFor a given setoid 't' of type '\u03b2', a function 'f' from '\u03b1' to '\u03b2', a proof 'h', and an element 'x' of type '\u03b1', mapping 'f' over the quotient of 'x' under the equivalence relation 's' is equal to the quotient of the image of 'x' under 'f' under the equivalence relation 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem map'_mk [t : Setoid \u03b2] (f : \u03b1 \u2192 \u03b2) (h) (x : \u03b1) :\n    (Quotient.mk s x).map' f h = (Quotient.mk t (f x)) :="}
{"input": "Statement in natural language:\nIf a convex cone S is blunt, then S is also salient.\nTranslate the statement in natural language to Lean:", "output": "theorem Blunt.salient {S : ConvexCone \ud835\udd5c E} : S.Blunt \u2192 S.Salient :="}
{"input": "Statement in natural language:\nGiven a prime ideal I, such that I is a subset of J, and a ring element r that belongs to the set difference of J and I, if the polynomial p mapped by the quotient of the preimage of f is not zero and the evaluation of p at r using f is in I, then there exists a coefficient i of p such that i belongs to the set difference of the preimage of J under f and the preimage of I under f.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff [IsPrime I] (hIJ : I \u2264 J) {r : S}\n    (hr : r \u2208 (J : Set S) \\ I) {p : R[X]} (p_ne_zero : p.map (Quotient.mk (I.comap f)) \u2260 0)\n    (hpI : p.eval\u2082 f r \u2208 I) : \u2203 i, p.coeff i \u2208 (J.comap f : Set R) \\ I.comap f :="}
{"input": "Statement in natural language:\nFor a given filter 'l' and a function 'f' from '\u03b1' to 'WeakBilin B', and a 'WeakBilin B' 'x', if 'B' is a function that is injective, then 'f' tends to 'x' with respect to the filter 'l' if and only if for all 'y', the function that maps 'i' to 'B' of 'f' of 'i' and 'y' tends to 'B' of 'x' and 'y' with respect to the filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_iff_forall_eval_tendsto {l : Filter \u03b1} {f : \u03b1 \u2192 WeakBilin B} {x : WeakBilin B}\n    (hB : Function.Injective B) :\n    Tendsto f l (\ud835\udcdd x) \u2194 \u2200 y, Tendsto (fun i => B (f i) y) l (\ud835\udcdd (B x y)) :="}
{"input": "Statement in natural language:\nFor all properties 'p' of an element '\u03b1' and 'q' of an element '\u03b2', and given a bijective function 'f' from '\u03b1' to '\u03b2', if for all 'x', 'p' of the inverse of 'f' at 'x' is equivalent to 'q' at 'x', then the statement \"for all 'x', 'p' of 'x' is true\" is equivalent to the statement \"for all 'y', 'q' of 'y' is true\".\nTranslate the statement in natural language to Lean:", "output": "theorem forall_congr' {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2)\n    (h : \u2200 {x}, p (f.symm x) \u2194 q x) : (\u2200 x, p x) \u2194 \u2200 y, q y :="}
{"input": "Statement in natural language:\nThe function 'circleMap' with parameters 'c' (a complex number) and 'R' (a real number) is periodic with a period of '2 * \u03c0'.\nTranslate the statement in natural language to Lean:", "output": "theorem periodic_circleMap (c : \u2102) (R : \u211d) : Periodic (circleMap c R) (2 * \u03c0) :="}
{"input": "Statement in natural language:\nIf a sequence of functions 'u' is summable, and for all 'n' and 'x', the function 'f n' has a derivative at 'x' given by 'f' n x', and the norm of 'f' n x' is less than or equal to 'u n', then the function defined by the sum of 'f n y' for all 'n' is differentiable.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiable_tsum (hu : Summable u) (hf : \u2200 n x, HasFDerivAt (f n) (f' n x) x)\n    (hf' : \u2200 n x, \u2016f' n x\u2016 \u2264 u n) : Differentiable \ud835\udd5c fun y => \u2211' n, f n y :="}
{"input": "Statement in natural language:\nThe product of replicating a number 'a' 'n' times is equal to 'a' raised to the power of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_replicate (n : \u2115) (a : \u03b1) : (replicate n a).prod = a ^ n :="}
{"input": "Statement in natural language:\nIf function f is Big O of g with respect to l and a constant c, and g is little o of k with respect to l, and if c is greater than 0, then f is little o of k with respect to l.\nTranslate the statement in natural language to Lean:", "output": "theorem IsBigOWith.trans_isLittleO (hfg : IsBigOWith c l f g) (hgk : g =o[l] k) (hc : 0 < c) :\n    f =o[l] k :="}
{"input": "Statement in natural language:\nFor a given natural number 'n' and a given element 'x' of the finite set of size 'n+1', the function 'succAbove' applied to 'x' is equal for 'a' and 'b' if and only if 'a' is equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem succAbove_right_inj {x : Fin (n + 1)} : x.succAbove a = x.succAbove b \u2194 a = b :="}
{"input": "Statement in natural language:\nFor any natural number 'n' greater than 0, the predecessor of 'n' in the set of positive natural numbers is equal to the predecessor of 'n' in the set of all natural numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem natPred_eq_pred {n : \u2115} (h : 0 < n) : natPred (\u27e8n, h\u27e9 : \u2115+) = n.pred :="}
{"input": "Statement in natural language:\nIf we have a set with seminorms 'p', and for every non-zero element 'x' there exists an 'i' such that the seminorm of 'x' with respect to 'i' is not zero, then the topological space 'E' is a T1 space.\nTranslate the statement in natural language to Lean:", "output": "theorem WithSeminorms.T1_of_separating (hp : WithSeminorms p)\n    (h : \u2200 x, x \u2260 0 \u2192 \u2203 i, p i x \u2260 0) : T1Space E :="}
{"input": "Statement in natural language:\nFor a quasi measure preserving function 'f' from '\u03b1' to '\u03b2', and two functions 'g' and 'g'' from '\u03b2' to '\u03b4', if 'g' is almost everywhere equal to 'g'' with respect to measure '\u03bd', then the composition of 'g' and 'f' is almost everywhere equal to the composition of 'g'' and 'f' with respect to measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem Measure.QuasiMeasurePreserving.ae_eq_comp {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {g g' : \u03b2 \u2192 \u03b4}\n    (hf : QuasiMeasurePreserving f \u03bc \u03bd) (h : g =\u1d50[\u03bd] g') : g \u2218 f =\u1d50[\u03bc] g' \u2218 f :="}
{"input": "Statement in natural language:\nThe degree of a monomial with a natural number 'n' and a coefficient 'a' from the ring 'R' is less than or equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_monomial_le (n : \u2115) (a : R) : degree (monomial n a) \u2264 n :="}
{"input": "Statement in natural language:\nFor a nonempty set A and a finite set B, with m and n as natural numbers, the cardinality of the set obtained by raising B to the power m and then dividing by B raised to the power n, is less than or equal to the cardinality of the set obtained by multiplying A and B, divided by the cardinality of A, all raised to the power of m plus n, and then multiplied by the cardinality of A. This is expressed in terms of nonnegative rational numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem card_pow_div_pow_le (hA : A.Nonempty) (B : Finset \u03b1) (m n : \u2115) :\n    ((B ^ m / B ^ n).card) \u2264 ((A * B).card / A.card : \u211a\u22650) ^ (m + n) * A.card :="}
{"input": "Statement in natural language:\n'p' is a prime number in the p-adic integers.\nTranslate the statement in natural language to Lean:", "output": "theorem prime_p : Prime (p : \u2124_[p]) :="}
{"input": "Statement in natural language:\nThe real number r is less than or equal to the real number q if and only if the non-negative extended real number representation of r is less than or equal to the non-negative extended real number representation of q.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_le_coe : (\u2191r : \u211d\u22650\u221e) \u2264 \u2191q \u2194 r \u2264 q :="}
{"input": "Statement in natural language:\nIf a is not infinity and b is not zero, then there exists a positive real number n such that the product of n and a is less than b.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_nnreal_pos_mul_lt (ha : a \u2260 \u221e) (hb : b \u2260 0) : \u2203 n > 0, \u2191(n : \u211d\u22650) * a < b :="}
{"input": "Statement in natural language:\nFor a summable function 'f' and a constant 'a' from a topological space 'M' that is also a T2 space (also known as a Hausdorff space), the infinite sum of the product of the function 'f' evaluated at 'z' and the constant 'a' is equal to the product of the infinite sum of the function 'f' evaluated at 'z' and the constant 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_smul_const [T2Space M] (hf : Summable f) (a : M) : (\u2211' z, f z \u2022 a) = (\u2211' z, f z) \u2022 a :="}
{"input": "Statement in natural language:\nFor a given ring homomorphism 'j' from ring 'L' to ring 'F', and a given polynomial 'f' over ring 'K', the polynomial 'f' splits over 'j' after mapping with 'i' if and only if 'f' splits over the composition of 'j' and 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem splits_map_iff (j : L \u2192+* F) {f : K[X]} : Splits j (f.map i) \u2194 Splits (j.comp i) f :="}
{"input": "Statement in natural language:\nIf \u03b2 is a topological space and a T0 space, and if there is an embedding function f from \u03b1 to \u03b2, then \u03b1 is also a T0 space.\nTranslate the statement in natural language to Lean:", "output": "theorem Embedding.t0Space [TopologicalSpace \u03b2] [T0Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Embedding f) : T0Space \u03b1 :="}
{"input": "Statement in natural language:\nFor a given path 'p' from point 'a' to point 'b', the composition function 'p.comp' (which takes a path from 'b' to 'c' and returns a path from 'a' to 'c') is injective. In other words, if two paths from 'b' to 'c' are mapped to the same path from 'a' to 'c' by the composition function, then those two paths must have been the same to begin with.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_injective_right (p : Path a b) : Injective (p.comp : Path b c \u2192 Path a c) :="}
{"input": "Statement in natural language:\nFor a function g from \u03b1 to \ud835\udd5c and a non-zero constant c from \ud835\udd5c, the function f is Big O of the function that multiplies c and g at limit l if and only if the function f is Big O of g at limit l.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigO_const_mul_right_iff {g : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (f =O[l] fun x => c * g x) \u2194 f =O[l] g :="}
{"input": "Statement in natural language:\nFor a polynomial 'p' in field 'K', the numerator of the algebraic mapping of 'p' is equal to 'p' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem num_algebraMap (p : K[X]) : num (algebraMap _ _ p) = p :="}
{"input": "Statement in natural language:\nThe arccosine of a real number x is less than pi divided by 2 if and only if x is greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem arccos_lt_pi_div_two {x : \u211d} : arccos x < \u03c0 / 2 \u2194 0 < x :="}
{"input": "Statement in natural language:\nFor a bilinear form B over a field K and a vector space V, if B is nondegenerate and reflexive, and a vector x is not orthogonal to itself, then the restriction of B to the orthogonal complement of the span of x is also nondegenerate.\nTranslate the statement in natural language to Lean:", "output": "theorem restrictOrthogonalSpanSingletonNondegenerate (B : BilinForm K V) (b\u2081 : B.Nondegenerate)\n    (b\u2082 : B.IsRefl) {x : V} (hx : \u00acB.IsOrtho x x) :\n    Nondegenerate <| B.restrict <| B.orthogonal (K \u2219 x) :="}
{"input": "Statement in natural language:\nFor a finite subgroup H, the cardinality of H is less than or equal to 1 if and only if H is the trivial group.\nTranslate the statement in natural language to Lean:", "output": "theorem card_le_one_iff_eq_bot [Fintype H] : Fintype.card H \u2264 1 \u2194 H = \u22a5 :="}
{"input": "Statement in natural language:\nFor a partially ordered set with a least element (denoted as \u22a5), the interval from the least element to any given element is equal to the set containing only the least element.\nTranslate the statement in natural language to Lean:", "output": "theorem Iic_bot [PartialOrder \u03b1] [OrderBot \u03b1] : Iic (\u22a5 : \u03b1) = {\u22a5} :="}
{"input": "Statement in natural language:\nIf function f has a local minimum at a point a and function g also has a local minimum at the same point a, then the function that takes the minimum of f(x) and g(x) for each x also has a local minimum at point a.\nTranslate the statement in natural language to Lean:", "output": "theorem IsLocalMin.min (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\n    IsLocalMin (fun x => min (f x) (g x)) a :="}
{"input": "Statement in natural language:\nA function 'x' tends to a filter 'f' along a filter 'l' if and only if for every set 's' in the filter 'f', eventually for every 'n' in the filter 'l', 'x n' is an element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_iff_forall_eventually_mem {x : \u03b9 \u2192 \u03b1} {f : Filter \u03b1} {l : Filter \u03b9} :\n    Tendsto x l f \u2194 \u2200 s \u2208 f, \u2200\u1da0 n in l, x n \u2208 s :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' from an ordered set '\u03b2', the inequality 'a' is less than 'b' is equivalent to the inequality 'inr a' is less than 'inr b' in the sum of two ordered sets '\u03b1' and '\u03b2'. Here, 'inr' is a function that injects '\u03b2' into the sum '\u03b1 + \u03b2'.\nTranslate the statement in natural language to Lean:", "output": "theorem inr_lt_inr_iff [LT \u03b1] [LT \u03b2] {a b : \u03b2} : (inr a : Sum \u03b1 \u03b2) < inr b \u2194 a < b :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'a' and 'b', if 'a' divides 'b' and the quotient of 'b' divided by 'a' is zero, then 'b' must be zero.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_zero_of_dvd_of_div_eq_zero {a b : \u2115} (w : a \u2223 b) (h : b / a = 0) : b = 0 :="}
{"input": "Statement in natural language:\nFor any integers x and y, the value of the auxiliary extended greatest common divisor function (xgcdAux) with parameters x, 1, 0, y, 0, 1 is equal to the pair consisting of the greatest common divisor of x and y, and the result of the extended greatest common divisor function (xgcd) on x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem xgcd_aux_val (x y) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y) :="}
{"input": "Statement in natural language:\nFor any given measure \u03bc, the function that maps every element of \u03b1 to 1 in \u03b2 is equal to the function that strongly measures the constant 1. This is under the condition that \u03b2 has a defined operation of 1.\nTranslate the statement in natural language to Lean:", "output": "theorem one_def [One \u03b2] : (1 : \u03b1 \u2192\u2098[\u03bc] \u03b2) = mk (fun _ : \u03b1 => 1) aestronglyMeasurable_const :="}
{"input": "Statement in natural language:\nFor a covariant class \u03b1 with respect to multiplication and less than or equal to relation, if a is less than or equal to d, b is less than or equal to e, and c is less than or equal to f, then the product of a, b, and c is less than or equal to the product of d, e, and f.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_le_mul_three [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d e f : \u03b1} (h\u2081 : a \u2264 d) (h\u2082 : b \u2264 e)\n    (h\u2083 : c \u2264 f) :\n    a * b * c \u2264 d * e * f :="}
{"input": "Statement in natural language:\nThe zero locus of the supremum of a collection of ideals (indexed by \u03b9) is equal to the intersection of the zero loci of each individual ideal in the collection.\nTranslate the statement in natural language to Lean:", "output": "theorem zeroLocus_iSup {\u03b9 : Sort _} (I : \u03b9 \u2192 Ideal R) :\n    zeroLocus ((\u2a06 i, I i : Ideal R) : Set R) = \u22c2 i, zeroLocus (I i) :="}
{"input": "Statement in natural language:\nFor a nonempty set \u03b1 and an element b from set \u03b2, the norm of the constant function from \u03b1 to b is equal to the norm of b.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_const_eq [h : Nonempty \u03b1] (b : \u03b2) : \u2016const \u03b1 b\u2016 = \u2016b\u2016 :="}
{"input": "Statement in natural language:\nFor a constant function (fun _ => c) in a filter L, the Frechet derivative at any point x in the domain E is zero. This is because the constant function does not change, so its rate of change (derivative) is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem hasFDerivAtFilter_const (c : F) (x : E) (L : Filter E) :\n    HasFDerivAtFilter (fun _ => c) (0 : E \u2192L[\ud835\udd5c] F) x L :="}
{"input": "Statement in natural language:\nFor an injective function 'f' and an element 'x' from a set 'L', the equivalence of the range of the injective function 'f' applied to 'x' is equal to the pair consisting of 'f' applied to 'x' and the proof that 'f' applied to 'x' is in the range of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem equivRangeOfInjective_apply (h : Function.Injective f) (x : L) :\n    f.equivRangeOfInjective h x = \u27e8f x, mem_range_self f x\u27e9 :="}
{"input": "Statement in natural language:\nFor any two matrices M and N, the product of the negation of M and N is equal to the negation of the product of M and N.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_mul (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) : (-M) \u2b1d N = -M \u2b1d N :="}
{"input": "Statement in natural language:\nFor a function from a pair of elements, one from set \u03b1 and one from set \u03b2, to a set M, if both set \u03b1 and set \u03b2 are finite, then the product of the function values over all elements in set \u03b1 and for each of these, over all elements in set \u03b2, is equal to the product of the function values over all elements in set \u03b2 and for each of these, over all elements in set \u03b1. This essentially means that the order of taking the product does not matter.\nTranslate the statement in natural language to Lean:", "output": "theorem finprod_mem_comm {s : Set \u03b1} {t : Set \u03b2} (f : \u03b1 \u2192 \u03b2 \u2192 M) (hs : s.Finite) (ht : t.Finite) :\n    (\u220f\u1da0 i \u2208 s, \u220f\u1da0 j \u2208 t, f i j) = \u220f\u1da0 j \u2208 t, \u220f\u1da0 i \u2208 s, f i j :="}
{"input": "Statement in natural language:\n\"a\" raised to the power of an odd number \"n\" is less than zero if and only if \"a\" is less than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_bit1_neg_iff : a ^ bit1 n < 0 \u2194 a < 0 :="}
{"input": "Statement in natural language:\nFor any composition as a set 'c', the boundaries of the composition converted to a regular composition are equal to the boundaries of the original composition as a set.\nTranslate the statement in natural language to Lean:", "output": "theorem CompositionAsSet.toComposition_boundaries (c : CompositionAsSet n) :\n    c.toComposition.boundaries = c.boundaries :="}
{"input": "Statement in natural language:\nFor a linear map T from a vector space E to itself that is self-adjoint, and a submodule U of the vector space E that is a complete space, the composition of the linear map U.subtypeL, the orthogonal projection onto U, the linear map T, the linear map U.subtypeL, and the orthogonal projection onto U is also self-adjoint.\nTranslate the statement in natural language to Lean:", "output": "theorem conj_orthogonalProjection {T : E \u2192L[\ud835\udd5c] E} (hT : IsSelfAdjoint T) (U : Submodule \ud835\udd5c E)\n    [CompleteSpace U] :\n    IsSelfAdjoint\n      (U.subtypeL \u2218L orthogonalProjection U \u2218L T \u2218L U.subtypeL \u2218L orthogonalProjection U) :="}
{"input": "Statement in natural language:\nFor a function from natural numbers to a set \u03b2, and for any two natural numbers m and n, the product of the function's values over the interval from m to n (excluding n) is equal to the product of the function's values over the range from 0 to (n - m), where the function's argument is (m + k).\nTranslate the statement in natural language to Lean:", "output": "theorem prod_Ico_eq_prod_range (f : \u2115 \u2192 \u03b2) (m n : \u2115) :\n    (\u220f k in Ico m n, f k) = \u220f k in range (n - m), f (m + k) :="}
{"input": "Statement in natural language:\nThe coefficient of the nth term of the negative of a polynomial p is equal to the negative of the coefficient of the nth term of the polynomial p.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_neg (p : R[X]) (n : \u2115) : coeff (-p) n = -coeff p n :="}
{"input": "Statement in natural language:\nIf the cardinality (or the number of elements) of the support of a polynomial f is greater than or equal to 2, then erasing the leading term of f will not result in a zero polynomial.\nTranslate the statement in natural language to Lean:", "output": "theorem eraseLead_ne_zero (f0 : 2 \u2264 f.support.card) : eraseLead f \u2260 0 :="}
{"input": "Statement in natural language:\nFor any submodule 'p' of a vector space 'V' over a field 'K', there exists a nonempty linear equivalence between the direct product of the quotient space 'V/p' and 'p' and the vector space 'V'.\nTranslate the statement in natural language to Lean:", "output": "theorem quotient_prod_linearEquiv (p : Submodule K V) : Nonempty (((V \u29f8 p) \u00d7 p) \u2243\u2097[K] V) :="}
{"input": "Statement in natural language:\nFor a given non-negative real number p, a measurable set t, a measure \u03bc such that \u03bc(t) is not infinite, and an element x from a set E, the integral of the indicator function of constant Lp over the set a with respect to the measure \u03bc is equal to the real part of the measure of the set t multiplied by the element x.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_indicatorConstLp {p : \u211d\u22650\u221e} (ht : MeasurableSet t) (h\u03bct : \u03bc t \u2260 \u221e) (x : E) :\n    (\u222b a, indicatorConstLp p ht h\u03bct x a \u2202\u03bc) = (\u03bc t).toReal \u2022 x :="}
{"input": "Statement in natural language:\nFor a non-zero constant 'c' and any constant 'd', the integral from 'a' to 'b' of the function 'f' evaluated at 'd + c * x' is equal to the reciprocal of 'c' times the integral from 'd + c * a' to 'd + c * b' of the function 'f' evaluated at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_comp_add_mul (hc : c \u2260 0) (d) :\n    (\u222b x in a..b, f (d + c * x)) = c\u207b\u00b9 \u2022 \u222b x in d + c * a..d + c * b, f x :="}
{"input": "Statement in natural language:\nFor a real-valued function g and a positive real number p, the integral over the interval greater than 0 of p times x to the power of (p - 1) times the function g of x to the power of p, is equal to the integral over the interval greater than 0 of the function g of y.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_comp_rpow_Ioi_of_pos {g : \u211d \u2192 E} {p : \u211d} (hp : 0 < p) :\n    (\u222b x in Ioi 0, (p * x ^ (p - 1)) \u2022 g (x ^ p)) = \u222b y in Ioi 0, g y :="}
{"input": "Statement in natural language:\nRemoving the left operation from the identity natural transformation of the left operation of a functor F equals the identity functor of F.\nTranslate the statement in natural language to Lean:", "output": "theorem removeLeftOp_id : NatTrans.removeLeftOp (\ud835\udfd9 F.leftOp) = \ud835\udfd9 F :="}
{"input": "Statement in natural language:\nIf we have three elements x, y, and z from a ring S, and if x and y are integral elements under a ring homomorphism f, and if z is in the subring closure of the set containing x and y, then z is also an integral element under the ring homomorphism f.\nTranslate the statement in natural language to Lean:", "output": "theorem RingHom.is_integral_of_mem_closure {x y z : S} (hx : f.IsIntegralElem x)\n    (hy : f.IsIntegralElem y) (hz : z \u2208 Subring.closure ({x, y} : Set S)) : f.IsIntegralElem z :="}
{"input": "Statement in natural language:\nFor any element 'x' of a set 'A', the image of the set of integer multiples of 'x' under the function that converts additive notation to multiplicative notation is equal to the set of integer powers of 'x' under multiplicative notation.\nTranslate the statement in natural language to Lean:", "output": "theorem ofAdd_image_zmultiples_eq_zpowers_ofAdd {x : A} :\n    Multiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) =\n      Subgroup.zpowers (Multiplicative.ofAdd x) :="}
{"input": "Statement in natural language:\nIf the space M over the ideal I is Hausdorff, then for any element x in M, if x is congruent to 0 modulo the nth power of I times the top submodule of R over M for all natural numbers n, then x equals 0.\nTranslate the statement in natural language to Lean:", "output": "theorem IsHausdorff.haus (_ : IsHausdorff I M) :\n    \u2200 x : M, (\u2200 n : \u2115, x \u2261 0 [SMOD (I ^ n \u2022 \u22a4 : Submodule R M)]) \u2192 x = 0 :="}
{"input": "Statement in natural language:\nFor a function 'f' that takes two inputs of types '\u03b1' and '\u03b2' and returns an output of type '\u03b3', and for two lists 'l' and 'l'' of types '\u03b1' and '\u03b2' respectively, mapping the uncurried version of 'f' over the zipped version of 'l' and 'l'' is equivalent to zipping 'l' and 'l'' with 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_uncurry_zip_eq_zipWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l : List \u03b1) (l' : List \u03b2) :\n    map (Function.uncurry f) (l.zip l') = zipWith f l l' :="}
{"input": "Statement in natural language:\nFor any element 'c' of type 'S\u2082', the iteration of the function 'iterToSum' applied to the polynomial 'C (X c)' is equal to the polynomial 'X (Sum.inr c)'.\nTranslate the statement in natural language to Lean:", "output": "theorem iterToSum_C_X (c : S\u2082) : iterToSum R S\u2081 S\u2082 (C (X c)) = X (Sum.inr c) :="}
{"input": "Statement in natural language:\nFor a given filter 'l' and sets 's' and 't' of any type '\u03b1', if 's' is a subset of 't', then 's' is eventually less than or equal to 't' with respect to the filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem HasSubset.Subset.eventuallyLE {\u03b1} {l : Filter \u03b1} {s t : Set \u03b1} (h : s \u2286 t) : s \u2264\u1da0[l] t :="}
{"input": "Statement in natural language:\nIf 'hV' is a Hilbert sum of a field '\ud835\udd5c', a set 'G', and a vector space 'V', then for any element 'w' in the sequence space 'lp G 2', the sum of the function 'V i (w i)' over all 'i' equals the inverse of the linear isometry equivalence of 'hV' applied to 'w'. This is under the condition that the sum exists (HasSum).\nTranslate the statement in natural language to Lean:", "output": "theorem IsHilbertSum.hasSum_linearIsometryEquiv_symm (hV : IsHilbertSum \ud835\udd5c G V)\n    (w : lp G 2) : HasSum (fun i => V i (w i)) (hV.linearIsometryEquiv.symm w) :="}
{"input": "Statement in natural language:\nIf 'p' and 'q' are properties of an element 'x' in a set '\u03b1', and both 'p' and 'q' are monotone (meaning they either always increase or always decrease), then the function that checks if both 'p' and 'q' are true for 'x' is also monotone.\nTranslate the statement in natural language to Lean:", "output": "theorem monotone_and {p q : \u03b1 \u2192 Prop} (m_p : Monotone p) (m_q : Monotone q) :\n    Monotone fun x => p x \u2227 q x :="}
{"input": "Statement in natural language:\nIf 'a' is the smallest element and 'b' is the smallest element, then the pair (a, b) is also the smallest element.\nTranslate the statement in natural language to Lean:", "output": "theorem IsBot.prod_mk (ha : IsBot a) (hb : IsBot b) : IsBot (a, b) :="}
{"input": "Statement in natural language:\nA set 's' is not bounded below if and only if for every 'x', there exists a 'y' in 's' such that 'x' is not less than or equal to 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem not_bddBelow_iff' : \u00acBddBelow s \u2194 \u2200 x, \u2203 y \u2208 s, \u00acx \u2264 y :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuously differentiable on a closed subset 's' of the field '\ud835\udd5c', then the function that adds a constant 'c' to 'f' at each point 'x' is also continuously differentiable on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem const_add (hf : DiffContOnCl \ud835\udd5c f s) (c : F) : DiffContOnCl \ud835\udd5c (fun x => c + f x) s :="}
{"input": "Statement in natural language:\nIf for all real numbers 'y' not equal to 'x', the function 'f' has a derivative at 'y' equal to 'g(y)', and if 'f' is continuous at 'x' and 'g' is also continuous at 'x', then 'f' has a derivative at 'x' equal to 'g(x)'.\nTranslate the statement in natural language to Lean:", "output": "theorem hasDerivAt_of_hasDerivAt_of_ne {f g : \u211d \u2192 E} {x : \u211d}\n    (f_diff : \u2200 (y) (_ : y \u2260 x), HasDerivAt f (g y) y) (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) : HasDerivAt f (g x) x :="}
{"input": "Statement in natural language:\nThe inverse function of converting a matrix to a bilinear form, under the equivalence relation over the ring R\u2082, is equal to the function of converting a bilinear form to a matrix.\nTranslate the statement in natural language to Lean:", "output": "theorem Matrix.toBilin'_symm :\n    (Matrix.toBilin'.symm : _ \u2243\u2097[R\u2082] Matrix n n R\u2082) = BilinForm.toMatrix' :="}
{"input": "Statement in natural language:\nFor any real number x, the absolute value of the sine of x is equal to the square root of (1 minus the square of the cosine of x).\nTranslate the statement in natural language to Lean:", "output": "theorem abs_sin_eq_sqrt_one_sub_cos_sq (x : \u211d) : |sin x| = sqrt (1 - cos x ^ 2) :="}
{"input": "Statement in natural language:\nThe pairwise filter of an empty list under any relation R is an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem pwFilter_nil : pwFilter R [] = [] :="}
{"input": "Statement in natural language:\nIf we have a measurable set 's' and for almost every 'x' in the measure '\u03bc', if 'x' is in 's' then 'f(x)' is less than or equal to 'g(x)', then the integral of 'f' over 's' with respect to '\u03bc' is less than or equal to the integral of 'g' over 's' with respect to '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem set_integral_mono_on_ae (hs : MeasurableSet s) (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x \u2264 g x) :\n    (\u222b a in s, f a \u2202\u03bc) \u2264 \u222b a in s, g a \u2202\u03bc :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from module 'M' to 'M\u2083', and another linear map 'g' from module 'M\u2082' to 'M\u2083', and for submodules 'p' of 'M' and 'q' of 'M\u2082', the map of the coproduct of 'f' and 'g' on the product of 'p' and 'q' is equal to the superset of the map of 'f' on 'p' and the map of 'g' on 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_coprod_prod (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) (p : Submodule R M)\n    (q : Submodule R M\u2082) : map (coprod f g) (p.prod q) = map f p \u2294 map g q :="}
{"input": "Statement in natural language:\nIn a preconnected space, the frontier of a set is empty if and only if the set is either empty or the entire universe.\nTranslate the statement in natural language to Lean:", "output": "theorem frontier_eq_empty_iff [PreconnectedSpace \u03b1] {s : Set \u03b1} :\n    frontier s = \u2205 \u2194 s = \u2205 \u2228 s = univ :="}
{"input": "Statement in natural language:\nIf a is non-negative (greater than or equal to zero) and less than b, then the square of a is less than the square of b.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_self_lt_mul_self (h1 : 0 \u2264 a) (h2 : a < b) : a * a < b * b :="}
{"input": "Statement in natural language:\nIf b is less than or equal to a, then subtracting b from a and then adding c is equal to adding c to a and then subtracting b.\nTranslate the statement in natural language to Lean:", "output": "theorem tsub_add_eq_add_tsub (h : b \u2264 a) : a - b + c = a + c - b :="}
{"input": "Statement in natural language:\nFor a given set 's' and a function 'f' from '\u03b2' to the set of '\u03b1', if every 'f i' for all 'i' in 's' is closed, then the intersection of 'f i' for all 'i' in 's' is also closed.\nTranslate the statement in natural language to Lean:", "output": "theorem isClosed_biInter {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (h : \u2200 i \u2208 s, IsClosed (f i)) :\n    IsClosed (\u22c2 i \u2208 s, f i) :="}
{"input": "Statement in natural language:\nIf a function 'f' is continuously differentiable at a point 'x' in the field '\ud835\udd42', and the order of differentiation 'n' is greater than or equal to 1, then 'f' has a strict derivative at 'x', and the value of this derivative is the derivative of 'f' at 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiffAt.hasStrictDerivAt {f : \ud835\udd42 \u2192 F'} {x : \ud835\udd42} (hf : ContDiffAt \ud835\udd42 n f x) (hn : 1 \u2264 n) :\n    HasStrictDerivAt f (deriv f x) x :="}
{"input": "Statement in natural language:\nFor a non-zero constant 'c' and a function 'f' from '\u03b1' to '\ud835\udd5c', the function 'f' is Big O of the function 'x' maps to 'c' times 'f(x)' at the limit 'l', with a constant of proportionality equal to the reciprocal of the norm of 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem isBigOWith_self_const_mul (c : \ud835\udd5c) (hc : c \u2260 0) (f : \u03b1 \u2192 \ud835\udd5c) (l : Filter \u03b1) :\n    IsBigOWith \u2016c\u2016\u207b\u00b9 l f fun x => c * f x :="}
{"input": "Statement in natural language:\nFor a pseudometrizable space \u03b2 and a measurable space \u03b1, a function f is almost everywhere strongly measurable with respect to the sum of measures \u03bc if and only if the function f is almost everywhere strongly measurable with respect to each individual measure \u03bc i.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.aestronglyMeasurable_sum_measure_iff [PseudoMetrizableSpace \u03b2]\n    {_m : MeasurableSpace \u03b1} {\u03bc : \u03b9 \u2192 Measure \u03b1} :\n    AEStronglyMeasurable f (sum \u03bc) \u2194 \u2200 i, AEStronglyMeasurable f (\u03bc i) :="}
{"input": "Statement in natural language:\nA set 's' is nontrivial if and only if there exists elements 'x' and 'y' in 's' such that 'x' is less than 'y'. This is under the condition that '\u03b1' is a linear order.\nTranslate the statement in natural language to Lean:", "output": "theorem nontrivial_iff_exists_lt [LinearOrder \u03b1] :\n    s.Nontrivial \u2194 \u2203 (x : \u03b1) (_ : x \u2208 s) (y : \u03b1) (_ : y \u2208 s), x < y :="}
{"input": "Statement in natural language:\nFor a prime number p and a finite group G, the cardinality (or the number of elements) of the Sylow p-subgroup of G is equal to the cardinality of the quotient group formed by G and the normalizer of the Sylow p-subgroup in G.\nTranslate the statement in natural language to Lean:", "output": "theorem card_sylow_eq_card_quotient_normalizer [Fact p.Prime] [Fintype (Sylow p G)]\n    (P : Sylow p G) : card (Sylow p G) = card (G \u29f8 (P : Subgroup G).normalizer) :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' in the dual of '\u03b1', the dual of the Heyting implication from 'a' to 'b' is equal to the set difference of the dual of 'b' and the dual of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofDual_himp (a b : \u03b1\u1d52\u1d48) : ofDual (a \u21e8 b) = ofDual b \\ ofDual a :="}
{"input": "Statement in natural language:\nFor any type \u03b1, there exists a nonempty erased type of \u03b1 if and only if \u03b1 is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem nonempty_iff {\u03b1} : Nonempty (Erased \u03b1) \u2194 Nonempty \u03b1 :="}
{"input": "Statement in natural language:\nIf a function 'v' (from a set '\u03b9' to a set 'M') is not injective, then the result of applying another function 'f' to 'v' is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem map_eq_zero_of_not_injective (v : \u03b9 \u2192 M) (hv : \u00acFunction.Injective v) : f v = 0 :="}
{"input": "Statement in natural language:\nFor any two distinct elements 'a' and 'a'' of type \u03b1, any value 'v' of type \u03b2 at 'a'', and any function 'f' from \u03b1 to \u03b2, updating the function 'f' at 'a'' with the value 'v' and then applying it to 'a' gives the same result as simply applying 'f' to 'a'. This is because 'a' and 'a'' are distinct, so updating the function at 'a'' does not affect its value at 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem update_noteq {a a' : \u03b1} (h : a \u2260 a') (v : \u03b2 a') (f : \u2200 a, \u03b2 a) : update f a' v a = f a :="}
{"input": "Statement in natural language:\nFor any natural number 'n', the value of '1' in the finite set of size 'n + 2' is equal to '1'.\nTranslate the statement in natural language to Lean:", "output": "theorem val_one (n : \u2115) : (1 : Fin (n + 2)).val = 1 :="}
{"input": "Statement in natural language:\nFor any finite number 'k' within a set of size 'm' and any natural number 'n', applying the function 'finAddFlip' to the result of casting 'k' with an added 'n' is equivalent to adding 'n' to 'k' using the 'Fin.natAdd' function.\nTranslate the statement in natural language to Lean:", "output": "theorem finAddFlip_apply_castAdd (k : Fin m) (n : \u2115) :\n    finAddFlip (Fin.castAdd n k) = Fin.natAdd n k :="}
{"input": "Statement in natural language:\nFor any two types M and N, where N is a monoid and there is a scalar multiplication operation between M and N, if for every element x of M and y of N, the operation y multiplied by the scalar multiplication of x and the identity element of N equals the scalar multiplication of x and y, then the scalar multiplication operation is commutative between M, N, and N.\nTranslate the statement in natural language to Lean:", "output": "theorem SMulCommClass.of_mul_smul_one {M N} [Monoid N] [SMul M N]\n    (H : \u2200 (x : M) (y : N), y * x \u2022 (1 : N) = x \u2022 y) : SMulCommClass M N N :="}
{"input": "Statement in natural language:\nFor a given equivalence relation between two sets n and m, and a given matrix A with elements from set n, the inverse of the reindexed matrix A (with the reindexing defined by the equivalence relations e\u2081 and e\u2082) is equal to the reindexed inverse of matrix A (with the reindexing defined by the inverse of the equivalence relations e\u2082 and e\u2081).\nTranslate the statement in natural language to Lean:", "output": "theorem inv_reindex (e\u2081 e\u2082 : n \u2243 m) (A : Matrix n n \u03b1) : (reindex e\u2081 e\u2082 A)\u207b\u00b9 = reindex e\u2082 e\u2081 A\u207b\u00b9 :="}
{"input": "Statement in natural language:\nIf x is algebraically independent over a ring R, then the multivariate polynomial option equivalent of the polynomial adjoin of x with respect to the polynomial X with no variables is equal to the polynomial X.\nTranslate the statement in natural language to Lean:", "output": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none\n    (hx : AlgebraicIndependent R x) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X :="}
{"input": "Statement in natural language:\nIf the angle formed by points p\u2081, p\u2082, and p\u2083 is equal to \u03c0/2 (a right angle), and either p\u2081 is not equal to p\u2082 or p\u2083 is not equal to p\u2082, then the angle formed by points p\u2082, p\u2083, and p\u2081 is equal to the arcsine of the ratio of the distance between p\u2081 and p\u2082 to the distance between p\u2081 and p\u2083.\nTranslate the statement in natural language to Lean:", "output": "theorem angle_eq_arcsin_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 = Real.arcsin (dist p\u2081 p\u2082 / dist p\u2081 p\u2083) :="}
{"input": "Statement in natural language:\nFor any three functions m, n, and n', where m maps from \u03b4 and \u03b3 to \u03b5, n maps from \u03b1 and \u03b2 to \u03b4, m\u2081 maps from \u03b1 and \u03b3 to \u03b1', m\u2082 maps from \u03b2 and \u03b3 to \u03b2', and n' maps from \u03b1' and \u03b2' to \u03b5, if for all a, b, and c, the function m applied to the result of the function n applied to a and b and c equals the function n' applied to the result of the function m\u2081 applied to a and c and the result of the function m\u2082 applied to b and c, then the result of the function map\u2082 applied to m, the result of the function map\u2082 applied to n, f, and g, and h is less than or equal to the result of the function map\u2082 applied to n', the result of the function map\u2082 applied to m\u2081, f, and h, and the result of the function map\u2082 applied to m\u2082, g, and h.\nTranslate the statement in natural language to Lean:", "output": "theorem map\u2082_distrib_le_right {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'} {m\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'}\n    {n' : \u03b1' \u2192 \u03b2' \u2192 \u03b5} (h_distrib : \u2200 a b c, m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)) :\n    map\u2082 m (map\u2082 n f g) h \u2264 map\u2082 n' (map\u2082 m\u2081 f h) (map\u2082 m\u2082 g h) :="}
{"input": "Statement in natural language:\nThe interval from a to b, including both endpoints, is preconnected.\nTranslate the statement in natural language to Lean:", "output": "theorem isPreconnected_uIcc : IsPreconnected (uIcc a b) :="}
{"input": "Statement in natural language:\nIf we have a uniformly continuous function 'f' and another uniformly continuous function 'g' from the completion of '\u03b1' to '\u03b2', such that for every element 'a' in '\u03b1', 'f(a)' equals 'g' of the completion of 'a', then the extension of 'f' to the completion of '\u03b1' is equal to 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem extension_unique (hf : UniformContinuous f) {g : Completion \u03b1 \u2192 \u03b2}\n    (hg : UniformContinuous g) (h : \u2200 a : \u03b1, f a = g (a : Completion \u03b1)) :\n    Completion.extension f = g :="}
{"input": "Statement in natural language:\nFor a given finite set 's' in a conditionally complete lattice '\u03b1', the infimum of 's' using the identity function is equal to the greatest lower bound of 's'. The condition 'H' ensures that the set 's' is not empty.\nTranslate the statement in natural language to Lean:", "output": "theorem inf'_id_eq_csInf [ConditionallyCompleteLattice \u03b1] (s : Finset \u03b1) (H) :\n    s.inf' H id = sInf s :="}
{"input": "Statement in natural language:\nFor three morphisms f, g, and h from X to Y, each having a cokernel, if f equals g (denoted by w\u2081) and g equals h (denoted by w\u2082), then the composition of the cokernel isomorphisms of w\u2081 and w\u2082 equals the cokernel isomorphism of the transitive relation of w\u2081 and w\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem cokernelIsoOfEq_trans {f g h : X \u27f6 Y} [HasCokernel f] [HasCokernel g] [HasCokernel h]\n    (w\u2081 : f = g) (w\u2082 : g = h) :\n    cokernelIsoOfEq w\u2081 \u226a\u226b cokernelIsoOfEq w\u2082 = cokernelIsoOfEq (w\u2081.trans w\u2082) :="}
{"input": "Statement in natural language:\nFor a sequence of sets V indexed by natural numbers, where each set V is in the uniformity of a topological space \u03b1, and for a sequence u of elements in \u03b1 that converges to an element a in \u03b1, there exists a strictly increasing sequence \u03c6 of natural numbers such that the pair consisting of the first element of the sequence u indexed by \u03c6 and the element a is in the first set V, and for every natural number n, the pair consisting of the elements of the sequence u indexed by the (n+1)th and nth elements of the sequence \u03c6 is in the (n+1)th set V.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.subseq_mem_entourage {V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hV : \u2200 n, V n \u2208 \ud835\udce4 \u03b1) {u : \u2115 \u2192 \u03b1}\n    {a : \u03b1} (hu : Tendsto u atTop (\ud835\udcdd a)) : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 (u (\u03c6 0), a) \u2208 V 0 \u2227\n      \u2200 n, (u <| \u03c6 (n + 1), u <| \u03c6 n) \u2208 V (n + 1) :="}
{"input": "Statement in natural language:\nFor any prime number p that is not equal to 2, the number obtained by subtracting 1 from p is even.\nTranslate the statement in natural language to Lean:", "output": "theorem Prime.even_sub_one {p : \u2115} (hp : p.Prime) (h2 : p \u2260 2) : Even (p - 1) :="}
{"input": "Statement in natural language:\nIf a function 'f' is almost everywhere strongly measurable with respect to a measure '\u03bc', then the function 'f' created by 'hf' is strongly measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem stronglyMeasurable_mk (hf : AEStronglyMeasurable f \u03bc) : StronglyMeasurable (hf.mk f) :="}
{"input": "Statement in natural language:\nFor a given predicate P, a node (consisting of a left subtree l, a value x, and a right subtree r) satisfies P if and only if the left subtree l, the value x, and the right subtree r all satisfy P.\nTranslate the statement in natural language to Lean:", "output": "theorem all_node' {P l x r} : @All \u03b1 P (node' l x r) \u2194 All P l \u2227 P x \u2227 All P r :="}
{"input": "Statement in natural language:\nFor any pair 'a' of type \u03b1 and \u03b3, applying the symmetric of the sum-product distribution function to the left injection of 'a' results in a pair consisting of the left injection of the first element of 'a' and the second element of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem sumProdDistrib_symm_apply_left (a : \u03b1 \u00d7 \u03b3) :\n    (sumProdDistrib \u03b1 \u03b2 \u03b3).symm (inl a) = (inl a.1, a.2) :="}
{"input": "Statement in natural language:\nIf 'c' is an additively left cancellable element and 'a - c' is less than 'b', then 'a' is less than 'b + c'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_add_of_tsub_lt_right (hc : AddLECancellable c) (h : a - c < b) :\n    a < b + c :="}
{"input": "Statement in natural language:\nFor any two functions 'g' mapping from \u03b2 to \u03b3 and 'f' mapping from \u03b1 to \u03b2, and for any symmetric pair 'x' of type \u03b1, applying the function 'g' to the result of applying the function 'f' to 'x' is the same as applying the composition of 'g' and 'f' to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_map {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (x : Sym2 \u03b1) : map g (map f x) = map (g \u2218 f) x :="}
{"input": "Statement in natural language:\nFor a measure \u03bd on a set \u03b1 and a function \u03c6 from \u03b9 to the set \u03b1, if \u03c6 is an almost everywhere cover for \u03bc at limit l and \u03bd is absolutely continuous with respect to \u03bc, then \u03c6 is also an almost everywhere cover for \u03bd at limit l.\nTranslate the statement in natural language to Lean:", "output": "theorem mono_ac {\u03bd : Measure \u03b1} {\u03c6 : \u03b9 \u2192 Set \u03b1} (h\u03c6 : AECover \u03bc l \u03c6) (hle : \u03bd \u226a \u03bc) :\n    AECover \u03bd l \u03c6 :="}
{"input": "Statement in natural language:\nFor a given type \u03b9 and a function t from \u03b9 to a finite set of \u03b1, and a finite set s of \u03b9, if the cardinality of s is equal to the cardinality of the bi-union of s and t, and for all finite sets s of \u03b9, the cardinality of s is less than or equal to the cardinality of the bi-union of s and t, then for a finite set s' of the complement of s in \u03b9, the cardinality of s' is less than or equal to the cardinality of the bi-union of s' and the set difference of t x' and the bi-union of s and t.\nTranslate the statement in natural language to Lean:", "output": "theorem hall_cond_of_compl {\u03b9 : Type u} {t : \u03b9 \u2192 Finset \u03b1} {s : Finset \u03b9}\n    (hus : s.card = (s.biUnion t).card) (ht : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card)\n    (s' : Finset (s\u1d9c : Set \u03b9)) : s'.card \u2264 (s'.biUnion fun x' => t x' \\ s.biUnion t).card :="}
{"input": "Statement in natural language:\nFor any dual number of a quaternion over a ring R, the first real part of the inverse of the dual number equivalence of the dual number is equal to the real part of the first element of the dual number.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_re_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).re.fst = d.fst.re :="}
{"input": "Statement in natural language:\nThe torsion of a commutative monoid G is equal to the submonoid generated by the torsion of G.\nTranslate the statement in natural language to Lean:", "output": "theorem torsion_eq_torsion_submonoid : CommMonoid.torsion G = (torsion G).toSubmonoid :="}
{"input": "Statement in natural language:\nFor a finite dimensional field 'K' and vector space 'V', and a subspace 'W'' of the dual of the dual of 'V', the inverse of the map evaluation equivalence applied to 'W'' is equal to the co-domain of 'W'' under the evaluation map.\nTranslate the statement in natural language to Lean:", "output": "theorem mapEvalEquiv_symm_apply [FiniteDimensional K V] (W'' : Subspace K (Dual K (Dual K V))) :\n    (mapEvalEquiv K V).symm W'' = W''.comap (eval K V) :="}
{"input": "Statement in natural language:\nFor a subgroup H of a group G, if H is normal, then the normal closure of H is equal to H itself.\nTranslate the statement in natural language to Lean:", "output": "theorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure \u2191H = H :="}
{"input": "Statement in natural language:\nIf we have a transitive relation 'r' on a set '\u03b1', and 'a', 'b', and 'c' are elements of '\u03b1' such that the antisymmetric relation holds between 'a' and 'b', and between 'b' and 'c', then the antisymmetric relation also holds between 'a' and 'c'.\nTranslate the statement in natural language to Lean:", "output": "theorem AntisymmRel.trans [IsTrans \u03b1 r] {a b c : \u03b1} (hab : AntisymmRel r a b)\n    (hbc : AntisymmRel r b c) : AntisymmRel r a c :="}
{"input": "Statement in natural language:\nFor any two indices 'i' and 'j' and any element 'x' of type '\u03b2 i', if 'i' is not equal to 'j', then erasing 'j' from the singleton set containing 'i' and 'x' will result in the original singleton set containing 'i' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_single_ne {i j : \u03b9} (x : \u03b2 i) (h : i \u2260 j) : (single i x).erase j = single i x :="}
{"input": "Statement in natural language:\nIn a linearly ordered commutative ring R, for any two elements a and b that are coprime, the sum of the squares of a and b is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem sq_add_sq_ne_zero {R : Type _} [LinearOrderedCommRing R] {a b : R} (h : IsCoprime a b) :\n    a ^ 2 + b ^ 2 \u2260 0 :="}
{"input": "Statement in natural language:\nIf two morphisms (or arrows) 'f' and 'g' from object 'X' to object 'Y' are equal (denoted by 'f = g'), then the composition of 'f' with another morphism 'h' from 'Y' to 'Z' is equal to the composition of 'g' with 'h'. This is denoted by 'f \u226b h = g \u226b h'. This is known as \"right whiskering\" in category theory.\nTranslate the statement in natural language to Lean:", "output": "theorem eq_whisker {f g : X \u27f6 Y} (w : f = g) (h : Y \u27f6 Z) : f \u226b h = g \u226b h :="}
{"input": "Statement in natural language:\nThe function 'f' is continuously differentiable on the closure of the entire space '\ud835\udd5c' if and only if 'f' is differentiable on '\ud835\udd5c'.\nTranslate the statement in natural language to Lean:", "output": "theorem diffContOnCl_univ : DiffContOnCl \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f :="}
{"input": "Statement in natural language:\nFor any relation 'r' between elements of type '\u03b1', for any lists 's\u2081' and 's\u2082', and any list 't', if 's\u2081' is lexicographically less than 's\u2082' according to the relation 'r', then 's\u2081' is also lexicographically less than the concatenation of 's\u2082' and 't' according to the same relation 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem append_right (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : \u2200 {s\u2081 s\u2082} (t), Lex r s\u2081 s\u2082 \u2192 Lex r s\u2081 (s\u2082 ++ t)"}
{"input": "Statement in natural language:\nFor a given finite set 's' and a property 'p' that each element in 's' may or may not satisfy, the product of applying either function 'f' or 'g' to each element in 's' (depending on whether or not the element satisfies 'p') is equal to the product of applying 'f' to each element in 's' that satisfies 'p' multiplied by the product of applying 'g' to each element in 's' that does not satisfy 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_ite {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b2) :\n    (\u220f x in s, if p x then f x else g x) =\n      (\u220f x in s.filter p, f x) * \u220f x in s.filter fun x => \u00acp x, g x :="}
{"input": "Statement in natural language:\nFor any integer k, the norm of k (when considered as a p-adic number) is less than one if and only if p (considered as an integer) divides k.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_int_lt_one_iff_dvd (k : \u2124) : \u2016(k : \u211a_[p])\u2016 < 1 \u2194 \u2191p \u2223 k :="}
{"input": "Statement in natural language:\nFor any three types \u03b1, \u03b2, and \u03b3 that are primcodable, and for any properties p of \u03b1, q of \u03b2, and r of \u03b3, if q and r are many-one equivalent, then p is many-one equivalent to q if and only if p is many-one equivalent to r.\nTranslate the statement in natural language to Lean:", "output": "theorem ManyOneEquiv.congr_right {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : ManyOneEquiv q r) :\n    ManyOneEquiv p q \u2194 ManyOneEquiv p r :="}
{"input": "Statement in natural language:\nIn the context of an adhesive category C, if we have a pushout consisting of morphisms f, g, h, and i, and if g is a monomorphism, then this pushout is also a pullback.\nTranslate the statement in natural language to Lean:", "output": "theorem Adhesive.isPullback_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i)\n    [Mono g] : IsPullback f g h i :="}
{"input": "Statement in natural language:\nAssuming there is at least one element in set \u03b1, if function f is surjective on sets s and t, then the inverse function on f and s is a right inverse on set t.\nTranslate the statement in natural language to Lean:", "output": "theorem SurjOn.rightInvOn_invFunOn [Nonempty \u03b1] (h : SurjOn f s t) :\n    RightInvOn (invFunOn f s) f t :="}
{"input": "Statement in natural language:\nIf the codomain of a function is a subsingleton, then the function is almost everywhere measurable with respect to measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem aemeasurable_of_subsingleton_codomain [Subsingleton \u03b2] : AEMeasurable f \u03bc :="}
{"input": "Statement in natural language:\nFor a given order-preserving monoid homomorphism 'f' from '\u03b1' to '\u03b2', the order homomorphism of 'f' is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem toOrderHom_eq_coe (f : \u03b1 \u2192*o \u03b2) : f.toOrderHom = f :="}
{"input": "Statement in natural language:\nFor a given set 's' of elements of type '\u03b1', an element 'a' of type '\u03b1', and a property 'p' applicable to elements of type '\u03b1', if every element in 's' has property 'p', then eventually, for all elements 'x' in the neighborhood of 'a' within set 's', 'x' will have property 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem eventually_nhdsWithin_of_forall {s : Set \u03b1} {a : \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200 x \u2208 s, p x) :\n    \u2200\u1da0 x in \ud835\udcdd[s] a, p x :="}
{"input": "Statement in natural language:\nFor a list L of elements of any type \u03b1, given two natural numbers i and j such that i is less than the length of L and i is also less than j, the i-th element of L is equal to the i-th element of the list obtained by taking the first j elements of L. This is true because the length of the taken list is less than or equal to the minimum of j and the length of L, and i is less than this minimum.\nTranslate the statement in natural language to Lean:", "output": "theorem nthLe_take (L : List \u03b1) {i j : \u2115} (hi : i < L.length) (hj : i < j) :\n    nthLe L i hi = nthLe (L.take j) i (length_take .. \u25b8 lt_min hj hi) :="}
{"input": "Statement in natural language:\nFor any two natural numbers 'm' and 'n', the cardinality of 'm' is less than or equal to 'n' if and only if 'm' is less than or equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem natCast_le {m n : \u2115} : (m : Cardinal) \u2264 n \u2194 m \u2264 n :="}
{"input": "Statement in natural language:\nFor any element 'a' of type '\u03b1' and any function 'f' from '\u03b1' to '\u03b2', the operation of mapping function 'f' over the option of 'a' is equal to the co-domain of function 'f' applied to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_coe' {a : \u03b1} {f : \u03b1 \u2192 \u03b2} : Option.map f (a : Option \u03b1) = \u2191(f a) :="}
{"input": "Statement in natural language:\nIf R is a Noetherian ring and M is a module over R such that the whole module M is finitely generated, then M is a Noetherian module.\nTranslate the statement in natural language to Lean:", "output": "theorem isNoetherian_of_fg_of_noetherian' {R M} [Ring R] [AddCommGroup M] [Module R M]\n    [IsNoetherianRing R] (h : (\u22a4 : Submodule R M).FG) : IsNoetherian R M :="}
{"input": "Statement in natural language:\nThe cardinality of the set of algebraic elements in A over R is less than or equal to the product of the cardinality of the set of polynomials over R and the cardinality of the set of natural numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem cardinal_mk_le_mul : (#{ x : A // IsAlgebraic R x }) \u2264 (#R[X]) * \u2135\u2080 :="}
{"input": "Statement in natural language:\nFor any element 'a' in a set '\u03b1' and any unit 'b', the product of 'a' and 'b' divided by 'b' is equal to 'a'. Here, 'IsUnit b' means 'b' is a unit, i.e., 'b' has a multiplicative inverse.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_mul_div (a : \u03b1) (h : IsUnit b) : a * b * (1 / b) = a :="}
{"input": "Statement in natural language:\nThe exponential function is continuous from a normed space to another normed space.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_continuous : Continuous (exp \ud835\udd42 : \ud835\udd38 \u2192 \ud835\udd38) :="}
{"input": "Statement in natural language:\nA hyperreal number 'x' is infinitely negative if and only if 'x' is infinite and 'x' is less than zero.\nTranslate the statement in natural language to Lean:", "output": "theorem infiniteNeg_iff_infinite_and_neg {x : \u211d*} : InfiniteNeg x \u2194 Infinite x \u2227 x < 0 :="}
{"input": "Statement in natural language:\nFor all numbers 'n', the successor of 'n' when cast to a natural number is equal to 'n' plus one.\nTranslate the statement in natural language to Lean:", "output": "theorem succ_to_nat : \u2200 n, (succ n : \u2115) = n + 1"}
{"input": "Statement in natural language:\nFor any additive group with an identity element \u03b1 that has characteristic zero and any integer n, n being not equal to 1 in \u03b1 is equivalent to n not being equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem cast_ne_one [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) \u2260 1 \u2194 n \u2260 1 :="}
{"input": "Statement in natural language:\nFor a real number x that is greater than or equal to zero, and a complex number y such that the real part of y is not zero, the absolute value of x raised to the power of y is equal to x raised to the power of the real part of y.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_cpow_eq_rpow_re_of_nonneg {x : \u211d} (hx : 0 \u2264 x) {y : \u2102} (hy : re y \u2260 0) :\n    abs (x ^ y) = x ^ re y :="}
{"input": "Statement in natural language:\nFor a nonempty set \u03b2 with a semilattice structure and a sequence u from \u03b2 to \u03b1, the sequence u is a Cauchy sequence if and only if the function that takes a pair of elements from \u03b2 and returns the distance between the images of these elements under u, tends to 0 as the pair goes to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem cauchySeq_iff_tendsto_dist_atTop_0 [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 Tendsto (fun n : \u03b2 \u00d7 \u03b2 => dist (u n.1) (u n.2)) atTop (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nIf a function 'f' has compact multiplication support, and the multiplication support of another function 'f'' is a subset of the multiplication support of 'f', then 'f'' also has compact multiplication support.\nTranslate the statement in natural language to Lean:", "output": "theorem HasCompactMulSupport.mono {f' : \u03b1 \u2192 \u03b3} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' \u2286 mulSupport f) : HasCompactMulSupport f' :="}
{"input": "Statement in natural language:\nFor any two spectral maps 'f' and 'g' from '\u03b1' to '\u03b2', if for every 'a', 'f' at 'a' equals 'g' at 'a', then 'f' equals 'g'.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {f g : SpectralMap \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g :="}
{"input": "Statement in natural language:\nThe bottom element in the set of extended non-negative real numbers is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem bot_eq_zero : (\u22a5 : \u211d\u22650\u221e) = 0 :="}
{"input": "Statement in natural language:\nThe diagonal of the union of two sets, s and t, is equal to the union of the diagonals of the two sets.\nTranslate the statement in natural language to Lean:", "output": "theorem diag_union : (s \u222a t).diag = s.diag \u222a t.diag :="}
{"input": "Statement in natural language:\nThe centralizer of the top element is equal to the center of the group G.\nTranslate the statement in natural language to Lean:", "output": "theorem centralizer_top : centralizer \u22a4 = center G :="}
{"input": "Statement in natural language:\nFor any multisets 's' and 't' and any element 'a', 's' with 'a' erased is less than or equal to 't' if and only if 's' is less than or equal to 't' with 'a' added.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_le_iff_le_cons {s t : Multiset \u03b1} {a : \u03b1} : s.erase a \u2264 t \u2194 s \u2264 a ::\u2098 t :="}
{"input": "Statement in natural language:\nFor any type \u03b1, natural number n, bounded formula \u03c6 of L in \u03b1 and n, and functions v and xs from \u03b1 and Fin n to the top substructure of M respectively, the realization of \u03c6 with respect to v and xs is equivalent to the realization of \u03c6 with respect to the composition of v and xs with the inclusion function from the top substructure of M to M.\nTranslate the statement in natural language to Lean:", "output": "theorem realize_boundedFormula_top {\u03b1 : Type _} {n : \u2115} {\u03c6 : L.BoundedFormula \u03b1 n}\n    {v : \u03b1 \u2192 (\u22a4 : L.Substructure M)} {xs : Fin n \u2192 (\u22a4 : L.Substructure M)} :\n    \u03c6.Realize v xs \u2194 \u03c6.Realize (((\u2191) : _ \u2192 M) \u2218 v) ((\u2191) \u2218 xs) :="}
{"input": "Statement in natural language:\nThe greatest lower bound (infimum) of the function f over all elements x in the universal set is equal to the greatest lower bound of the function f over all elements x.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_univ {f : \u03b2 \u2192 \u03b1} : (\u2a05 x \u2208 (univ : Set \u03b2), f x) = \u2a05 x, f x :="}
{"input": "Statement in natural language:\nThe head of the negation of a vector 'a' is equal to the negation of the head of the vector 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem head_neg (a : Fin n.succ \u2192 \u03b1) : vecHead (-a) = -vecHead a :="}
{"input": "Statement in natural language:\nFor a finite measure \u03bc, another measure \u03bd (which is also finite), and a function f from \u03b1 to E, if f is integrable with respect to both \u03bc and \u03bd, then the integral of f with respect to the sum of \u03bc and \u03bd is equal to the weighted sum of the integral of f with respect to \u03bc and the integral of f with respect to \u03bd. The weights are the ratio of the measure of the entire space under \u03bc and \u03bd to the sum of the measures of the entire space under \u03bc and \u03bd, respectively.\nTranslate the statement in natural language to Lean:", "output": "theorem average_add_measure [IsFiniteMeasure \u03bc] {\u03bd : Measure \u03b1} [IsFiniteMeasure \u03bd] {f : \u03b1 \u2192 E}\n    (h\u03bc : Integrable f \u03bc) (h\u03bd : Integrable f \u03bd) :\n    (\u2a0d x, f x \u2202\u03bc + \u03bd) =\n      (((\u03bc univ).toReal / ((\u03bc univ).toReal + (\u03bd univ).toReal)) \u2022 \u2a0d x, f x \u2202\u03bc) +\n        ((\u03bd univ).toReal / ((\u03bc univ).toReal + (\u03bd univ).toReal)) \u2022 \u2a0d x, f x \u2202\u03bd :="}
{"input": "Statement in natural language:\nFor any given finite set 't' of type \u03b2, the scalar multiplication of 't' by the zero set of type \u03b1 is a subset of the zero set.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_smul_subset (t : Finset \u03b2) : (0 : Finset \u03b1) \u2022 t \u2286 0 :="}
{"input": "Statement in natural language:\nFor any non-negative real number 'a' and any two functions 'g' and 'h' that map from an index set '\u03b9' to the set of non-negative real numbers, if 'a' is less than or equal to the product of 'g i' and 'h j' for all 'i' and 'j' in the index set, then 'a' is also less than or equal to the product of the infimum (greatest lower bound) of 'g' and the infimum of 'h'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_iInf_mul_iInf {a : \u211d\u22650} {g h : \u03b9 \u2192 \u211d\u22650} (H : \u2200 i j, a \u2264 g i * h j) :\n    a \u2264 iInf g * iInf h :="}
{"input": "Statement in natural language:\nFor any type R and L, where R is a commutative ring, L is a Lie ring, and L is a Lie algebra over R, the bottom element of the Lie ideal of R in L is a Lie abelian.\nTranslate the statement in natural language to Lean:", "output": "theorem LieAlgebra.isLieAbelian_bot (R : Type u) (L : Type v) [CommRing R] [LieRing L]\n    [LieAlgebra R L] : IsLieAbelian (\u22a5 : LieIdeal R L) :="}
{"input": "Statement in natural language:\nFor any real numbers p and q that are conjugate exponents, and for any two functions f and g from \u03b1 to the set of non-negative extended real numbers that are almost everywhere measurable with respect to measure \u03bc, if the p-th power integrals of f and g with respect to \u03bc are not infinite, and if the p-th power integral of the sum of f and g with respect to \u03bc is not zero or infinite, then the p-th root of the p-th power integral of the sum of f and g with respect to \u03bc is less than or equal to the sum of the p-th roots of the p-th power integrals of f and g with respect to \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem lintegral_Lp_add_le_aux {p q : \u211d} (hpq : p.IsConjugateExponent q) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) (hg : AEMeasurable g \u03bc)\n    (hg_top : (\u222b\u207b a, g a ^ p \u2202\u03bc) \u2260 \u22a4) (h_add_zero : (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2260 0)\n    (h_add_top : (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264\n      (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p) :="}
{"input": "Statement in natural language:\nFor any composition series 's' of 'X', the top of the series after erasing the top element is less than or equal to the original top of the series 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem eraseTop_top_le (s : CompositionSeries X) : s.eraseTop.top \u2264 s.top :="}
{"input": "Statement in natural language:\nFor any two games x and y, and for any property P that applies to the left moves of the sum of x and y, if P holds for all left moves of x and all left moves of y when they are considered as left moves of the sum, then P holds for any left move of the sum of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem leftMoves_add_cases {x y : PGame} (k) {P : (x + y).LeftMoves \u2192 Prop}\n    (hl : \u2200 i, P <| toLeftMovesAdd (Sum.inl i)) (hr : \u2200 i, P <| toLeftMovesAdd (Sum.inr i)) :\n    P k :="}
{"input": "Statement in natural language:\nIf function f\u2081 is eventually equal to function f\u2082 at filter l, and function f\u2082 is asymptotically equivalent to function g at the same filter, then function f\u2081 is also asymptotically equivalent to function g at filter l.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Filter.EventuallyEq.trans_isTheta {f\u2081 f\u2082 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hf : f\u2081 =\u1da0[l] f\u2082)\n    (h : f\u2082 =\u0398[l] g) : f\u2081 =\u0398[l] g :="}
{"input": "Statement in natural language:\nThe keys of the associative list obtained by erasing an element 'a' from another associative list 's' are equal to the keys of 's' with 'a' erased.\nTranslate the statement in natural language to Lean:", "output": "theorem keys_erase (a : \u03b1) (s : AList \u03b2) : (erase a s).keys = s.keys.erase a :="}
{"input": "Statement in natural language:\nThe image of the second projection linear map under the first projection submodule is the zero submodule.\nTranslate the statement in natural language to Lean:", "output": "theorem fst_map_snd : (Submodule.fst R M M\u2082).map (LinearMap.snd R M M\u2082) = \u22a5 :="}
{"input": "Statement in natural language:\nFor a function 'f' that maps from the finite set of size 'm * n' to any type '\u03b1', the list created by applying 'f' to each element in the finite set is equal to the list obtained by joining the list of lists created by applying 'f' to each element in the finite set of size 'm' for each element in the finite set of size 'n'. The index for 'f' in the latter case is calculated as 'm * i + j', where 'i' is the element from the finite set of size 'n' and 'j' is the element from the finite set of size 'm'. The theorem also includes a proof that 'm * i + j' is less than or equal to 'm * (i + 1)', which ensures that the index is within the bounds of the finite set of size 'm * n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofFn_mul' {m n} (f : Fin (m * n) \u2192 \u03b1) :\n    List.ofFn f = List.join (List.ofFn fun i : Fin n => List.ofFn fun j : Fin m => f \u27e8m * i + j,\n    calc\n      m * i + j < m * (i + 1) := (add_lt_add_left j.prop _).trans_eq (mul_add_one (_ : \u2115) _).symm\n      _ \u2264 _ := Nat.mul_le_mul_left _ i.prop\u27e9) :="}
{"input": "Statement in natural language:\nFor a function 'f' from an optional value of type '\u03b1' to type '\u03b2', the range of 'f' is equal to the insertion of the function 'f' applied to 'none' into the range of the function 'f' composed with 'some'.\nTranslate the statement in natural language to Lean:", "output": "theorem range_eq {\u03b1 \u03b2} (f : Option \u03b1 \u2192 \u03b2) : range f = insert (f none) (range (f \u2218 some)) :="}
{"input": "Statement in natural language:\nFor a given point 'x' in a set 'E' and a real number '\u03b4', the open ball centered at 'x' with radius '\u03b4' is a subset of the thickening of 'E' by '\u03b4'.\nTranslate the statement in natural language to Lean:", "output": "theorem ball_subset_thickening {x : X} {E : Set X} (hx : x \u2208 E) (\u03b4 : \u211d) :\n    ball x \u03b4 \u2286 thickening \u03b4 E :="}
{"input": "Statement in natural language:\nFor any two elements r and s from a ring R, the coercion of the division of r by s is equal to the division of the coerced r by the coerced s in a ring A.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_div (r s : R) : \u2191(r / s) = (\u2191r / \u2191s : A) :="}
{"input": "Statement in natural language:\nIf the kernel of a homomorphism \u03d5 is a p-group, and the image of a subgroup P under \u03d5 is a subset of the range of \u03d5, then the preimage of P under \u03d5 (with respect to the kernel being a p-group) is equal to the preimage of P under \u03d5.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_comapOfKerIsPGroup (h\u03d5 : IsPGroup p \u03d5.ker) (h : \u2191P \u2264 \u03d5.range) :\n    (P.comapOfKerIsPGroup \u03d5 h\u03d5 h : Subgroup K) = Subgroup.comap \u03d5 \u2191P :="}
{"input": "Statement in natural language:\nFor a scalar 's' and an element 'a' from the module over a field '\ud835\udd5c' and a ring 'A', the first component of the scaled element 's \u2022 a' is equal to the scalar multiplication of 's' and the first component of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_fst (s : S) (a : \ud835\udcdc(\ud835\udd5c, A)) : (s \u2022 a).fst = s \u2022 a.fst :="}
{"input": "Statement in natural language:\nThe kernel of the first projection function from a product of two modules over a ring to the first module is equal to the range of the function that injects the second module into the product.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_fst : ker (fst R M M\u2082) = range (inr R M M\u2082) :="}
{"input": "Statement in natural language:\nFor any type \u03b9, and for any complete lattice \u03b2, if we have a function f from \u03b9 to the order-preserving function from \u03b1 to \u03b2, then the function obtained by taking the greatest lower bound over all i of the function f(i), when coerced to a function from \u03b1 to \u03b2, is equal to the function obtained by taking the greatest lower bound over all i of the function f(i) coerced to a function from \u03b1 to \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_iInf {\u03b9 : Sort _} [CompleteLattice \u03b2] (f : \u03b9 \u2192 \u03b1 \u2192o \u03b2) :\n    ((\u2a05 i, f i : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2) = \u2a05 i, (f i : \u03b1 \u2192 \u03b2) :="}
{"input": "Statement in natural language:\nFor any encodable type \u03b1, the function 'decode\u2082 \u03b1' is a partial inverse of the function 'encode'. This means that if you encode a value and then decode it using 'decode\u2082 \u03b1', you will get the original value back, at least for some values.\nTranslate the statement in natural language to Lean:", "output": "theorem decode\u2082_is_partial_inv [Encodable \u03b1] : IsPartialInv encode (decode\u2082 \u03b1) :="}
{"input": "Statement in natural language:\nIf the function pair f and g is antivariant, then the sum of the product of f(i) and g(i) for all i is less than or equal to the sum of the product of f(\u03c3(i)) and g(i) for all i. Here, \u03c3 is a permutation function.\nTranslate the statement in natural language to Lean:", "output": "theorem Antivary.sum_smul_le_sum_comp_perm_smul (hfg : Antivary f g) :\n    (\u2211 i, f i \u2022 g i) \u2264 \u2211 i, f (\u03c3 i) \u2022 g i :="}
{"input": "Statement in natural language:\nIf functions 'f' and 'g' are continuously differentiable 'n' times over the real numbers, then the inner product of 'f' and 'g' is also continuously differentiable 'n' times over the real numbers.\nTranslate the statement in natural language to Lean:", "output": "theorem ContDiff.inner (hf : ContDiff \u211d n f) (hg : ContDiff \u211d n g) :\n    ContDiff \u211d n fun x => \u27eaf x, g x\u27eb :="}
{"input": "Statement in natural language:\nThe Fr\u00e9chet derivative of a continuous linear map at any point is the map itself.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousLinearMap.fderiv : fderiv \ud835\udd5c e x = e :="}
{"input": "Statement in natural language:\nFor a given type G with a group structure, and given types R and M with distributive multiplication actions by G, and given that G is a scalar tower over R and M, if the span of the set range of a function v from index set \u03b9 to M over R equals the top element (i.e., the whole space), then the span of the set range of the function obtained by scaling v by a function w from \u03b9 to G over R also equals the top element.\nTranslate the statement in natural language to Lean:", "output": "theorem groupSmul_span_eq_top {G : Type _} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] {v : \u03b9 \u2192 M} (hv : Submodule.span R (Set.range v) = \u22a4) {w : \u03b9 \u2192 G} :\n    Submodule.span R (Set.range (w \u2022 v)) = \u22a4 :="}
{"input": "Statement in natural language:\nIf 'q prime' is an element of the transformation of 'q' under the function 'trStmts\u2081', then the set of elements transformed by 'trStmts\u2081' from 'q prime' is a subset of the set of elements transformed by 'trStmts\u2081' from 'q'.\nTranslate the statement in natural language to Lean:", "output": "theorem trStmts\u2081_trans {q q'} : q' \u2208 trStmts\u2081 q \u2192 trStmts\u2081 q' \u2286 trStmts\u2081 q :="}
{"input": "Statement in natural language:\nFor a multilinear map \u03c6 from a ring R to a set s of elements E, and for all elements f in set s, the auxiliary lift of \u03c6 at the tensor product of R and f is equal to \u03c6 at f.\nTranslate the statement in natural language to Lean:", "output": "theorem liftAux_tprod (\u03c6 : MultilinearMap R s E) (f : \u2200 i, s i) : liftAux \u03c6 (tprod R f) = \u03c6 f :="}
{"input": "Statement in natural language:\nFor any filter 'l' and any function 'f', 'f' is eventually less than or equal to 'f' with respect to the filter 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem EventuallyLE.refl (l : Filter \u03b1) (f : \u03b1 \u2192 \u03b2) : f \u2264\u1da0[l] f :="}
{"input": "Statement in natural language:\nFor a given index 'i' and a function 't' that maps each index to a set of elements of type '\u03b1 i', the Cartesian product of the set containing only 'i' and the function 't' is equal to the set of all functions 'x' such that the element of 'x' at index 'i' is in the set 't i'.\nTranslate the statement in natural language to Lean:", "output": "theorem singleton_pi' (i : \u03b9) (t : \u2200 i, Set (\u03b1 i)) : pi {i} t = { x | x i \u2208 t i } :="}
{"input": "Statement in natural language:\nThe size up to a given natural number 'i' in composition 'c' is less than or equal to 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem sizeUpTo_le (i : \u2115) : c.sizeUpTo i \u2264 n :="}
{"input": "Statement in natural language:\nThe evaluation function, which takes a continuous multilinear map from a scalar field \ud835\udd5c and vector spaces E to a vector space G, and a function that assigns a vector in E to each index i, and applies the multilinear map to this function, is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_eval : Continuous fun p :\n    ContinuousMultilinearMap \ud835\udd5c E G \u00d7 \u2200 i, E i => p.1 p.2 :="}
{"input": "Statement in natural language:\nFor any given index 'i' in the set '\u03b9', the function 'of \u03b2 i' is injective. An injective function is one where every element of the input maps to a unique element of the output, meaning there are no two different inputs that produce the same output.\nTranslate the statement in natural language to Lean:", "output": "theorem of_injective (i : \u03b9) : Function.Injective (of \u03b2 i) :="}
{"input": "Statement in natural language:\nThe function that maps a ring homomorphism from \u03b1 to \u03b2 to its underlying additive monoid homomorphism is injective. This means that if two ring homomorphisms from \u03b1 to \u03b2 are different, then their underlying additive monoid homomorphisms are also different.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_addMonoidHom_injective : Injective fun f : \u03b1 \u2192\u2099+* \u03b2 => (f : \u03b1 \u2192+ \u03b2) :="}
{"input": "Statement in natural language:\nIf an element 'a' does not belong to set 't', then the intersection of the set 't' and the set obtained by inserting 'a' into another set 's' is equal to the intersection of the sets 's' and 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem insert_inter_of_not_mem (h : a \u2209 t) : insert a s \u2229 t = s \u2229 t :="}
{"input": "Statement in natural language:\nFor a unitary element U in the ring R, the inverse of U when considered as an element of the ring R is the same as the inverse of U when considered as a unitary element.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_inv (U : unitary R) : \u2191U\u207b\u00b9 = (U\u207b\u00b9 : R) :="}
{"input": "Statement in natural language:\nFor any list 'l' and for any integers 'm' and 'n', if 'm' is less than 'n', then there is a chain of strictly increasing elements starting from 'm' in the list obtained by applying the function 'raise'' to 'l' and 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem raise'_chain : \u2200 (l) {m n}, m < n \u2192 List.Chain (\u00b7 < \u00b7) m (raise' l n)"}
{"input": "Statement in natural language:\nFor any index 'i' and any real number 'r' that is greater than zero, the open ball of radius 'r' centered at zero in the seminorm 'p i' is a member of the basis sets of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem basisSets_singleton_mem (i : \u03b9) {r : \u211d} (hr : 0 < r) : (p i).ball 0 r \u2208 p.basisSets :="}
{"input": "Statement in natural language:\nIf a function f\u2082 is differentiable at a point x in a field \ud835\udd5c, then the first component of the function f\u2082 at point x is also differentiable at that point.\nTranslate the statement in natural language to Lean:", "output": "theorem DifferentiableAt.fst (h : DifferentiableAt \ud835\udd5c f\u2082 x) :\n    DifferentiableAt \ud835\udd5c (fun x => (f\u2082 x).1) x :="}
{"input": "Statement in natural language:\nFor any element 'x' of 'M F', if we apply the function 'dest' to 'x' and then apply the function 'M.mk' to the result, we will get back 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_dest (x : M F) : M.mk (dest x) = x :="}
{"input": "Statement in natural language:\nFor a given complex number 'c', a real number 'R' (where 'R' is greater than or equal to 0), and another real number '\u03b8', the circle map of 'c', 'R', and '\u03b8' belongs to the sphere with center 'c' and radius 'R'.\nTranslate the statement in natural language to Lean:", "output": "theorem circleMap_mem_sphere (c : \u2102) {R : \u211d} (hR : 0 \u2264 R) (\u03b8 : \u211d) : circleMap c R \u03b8 \u2208 sphere c R :="}
{"input": "Statement in natural language:\nFor any element 'i' of type '\u03b1' and any element 'b' that is not equal to zero, the support of the single function applied to 'i' and 'b' is not equal to the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem support_single_ne_bot (i : \u03b1) (h : b \u2260 0) : (single i b).support \u2260 \u22a5 :="}
{"input": "Statement in natural language:\nFor two affine equivalences 'e' and 'e'' between two points P\u2081 and P\u2082, 'e' is equal to 'e'' if and only if the equivalent transformation of 'e' is equal to the equivalent transformation of 'e''.\nTranslate the statement in natural language to Lean:", "output": "theorem toEquiv_inj {e e' : P\u2081 \u2243\u1d43[k] P\u2082} : e.toEquiv = e'.toEquiv \u2194 e = e' :="}
{"input": "Statement in natural language:\nThe difference of a set with itself is the bottom element, or the empty set.\nTranslate the statement in natural language to Lean:", "output": "theorem sdiff_self : a \\ a = \u22a5 :="}
{"input": "Statement in natural language:\nFor a given ring homomorphism class from R[X] to S[X], and a ring homomorphism \u03c6 such that the non-zero elements of R[X] are less than or equal to the preimage of the non-zero elements of S[X] under \u03c6, the mapping of the ring homomorphism from the rational functions over R to the rational functions over S is equal to the mapping of \u03c6 under the same conditions.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_mapRingHom_eq_coe_map [RingHomClass F R[X] S[X]] (\u03c6 : F) (h\u03c6 : R[X]\u2070 \u2264 S[X]\u2070.comap \u03c6) :\n    (mapRingHom \u03c6 h\u03c6 : RatFunc R \u2192 RatFunc S) = map \u03c6 h\u03c6 :="}
{"input": "Statement in natural language:\nFor a set of vectors 'v' that are orthonormal (meaning, they are orthogonal and of unit length), and two functions 'l\u2081' and 'l\u2082' that map to the field of scalars, and a finite set 's', the inner product of the sum of the scaled vectors according to 'l\u2081' and 'l\u2082' over the set 's' is equal to the sum over 's' of the product of the conjugate of 'l\u2081' and 'l\u2082'.\nTranslate the statement in natural language to Lean:", "output": "theorem Orthonormal.inner_sum {v : \u03b9 \u2192 E} (hv : Orthonormal \ud835\udd5c v) (l\u2081 l\u2082 : \u03b9 \u2192 \ud835\udd5c) (s : Finset \u03b9) :\n    \u27ea\u2211 i in s, l\u2081 i \u2022 v i, \u2211 i in s, l\u2082 i \u2022 v i\u27eb = \u2211 i in s, conj (l\u2081 i) * l\u2082 i :="}
{"input": "Statement in natural language:\nIf a function 'f' is surjective (meaning that for every element in the target space there is at least one element in the domain that maps to it), then 'f' has a right inverse (meaning there exists a function that, when composed with 'f' from the right, results in the identity function).\nTranslate the statement in natural language to Lean:", "output": "theorem Surjective.hasRightInverse (hf : Surjective f) : HasRightInverse f :="}
{"input": "Statement in natural language:\nThe closure of the union of a set of sets in field K is equal to the supremum of the closures of the sets in the set, for each set in the set.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_sUnion (s : Set (Set K)) : closure (\u22c3\u2080 s) = \u2a06 t \u2208 s, closure t :="}
{"input": "Statement in natural language:\nThe matrix representation of the Gram-Schmidt orthonormal basis, when applied to a function f, is block triangular with respect to the identity function.\nTranslate the statement in natural language to Lean:", "output": "theorem gramSchmidtOrthonormalBasis_inv_blockTriangular :\n    ((gramSchmidtOrthonormalBasis h f).toBasis.toMatrix f).BlockTriangular id :="}
{"input": "Statement in natural language:\nFor a trinomial with indices k, m, and n, where k is less than m and m is less than n, and where w is not equal to zero, the leading coefficient of the trinomial is equal to w.\nTranslate the statement in natural language to Lean:", "output": "theorem trinomial_leadingCoeff (hkm : k < m) (hmn : m < n) (hw : w \u2260 0) :\n    (trinomial k m n u v w).leadingCoeff = w :="}
{"input": "Statement in natural language:\nFor any type \u03b1, if we have two thunks a and b of type \u03b1, and if the result of getting the value from a is equal to the result of getting the value from b, then a is equal to b.\nTranslate the statement in natural language to Lean:", "output": "theorem ext {\u03b1 : Type u} {a b : Thunk \u03b1} (eq : a.get = b.get) : a = b :="}
{"input": "Statement in natural language:\nThe closure of an empty set in a structure L is the bottom element.\nTranslate the statement in natural language to Lean:", "output": "theorem closure_empty : closure L (\u2205 : Set M) = \u22a5 :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' of a certain set '\u03b1', if 'a' is less than the successor of 'b', then 'a' is less than or equal to 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_of_lt_succ {a b : \u03b1} : a < succ b \u2192 a \u2264 b :="}
{"input": "Statement in natural language:\nFor a special linear group 'g' of order 'n' over a ring 'R', the matrix representation of 'g' when it is cast as a general linear group and then as a positive general linear group is the same as the matrix representation of 'g' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_GLPos_coe_GL_coe_matrix (g : SpecialLinearGroup n R) :\n    (\u2191(\u2191(\u2191g : GLPos n R) : GL n R) : Matrix n n R) = \u2191g :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from type \u03b1 to \u03b2, and a finite support function 's' from \u03b1 to some type M, such that 'f' is injective on the support of 's', then the support of the function obtained by mapping the domain of 's' through 'f' is equal to the image of the support of 's' under 'f'. This is under the condition that \u03b2 has a decidable equality.\nTranslate the statement in natural language to Lean:", "output": "theorem mapDomain_support_of_injOn [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (s : \u03b1 \u2192\u2080 M)\n    (hf : Set.InjOn f s.support) : (mapDomain f s).support = Finset.image f s.support :="}
{"input": "Statement in natural language:\nFor any two elements x and y of a certain set \u03b1, the normalization of x equals the normalization of y if and only if x divides y and y divides x.\nTranslate the statement in natural language to Lean:", "output": "theorem normalize_eq_normalize_iff {x y : \u03b1} : normalize x = normalize y \u2194 x \u2223 y \u2227 y \u2223 x :="}
{"input": "Statement in natural language:\nFor a linear map 'f' from 'M' to 'N' and a function 'g' from '\u03b1' to 'M', the application of the linear map 'f' to 'g' using the 'mapRange.linearMap' function is equal to the application of 'f' and 'f.map_zero' to 'g' using the 'mapRange' function.\nTranslate the statement in natural language to Lean:", "output": "theorem mapRange.linearMap_apply (f : M \u2192\u2097[R] N) (g : \u03b1 \u2192\u2080 M) :\n  mapRange.linearMap f g = mapRange f f.map_zero g :="}
{"input": "Statement in natural language:\nIf for every element 'a' in set 's', 'f a' is an element of set 't', and the cardinality of set 't' multiplied by 'b' is less than the cardinality of set 's', then there exists an element 'y' in set 't' such that 'b' is less than the cardinality of the subset of 's' for which 'f x' equals 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to (hf : \u2200 a \u2208 s, f a \u2208 t)\n    (ht : t.card \u2022 b < s.card) : \u2203 y \u2208 t, b < (s.filter fun x => f x = y).card :="}
{"input": "Statement in natural language:\nThe cosine of (x minus two times pi) is equal to the cosine of x, for any real number x.\nTranslate the statement in natural language to Lean:", "output": "theorem cos_sub_two_pi (x : \u211d) : cos (x - 2 * \u03c0) = cos x :="}
{"input": "Statement in natural language:\nThe inverse function of a member of a range is surjective, meaning that for every element in the codomain, there is at least one element in the domain that maps to it.\nTranslate the statement in natural language to Lean:", "output": "theorem invOfMemRange_surjective : Function.Surjective f.invOfMemRange :="}
{"input": "Statement in natural language:\nFor two functors F from category E to category D and G from category D to category C, the mapping of the composition of F and G is equal to the composition of the mapping of F and the mapping of G.\nTranslate the statement in natural language to Lean:", "output": "theorem map_comp_eq (F : E \u2964 D) (G : D \u2964 C) : map (F \u22d9 G) = map F \u22d9 map G :="}
{"input": "Statement in natural language:\nIf a set \u03b1 is finite and nonempty, then the cardinality (or size) of \u03b1 is greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem Finite.card_pos [Finite \u03b1] [h : Nonempty \u03b1] : 0 < Nat.card \u03b1 :="}
{"input": "Statement in natural language:\nFor a given set S and group G with an involutive inverse, and assuming that S is a subset of G with an inverse element belonging to S, then for any subgroup H of S and any element x of G, the inverse of x is in H if and only if x is in H.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_mem_iff {S G} [InvolutiveInv G] {_ : SetLike S G} [InvMemClass S G] {H : S}\n    {x : G} : x\u207b\u00b9 \u2208 H \u2194 x \u2208 H :="}
{"input": "Statement in natural language:\nFor any function 'f' from '\u03b1' to '\u03c3', where '\u03b1' and '\u03c3' are primitively encodable, if 'f' is a primitive recursive function, then 'f' is computable.\nTranslate the statement in natural language to Lean:", "output": "theorem Primrec.to_comp {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] {f : \u03b1 \u2192 \u03c3} (hf : Primrec f) :\n    Computable f :="}
{"input": "Statement in natural language:\nFor any three paths p, q, and r in a topological space X, with p going from point x\u2080 to x\u2081, q from x\u2081 to x\u2082, and r from x\u2082 to x\u2083, the path obtained by first traversing p, then q, and then r is the same as the path obtained by first traversing p, then the path obtained by traversing q and then r, after reparametrizing this latter path using a function that satisfies certain conditions (namely, it is continuous, and its values at 0 and 1 are the same as those of a certain auxiliary function).\nTranslate the statement in natural language to Lean:", "output": "theorem trans_assoc_reparam {x\u2080 x\u2081 x\u2082 x\u2083 : X} (p : Path x\u2080 x\u2081) (q : Path x\u2081 x\u2082) (r : Path x\u2082 x\u2083) :\n    (p.trans q).trans r =\n      (p.trans (q.trans r)).reparam\n        (fun t => \u27e8transAssocReparamAux t, transAssocReparamAux_mem_I t\u27e9) (by continuity)\n        (Subtype.ext transAssocReparamAux_zero) (Subtype.ext transAssocReparamAux_one) :="}
{"input": "Statement in natural language:\nFor a given set 's' in Euclidean space 'E', if 's' is finite, then the convex hull of 's' in the real numbers is compact.\nTranslate the statement in natural language to Lean:", "output": "theorem Set.Finite.isCompact_convexHull {s : Set E} (hs : s.Finite) :\n    IsCompact (convexHull \u211d s) :="}
{"input": "Statement in natural language:\nFor a given polynomial 'f' over a field 'K', if 'f' splits over the ring homomorphism identity on 'K', then the roots of the mapped polynomial 'f' under a function 'i' are equal to the roots of 'f' mapped under the same function 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem roots_map {f : K[X]} (hf : f.Splits <| RingHom.id K) : (f.map i).roots = f.roots.map i :="}
{"input": "Statement in natural language:\nThe object 'one' of the parallel family 'f' is equal to 'Y'.\nTranslate the statement in natural language to Lean:", "output": "theorem parallelFamily_obj_one : (parallelFamily f).obj one = Y :="}
{"input": "Statement in natural language:\nFor two complex-valued functions 'f' and 'g', a complex number 'c', and a real number 'R', if 'f' and 'g' are both circle integrable with respect to 'c' and 'R', then the integral over the circle centered at 'c' with radius 'R' of the difference between 'f' and 'g' is equal to the difference between the integral of 'f' and the integral of 'g' over the same circle.\nTranslate the statement in natural language to Lean:", "output": "theorem integral_sub {f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d} (hf : CircleIntegrable f c R)\n    (hg : CircleIntegrable g c R) :\n    (\u222e z in C(c, R), f z - g z) = (\u222e z in C(c, R), f z) - \u222e z in C(c, R), g z :="}
{"input": "Statement in natural language:\nFor a given object 'k' in category 'K', the composition of the limit precomposition of functor 'F' with 'E' and the limit cone projection of the functor composition of 'E' and 'F' at 'k' is equal to the limit cone projection of 'F' at the object 'E.obj k'.\nTranslate the statement in natural language to Lean:", "output": "theorem limit.pre_\u03c0 (k : K) : limit.pre F E \u226b limit.\u03c0 (E \u22d9 F) k = limit.\u03c0 F (E.obj k) :="}
{"input": "Statement in natural language:\nFor a given measure '\u03bc' and a set 's' in the measure space '\u03b1', the set 's' is a subset of the measurable set 'toMeasurable \u03bc s'.\nTranslate the statement in natural language to Lean:", "output": "theorem subset_toMeasurable (\u03bc : Measure \u03b1) (s : Set \u03b1) : s \u2286 toMeasurable \u03bc s :="}
{"input": "Statement in natural language:\nFor a given commutative semiring R, a function f from M to \u03b9, an element m of M, and an element r of R, the single-valued function (Finsupp.single) with m as the key and r as the value belongs to the gradeBy of R, f, and the function of m.\nTranslate the statement in natural language to Lean:", "output": "theorem single_mem_gradeBy {R} [CommSemiring R] (f : M \u2192 \u03b9) (m : M) (r : R) :\n    Finsupp.single m r \u2208 gradeBy R f (f m) :="}
{"input": "Statement in natural language:\nIf a\u2082 is less than or equal to b\u2082, a\u2082 is less than a\u2081, and b\u2081 is less than or equal to b\u2082, then the closed interval from a\u2081 to b\u2081 is a proper subset of the closed interval from a\u2082 to b\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem Icc_ssubset_Icc_left (hI : a\u2082 \u2264 b\u2082) (ha : a\u2082 < a\u2081) (hb : b\u2081 \u2264 b\u2082) : Icc a\u2081 b\u2081 \u2282 Icc a\u2082 b\u2082 :="}
{"input": "Statement in natural language:\nIf the natural degree of a polynomial 'p' is less than or equal to one, then there exist coefficients 'a' and 'b' such that 'p' can be expressed as 'a' times 'X' plus 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_eq_X_add_C_of_natDegree_le_one (h : natDegree p \u2264 1) : \u2203 a b, p = C a * X + C b :="}
{"input": "Statement in natural language:\nA constant function (denoted by 'c' and of type 'F') is differentiable over the field '\ud835\udd5c' and the domain 'E'.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiable_const (c : F) : Differentiable \ud835\udd5c fun _ : E => c :="}
{"input": "Statement in natural language:\nFor a given filter L on a set E, the function that maps each element x' in E to the product of the inverse of the norm of the difference between x' and x, and the norm of the difference between the function f at x' and the function f at x minus the derivative of f at the difference between x' and x, tends to 0 as x' approaches x if and only if the function that maps each element x' in E to the scalar product of the inverse of the norm of the difference between x' and x, and the difference between the function f at x' and the function f at x minus the derivative of f at the difference between x' and x, tends to 0 as x' approaches x.\nTranslate the statement in natural language to Lean:", "output": "theorem has_fderiv_at_filter_real_equiv {L : Filter E} :\n    Tendsto (fun x' : E => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - f' (x' - x)\u2016) L (\ud835\udcdd 0) \u2194\n      Tendsto (fun x' : E => \u2016x' - x\u2016\u207b\u00b9 \u2022 (f x' - f x - f' (x' - x))) L (\ud835\udcdd 0) :="}
{"input": "Statement in natural language:\nFor any subgroup H of N, the product of the top subgroup of G and H is equal to the comap of H with respect to the second monoid homomorphism from G to N.\nTranslate the statement in natural language to Lean:", "output": "theorem top_prod (H : Subgroup N) : (\u22a4 : Subgroup G).prod H = H.comap (MonoidHom.snd G N) :="}
{"input": "Statement in natural language:\nFor any four objects W, X, Y, Z in a category C, given that W and X have a binary biproduct and Y and Z also have a binary biproduct, for any morphism f from W to Y and any morphism g from X to Z, the composition of the biproduct map of f and g followed by the first projection of the biproduct is equal to the composition of the first projection of the biproduct followed by f.\nTranslate the statement in natural language to Lean:", "output": "theorem biprod.map_fst {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) : biprod.map f g \u226b biprod.fst = biprod.fst \u226b f :="}
{"input": "Statement in natural language:\nIf we have a supremum operation on \u03b2 and this operation is continuous, then if function f is strongly measurable and function g is also strongly measurable, the supremum of f and g is also strongly measurable.\nTranslate the statement in natural language to Lean:", "output": "theorem sup [Sup \u03b2] [ContinuousSup \u03b2] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f \u2294 g) :="}
{"input": "Statement in natural language:\nThe absolute value of the sum of x and y equals the sum of the absolute values of x and y if and only if either x equals zero, y equals zero, or the argument of x equals the argument of y.\nTranslate the statement in natural language to Lean:", "output": "theorem abs_add_eq_iff : abs (x + y) = abs x + abs y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg :="}
{"input": "Statement in natural language:\nFor a given ring isomorphism between S and R, and a given element r of R, the inverse of the equivalence between L and M under the algebra map of R to M applied to r is equal to the algebra map of S to L applied to the inverse of the ring isomorphism applied to r.\nTranslate the statement in natural language to Lean:", "output": "theorem equivOfEquiv_symm_algebraMap (hSR : S \u2243+* R) (r : R) :\n    (equivOfEquiv L M hSR).symm (algebraMap R M r) = algebraMap S L (hSR.symm r) :="}
{"input": "Statement in natural language:\nFor a given set 's' of a certain type '\u03b1', under the conditions that '\u03b1' has a topological space structure, a complete linear order, and an order topology, if the set 's' is nonempty, then the greatest lower bound (infimum) of the set 's' is an element of the closure of the set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem sInf_mem_closure {\u03b1 : Type u} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    {s : Set \u03b1} (hs : s.Nonempty) : sInf s \u2208 closure s :="}
{"input": "Statement in natural language:\nFor two supremum-preserving functions g\u2081 and g\u2082 from \u03b2 to \u03b3, and a surjective supremum-preserving function f from \u03b1 to \u03b2, g\u2081 composed with f equals g\u2082 composed with f if and only if g\u2081 equals g\u2082. This is known as right cancellation.\nTranslate the statement in natural language to Lean:", "output": "theorem cancel_right {g\u2081 g\u2082 : SupHom \u03b2 \u03b3} {f : SupHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082 :="}
{"input": "Statement in natural language:\nThe neighborhood of infinity has a basis consisting of sets that are greater than a certain value, where this value is less than infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem nhds_top_basis : (\ud835\udcdd \u221e).HasBasis (fun a => a < \u221e) fun a => Ioi a :="}
{"input": "Statement in natural language:\nFor two functions f\u2081 and f\u2082 from \u03b1 to \u03b2, and two filters l\u2081 on \u03b1 and l\u2082 on \u03b2, if f\u2081 is eventually equal to f\u2082 at l\u2081, then the tendency of f\u2081 to go from l\u2081 to l\u2082 is equivalent to the tendency of f\u2082 to go from l\u2081 to l\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_congr' {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (hl : f\u2081 =\u1da0[l\u2081] f\u2082) :\n    Tendsto f\u2081 l\u2081 l\u2082 \u2194 Tendsto f\u2082 l\u2081 l\u2082 :="}
{"input": "Statement in natural language:\nFor any element 'x' of the Centroid Homomorphism of '\u03b1' and any natural number 'n', the endomorphism of 'x' raised to the power 'n' is equal to the endomorphism of 'x' itself raised to the power 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem toEnd_pow (x : CentroidHom \u03b1) (n : \u2115) : (x ^ n).toEnd = x.toEnd ^ n :="}
{"input": "Statement in natural language:\nThe arccosine function is differentiable at a real number x if and only if x is not equal to -1 and x is not equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem differentiableAt_arccos {x : \u211d} : DifferentiableAt \u211d arccos x \u2194 x \u2260 -1 \u2227 x \u2260 1 :="}
{"input": "Statement in natural language:\nFor any natural number 'n', and any function 'v' from the finite set of size 'n' to the real numbers 'R', the value of the Vandermonde matrix at the 'i'th row and 'j'th column is equal to the 'i'th value of 'v' raised to the power of 'j'.\nTranslate the statement in natural language to Lean:", "output": "theorem vandermonde_apply {n : \u2115} (v : Fin n \u2192 R) (i j) : vandermonde v i j = v i ^ (j : \u2115) :="}
{"input": "Statement in natural language:\nThe function that maps a point to the infimum non-negative distance from that point to a set is continuous.\nTranslate the statement in natural language to Lean:", "output": "theorem continuous_infNndist_pt (s : Set \u03b1) : Continuous fun x => infNndist x s :="}
{"input": "Statement in natural language:\nFor any cardinal number 'c', 'c' is greater than or equal to 1 if and only if 'c' is not equal to 0.\nTranslate the statement in natural language to Lean:", "output": "theorem one_le_iff_ne_zero {c : Cardinal} : 1 \u2264 c \u2194 c \u2260 0 :="}
{"input": "Statement in natural language:\nFor any four games w, x, y, z, if game w is less than or equal to game x and game y is not fuzzy with game z, then the sum of game w and game y is not fuzzy with the sum of game x and game z.\nTranslate the statement in natural language to Lean:", "output": "theorem add_lf_add_of_le_of_lf {w x y z : PGame} (hwx : w \u2264 x) (hyz : y \u29cf z) : w + y \u29cf x + z :="}
{"input": "Statement in natural language:\nFor a set 's' of sequences in 'E', if 's' is closed and nonempty, and 'x' is any sequence in 'E', then the intersection of 's' and the cylinder of 'x' with the longest prefix in 's' is also nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem inter_cylinder_longestPrefix_nonempty {s : Set (\u2200 n, E n)} (hs : IsClosed s)\n    (hne : s.Nonempty) (x : \u2200 n, E n) : (s \u2229 cylinder x (longestPrefix x s)).Nonempty :="}
{"input": "Statement in natural language:\nFor any element 'a' and any finite set 's', if 'a' is not a member of 's', then the set that results from attempting to remove 'a' from 's' is equal to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem erase_eq_of_not_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : erase s a = s :="}
{"input": "Statement in natural language:\nThe positive value is equal to one.\nTranslate the statement in natural language to Lean:", "output": "theorem pos_eq_one : pos = 1 :="}
{"input": "Statement in natural language:\nFor any two local equivalences 'e' between types \u03b1 and \u03b2, and 'e'' between types \u03b3 and \u03b4, the symmetry of the product of 'e' and 'e'' is equal to the product of the symmetries of 'e' and 'e''.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_symm (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) :\n    (e.prod e').symm = e.symm.prod e'.symm :="}
{"input": "Statement in natural language:\nFor any natural number 'n', converting 'n' from a non-negative extended real number to a non-negative real number results in 'n' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem toNNReal_nat (n : \u2115) : (n : \u211d\u22650\u221e).toNNReal = n :="}
{"input": "Statement in natural language:\nThe inverse of zero in the power series over a field k is zero.\nTranslate the statement in natural language to Lean:", "output": "theorem zero_inv : (0 : PowerSeries k)\u207b\u00b9 = 0 :="}
{"input": "Statement in natural language:\nFor a given function 'f' from '\u03b1' to 'M' where 'M' is a zero element and 'G' is an additive commutative group, and two functions 'h\u2081' and 'h\u2082' from '\u03b1' to 'M' to 'G', the sum of the differences between 'h\u2081' and 'h\u2082' for each element in 'f' is equal to the difference between the sum of 'h\u2081' for each element in 'f' and the sum of 'h\u2082' for each element in 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem sum_sub [Zero M] [AddCommGroup G] {f : \u03b1 \u2192\u2080 M} {h\u2081 h\u2082 : \u03b1 \u2192 M \u2192 G} :\n    (f.sum fun a b => h\u2081 a b - h\u2082 a b) = f.sum h\u2081 - f.sum h\u2082 :="}
{"input": "Statement in natural language:\nThe sum of the reciprocals of the non-negative real numbers p and q is equal to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_add_inv_conj_nnreal : 1 / Real.toNNReal p + 1 / Real.toNNReal q = 1 :="}
{"input": "Statement in natural language:\nFor a function 'f' which is a complete lattice homomorphism from \u03b1 to \u03b2, the coercion of 'f' to an infimum-preserving function is equal to the function 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem toFun_eq_coe_aux {f : CompleteLatticeHom \u03b1 \u03b2} : \u2191f.tosInfHom = \u21d1f :="}
{"input": "Statement in natural language:\nFor a given type G, if G is a group and a topological space, and if the following conditions are met:\n\n1. The uncurried function of multiplication tends to 1 when both its arguments tend to 1 in the topology of G.\n2. The function that takes an element to its inverse in the group G tends to 1 when the element tends to 1 in the topology of G.\n3. For every element in G, the neighborhood of that element is the image of the neighborhood of 1 under the function that multiplies by that element.\n4. For every element in G, the function that conjugates by that element tends to 1 when the argument tends to 1 in the topology of G.\n\nThen G is a topological group.\nTranslate the statement in natural language to Lean:", "output": "theorem TopologicalGroup.of_nhds_one {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : G \u2192 G \u2192 G)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n    (hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n    (hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1))\n    (hconj : \u2200 x\u2080 : G, Tendsto (fun x => x\u2080 * x * x\u2080\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1)) : TopologicalGroup G :="}
{"input": "Statement in natural language:\nIf I and J are ideals of a ring A and both are homogeneous with respect to a graded algebra \ud835\udc9c, then the product of I and J is also homogeneous with respect to \ud835\udc9c.\nTranslate the statement in natural language to Lean:", "output": "theorem Ideal.IsHomogeneous.mul {I J : Ideal A} (HI : I.IsHomogeneous \ud835\udc9c) (HJ : J.IsHomogeneous \ud835\udc9c) :\n    (I * J).IsHomogeneous \ud835\udc9c :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from '\u03b1' to '\u03b2', a set 's' of '\u03b1', and an element 'a' of '\u03b1', and if the function 'f' is strictly monotonically increasing on the set 's', and if the set 's' is in the neighborhood of 'a' with values greater than or equal to 'a', and if for every 'b' greater than 'f(a)', there exists a 'c' in 's' such that 'f(c)' is in the open interval between 'f(a)' and 'b', then the function 'f' is continuous at 'a' within the set of all '\u03b1' greater than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem StrictMonoOn.continuousWithinAt_right_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a) (hfs : \u2200 b > f a, \u2203 c \u2208 s, f c \u2208 Ioc (f a) b) :\n    ContinuousWithinAt f (Ici a) a :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03c3' to '\u03c4' that is injective, a multivariate polynomial '\u03c6' over '\u03c3' and 'R', and a function 'd' from '\u03c3' to the natural numbers, the coefficient of the renamed polynomial (where 'f' is applied to '\u03c6') at the domain mapped by 'f' is equal to the coefficient of '\u03c6' at 'd'.\nTranslate the statement in natural language to Lean:", "output": "theorem coeff_rename_mapDomain (f : \u03c3 \u2192 \u03c4) (hf : Injective f) (\u03c6 : MvPolynomial \u03c3 R) (d : \u03c3 \u2192\u2080 \u2115) :\n    (rename f \u03c6).coeff (d.mapDomain f) = \u03c6.coeff d :="}
{"input": "Statement in natural language:\nA function 'f' is equitable on a set 's' if and only if for every element 'a' in 's', the value of 'f' at 'a' is equal to the sum of the values of 'f' at every element in 's' divided by the cardinality of 's', or the value of 'f' at 'a' is equal to the sum of the values of 'f' at every element in 's' divided by the cardinality of 's' plus one.\nTranslate the statement in natural language to Lean:", "output": "theorem equitableOn_iff :\n    EquitableOn (s : Set \u03b1) f \u2194\n      \u2200 a \u2208 s, f a = (\u2211 i in s, f i) / s.card \u2228 f a = (\u2211 i in s, f i) / s.card + 1 :="}
{"input": "Statement in natural language:\nFor a measurable set 's', the indicator function of 's' applied to a function 'f' is almost everywhere equal to the function 'f' restricted to the set 's' with respect to the measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem indicator_ae_eq_restrict (hs : MeasurableSet s) : indicator s f =\u1d50[\u03bc.restrict s] f :="}
{"input": "Statement in natural language:\nFor a given equivalence between two types \u03b3 and \u03b2, and a function from \u03b2 to \u03b1, the infinite sum over \u03b3 of the function composed with the equivalence is equal to the infinite sum over \u03b2 of the function.\nTranslate the statement in natural language to Lean:", "output": "theorem Equiv.tsum_eq (j : \u03b3 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b1) : (\u2211' c, f (j c)) = \u2211' b, f b :="}
{"input": "Statement in natural language:\nFor any function 'f' that maps each index 'i' to a filter on '\u03b1 i', and for any index 'i', the function 'eval i' tends towards the filter 'f i' when evaluated over the product of filters 'pi f'.\nTranslate the statement in natural language to Lean:", "output": "theorem tendsto_eval_pi (f : \u2200 i, Filter (\u03b1 i)) (i : \u03b9) : Tendsto (eval i) (pi f) (f i) :="}
{"input": "Statement in natural language:\n, given a function 'k' that tends to 'l' at the top, the function 'f' has superpolynomial decay with respect to 'l' and 'k' if and only if for every integer 'z', 'f' is a big O of the function that maps 'a' (of type alpha) to 'k' of 'a' raised to the power of 'z', at 'l'.\nTranslate the statement in natural language to Lean:", "output": "theorem superpolynomialDecay_iff_isBigO (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k f \u2194 \u2200 z : \u2124, f =O[l] fun a : \u03b1 => k a ^ z :="}
{"input": "Statement in natural language:\nThe range of the identity function from a structure L to a structure M is the top element or the whole set.\nTranslate the statement in natural language to Lean:", "output": "theorem range_id : range (id L M) = \u22a4 :="}
{"input": "Statement in natural language:\nFor two functions f and g that commute, where f is monotone and g is strictly monotone, for any x and a positive integer n, the nth iteration of f and g applied to x are equal if and only if the functions f and g are equal when applied to x.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_pos_eq_iff_map_eq (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : (f^[n]) x = (g^[n]) x \u2194 f x = g x :="}
{"input": "Statement in natural language:\nThe bounded limit inferior (bliminf) of a function u with respect to a filter f for a condition that is either p(x) or q(x), is less than or equal to the bounded limit inferior of the same function with respect to the same filter for the condition p(x).\nTranslate the statement in natural language to Lean:", "output": "theorem bliminf_or_le_inf_aux_left : (bliminf u f fun x => p x \u2228 q x) \u2264 bliminf u f p :="}
{"input": "Statement in natural language:\nThe dual pairing of a subspace W of V\u2081 over a field K is nondegenerate.\nTranslate the statement in natural language to Lean:", "output": "theorem dualPairing_nondegenerate (W : Subspace K V\u2081) : W.dualPairing.Nondegenerate :="}
{"input": "Statement in natural language:\nFor any natural numbers 'b' and 'n', the logarithm base 'b' of the product of 'n' divided by 'b' and 'b' is equal to the logarithm base 'b' of 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem log_div_mul_self (b n : \u2115) : log b (n / b * b) = log b n :="}
{"input": "Statement in natural language:\nFor any measure '\u03bc' on a group 'G', the condition that for all elements 'g' of 'G' and for all sets 'A' of 'G' that are measurable, the measure of the preimage of 'A' under the function that multiplies 'g' with an element 'h' is equal to the measure of 'A', if and only if the measure '\u03bc' is left invariant under multiplication.\nTranslate the statement in natural language to Lean:", "output": "theorem forall_measure_preimage_mul_iff (\u03bc : Measure G) :\n    (\u2200 (g : G) (A : Set G), MeasurableSet A \u2192 \u03bc ((fun h => g * h) \u207b\u00b9' A) = \u03bc A) \u2194\n      IsMulLeftInvariant \u03bc :="}
{"input": "Statement in natural language:\nFor a covariant class in algebraic order, given any three elements a, b, and c, the supremum (or greatest lower bound) of a and b, when multiplied by c, is equal to the supremum of the products of a and c, and b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem sup_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) : (a \u2294 b) * c = a * c \u2294 b * c :="}
{"input": "Statement in natural language:\nFor a given convex set 's' in a vector space 'E' and a given element 'x' in 'E', the set 's' remains convex after removing 'x' if and only if 'x' is not in the convex hull of the set 's' after 'x' has been removed.\nTranslate the statement in natural language to Lean:", "output": "theorem Convex.convex_remove_iff_not_mem_convexHull_remove {s : Set E} (hs : Convex \ud835\udd5c s) (x : E) :\n    Convex \ud835\udd5c (s \\ {x}) \u2194 x \u2209 convexHull \ud835\udd5c (s \\ {x}) :="}
{"input": "Statement in natural language:\nFor a given element 'a' of a ring 'R', if 'a' is in the set of non-units of 'R', then '1 - a' is a unit.\nTranslate the statement in natural language to Lean:", "output": "theorem isUnit_one_sub_self_of_mem_nonunits (a : R) (h : a \u2208 nonunits R) : IsUnit (1 - a) :="}
{"input": "Statement in natural language:\nIn a preordered set \u03b1, if for every element a there exists an element b in set s such that a is less than or equal to b, then the set s is unbounded with respect to the less than relation.\nTranslate the statement in natural language to Lean:", "output": "theorem unbounded_lt_of_forall_exists_le [Preorder \u03b1] (h : \u2200 a, \u2203 b \u2208 s, a \u2264 b) :\n    Unbounded (\u00b7 < \u00b7) s :="}
{"input": "Statement in natural language:\nFor any object X in category C, applying the function 'app \u03c4' to the object 'W.Q.obj X' is equal to applying '\u03c4.app' to X.\nTranslate the statement in natural language to Lean:", "output": "theorem app_eq (X : C) : (app \u03c4) (W.Q.obj X) = \u03c4.app X :="}
{"input": "Statement in natural language:\nFor a nonempty set \u03b1 and a real number M, the norm of function f is less than M if and only if for all elements x, the norm of f(x) is less than M.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_lt_iff_of_nonempty [Nonempty \u03b1] {M : \u211d} : \u2016f\u2016 < M \u2194 \u2200 x, \u2016f x\u2016 < M :="}
{"input": "Statement in natural language:\nIn the box product of two simple graphs G and H, the vertices (a, b\u2081) and (a, b\u2082) are adjacent if and only if the vertices b\u2081 and b\u2082 are adjacent in the graph H.\nTranslate the statement in natural language to Lean:", "output": "theorem boxProd_adj_right : (G \u25a1 H).Adj (a, b\u2081) (a, b\u2082) \u2194 H.Adj b\u2081 b\u2082 :="}
{"input": "Statement in natural language:\nFor a function 'f' from set M to N, if the closure of a subset 's' equals the universal set, then the function derived from the closure of M equals the top left, which is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_ofClosureMEqTopLeft (f : M \u2192 N) (hs : closure s = \u22a4) (h1 hmul) :\n    \u21d1(ofClosureMEqTopLeft f hs h1 hmul) = f :="}
{"input": "Statement in natural language:\nFor any even number 'n' and any element 'a' in a field, the nth power of 'a' is greater than or equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem Even.zpow_nonneg (hn : Even n) (a : \u03b1) : 0 \u2264 a ^ n :="}
{"input": "Statement in natural language:\nFor a decidable equality type \u03b7 that is finite, given a function H that maps each element i to a subgroup of f(i), and a subgroup J of the function that maps each element i to f(i), the product over the universe of H is less than or equal to J if and only if for every element i of \u03b7, the map of the monoid homomorphism of f at i and H(i) is less than or equal to J.\nTranslate the statement in natural language to Lean:", "output": "theorem pi_le_iff [DecidableEq \u03b7] [Finite \u03b7] {H : \u2200 i, Subgroup (f i)} {J : Subgroup (\u2200 i, f i)} :\n    pi univ H \u2264 J \u2194 \u2200 i : \u03b7, map (MonoidHom.single f i) (H i) \u2264 J :="}
{"input": "Statement in natural language:\nIf a function c is differentiable at a point x, then the derivative of the function that multiplies c by a constant d at the point x is equal to d times the derivative of c at x.\nTranslate the statement in natural language to Lean:", "output": "theorem fderiv_mul_const (hc : DifferentiableAt \ud835\udd5c c x) (d : \ud835\udd38') :\n    fderiv \ud835\udd5c (fun y => c y * d) x = d \u2022 fderiv \ud835\udd5c c x :="}
{"input": "Statement in natural language:\nFor any three numbers a, b, and c, the maximum value of the division of a by b and the division of a by c is equal to the division of a by the minimum value of b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem max_div_div_left' (a b c : \u03b1) : max (a / b) (a / c) = a / min b c :="}
{"input": "Statement in natural language:\nThe intersection over the union of two sets of sets, S and T, is equal to the intersection of the intersection over S and the intersection over T.\nTranslate the statement in natural language to Lean:", "output": "theorem sInter_union (S T : Set (Set \u03b1)) : \u22c2\u2080 (S \u222a T) = \u22c2\u2080 S \u2229 \u22c2\u2080 T :="}
{"input": "Statement in natural language:\nFor a real-valued linear map 'f' from a function '\u03b9 \u2192 \u211d' to another function '\u03b9 \u2192 \u211d', if the determinant of 'f' is not zero, then the measure of the map 'f' with respect to the volume is equal to the scalar multiple of the volume, where the scalar is the inverse of the absolute value of the determinant of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem map_linearMap_volume_pi_eq_smul_volume_pi {f : (\u03b9 \u2192 \u211d) \u2192\u2097[\u211d] \u03b9 \u2192 \u211d}\n    (hf : LinearMap.det f \u2260 0) : Measure.map f volume =\n      ENNReal.ofReal (abs (LinearMap.det f)\u207b\u00b9) \u2022 volume :="}
{"input": "Statement in natural language:\nFor any element 'r' from set M and any elements 'x' and 'y' from set A, the scalar multiplication of 'r' with the division of 'x' and 'y' is equal to the division of the scalar multiplication of 'r' with 'x' and the scalar multiplication of 'r' with 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_div' (r : M) (x y : A) : r \u2022 (x / y) = r \u2022 x / r \u2022 y :="}
{"input": "Statement in natural language:\nIn a preorder set of elements \u03b1, where \u03b1 is a subsingleton (a set with at most one element), any element x is less than or equal to any element y.\nTranslate the statement in natural language to Lean:", "output": "theorem Subsingleton.le [Preorder \u03b1] [Subsingleton \u03b1] (x y : \u03b1) : x \u2264 y :="}
{"input": "Statement in natural language:\nFor any three natural numbers a, b, and c, if a is greater than 0, then the product of b and a not being equal to the product of c and a implies that b is not equal to c.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_ne_mul_left {a b c : \u2115} (ha : 0 < a) : b * a \u2260 c * a \u2194 b \u2260 c :="}
{"input": "Statement in natural language:\nFor any two elements a\u2081, b\u2081 from ring R and any two elements a\u2082, b\u2082 from module M, if the product of b\u2081 and the co-unit of a\u2082 equals the product of a\u2081 and the co-unit of b\u2082, then the localization of ring R at multiplicative set S with respect to a\u2081 and a\u2082 equals the localization of ring R at multiplicative set S with respect to b\u2081 and b\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem mk'_eq_of_eq' {a\u2081 b\u2081 : R} {a\u2082 b\u2082 : M} (H : b\u2081 * \u2191a\u2082 = a\u2081 * \u2191b\u2082) :\n    mk' S a\u2081 a\u2082 = mk' S b\u2081 b\u2082 :="}
{"input": "Statement in natural language:\nFor any two decidable predicates P and Q, if P is less than or equal to Q, then the greatest natural number satisfying P is less than or equal to the greatest natural number satisfying Q.\nTranslate the statement in natural language to Lean:", "output": "theorem findGreatest_mono_left [DecidablePred Q] (hPQ : P \u2264 Q) :\n    Nat.findGreatest P \u2264 Nat.findGreatest Q :="}
{"input": "Statement in natural language:\nFor any two fractional ideals I and J in a ring of fractions S over a ring P, and for any property C of elements in P, if an element r belongs to the product of I and J, and if the property C holds for the product of any element in I and any element in J, and if the property C holds for the sum of any two elements for which C holds, then the property C holds for the element r.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_induction_on {I J : FractionalIdeal S P} {C : P \u2192 Prop} {r : P}\n    (hr : r \u2208 I * J) (hm : \u2200 i \u2208 I, \u2200 j \u2208 J, C (i * j)) (ha : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) :\n    C r :="}
{"input": "Statement in natural language:\nThe degree of the product of a multiset 't' is less than or equal to the sum of the degrees of the polynomials in 't'.\nTranslate the statement in natural language to Lean:", "output": "theorem degree_multiset_prod_le : t.prod.degree \u2264 (t.map Polynomial.degree).sum :="}
{"input": "Statement in natural language:\nIn a Polish space, a measurable space, and a Borel space, for any set 's', if 's' is a measurable set, then 's' is clopenable.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.MeasurableSet.isClopenable [PolishSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1]\n    {s : Set \u03b1} (hs : MeasurableSet s) : IsClopenable s :="}
{"input": "Statement in natural language:\nFor a covariant class in algebra, given two elements b and c such that b is less than c, and another element a, the product of a and b is less than the product of a and c. This is under the condition that the operation is multiplication and the relation is less than.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_lt_mul_left' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {b c : \u03b1} (bc : b < c) (a : \u03b1) :\n    a * b < a * c :="}
{"input": "Statement in natural language:\nThe Chebyshev polynomial of the second kind in ring R is equal to 2 times the square of the polynomial variable minus 1.\nTranslate the statement in natural language to Lean:", "output": "theorem T_two : T R 2 = 2 * X ^ 2 - 1 :="}
{"input": "Statement in natural language:\nThe arccosine of zero is equal to pi divided by two.\nTranslate the statement in natural language to Lean:", "output": "theorem arccos_zero : arccos 0 = \u03c0 / 2 :="}
{"input": "Statement in natural language:\nFor a given multiset 'm' of type \u03b1, if we convert 'm' to an enumerated finite set and then map the first element of each pair in the set, we will get back the original multiset 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem Multiset.map_toEnumFinset_fst (m : Multiset \u03b1) : m.toEnumFinset.val.map Prod.fst = m :="}
{"input": "Statement in natural language:\nThe exponential of the conjugate of a complex number is equal to the conjugate of the exponential of the complex number.\nTranslate the statement in natural language to Lean:", "output": "theorem exp_conj : exp (conj x) = conj (exp x) :="}
{"input": "Statement in natural language:\nFor any element 'x' in a set 's', the inclusion of 'x' in the subset that is identical to 's' (i.e., the subset is 's' itself) is equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem inclusion_self (x : s) : inclusion Subset.rfl x = x :="}
{"input": "Statement in natural language:\nIf we have a filter 'f' on a set '\u03b1' and two functions 'ma' and 'mb' from '\u03b1' to the extended non-negative real numbers, along with two extended non-negative real numbers 'a' and 'b'. If 'ma' tends to 'a' along 'f', 'a' is not zero or 'b' is not infinity, 'mb' tends to 'b' along 'f', and 'b' is not zero or 'a' is not infinity, then the function that maps 'a' to the product of 'ma' at 'a' and 'mb' at 'a' tends to the product of 'a' and 'b' along 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Tendsto.mul {f : Filter \u03b1} {ma : \u03b1 \u2192 \u211d\u22650\u221e} {mb : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hma : Tendsto ma f (\ud835\udcdd a)) (ha : a \u2260 0 \u2228 b \u2260 \u22a4) (hmb : Tendsto mb f (\ud835\udcdd b))\n    (hb : b \u2260 0 \u2228 a \u2260 \u22a4) : Tendsto (fun a => ma a * mb a) f (\ud835\udcdd (a * b)) :="}
{"input": "Statement in natural language:\nFor a given point 'x' that is a generic point of a set 'S', and a set 'U' that is open, 'S' and 'U' are disjoint if and only if 'x' is not an element of 'U'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_iff (h : IsGenericPoint x S) (hU : IsOpen U) : Disjoint S U \u2194 x \u2209 U :="}
{"input": "Statement in natural language:\nFor a given element 'x' from the trivial square zero extension of rings 'R' and 'M', if 'x.fst' (the first component of 'x') is invertible, then 'x' is equal to the scalar multiplication of 'x.fst' and the exponential of the scalar multiplication of the inverse of 'x.fst' and 'inr x.snd' (the second component of 'x' embedded in the extension).\nTranslate the statement in natural language to Lean:", "output": "theorem eq_smul_exp_of_invertible (x : tsze R M) [Invertible x.fst] :\n    x = x.fst \u2022 exp \ud835\udd5c (\u215f x.fst \u2022 inr x.snd) :="}
{"input": "Statement in natural language:\nThe upper bounds of the set of all elements less than or equal to a certain value 'a' is the set of all elements greater than or equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem upperBounds_Iic : upperBounds (Iic a) = Ici a :="}
{"input": "Statement in natural language:\nIf R is a type with a commutative semiring structure, \u03c3 is a finite type, and R has no zero divisors, then the multivariate polynomial ring over R with variables from \u03c3 also has no zero divisors.\nTranslate the statement in natural language to Lean:", "output": "theorem noZeroDivisors_of_finite (R : Type u) (\u03c3 : Type v) [CommSemiring R] [Finite \u03c3]\n    [NoZeroDivisors R] : NoZeroDivisors (MvPolynomial \u03c3 R) :="}
{"input": "Statement in natural language:\nThe set of proper divisors of 1 is empty.\nTranslate the statement in natural language to Lean:", "output": "theorem properDivisors_one : properDivisors 1 = \u2205 :="}
{"input": "Statement in natural language:\nIf set t\u2081 is a subset of set t\u2082, then the union of set s and t\u2081 is a subset of the union of set s and t\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem union_subset_union_right (h : t\u2081 \u2286 t\u2082) : s \u222a t\u2081 \u2286 s \u222a t\u2082 :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b' from a set '\u03b1', the function 'toBoolAlg' applied to 'a' equals 'toBoolAlg' applied to 'b' if and only if 'a' equals 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem toBoolAlg_inj {a b : \u03b1} : toBoolAlg a = toBoolAlg b \u2194 a = b :="}
{"input": "Statement in natural language:\nFor any two positional games x and y, x is less than or equal to y if and only if one of the following two conditions is met:\n\n1. There exists a move i for x such that for all moves i' for x, the game resulting from x moving left by i' is less than or equal to the game resulting from y moving left by i, and for all moves j for y, x is less than or equal to the game resulting from the game resulting from y moving left by i moving right by j.\n\n2. There exists a move j for y such that for all moves i for x, the game resulting from the game resulting from x moving right by j moving left by i is less than or equal to y, and for all moves j' for y, the game resulting from x moving right by j is less than or equal to the game resulting from y moving right by j'.\nTranslate the statement in natural language to Lean:", "output": "theorem lf_def {x y : PGame} :\n    x \u29cf y \u2194\n      (\u2203 i, (\u2200 i', x.moveLeft i' \u29cf y.moveLeft i) \u2227 \u2200 j, x \u29cf (y.moveLeft i).moveRight j) \u2228\n        \u2203 j, (\u2200 i, (x.moveRight j).moveLeft i \u29cf y) \u2227 \u2200 j', x.moveRight j \u29cf y.moveRight j' :="}
{"input": "Statement in natural language:\nFor any partial function 's' with output type '\u03c3', the function that ignores its input and always returns 's' is partially recursive.\nTranslate the statement in natural language to Lean:", "output": "theorem const' (s : Part \u03c3) : Partrec fun _ : \u03b1 => s :="}
{"input": "Statement in natural language:\nFor any three finite sets s, t, and u, the difference of the difference of s and t with u is equal to the intersection of the difference of s and t with the difference of s and u.\nTranslate the statement in natural language to Lean:", "output": "theorem sdiff_sdiff_left' (s t u : Finset \u03b1) : (s \\ t) \\ u = s \\ t \u2229 (s \\ u) :="}
{"input": "Statement in natural language:\nFor any natural number 'n', casting 'n' to a real number and then to a field 'K' is equal to the original natural number 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem ofReal_natCast (n : \u2115) : ((n : \u211d) : K) = n :="}
{"input": "Statement in natural language:\nThe infimum (greatest lower bound) of the union of two multisets s\u2081 and s\u2082 is equal to the infimum of s\u2081 intersected with the infimum of s\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem inf_union (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 \u222a s\u2082).inf = s\u2081.inf \u2293 s\u2082.inf :="}
{"input": "Statement in natural language:\nThe product of 'a' and 'b' divided by 'c' is equal to 'a' divided by 'c' multiplied by 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_div_right_comm : a * b / c = a / c * b :="}
{"input": "Statement in natural language:\nFor a given preorder \u03b9, a filter l, and a function s from \u03b9 to the set of \u03b1, if l has an antitone basis s, then a set t is in l if and only if there exists an i such that s(i) is a subset of t.\nTranslate the statement in natural language to Lean:", "output": "theorem HasAntitoneBasis.mem_iff [Preorder \u03b9] {l : Filter \u03b1} {s : \u03b9 \u2192 Set \u03b1}\n    (hs : l.HasAntitoneBasis s) {t : Set \u03b1} : t \u2208 l \u2194 \u2203 i, s i \u2286 t :="}
{"input": "Statement in natural language:\nFor any given element 'c' in a set '\u03b1', 'a' divided by 'c' is less than 'b' divided by 'c' if and only if 'a' is less than 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem div_lt_div_iff_right (c : \u03b1) : a / c < b / c \u2194 a < b :="}
{"input": "Statement in natural language:\nMapping a matrix with the identity ring equivalence (which leaves every element unchanged) is the same as the identity ring equivalence of the matrix itself. This is true for a matrix of any size m by m with elements from the ring \u03b1.\nTranslate the statement in natural language to Lean:", "output": "theorem mapMatrix_refl : (RingEquiv.refl \u03b1).mapMatrix = RingEquiv.refl (Matrix m m \u03b1) :="}
{"input": "Statement in natural language:\nFor any two functions 'f' and 'g' from a set '\u03b9' to the non-negative real numbers, and for any real number 'p' greater than or equal to 1, if the series of 'f' to the power of 'p' and 'g' to the power of 'p' are both summable, then the series of '(f + g) to the power of 'p' is also summable. Furthermore, the pth root of the sum of '(f + g) to the power of 'p' is less than or equal to the sum of the pth root of 'f to the power of 'p' and the pth root of 'g to the power of 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem Lp_add_le_tsum {f g : \u03b9 \u2192 \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) \u2227\n      (\u2211' i, (f i + g i) ^ p) ^ (1 / p) \u2264\n        (\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p) :="}
{"input": "Statement in natural language:\nIf a function f has a derivative at a filter L around a point x, then the function obtained by scaling f by a constant c also has a derivative at the same filter, and this derivative is the original derivative scaled by the same constant c.\nTranslate the statement in natural language to Lean:", "output": "theorem HasDerivAtFilter.const_smul (c : R) (hf : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun y => c \u2022 f y) (c \u2022 f') x L :="}
{"input": "Statement in natural language:\nFor any number 'n' of the numerical type 'Num', converting 'n' to a natural number and then to an integer results in the original number 'n'.\nTranslate the statement in natural language to Lean:", "output": "theorem to_nat_to_int (n : Num) : ((n : \u2115) : \u2124) = n :="}
{"input": "Statement in natural language:\nIf a function 'a' is differentiable at a point 'x' in a field '\ud835\udd5c', then the derivative of the function that multiplies 'a' by a constant 'b' at the point 'x' is equal to the derivative of 'a' at 'x' multiplied on the right by 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem fderiv_mul_const' (ha : DifferentiableAt \ud835\udd5c a x) (b : \ud835\udd38) :\n    fderiv \ud835\udd5c (fun y => a y * b) x = (fderiv \ud835\udd5c a x).smulRight b :="}
{"input": "Statement in natural language:\nThe sum of a multiset 'i' is disjoint from a multiset 'a' if and only if every element 'b' in 'i' is disjoint from 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem disjoint_sum_left {a : Multiset \u03b1} {i : Multiset (Multiset \u03b1)} :\n    Multiset.Disjoint i.sum a \u2194 \u2200 b \u2208 i, Multiset.Disjoint b a :="}
{"input": "Statement in natural language:\nIf function f tends towards a and function g tends towards b as x approaches a certain value in the filter \u03b1, then the function that multiplies the outputs of f and g also tends towards the product of a and b.\nTranslate the statement in natural language to Lean:", "output": "theorem Filter.Tendsto.mul {f g : \u03b1 \u2192 M} {x : Filter \u03b1} {a b : M} (hf : Tendsto f x (\ud835\udcdd a))\n    (hg : Tendsto g x (\ud835\udcdd b)) : Tendsto (fun x => f x * g x) x (\ud835\udcdd (a * b)) :="}
{"input": "Statement in natural language:\nA pair (u, v) is dependent in the projective space over a field K with vector space V if and only if u is equal to v.\nTranslate the statement in natural language to Lean:", "output": "theorem dependent_pair_iff_eq (u v : \u2119 K V) : Dependent ![u, v] \u2194 u = v :="}
{"input": "Statement in natural language:\nThe length of the row lengths in a Young Diagram, denoted as \u03bc, is equal to the length of the column at index 0.\nTranslate the statement in natural language to Lean:", "output": "theorem length_rowLens {\u03bc : YoungDiagram} : \u03bc.rowLens.length = \u03bc.colLen 0 :="}
{"input": "Statement in natural language:\nFor any bounded linear map 'f' from a normed space over a field '\ud835\udd5c' to a semi-normed space over a nontrivially normed field '\ud835\udd5c\u2082', the supremum of the nonnegative norms of 'f' over the closed unit ball is equal to the nonnegative norm of 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem sSup_closed_unit_ball_eq_nnnorm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type _} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    sSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1) = \u2016f\u2016\u208a :="}
{"input": "Statement in natural language:\nIf there is a reduction step from list L\u2081 to list L\u2082, then the reduction of list L\u2081 is equal to the reduction of list L\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem reduce.Step.eq (H : Red.Step L\u2081 L\u2082) : reduce L\u2081 = reduce L\u2082 :="}
{"input": "Statement in natural language:\nIf \u03c6 is an integrable function from \u03b1 to H, and L is a continuous linear map from H to E, then the composition of L and \u03c6 (i.e., the function that maps each element a in \u03b1 to L(\u03c6(a))) is also integrable.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousLinearMap.integrable_comp {\u03c6 : \u03b1 \u2192 H} (L : H \u2192L[\ud835\udd5c] E) (\u03c6_int : Integrable \u03c6 \u03bc) :\n    Integrable (fun a : \u03b1 => L (\u03c6 a)) \u03bc :="}
{"input": "Statement in natural language:\nFor a given type \u03b1 with a zero element, and another type \u03b9, if we have a function f mapping \u03b9 to \u03b1 and another function g mapping \u03b9 and \u03b1 to a type A, then the product of the function f and g under a homomorphism \u03c6 is equal to the product of the function f and the function that maps i and a to the homomorphism \u03c6 of g applied to i and a.\nTranslate the statement in natural language to Lean:", "output": "theorem map_finsupp_prod {\u03b1 : Type _} [Zero \u03b1] {\u03b9 : Type _} (f : \u03b9 \u2192\u2080 \u03b1) (g : \u03b9 \u2192 \u03b1 \u2192 A) :\n    \u03c6 (f.prod g) = f.prod fun i a => \u03c6 (g i a) :="}
{"input": "Statement in natural language:\nThe product of the filters 'f' and 'g' is equal to the composition of the function 'Prod.swap' and the product of the filters 'g' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_comm' : f \u00d7\u02e2 g = comap Prod.swap (g \u00d7\u02e2 f) :="}
{"input": "Statement in natural language:\nA set 's' is closed if and only if for every element 'x', if every neighborhood 'U' of 'x' has a nonempty intersection with 's', then 'x' belongs to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isClosed_iff_nhds {s : Set \u03b1} : IsClosed s \u2194 \u2200 x, (\u2200 U \u2208 \ud835\udcdd x, (U \u2229 s).Nonempty) \u2192 x \u2208 s :="}
{"input": "Statement in natural language:\nThe kernel of the subtype of a subgroup H of a group G is the trivial group.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = \u22a5 :="}
{"input": "Statement in natural language:\nFor a morphism 'f' from the presheaf of 'G' to 'F'', given that 'F'' is a sheaf with respect to the Grothendieck topology 'J', the composition of the morphism derived from the less than or equal to relation of 'G' to the sheafification of 'J' and the lift of the sheafification of 'G' with respect to 'f' and 'h' is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem Subpresheaf.to_sheafifyLift (f : G.toPresheaf \u27f6 F') (h : Presieve.IsSheaf J F') :\n    Subpresheaf.homOfLe (G.le_sheafify J) \u226b G.sheafifyLift f h = f :="}
{"input": "Statement in natural language:\nFor any element 'a' of type \u03b1 that is not the bottom element, the predecessor of the co-element of 'a' in the type WithBot \u03b1 is equal to the co-element of the predecessor of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem pred_coe_of_ne_bot {a : \u03b1} (h : a \u2260 \u22a5) : pred (\u2191a : WithBot \u03b1) = \u2191(pred a) :="}
{"input": "Statement in natural language:\nFor a continuous function 'f' from a topological space '\u03b1' to another topological space '\u03b2', the continuous map of 'f' is equal to 'f' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_toContinuousMap (f : \u03b1 \u2192CO \u03b2) : (f.toContinuousMap : \u03b1 \u2192 \u03b2) = f :="}
{"input": "Statement in natural language:\nFor a given equivalence 'e' that maps set 's' to set 't', for any element 'y', if 'y' is in the target of 'e', then 'y' is in 't' if and only if the inverse of 'e' applied to 'y' is in 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem symm_apply_mem_iff (h : e.IsImage s t) : \u2200 \u2983y\u2984, y \u2208 e.target \u2192 (e.symm y \u2208 s \u2194 y \u2208 t) :="}
{"input": "Statement in natural language:\nFor any nonempty finite set 's', there exists an element 'a' such that 'a' is the maximum of set 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem max_of_nonempty {s : Finset \u03b1} (h : s.Nonempty) : \u2203 a : \u03b1, s.max = a :="}
{"input": "Statement in natural language:\nThe interval from r to s under the function u is convex in the field \ud835\udd5c.\nTranslate the statement in natural language to Lean:", "output": "theorem convex_uIcc (r s : \u03b2) : Convex \ud835\udd5c (uIcc r s) :="}
{"input": "Statement in natural language:\nFor any two sets 's' and 't', and any other two sets 's'' and 't'', if 's' is almost everywhere less than or equal to 't' with respect to measure '\u03bc', and 's'' is almost everywhere less than or equal to 't'' with respect to the same measure '\u03bc', then the intersection of 's' and 's'' is almost everywhere less than or equal to the intersection of 't' and 't'' with respect to measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_le_set_inter {s' t' : Set \u03b1} (h : s \u2264\u1d50[\u03bc] t) (h' : s' \u2264\u1d50[\u03bc] t') :\n    (s \u2229 s' : Set \u03b1) \u2264\u1d50[\u03bc] (t \u2229 t' : Set \u03b1) :="}
{"input": "Statement in natural language:\nFor a functor H from category J to the functor category K\u2964C, given that H has a colimit and given a cocone c over H, for any objects j in J and k in K, the composition of the application of the colimit cocone's morphism at j and the application of the morphism of the cocone c at j, both applied at k, is equal to the application at k of the application at j of the morphism of the cocone c.\nTranslate the statement in natural language to Lean:", "output": "theorem colimit.\u03b9_desc_app (H : J \u2964 K \u2964 C) [HasColimit H] (c : Cocone H) (j : J) (k : K) :\n    (colimit.\u03b9 H j).app k \u226b (colimit.desc H c).app k = (c.\u03b9.app j).app k :="}
{"input": "Statement in natural language:\nFor any two disjoint closed sets 's' and 't' in a topological space 'X', there exists a continuous function 'f' from 'X' to the real numbers such that 'f' equals 0 on 's', 'f' equals 1 on 't', and for all 'x' in 'X', the value of 'f(x)' lies in the closed interval from 0 to 1.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_continuous_zero_one_of_closed {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)\n    (hd : Disjoint s t) : \u2203 f : C(X, \u211d), EqOn f 0 s \u2227 EqOn f 1 t \u2227 \u2200 x, f x \u2208 Icc (0 : \u211d) 1 :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and any two sets S and T of this type, the cardinality (or size) of the union of S and T is less than or equal to the sum of the cardinalities of S and T.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_union_le {\u03b1 : Type u} (S T : Set \u03b1) : (#(S \u222a T : Set \u03b1)) \u2264 (#S) + (#T) :="}
{"input": "Statement in natural language:\nFor a ring homomorphism 'f' from ring 'R' to ring 'S' and an element 'r' from ring 'R', the kernel lift of 'f' applied to the quotient of the kernel of 'f' and 'r' is equal to the application of 'f' to 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem kerLift_mk (f : R \u2192+* S) (r : R) : kerLift f (Ideal.Quotient.mk (ker f) r) = f r :="}
{"input": "Statement in natural language:\nFor any element 'x' from the opposite of a set '\u03b1' that has a negation operation, the unary operation on the negation of 'x' is equal to the negation of the unary operation on 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem unop_neg [Neg \u03b1] (x : \u03b1\u1d50\u1d52\u1d56) : unop (-x) = -unop x :="}
{"input": "Statement in natural language:\nFor any three integers a, b, and c, if c is greater than 0 and the product of a and c is less than or equal to b, then a is less than or equal to the quotient of b and c.\nTranslate the statement in natural language to Lean:", "output": "theorem le_ediv_of_mul_le {a b c : \u2124} (H1 : 0 < c) (H2 : a * c \u2264 b) : a \u2264 b / c :="}
{"input": "Statement in natural language:\nFor a set 's' of elements of type \u03b2 and an element 'b' of type \u03b2, the vector subtraction of set 's' and singleton set containing 'b' is equal to the image of set 's' under the function of vector subtraction by 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem vsub_singleton (s : Set \u03b2) (b : \u03b2) : s -\u1d65 {b} = (\u00b7 -\u1d65 b) '' s :="}
{"input": "Statement in natural language:\nFor a given non-negative real number q that is greater than or equal to 1, and a function f from \u03b1 to \u03b2, if the measure \u03bc is finite and the function f belongs to the space of measurable functions for which the p-th power of the absolute value is integrable (Mem\u2112p), then the function f is integrable with respect to the measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem Mem\u2112p.integrable {q : \u211d\u22650\u221e} (hq1 : 1 \u2264 q) {f : \u03b1 \u2192 \u03b2} [IsFiniteMeasure \u03bc]\n    (hfq : Mem\u2112p f q \u03bc) : Integrable f \u03bc :="}
{"input": "Statement in natural language:\nTheorem step 5: Given a Sylow subgroup P of N, where N is a finite group and its order is the smallest prime factor of the order of N, P is not the trivial group.\nTranslate the statement in natural language to Lean:", "output": "theorem step5 {P : Sylow (Fintype.card N).minFac N} : P.1 \u2260 \u22a5 :="}
{"input": "Statement in natural language:\nFor any matrix A and any natural number n, the negative nth power of A is equal to the inverse of the nth power of A.\nTranslate the statement in natural language to Lean:", "output": "theorem zpow_neg_coe_nat (A : M) (n : \u2115) : A ^ (-n : \u2124) = (A ^ n)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nAn element 'x' belongs to the Lie Span of a set 's' if and only if for every Lie Submodule 'N', if 's' is a subset of 'N', then 'x' belongs to 'N'.\nTranslate the statement in natural language to Lean:", "output": "theorem mem_lieSpan {x : M} : x \u2208 lieSpan R L s \u2194 \u2200 N : LieSubmodule R L M, s \u2286 N \u2192 x \u2208 N :="}
{"input": "Statement in natural language:\nFor any natural numbers a, k, x, and y, there exists a natural number a1 greater than 1 such that the nth Pell number with parameter a1 equals x and the nth companion Pell number with parameter a1 equals y if and only if a is greater than 1, k is less than or equal to y, and either x equals 1 and y equals 0, or there exist natural numbers u, v, s, t, and b such that the following conditions are met: \n\n1. The difference between the square of x and the product of the difference of the square of a and 1 and the square of y equals 1.\n2. The difference between the square of u and the product of the difference of the square of a and 1 and the square of v equals 1.\n3. The difference between the square of s and the product of the difference of the square of b and 1 and the square of t equals 1.\n4. b is greater than 1.\n5. b is congruent to 1 modulo 4 times y.\n6. b is congruent to a modulo u.\n7. v is greater than 0.\n8. The\nTranslate the statement in natural language to Lean:", "output": "theorem matiyasevic {a k x y} :\n    (\u2203 a1 : 1 < a, xn a1 k = x \u2227 yn a1 k = y) \u2194\n      1 < a \u2227 k \u2264 y \u2227 (x = 1 \u2227 y = 0 \u2228\n        \u2203 u v s t b : \u2115,\n          x * x - (a * a - 1) * y * y = 1 \u2227 u * u - (a * a - 1) * v * v = 1 \u2227\n          s * s - (b * b - 1) * t * t = 1 \u2227 1 < b \u2227 b \u2261 1 [MOD 4 * y] \u2227\n          b \u2261 a [MOD u] \u2227 0 < v \u2227 y * y \u2223 v \u2227 s \u2261 x [MOD u] \u2227 t \u2261 k [MOD 4 * y]) :="}
{"input": "Statement in natural language:\nFor a maximal theory T and a sentence \u03c6 in the language L, \u03c6 is a member of T if and only if T logically entails \u03c6.\nTranslate the statement in natural language to Lean:", "output": "theorem IsMaximal.mem_iff_models (h : T.IsMaximal) (\u03c6 : L.Sentence) : \u03c6 \u2208 T \u2194 T \u22a8\u1d47 \u03c6 :="}
{"input": "Statement in natural language:\nThe lower limit inferior of a function u with respect to a filter f for values x that satisfy either property p or property q, is less than or equal to the lower limit inferior of the same function with respect to the same filter for values x that satisfy property q.\nTranslate the statement in natural language to Lean:", "output": "theorem bliminf_or_le_inf_aux_right : (bliminf u f fun x => p x \u2228 q x) \u2264 bliminf u f q :="}
{"input": "Statement in natural language:\n\"a and b or (if a then c)\" is equivalent to \"if a then b or c\".\nTranslate the statement in natural language to Lean:", "output": "theorem and_or_imp : a \u2227 b \u2228 (a \u2192 c) \u2194 a \u2192 b \u2228 c :="}
{"input": "Statement in natural language:\nFor a supremum-preserving function 'f' from a complete lattice \u03b3 to a complete lattice \u03b4, a supremum-preserving function 'g' from a complete lattice \u03b2 to \u03b3, and a supremum-preserving function 'h' from a complete lattice \u03b1 to \u03b2, the composition of 'f' and 'g', when further composed with 'h', is equal to the composition of 'f' with the composition of 'g' and 'h'. This is the associative property of function composition in the context of supremum-preserving functions.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_assoc (f : sSupHom \u03b3 \u03b4) (g : sSupHom \u03b2 \u03b3) (h : sSupHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h) :="}
{"input": "Statement in natural language:\nFor a given finite set 's' of elements of type '\u03b1' (where '\u03b1' is a type with a decidable equality), the image under the quotient map of the filtered set of pairs from 's' that are diagonal is equal to the image under the quotient map of the diagonal of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem filter_image_quotient_mk''_isDiag [DecidableEq \u03b1] (s : Finset \u03b1) :\n    ((s \u00d7\u02e2 s).image Quotient.mk'').filter IsDiag = s.diag.image Quotient.mk'' :="}
{"input": "Statement in natural language:\nFor any real number 'r', the algebraic mapping from 'R' to the quaternion number system '\u210d[R,c\u2081,c\u2082]' of 'r' is equal to the quaternion '\u27e8r, 0, 0, 0\u27e9'.\nTranslate the statement in natural language to Lean:", "output": "theorem algebraMap_eq (r : R) : algebraMap R \u210d[R,c\u2081,c\u2082] r = \u27e8r, 0, 0, 0\u27e9 :="}
{"input": "Statement in natural language:\nFor a polynomial 'p' over a domain 'R', if the number of roots of 'p' is equal to the degree of 'p', then the coefficient of 'p' at a natural number 'k' (where 'k' is less than or equal to the degree of 'p') is equal to the leading coefficient of 'p' times negative one raised to the power of the difference between the degree of 'p' and 'k', times the symmetric function of the roots of 'p' at the difference between the degree of 'p' and 'k'.\nTranslate the statement in natural language to Lean:", "output": "theorem _root_.Polynomial.coeff_eq_esymm_roots_of_card [IsDomain R] {p : R[X]}\n    (hroots : Multiset.card p.roots = p.natDegree) {k : \u2115} (h : k \u2264 p.natDegree) :\n    p.coeff k = p.leadingCoeff * (-1) ^ (p.natDegree - k) * p.roots.esymm (p.natDegree - k) :="}
{"input": "Statement in natural language:\nApplying a function f to x for (n + minimalPeriod f x) iterations is equal to applying the function f to x for n iterations. This implies that the minimal period of the function f at x is a cycle that repeats itself.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_add_minimalPeriod_eq : (f^[n + minimalPeriod f x]) x = (f^[n]) x :="}
{"input": "Statement in natural language:\nThe application of the cospan extension, given objects iX, iY, iZ and morphisms wf and wg, to the right walking cospan equals iY.\nTranslate the statement in natural language to Lean:", "output": "theorem cospanExt_app_right : (cospanExt iX iY iZ wf wg).app WalkingCospan.right = iY :="}
{"input": "Statement in natural language:\nThe cosine of an angle (\u03b8) plus pi divided by two is equal to the negative sine of the angle (\u03b8).\nTranslate the statement in natural language to Lean:", "output": "theorem cos_add_pi_div_two (\u03b8 : Angle) : cos (\u03b8 + \u2191(\u03c0 / 2)) = -sin \u03b8 :="}
{"input": "Statement in natural language:\nFor any ordinal number 'a', the lift of the successor of 'a' is equal to the successor of the lift of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem lift_succ (a : Ordinal.{v}) : lift.{u} (succ a) = succ (lift.{u} a) :="}
{"input": "Statement in natural language:\nIf there is a left isomorphism, then there is a pushout of functions f and g.\nTranslate the statement in natural language to Lean:", "output": "theorem hasPushout_of_left_iso : HasPushout f g :="}
{"input": "Statement in natural language:\nThe constant coefficient of the inverse of a power series \u03c6 is the inverse of the constant coefficient of \u03c6.\nTranslate the statement in natural language to Lean:", "output": "theorem constantCoeff_inv (\u03c6 : PowerSeries k) : constantCoeff k \u03c6\u207b\u00b9 = (constantCoeff k \u03c6)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nThe base change of 'f' with respect to 'A' is equal to the left tensor of 'f' with respect to 'A'.\nTranslate the statement in natural language to Lean:", "output": "theorem baseChange_eq_ltensor : (f.baseChange A : A \u2297 M \u2192 A \u2297 N) = f.lTensor A :="}
{"input": "Statement in natural language:\nThe function obtained by composing the function f with the vector field v is interval integrable over the volume from t\u2081 to t\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem intervalIntegrable_vComp (t\u2081 t\u2082 : \u211d) : IntervalIntegrable f.vComp volume t\u2081 t\u2082 :="}
{"input": "Statement in natural language:\nIf a function f is differentiable at a point x in the field \ud835\udd5c, then the function that maps y to the negation of f(y) is also differentiable at the point x.\nTranslate the statement in natural language to Lean:", "output": "theorem DifferentiableAt.neg (h : DifferentiableAt \ud835\udd5c f x) : DifferentiableAt \ud835\udd5c (fun y => -f y) x :="}
{"input": "Statement in natural language:\nFor any prime number p and any natural number x, there exist two natural numbers a and b, both less than or equal to half of p, such that the sum of their squares is congruent to x modulo p.\nTranslate the statement in natural language to Lean:", "output": "theorem Nat.sq_add_sq_modEq (p : \u2115) [Fact p.Prime] (x : \u2115) :\n    \u2203 a b : \u2115, a \u2264 p / 2 \u2227 b \u2264 p / 2 \u2227 a ^ 2 + b ^ 2 \u2261 x [MOD p] :="}
{"input": "Statement in natural language:\nFor any types \u03b1, \u03b2, \u03b3 and a property p of type \u03b1, given a function f that maps any element of type \u03b1 satisfying property p to type \u03b2, an optional value x of type \u03b1, and a function g that maps type \u03b2 to an optional value of type \u03b3, the bind operation of the partial map of f on x with respect to property p and function g is equal to the partial bind of x with the function that takes an element a and a proof h of property p for a, and maps them to the application of function g on the result of applying function f on a and the proof of property p for a.\nTranslate the statement in natural language to Lean:", "output": "theorem bind_pmap {\u03b1 \u03b2 \u03b3} {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (x : Option \u03b1) (g : \u03b2 \u2192 Option \u03b3) (H) :\n    pmap f x H >>= g = x.pbind fun a h \u21a6 g (f a (H _ h)) :="}
{"input": "Statement in natural language:\nIf a function 'f' is differentiable on a subset 's' of the field '\ud835\udd5c', and the derivative of 'f' within 's' is continuously differentiable 'n' times on 's', then 'f' is continuously differentiable 'n + 1' times on 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem contDiffOn_succ_of_fderivWithin {n : \u2115} (hf : DifferentiableOn \ud835\udd5c f s)\n    (h : ContDiffOn \ud835\udd5c n (fun y => fderivWithin \ud835\udd5c f s y) s) : ContDiffOn \ud835\udd5c (n + 1 : \u2115) f s :="}
{"input": "Statement in natural language:\nFor any two elements x and y from a module M\u2081, the bilinear form of the negation of x and y is equal to the negation of the bilinear form of x and y.\nTranslate the statement in natural language to Lean:", "output": "theorem neg_left (x y : M\u2081) : B\u2081 (-x) y = -B\u2081 x y :="}
{"input": "Statement in natural language:\nFor any two order-preserving functions 'g' from '\u03b2' to '\u03b3' and 'f' from '\u03b1' to '\u03b2', the dual of the composition of 'g' and 'f' is equal to the composition of the duals of 'g' and 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem dual_comp (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2) :\n    OrderHom.dual (g.comp f) = (OrderHom.dual g).comp (OrderHom.dual f) :="}
{"input": "Statement in natural language:\nThe coefficient of zero in the Teichmuller expansion of a ring element r is equal to r itself.\nTranslate the statement in natural language to Lean:", "output": "theorem teichmuller_coeff_zero (r : R) : (teichmuller p r).coeff 0 = r :="}
{"input": "Statement in natural language:\nFor a given set 's' of subsets of '\u03b1' and a subset 't' of '\u03b1', if 't' is an element of 's', then 't' is a measurable set in the sigma-algebra generated by 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem measurableSet_generateFrom {s : Set (Set \u03b1)} {t : Set \u03b1} (ht : t \u2208 s) :\n    MeasurableSet[generateFrom s] t :="}
{"input": "Statement in natural language:\nFor any three elements a, b, and x of a set \u03b1, the swapping of a and b in x is not equal to x if and only if a is not equal to b and x is either equal to a or b.\nTranslate the statement in natural language to Lean:", "output": "theorem swap_apply_ne_self_iff {a b x : \u03b1} : swap a b x \u2260 x \u2194 a \u2260 b \u2227 (x = a \u2228 x = b) :="}
{"input": "Statement in natural language:\nIf an element 'x' is of finite order and another element 'y' belongs to the subgroup generated by 'x', then 'y' is also of finite order.\nTranslate the statement in natural language to Lean:", "output": "theorem IsOfFinOrder.of_mem_zpowers (h : IsOfFinOrder x) (h' : y \u2208 Subgroup.zpowers x) :\n    IsOfFinOrder y :="}
{"input": "Statement in natural language:\nThe orbit of the element 1 under the action of the subgroup s is equal to the subgroup s itself.\nTranslate the statement in natural language to Lean:", "output": "theorem orbit_subgroup_one_eq_self : MulAction.orbit s (1 : \u03b1) = s :="}
{"input": "Statement in natural language:\nThe sum of the product of a function f, which maps from a pair of types \u03b1 and \u03b2 to non-negative real numbers, over all pairs (p.1, p.2) where p is a pair from \u03b1 and \u03b2, is equal to the double sum over all elements a from \u03b1 and b from \u03b2 of the function f applied to a and b.\nTranslate the statement in natural language to Lean:", "output": "theorem tsum_prod {f : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e} : (\u2211' p : \u03b1 \u00d7 \u03b2, f p.1 p.2) = \u2211' (a) (b), f a b :="}
{"input": "Statement in natural language:\nThe length of an empty path, from a vertex 'a' to itself in a graph, is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem length_nil {a : V} : (nil : Path a a).length = 0 :="}
{"input": "Statement in natural language:\nThe Cartesian product of sets s and t is equal to the union of the image of set t under the function that pairs each element of t with a fixed element of s, for each element in s.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_eq_biUnion_left : s \u00d7\u02e2 t = \u22c3 a \u2208 s, (fun b => (a, b)) '' t :="}
{"input": "Statement in natural language:\nFor any two submodules 'p' and 'p'' of a module 'M' over a ring 'R', if 'p' is less than or equal to 'p'', then the kernel of the function 'ofLe' (which represents the inclusion of 'p' in 'p'') is the zero submodule.\nTranslate the statement in natural language to Lean:", "output": "theorem ker_ofLe (p p' : Submodule R M) (h : p \u2264 p') : ker (ofLe h) = \u22a5 :="}
{"input": "Statement in natural language:\nIf a function f is differentiable within a set s at a point x, then the function obtained by subtracting a constant c from f is also differentiable within the set s at the same point x.\nTranslate the statement in natural language to Lean:", "output": "theorem DifferentiableWithinAt.sub_const (hf : DifferentiableWithinAt \ud835\udd5c f s x) (c : F) :\n    DifferentiableWithinAt \ud835\udd5c (fun y => f y - c) s x :="}
{"input": "Statement in natural language:\nFor a countable index set \u03b9 and a directed family of sets s indexed by \u03b9, the measure of the union of all sets in the family is equal to the supremum of the measures of the individual sets in the family.\nTranslate the statement in natural language to Lean:", "output": "theorem measure_iUnion_eq_iSup [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Directed (\u00b7 \u2286 \u00b7) s) :\n    \u03bc (\u22c3 i, s i) = \u2a06 i, \u03bc (s i) :="}
{"input": "Statement in natural language:\nFor any element 'z' from the field 'K', the real part of 'z' is less than or equal to the norm of 'z'.\nTranslate the statement in natural language to Lean:", "output": "theorem re_le_norm (z : K) : re z \u2264 \u2016z\u2016 :="}
{"input": "Statement in natural language:\nIf function 'f' is Big O of function 'g' (denoted as f =O[l] g) under a filter 'l', then the norm of the ratio of 'f' and 'g' (\u2016f x / g x\u2016) is bounded under the filter 'l'. This is a statement in the field of asymptotic analysis.\nTranslate the statement in natural language to Lean:", "output": "theorem div_isBoundedUnder_of_isBigO {\u03b1 : Type _} {l : Filter \u03b1} {f g : \u03b1 \u2192 \ud835\udd5c} (h : f =O[l] g) :\n    IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => \u2016f x / g x\u2016 :="}
{"input": "Statement in natural language:\nFor all elements x and y, the equivalence of the sum of x and y is equal to the sum of the equivalence of x and the equivalence of y.\nTranslate the statement in natural language to Lean:", "output": "theorem map_add : \u2200 x y, e (x + y) = e x + e y :="}
{"input": "Statement in natural language:\nFor any type \u03b1 and two type families \u03b2\u2081 and \u03b2\u2082 over \u03b1, given a function F that for each element of \u03b1 provides an equivalence between \u03b2\u2081 and \u03b2\u2082, the symmetry of the right congruence of the dependent pair (psigma) under F is equal to the right congruence of the dependent pair under the symmetry of F.\nTranslate the statement in natural language to Lean:", "output": "theorem psigmaCongrRight_symm {\u03b1} {\u03b2\u2081 \u03b2\u2082 : \u03b1 \u2192 Sort _} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) :\n    (psigmaCongrRight F).symm = psigmaCongrRight fun a => (F a).symm :="}
{"input": "Statement in natural language:\nFor a functor 'F' from category 'D' to category 'E', the object of the functor 'whiskeringLeftFunctor' applied to 'L', 'W', and 'E' and then applied to 'F' is equal to the composition of functors 'L' and 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem whiskeringLeftFunctor'_obj (F : D \u2964 E) : (whiskeringLeftFunctor' L W E).obj F = L \u22d9 F :="}
{"input": "Statement in natural language:\nFor a semidirect product of two groups N and G (denoted as N \u22ca[\u03c6] G), with a given element 'a' from this semidirect product, the left component of the inverse of 'a' is equal to the result of applying the homomorphism \u03c6 to the inverse of the right component of 'a', and then applying the inverse operation to the left component of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem inv_left (a : N \u22ca[\u03c6] G) : a\u207b\u00b9.left = \u03c6 a.right\u207b\u00b9 a.left\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor a given property 'p' of an element 'x' in the lowest possible value (atBot), if 'p' eventually holds for 'x', then there exists an element 'a' such that for all elements 'b' less than or equal to 'a', the property 'p' holds. This is under the conditions that '\u03b1' is a semilattice with an infimum operation and '\u03b1' is nonempty.\nTranslate the statement in natural language to Lean:", "output": "theorem Eventually.exists_forall_of_atBot [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop}\n    (h : \u2200\u1da0 x in atBot, p x) : \u2203 a, \u2200 b \u2264 a, p b :="}
{"input": "Statement in natural language:\n's' is a lower set if and only if for all 'a' in 's', the set of all elements less than 'a' is a subset of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem isLowerSet_iff_Iio_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iio a \u2286 s :="}
{"input": "Statement in natural language:\nFor any two types \u03b1 and \u03b2, where \u03b1 has a multiplication operation and \u03b2 is a commutative group, if there is a function f from \u03b1 to \u03b2 that preserves multiplication (i.e., is a multiplicative homomorphism), then the function that maps each element of \u03b1 to the inverse of its image under f is also a multiplicative homomorphism.\nTranslate the statement in natural language to Lean:", "output": "theorem inv {\u03b1 \u03b2} [Mul \u03b1] [CommGroup \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : IsMulHom f) : IsMulHom fun a => (f a)\u207b\u00b9 :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b1' to '\u03b2' (where '\u03b2' is a topological space) and given two elements 'a' and 'b' from '\u03b1' such that 'a' is less than 'b', the function 'f' is continuous at 'b' within the interval open at 'a' and closed at 'b' if and only if the function 'f' is continuous at 'b' within the interval closed at 'b' and extending to negative infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousWithinAt_Ioc_iff_Iic [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\n    ContinuousWithinAt f (Ioc a b) b \u2194 ContinuousWithinAt f (Iic b) b :="}
{"input": "Statement in natural language:\nGiven a prime number 'p' and a natural number 'n', and given that 'p' divides the cardinality of a finite type '\u03b1', there exists a permutation '\u03c3' of '\u03b1' such that '\u03c3' raised to the power of 'p' to the power of 'n' equals 1. Furthermore, given an element 'a' of '\u03b1' such that '\u03c3' of 'a' equals 'a', there exists an element 'b' of '\u03b1' such that '\u03c3' of 'b' equals 'b' and 'b' is not equal to 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem exists_fixed_point_of_prime' {p n : \u2115} [hp : Fact p.Prime] (h\u03b1 : p \u2223 Fintype.card \u03b1)\n    {\u03c3 : Perm \u03b1} (h\u03c3 : \u03c3 ^ p ^ n = 1) {a : \u03b1} (ha : \u03c3 a = a) : \u2203 b : \u03b1, \u03c3 b = b \u2227 b \u2260 a :="}
{"input": "Statement in natural language:\nThe commutator of the identity element (1) and any element (g) in a group (G) is equal to the identity element.\nTranslate the statement in natural language to Lean:", "output": "theorem commutatorElement_one_left : \u2045(1 : G), g\u2046 = 1 :="}
{"input": "Statement in natural language:\nFor any objects m, n, m', n' in M and morphisms f from m to m' and g from n to n' and any object X in C, the composition of the application of the functor F's map on g to the object obtained by applying the functor F's object on m to X, the map of the functor F's object on n' applied to the application of the functor F's map on f to X, and the application of the functor F's \u03bc on m' and n' to X, is equal to the composition of the application of the functor F's \u03bc on m and n to X and the application of the functor F's map on the tensor product of f and g to X.\nTranslate the statement in natural language to Lean:", "output": "theorem \u03bc_naturality\u2082 {m n m' n' : M} (f : m \u27f6 m') (g : n \u27f6 n') (X : C) :\n    (F.map g).app ((F.obj m).obj X) \u226b (F.obj n').map ((F.map f).app X) \u226b (F.\u03bc m' n').app X =\n      (F.\u03bc m n).app X \u226b (F.map (f \u2297 g)).app X :="}
{"input": "Statement in natural language:\nThe application of the function 'mapPair' with parameters 'f' and 'g' to 'left' is equal to 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mapPair_left : (mapPair f g).app \u27e8left\u27e9 = f :="}
{"input": "Statement in natural language:\nFor any two points x and y in an affine space P, it is not the case that x and y are on the same weak side of the bottom (denoted by \u22a5) affine subspace in P.\nTranslate the statement in natural language to Lean:", "output": "theorem not_wSameSide_bot (x y : P) : \u00ac(\u22a5 : AffineSubspace R P).WSameSide x y :="}
{"input": "Statement in natural language:\nIf a function f is integrable over a measurable set s with respect to measure \u03bc, and if function f equals function g on set s, then function g is also integrable over set s with respect to measure \u03bc.\nTranslate the statement in natural language to Lean:", "output": "theorem IntegrableOn.congr_fun (h : IntegrableOn f s \u03bc) (hst : EqOn f g s) (hs : MeasurableSet s) :\n    IntegrableOn g s \u03bc :="}
{"input": "Statement in natural language:\nFor a given semiring S, a scalar multiplication operation between R and S, a module S over M, and a scalar tower between R, S, and M, the span of S over the span of R over a set s (in the module M) is equal to the span of S over the set s.\nTranslate the statement in natural language to Lean:", "output": "theorem span_span_of_tower [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    span S (span R s : Set M) = span S s :="}
{"input": "Statement in natural language:\nFor any ordinal number 'a' and any ordinal number 'b' greater than zero, 'a' is less than or equal to the product of 'b' and 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem le_mul_right (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a \u2264 b * a :="}
{"input": "Statement in natural language:\nThere exists a unique integer 'm' such that the sum of 'b' and 'm' times 'a' is in the half-open interval from 'c' to 'c + a'. This is under the condition that 'a' is greater than 0.\nTranslate the statement in natural language to Lean:", "output": "theorem existsUnique_add_zsmul_mem_Ico {a : \u03b1} (ha : 0 < a) (b c : \u03b1) :\n    \u2203! m : \u2124, b + m \u2022 a \u2208 Set.Ico c (c + a) :="}
{"input": "Statement in natural language:\nFor any semiring R and any natural numbers n and m, the cast of n to the power of m in R is equal to the cast of n in R to the power of m.\nTranslate the statement in natural language to Lean:", "output": "theorem Nat.cast_pow [Semiring R] (n m : \u2115) : (\u2191(n ^ m) : R) = (\u2191n : R) ^ m :="}
{"input": "Statement in natural language:\nFor any index set \u03b9 and any two functions f and g from \u03b9 to the set of cardinals, if for every element in the index set, the value of function f at that element is less than or equal to the value of function g at that element, then the product of the values of function f over the index set is less than or equal to the product of the values of function g over the index set.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_le_prod {\u03b9} (f g : \u03b9 \u2192 Cardinal) (H : \u2200 i, f i \u2264 g i) : prod f \u2264 prod g :="}
{"input": "Statement in natural language:\nIf we have a chain (a set where any two elements are related) under a relation 'r' on a set 's' and the relation 'r' is transitive on a set '\u03b1', then for any three elements 'a', 'b', and 'c' in 's', there exists an element 'z' in 's' such that 'a', 'b', and 'c' are all related to 'z' under the relation 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem IsChain.exists3 (hchain : IsChain r s) [IsTrans \u03b1 r] {a b c} (mem1 : a \u2208 s) (mem2 : b \u2208 s)\n    (mem3 : c \u2208 s) : \u2203 (z : _) (_ : z \u2208 s), r a z \u2227 r b z \u2227 r c z :="}
{"input": "Statement in natural language:\nThe ordered connected component of a set 's' at a point 'x' is equal to the empty set if and only if 'x' is not an element of 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem ordConnectedComponent_eq_empty : ordConnectedComponent s x = \u2205 \u2194 x \u2209 s :="}
{"input": "Statement in natural language:\nFor any order-preserving bijection \u03c6 from a set \u03b1 to a set \u03b2, a set s is an antichain under the order relation \"less than or equal to\" if and only if the image of s under \u03c6 is also an antichain under the same order relation.\nTranslate the statement in natural language to Lean:", "output": "theorem image_iso_iff [LE \u03b1] [LE \u03b2] {\u03c6 : \u03b1 \u2243o \u03b2} :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 '' s) \u2194 IsAntichain (\u00b7 \u2264 \u00b7) s :="}
{"input": "Statement in natural language:\n'a' is equal to the product of 'gcdA' of 'a' and 'b' and the greatest common divisor of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem gcd_a_eq : a = gcdA' a b * gcd a b :="}
{"input": "Statement in natural language:\nFor any two real numbers 'a' and 'b' that are both nonnegative, and any complex number 'r', the complex power of the product of 'a' and 'b' is equal to the product of the complex powers of 'a' and 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_cpow_ofReal_nonneg {a b : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (r : \u2102) :\n    ((a : \u2102) * (b : \u2102)) ^ r = (a : \u2102) ^ r * (b : \u2102) ^ r :="}
{"input": "Statement in natural language:\nIf a category C has limits of a shape defined by a wide pullback shape J, then for any object B in C, the category of arrows over B has limits of a shape defined by the discrete category J.\nTranslate the statement in natural language to Lean:", "output": "theorem over_product_of_widePullback [HasLimitsOfShape (WidePullbackShape J) C] {B : C} :\n    HasLimitsOfShape (Discrete J) (Over B) :="}
{"input": "Statement in natural language:\nFor any element 'k' in field 'K', the floor function of 'k' in the basis singleton of 'K' is equal to the floor of 'k'.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_floor_self (k : K) : (floor (Basis.singleton \u03b9 K) k : K) = \u230ak\u230b :="}
{"input": "Statement in natural language:\nIf the scalar multiplication of 'c' and 'a' is less than the scalar multiplication of 'c' and 'b', and 'c' is nonnegative, then 'a' is less than 'b'.\nTranslate the statement in natural language to Lean:", "output": "theorem lt_of_smul_lt_smul_of_nonneg (h : c \u2022 a < c \u2022 b) (hc : 0 \u2264 c) : a < b :="}
{"input": "Statement in natural language:\nFor a finite type \u03b9, the application of the dual basis to the basis h is equal to \u03b5.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_dualBasis [Fintype \u03b9] : \u21d1h.basis.dualBasis = \u03b5 :="}
{"input": "Statement in natural language:\nThe vector measure with density zero is equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem withDensity\u1d65_zero : \u03bc.withDensity\u1d65 (0 : \u03b1 \u2192 E) = 0 :="}
{"input": "Statement in natural language:\nIf we have a function 'f' from a finite set of size 0 to any set '\u03b1', then the list obtained by applying 'f' to each element of the finite set is an empty list.\nTranslate the statement in natural language to Lean:", "output": "theorem ofFn_zero (f : Fin 0 \u2192 \u03b1) : ofFn f = [] :="}
{"input": "Statement in natural language:\nFor a function 'f' from '\u03b9' to '\u03b1', the infimum (greatest lower bound) of 'f' is less than or equal to 'f' at any given index 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem iInf_le (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : iInf f \u2264 f i :="}
{"input": "Statement in natural language:\nFor any four type vectors \u03b1, \u03b2, \u03b3, \u03b4 of the same length n, the composition of the functions h, g, and f is associative. That is, composing h and g first and then f is the same as composing h with the composition of g and f.\nTranslate the statement in natural language to Lean:", "output": "theorem comp_assoc {\u03b1 \u03b2 \u03b3 \u03b4 : TypeVec n} (h : \u03b3 \u27f9 \u03b4) (g : \u03b2 \u27f9 \u03b3) (f : \u03b1 \u27f9 \u03b2) :\n    (h \u229a g) \u229a f = h \u229a g \u229a f :="}
{"input": "Statement in natural language:\nFor a continuous linear map 'l', the set 'l.toExposed A' is an exposed set in the field '\ud835\udd5c' and the set 'A'.\nTranslate the statement in natural language to Lean:", "output": "theorem ContinuousLinearMap.toExposed.isExposed : IsExposed \ud835\udd5c A (l.toExposed A) :="}
{"input": "Statement in natural language:\nFor any object 'i' in the diagram 'D.J', the composition of the functor 'F' mapped over the morphism 'D.\u03b9 i' and the homomorphism of the glued isomorphism of 'D' with respect to 'F' is equal to the 'i'-th component of the morphism associated with the glued data of 'D' with respect to 'F'.\nTranslate the statement in natural language to Lean:", "output": "theorem \u03b9_gluedIso_hom (i : D.J) : F.map (D.\u03b9 i) \u226b (D.gluedIso F).hom = (D.mapGlueData F).\u03b9 i :="}
{"input": "Statement in natural language:\nFor a number 'a' greater than 1, 'a' raised to the power of 'n' is less than or equal to 'a' raised to the power of 'm' if and only if 'n' is less than or equal to 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem pow_le_pow_iff (h : 1 < a) : a ^ n \u2264 a ^ m \u2194 n \u2264 m :="}
{"input": "Statement in natural language:\nFor any element 'x' from group 'G', the application of the function 'mk' with 'N' on 'x' equals 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem mk'_apply (x : G) : mk' N x = x :="}
{"input": "Statement in natural language:\nIf 's' is an open set in a topological space and 'c' is a non-zero element of a group with zero, then the set resulting from scaling 's' by 'c' is also an open set.\nTranslate the statement in natural language to Lean:", "output": "theorem IsOpen.smul\u2080 {c : G\u2080} {s : Set \u03b1} (hs : IsOpen s) (hc : c \u2260 0) : IsOpen (c \u2022 s) :="}
{"input": "Statement in natural language:\nFor a given metric space 'm' over a set '\u03b3' with a topological space 'U', if the topological space 'U' is equivalent to the topological space derived from the metric space 'm', then replacing the topology of the metric space 'm' with 'U' does not change the metric space 'm'.\nTranslate the statement in natural language to Lean:", "output": "theorem MetricSpace.replaceTopology_eq {\u03b3} [U : TopologicalSpace \u03b3] (m : MetricSpace \u03b3)\n    (H : U = m.toPseudoMetricSpace.toUniformSpace.toTopologicalSpace) :\n    m.replaceTopology H = m :="}
{"input": "Statement in natural language:\nFor a given object G in category C, if G is a coseparator, then for all objects X and Y in C, and for all morphisms f and g from X to Y, if for all morphisms h from Y to G, the composition of f and h equals the composition of g and h, then f equals g.\nTranslate the statement in natural language to Lean:", "output": "theorem IsCoseparator.def {G : C} :\n    IsCoseparator G \u2192 \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 h : Y \u27f6 G, f \u226b h = g \u226b h) \u2192 f = g :="}
{"input": "Statement in natural language:\nFor any two real numbers x and y, if the inner product of x and y is zero, then the square of the norm of the difference between x and y is equal to the sum of the square of the norm of x and the square of the norm of y.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : \u27eax, y\u27eb_\u211d = 0) :\n    \u2016x - y\u2016 * \u2016x - y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 :="}
{"input": "Statement in natural language:\nFor a given function 'g' mapping from \u03b4 to \u03b2, the preimage of the set 's' cross 't' under the function that maps 'b' to the pair '(a, g b)' is equal to the preimage of 't' under 'g' if 'a' is in 's', otherwise it is the empty set. This is under the condition that whether an element is in 's' is decidable.\nTranslate the statement in natural language to Lean:", "output": "theorem mk_preimage_prod_right_fn_eq_if [DecidablePred (\u00b7 \u2208 s)] (g : \u03b4 \u2192 \u03b2) :\n    (fun b => (a, g b)) \u207b\u00b9' s \u00d7\u02e2 t = if a \u2208 s then g \u207b\u00b9' t else \u2205 :="}
{"input": "Statement in natural language:\nIf x is less than y for any partial natural numbers x and y, then x is not equal to infinity.\nTranslate the statement in natural language to Lean:", "output": "theorem ne_top_of_lt {x y : PartENat} (h : x < y) : x \u2260 \u22a4 :="}
{"input": "Statement in natural language:\nFor any two elements 'a' and 'b', there exists an element 'm' such that for any element 'c', if 'c' is related to 'a' or 'c' is related to 'b', then 'c' is related to 'm'. Given an element 'a', the set 's' is unbounded by the relation 'r' intersected with the set of all elements 'b' that are not related to 'a', if and only if the set 's' is unbounded by the relation 'r'.\nTranslate the statement in natural language to Lean:", "output": "theorem unbounded_inter_not (H : \u2200 a b, \u2203 m, \u2200 c, r c a \u2228 r c b \u2192 r c m) (a : \u03b1) :\n    Unbounded r (s \u2229 { b | \u00acr b a }) \u2194 Unbounded r s :="}
{"input": "Statement in natural language:\nMultiplication is commutative, meaning the order in which two numbers are multiplied does not change the result. In other words, multiplying M by N is the same as multiplying N by M.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_comm : M * N = N * M :="}
{"input": "Statement in natural language:\nThe Cartesian product of the image of set 's' under function 'm\u2081' and the image of set 't' under function 'm\u2082' is equal to the image of the Cartesian product of sets 's' and 't' under the function that maps each pair '(p.1, p.2)' to '(m\u2081 p.1, m\u2082 p.2)'.\nTranslate the statement in natural language to Lean:", "output": "theorem prod_image_image_eq {m\u2081 : \u03b1 \u2192 \u03b3} {m\u2082 : \u03b2 \u2192 \u03b4} :\n    (m\u2081 '' s) \u00d7\u02e2 (m\u2082 '' t) = (fun p : \u03b1 \u00d7 \u03b2 => (m\u2081 p.1, m\u2082 p.2)) '' s \u00d7\u02e2 t :="}
{"input": "Statement in natural language:\nFor a given property 'p' that applies to elements of type '\u03b2' and a given measure '\u03bc' of type '\u03b1', the property 'p' holds almost everywhere for the measure '\u03bc' mapped by a function 'f' if and only if the property 'p' applied to 'f x' holds almost everywhere for the measure '\u03bc'.\nTranslate the statement in natural language to Lean:", "output": "theorem ae_map_iff {p : \u03b2 \u2192 Prop} {\u03bc : Measure \u03b1} : (\u2200\u1d50 x \u2202\u03bc.map f, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, p (f x) :="}
{"input": "Statement in natural language:\nIn a preordered set of elements of type \u03b1, the interval (a, b] is bounded above by the greater-than relation.\nTranslate the statement in natural language to Lean:", "output": "theorem bounded_gt_Ioc [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 > \u00b7) (Ioc a b) :="}
{"input": "Statement in natural language:\nFor any element 'y' in the set 'S', the application of the function 'toAlgHom' to 'y' is equal to the application of the function 'algebraMap' from 'S' to 'A' to 'y'.\nTranslate the statement in natural language to Lean:", "output": "theorem toAlgHom_apply (y : S) : toAlgHom R S A y = algebraMap S A y :="}
{"input": "Statement in natural language:\nFor a set 's' of type \u03b1, if 's' is not a subset of 0, then the scalar multiplication of 's' with the universal set of type \u03b2 equals the universal set.\nTranslate the statement in natural language to Lean:", "output": "theorem smul_univ\u2080 {s : Set \u03b1} (hs : \u00acs \u2286 0) : s \u2022 (univ : Set \u03b2) = univ :="}
{"input": "Statement in natural language:\nFor any element 'z' from the field 'K', the norm of the imaginary part of 'z' is less than or equal to the norm of 'z' itself.\nTranslate the statement in natural language to Lean:", "output": "theorem norm_im_le_norm (z : K) : \u2016im z\u2016 \u2264 \u2016z\u2016 :="}
{"input": "Statement in natural language:\nFor a given element 'a' of a set '\u03b1', which has a covariant class structure with respect to addition and a less-than relation, the sign of the negation of 'a' is equal to the negation of the sign of 'a'.\nTranslate the statement in natural language to Lean:", "output": "theorem Right.sign_neg [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (a : \u03b1) :\n    sign (-a) = -sign a :="}
{"input": "Statement in natural language:\nFor a given set 's' and a function 'f' from '\u03b1' to 'M', the product of the multiplication indicator of the complement of 's' and the multiplication indicator of 's' itself is equal to the function 'f'.\nTranslate the statement in natural language to Lean:", "output": "theorem mulIndicator_compl_mul_self (s : Set \u03b1) (f : \u03b1 \u2192 M) :\n    mulIndicator (s\u1d9c) f * mulIndicator s f = f :="}
{"input": "Statement in natural language:\nFor any two complex numbers z and w, the imaginary part of the difference between z and w is equal to the difference between the imaginary parts of z and w.\nTranslate the statement in natural language to Lean:", "output": "theorem sub_im (z w : \u2102) : (z - w).im = z.im - w.im :="}
{"input": "Statement in natural language:\nFor any ideal P of the polynomial ring R[X], the quotient map of the ideal, which is mapped by the polynomial map ring homomorphism of the quotient of the comap of P and the ring homomorphism from R to R[X], is injective. This is under the condition that the polynomial map ring homomorphism of the quotient of the comap of P and the ring homomorphism from R to R[X] is less than or equal to the comap map.\nTranslate the statement in natural language to Lean:", "output": "theorem injective_quotient_le_comap_map (P : Ideal R[X]) :\n    Function.Injective <|\n      Ideal.quotientMap\n        (Ideal.map (Polynomial.mapRingHom (Quotient.mk (P.comap (C : R \u2192+* R[X])))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (P.comap (C : R \u2192+* R[X]))))\n        le_comap_map :="}
{"input": "Statement in natural language:\nFor any two morphisms \u03b1 and \u03b2 from presheafed space X to Y, if \u03b1 equals \u03b2, then the application of \u03b1's structure morphism at U equals the composition of the application of \u03b2's structure morphism at U and the map of X's presheaf induced by the equality of \u03b1 and \u03b2.\nTranslate the statement in natural language to Lean:", "output": "theorem congr_app {X Y : PresheafedSpace C} {\u03b1 \u03b2 : X \u27f6 Y} (h : \u03b1 = \u03b2) (U) :\n    \u03b1.c.app U = \u03b2.c.app U \u226b X.presheaf.map (eqToHom (by subst h ; rfl)) :="}
{"input": "Statement in natural language:\nFor any three finite sets s, t\u2081, and t\u2082, the difference of s and the union of t\u2081 and t\u2082 is equal to the intersection of the difference of s and t\u2081 and the difference of s and t\u2082.\nTranslate the statement in natural language to Lean:", "output": "theorem sdiff_union_distrib (s t\u2081 t\u2082 : Finset \u03b1) : s \\ (t\u2081 \u222a t\u2082) = s \\ t\u2081 \u2229 (s \\ t\u2082) :="}
{"input": "Statement in natural language:\nFor a positive multiplication-monotone type \u03b1, if a is greater than or equal to 0 and b is less than or equal to 1, then the product of a and b is less than or equal to a.\nTranslate the statement in natural language to Lean:", "output": "theorem mul_le_of_le_one_right [PosMulMono \u03b1] (ha : 0 \u2264 a) (h : b \u2264 1) : a * b \u2264 a :="}
{"input": "Statement in natural language:\nThe logarithm function is continuous at any point 'x' that is not equal to zero.\nTranslate the statement in natural language to Lean:", "output": "theorem continuousAt_log (hx : x \u2260 0) : ContinuousAt log x :="}
{"input": "Statement in natural language:\nIf you insert an element at the position equal to the length of the list, it is the same as appending the element to the end of the list.\nTranslate the statement in natural language to Lean:", "output": "theorem insertNth_length_self (l : List \u03b1) (x : \u03b1) : insertNth l.length x l = l ++ [x] :="}
{"input": "Statement in natural language:\nIf 'a' is not equal to 'a' (denoted as 'a \u2260 a'), then the function 'single a b' applied to 'a' (denoted as '(single a b : \u03b1 \u2192\u2080 M) a') equals zero.\nTranslate the statement in natural language to Lean:", "output": "theorem single_eq_of_ne (h : a \u2260 a') : (single a b : \u03b1 \u2192\u2080 M) a' = 0 :="}
{"input": "Statement in natural language:\nThe subtype function of a submonoid S' is equal to the value of the subtype.\nTranslate the statement in natural language to Lean:", "output": "theorem coe_subtype : (SubmonoidClass.Subtype S' : S' \u2192 M) = Subtype.val :="}
{"input": "Statement in natural language:\nIf you bind a measure 'm' from the set '\u03b1' to a zero measure on the set '\u03b1 \u2192 Measure \u03b2', the result will be zero.\nTranslate the statement in natural language to Lean:", "output": "theorem bind_zero_right (m : Measure \u03b1) : bind m (0 : \u03b1 \u2192 Measure \u03b2) = 0 :="}
{"input": "Statement in natural language:\nThe inverse of the algebraic equivalence reindexing given by a certain equivalence 'e' between 'm' and 'n', is the same as the algebraic equivalence reindexing given by the inverse of 'e'.\nTranslate the statement in natural language to Lean:", "output": "theorem reindexAlgEquiv_symm (e : m \u2243 n) : (reindexAlgEquiv R e).symm = reindexAlgEquiv R e.symm :="}
{"input": "Statement in natural language:\nFor a projection of an interval from 'a' to 'b' where 'a' is less than 'b', the projection at point 'x' equals 'b' if and only if 'b' is less than or equal to 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem projIcc_eq_right (h : a < b) :\n    projIcc a b h.le x = \u27e8b, right_mem_Icc.mpr h.le\u27e9 \u2194 b \u2264 x :="}
{"input": "Statement in natural language:\nFor a measurable set 's', the measure of 's' according to the probability mass function 'p' is equal to the sum over all 'x' of the indicator function of 's' applied to 'p' and 'x'.\nTranslate the statement in natural language to Lean:", "output": "theorem toMeasure_apply (hs : MeasurableSet s) : p.toMeasure s = \u2211' x, s.indicator p x :="}
{"input": "Statement in natural language:\nFor a given order isomorphism 'e' between two sets \u03b1 and \u03b2, and a given set 's' of \u03b1, the preimage of the preimage of 's' under the inverse of 'e' is equal to 's'.\nTranslate the statement in natural language to Lean:", "output": "theorem preimage_symm_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e.symm \u207b\u00b9' s) = s :="}
{"input": "Statement in natural language:\nIf two functions f and g commute and for a given natural number n and an element x, if f of x equals g of x, then the nth iteration of f on x equals the nth iteration of g on x.\nTranslate the statement in natural language to Lean:", "output": "theorem iterate_eq_of_map_eq (h : Commute f g) (n : \u2115) {x} (hx : f x = g x) :\n    (f^[n]) x = (g^[n]) x :="}
{"input": "Statement in natural language:\nFor any isomorphism 'i' between 'X' and 'Y', the function from 'X' to 'Y' derived from the equivalence corresponding to 'i' is equal to the morphism 'hom' of 'i'.\nTranslate the statement in natural language to Lean:", "output": "theorem toEquiv_fun (i : X \u2245 Y) : (i.toEquiv : X \u2192 Y) = i.hom :="}
{"input": "Statement in natural language:\nIf you map a substructure S of a model M using the identity homomorphism of a language L and M, you will get the same substructure S.\nTranslate the statement in natural language to Lean:", "output": "theorem map_id (S : L.Substructure M) : S.map (Hom.id L M) = S :="}
{"input": "Statement in natural language:\nFor any list 'l', the count of elements in 'l' that satisfy a predicate 'p' is equal to the length of the list obtained by filtering 'l' with the same predicate 'p'.\nTranslate the statement in natural language to Lean:", "output": "theorem countp_eq_length_filter (l) : countp p l = length (filter p l) :="}
