postulate lt_to_not_zero : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not_zero m
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate le_exp_to_le1 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq (pow n p) (pow m p)) -> Leq n m
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate let_clause_1549 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (eqm0 : Eq 0 m) -> (x1106 : Nat) -> Eq x1106 (minus x1106 m)
postulate log_times : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m
postulate Prod_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P Hterm)
postulate le_div_S_S_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (div (plus n 1) m) (plus (div n m) 1)
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate le_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate Aop_rect_CProp1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_883 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_883 : Aop A _nil) -> Q_ x_883
postulate range_rect_Type3 : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921
postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H
postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate Sig_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1170 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1171 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)
postulate div_mod_spec_rect_CProp3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_847 : Lt _r _m) -> (x_846 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> (x_845 : div_mod_spec _n _m _q _r) -> Q_ x_845
postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (plus l 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate le_maxl : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq n i
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate le_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq n m) -> Leq (pow p n) (pow p m)
postulate pi1 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term univs.Type0 A
postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)
postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate Dop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_949 : Dop A _nil) -> Type3) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_949 : Dop A _nil) -> Q_ x_949
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate divides_d_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : divisible d m) -> (__1 : divisible d n) -> divisible d (gcd n m)
postulate Aop_rect_Type0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate let_clause_15311 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (p : Nat) -> (eqm : Eq m (times n (plus p 1))) -> Eq m (plus n (times n p))
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m
postulate minus_le_minus_minus_comm : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a c) b))
postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1))
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P
postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)
postulate le_max_n : (f : (_ : Nat) -> bool) -> (n : Nat) -> Leq (max n f) n
postulate minus_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.minus matita_arithmetics_nat.O n))
postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)
postulate range_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1680 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1681 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate smallest_factor_to_prime : (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (smallest_factor n) n) -> prime n
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate distr : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> (b : A) -> (c : A) -> Eq (prod A nil xxx a (aop__o__op A nil (sum A nil xxx) b c)) (aop__o__op A nil (sum A nil xxx) (prod A nil xxx a b) (prod A nil xxx a c))
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate list_ind2 : (T1 : cic.Univ univs.Type0) -> (T2 : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length T1 l1) (matita_basics_lists_list.length T2 l2))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil T1) (matita_basics_lists_list.nil T2))) -> (__2 : (tl1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (tl2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (hd1 : cic.Term univs.Type0 T1) -> (hd2 : cic.Term univs.Type0 T2) -> (__2 : cic.Term cic.prop (P tl1 tl2)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons T1 hd1 tl1) (matita_basics_lists_list.cons T2 hd2 tl2))) -> cic.Term cic.prop (P l1 l2)
postulate f_ind_aux : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)
postulate match_nat : (return_sort : Sort) -> (return_type : (z : Nat) -> return_sort) -> (case_O : return_type 0) -> (case_S : (_ : Nat) -> return_type (plus __ 1)) -> (z : Nat) -> return_type z
postulate range : (_A : Set) -> Set
postulate div_mod_spec_rect_Type1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_829 : div_mod_spec _n _m _q _r) -> Type1) -> (_H_div_mod_spec_intro : (x_831 : Lt _r _m) -> (x_830 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)) -> (x_829 : div_mod_spec _n _m _q _r) -> Q_ x_829
postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\ _ : Aop a1 a2 -> univ Type2) (\ t0 : ((_ : a1) -> (__1 : a1) -> a1) -> \ t1 : ((a : a1) -> Eq (t0 a2 a) a) -> \ t2 : ((a : a1) -> Eq (t0 a a2) a) -> \ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) -> match_Aop a1 a2 (plus Type2 1) (\ _ : Aop a1 a2 -> univ Type2) (\ u0 : ((_ : a1) -> (__1 : a1) -> a1) -> \ u1 : ((a : a1) -> Eq (u0 a2 a) a) -> \ u2 : ((a : a1) -> Eq (u0 a a2) a) -> \ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0) u0) (\ e0 : Eq (R0 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0 (\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \ _x_
postulate lt_to_le_to_lt_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Leq p q) -> (__2 : Lt 0 q) -> Lt (times n p) (times m q)
postulate range_rect_CProp1 : (_A : Set) -> (Q_ : (_x_937 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937
postulate Dop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_951 : Dop A _nil) -> Type2) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_951 : Dop A _nil) -> Q_ x_951
postulate fact : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate nat_rect_Type4 : (Q_ : (_x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type4) -> (_H_O : cic.Term univs.Type4 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_370 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_372 : cic.Term univs.Type4 (Q_ x_370)) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_nat.S x_370))) -> (x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type4 (Q_ x_369)
postulate lt_max_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)
postulate divides_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> (__3 : divisible d m) -> (__4 : divisible d n) -> divisible d (gcd_aux p m n)
postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n
postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d
postulate leb_true_to_le : (n : Nat) -> (m : Nat) -> (_ : Eq (leb n m) true) -> Leq n m
postulate option_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)
postulate lt_mod_m_m : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt (mod n m) m
postulate nat_inv_rect_Type4 : (Hterm : Nat) -> (P : (_z659 : Nat) -> Type4) -> (_H1 : (_z660 : Eq Hterm 0) -> P 0) -> (_H2 : (x_370 : Nat) -> (_x_372 : (_z660 : Eq Hterm x_370) -> P x_370) -> (_z660 : Eq Hterm (plus x_370 1)) -> P (plus x_370 1)) -> P Hterm
postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate bigop_iso : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> Eq (bigop n1 (\ i : Nat -> p1 i) B nil (aop__o__op B nil op) (\ i : Nat -> f1 i)) (bigop n2 (\ i : Nat -> p2 i) B nil (aop__o__op B nil op) (\ i : Nat -> f2 i))
postulate le_Psi_BPsi1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))
postulate DPair_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)
postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate ACop_inv_rect_CProp0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1626 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1627 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)
postulate div_mod_spec_rect_CProp5_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate div_mod_spec_inv_rect_CProp3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1476 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_847 : Lt x4 x2) -> (x_846 : Eq x1 (plus (times x3 x2) x4)) -> (_z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm
postulate Dop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type0 (Q_ x_955)
postulate null : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil
postulate range_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1674 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1675 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate match_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (case_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> (z : range _A) -> return_type z
postulate Dop_inv_rect_Type2 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1716 : Dop x1 x2) -> Type2) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1717 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate nat_inv_ind : (Hterm : Nat) -> (P : (_z653 : Nat) -> Prop) -> (_H1 : (_z654 : Eq Hterm 0) -> P 0) -> (_H2 : (x_366 : Nat) -> (_x_368 : (_z654 : Eq Hterm x_366) -> P x_366) -> (_z654 : Eq Hterm (plus x_366 1)) -> P (plus x_366 1)) -> P Hterm
postulate divides_to_le : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Leq n m
postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)
postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)
postulate sqrt_bound : (n : Nat) -> (_ : Leq (pow 2 8) n) -> Leq (times 2 (plus (log 2 (times 2 n)) 1)) (sqrt (times 2 n))
postulate monotonic_iter2 : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i j)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g j a))
postulate divides_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> divisible (ord_rem n p) n
postulate noLabel_15 : all Int (\ n -> if (odd n) (odd (minus (plus (times 4 (pow n 3)) (times 2 n)) 1)))
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate mk_DPair : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (f dpi1)) -> cic.Term univs.Type0 (matita_basics_types.DPair A f)
postulate Psi_1 : Eq (Psi 1) 1
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate option_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_623 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))) -> (x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_622)
postulate Dop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)
postulate filter_Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)
postulate ACop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_901 : ACop A _nil) -> Set) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_901 : ACop A _nil) -> Q_ x_901
postulate le_times_to_le_div2 : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Leq n (times m q)) -> Leq (div n q) m
postulate lt_length_to_not_mem : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> (__2 : Lt (length Nat l) n) -> ex Nat (\ i : Nat -> and (Lt i n) (not (mem Nat i l)))
postulate Not_rect_CProp4 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)
postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate Dop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_949 : Dop A _nil) -> Type3) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_949 : Dop A _nil) -> Q_ x_949
postulate div_mod_spec_inv_rect_CProp1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P Hterm)
postulate Aop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_881)
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate Prod_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_10333 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate eq_to_bijn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f i) (g i))) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate list_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_753 : cic.Term univs.Type0 _A) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_755 : cic.Term cic.prop (Q_ x_752)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_753 x_752))) -> (x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_751)
postulate sameF_p_le : (A : Set) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_p m p A f g) -> sameF_p n p A f g
postulate not_found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (_ : (i : Nat) -> (_ : Lt i n) -> Eq (f i) false) -> max_spec n f 0
postulate mod_plus_times : (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> Eq (mod (plus (times q m) r) m) r
postulate Aop_rect_Type1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_871 : Aop A _nil) -> Type1) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_871 : Aop A _nil) -> Q_ x_871
postulate le_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> (__1 : Leq a (minus b c)) -> Leq (plus a c) b
postulate let_clause_1075 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (bijf : cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))) -> (fS : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n))) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i a)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate And_rect_CProp2_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) -> (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_158)
postulate B1 : (_n : Nat) -> Nat
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (f1 n1) (f2 (h n1))
postulate DPair_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_658)
postulate Dop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)
postulate factS : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_factorial.fact n)))
postulate increasing_to_monotonic : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt f)
postulate le_sqrt_n : (n : Nat) -> Leq (sqrt n) n
postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> Leq p n
postulate unit_rect_CProp3_body : (Q_ : (_x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_513)
postulate let_clause_1009 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (Hfn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false)) -> (Hmax : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n)) -> (Hmax0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) n)) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i m) (\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) n))) -> (Hmax0' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) n)) -> (Hfn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f
postulate let_clause_10332 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Not_rect_CProp2_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_110 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))) -> (x_109 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_109)
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate let_clause_16171 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_ar
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1531 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (eqm : Eq m (times n 0)) -> Eq m 0
postulate nat_rect_CProp3 : (Q_ : (_x_401 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_402 : Nat) -> (_x_404 : Q_ x_402) -> Q_ (plus x_402 1)) -> (x_401 : Nat) -> Q_ x_401
postulate nat_rect_CProp2 : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)
postulate divides_to_lt_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Lt 0 n
postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus (plus b 1) a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f (succ i0)) (plus i a))) (f a))
postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))
postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate prime_smallest_factor_n : (n : Nat) -> (_ : Lt 1 n) -> prime (smallest_factor n)
postulate nth_prime_body : (_ : Nat) -> Nat
postulate sameF_p_le : (A : Set) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_p m p A f g) -> sameF_p n p A f g
postulate le_n_O_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P n)
postulate let_previous_prime6 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> (x : Nat) -> Nat
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate let_clause_1227 : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (Hlen : (x : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A x) n)) -> (Ha : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A a) n)) -> (Hnil : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.nil A) (matita_basics_lists_list.append A l1 (matita_basics_lists_list.append A a l2)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)
postulate le_exp_B : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (times (times 2 n) (B (times 2 n)))
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate checker_ab : (a : Nat) -> (b : Nat) -> (l : list Nat) -> Eq (checker (cons Nat a (cons Nat b l))) (andb (andb (leb (plus a 1) b) (leb b (times 2 a))) (checker (cons Nat b l)))
postulate transpose_i_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i i n) n)
postulate not_bertrand : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))
postulate let_clause_10334 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate lt_1_max_prime : (n : Nat) -> (_ : Lt 1 n) -> Lt 1 (max (plus n 1) (\ i : Nat -> andb (primeb i) (dividesb i n)))
postulate Sig_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_680)
postulate let_upper_bound6 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> (x : Nat) -> Nat
postulate lt_log_n_n : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt (log p n) n
postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3
postulate f_ind_aux : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a
postulate lt_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 6) n) -> Lt (log 2 n) (sqrt n)
postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n
postulate divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (times n m)) -> or (divisible p n) (divisible p m)
postulate DPair_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_656)
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate filter_ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)
postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1
postulate decidable_mem_nat : (n : Nat) -> (l : list Nat) -> decidable (mem Nat n l)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm
postulate nat_inv_rect_CProp4 : (Hterm : Nat) -> (P : (_z689 : Nat) -> Prop) -> (_H1 : (_z690 : Eq Hterm 0) -> P 0) -> (_H2 : (x_394 : Nat) -> (_x_396 : (_z690 : Eq Hterm x_394) -> P x_394) -> (_z690 : Eq Hterm (plus x_394 1)) -> P (plus x_394 1)) -> P Hterm
postulate match_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate void_rect_CProp0 : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)
postulate div_mod_spec_to_eq2 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq r r1
postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z
postulate prime_to_gcd_1 : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : not (divisible n m)) -> Eq (gcd n m) 1
postulate range_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1686 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1687 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate congruent_ab : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)))
postulate bigop_I : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus n matita_arithmetics_nat.O) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate leb_true_to_le : (n : Nat) -> (m : Nat) -> (_ : Eq (leb n m) true) -> Leq n m
postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)
postulate div_mod_spec_rect_CProp2 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849
postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)
postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate gcd_O_l : (m : Nat) -> Eq (gcd 0 m) m
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate lt_smallest_factor_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n))
postulate not_divides_to_p_ord_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n))
postulate injective_times_r : (n : Nat) -> (_ : Lt 0 n) -> injective Nat Nat (\ m : Nat -> times n m)
postulate lt_m_exp_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> Lt m (pow n m)
postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate square_S : (a : Nat) -> Eq (pow (plus a 1) 2) (plus (plus (pow a 2) (times 2 a)) 1)
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate le_times_div_div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m))
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_1012 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) (\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m2 f n i b) (matita_arithmetics_nat.plus i b)))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true)
postulate Sum_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)
postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0
postulate let_clause_1571 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m n
postulate compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (_l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_l2 : cic.Term univs.Type0 (matita_basics_lists_list.list B)) -> cic.Term univs.Type0 (matita_basics_lists_list.list C)
postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)
postulate option_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1080 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_623 : cic.Term univs.Type0 x1) -> (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (plus n 1) (\ i : Nat -> true) B nil (op B nil op) (\ i : Nat -> f i)) (op B nil op (bigop n (\ i : Nat -> true) B nil (op B nil op) (\ i : Nat -> f (plus i 1))) (f 0))
postulate eq_rect_CProp5 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)
postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (plus l 1) b1 b2
postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z
postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (mat
postulate divides_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)
postulate Prod_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)
postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate lt_min_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_minimization.min n b f))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate Dop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P Hterm)
postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n
postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))
postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)
postulate nat_rect_Type3_body : (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type3 (Q_ x_377)
postulate nat_inv_rect_CProp3 : (Hterm : Nat) -> (P : (_z695 : Nat) -> Prop) -> (_H1 : (_z696 : Eq Hterm 0) -> P 0) -> (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Eq Hterm x_402) -> P x_402) -> (_z696 : Eq Hterm (plus x_402 1)) -> P (plus x_402 1)) -> P Hterm
postulate bool_rect_CProp5_body : (Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_350)
postulate lt_to_le_times_to_lt_S_to_div : (a : Nat) -> (c : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> (__1 : Leq (times b c) a) -> (__2 : Lt a (times b (plus c 1))) -> Eq (div a b) c
postulate eq_gcd_SO_to_not_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (gcd n m) 1) -> not (divisible n m)
postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate times_n_1 : (n : Nat) -> Eq n (times n 1)
postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate nat_ind : (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) -> (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_365)
postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))))
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n
postulate let_clause_10331 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> Leq p n
postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S p))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times a (matita_arithmetics_nat
postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n
postulate pad_bigop : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> match_bool Set (\ _0 : bool -> bool) false (p i) (leb n i)) B nil op (\ i : Nat -> f i))
postulate min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate lt_4_to_le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate eqb_true_to_eq : (n : Nat) -> (m : Nat) -> (_ : Eq (eqb n m) true) -> Eq n m
postulate bc1 : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (bc (plus n 1) (plus k 1)) (plus (bc n k) (bc n (plus k 1)))
postulate nat_inv_rect_CProp0 : (Hterm : Nat) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm
postulate plus_div : (n : Nat) -> (m : Nat) -> (d : Nat) -> (_ : Lt 0 d) -> (__1 : divisible d n) -> (__2 : divisible d m) -> Eq (div (plus n m) d) (plus (div n d) (div m d))
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate le_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (times 2 n) (times (plus (log 2 (times 2 n)) 1) (plus (prim (times 2 n)) 1))
postulate max_spec : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (_ : Nat) -> Prop
postulate max_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> Eq (f i) false) -> Eq (max n f) 0
postulate let_clause_1531 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (eqm : Eq m (times n 0)) -> Eq m 0
postulate let_previous_prime7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat
postulate primes_below_to_bertrand : (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) -> (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ pp : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)
postulate div_mod_spec_rect_Type1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) -> (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type1 (Q_ x_829)
postulate divides_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> (__3 : divisible d m) -> (__4 : divisible d n) -> divisible d (gcd_aux p m n)
postulate nat_rect_Type0 : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)
postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P
postulate prime_to_primeb_true : (n : Nat) -> (_ : prime n) -> Eq (primeb n) true
postulate range_rect_Type2 : (_A : Set) -> (Q_ : (_x_923 : range _A) -> Type2) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_923 : range _A) -> Q_ x_923
postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm
postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n
postulate Aop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm)
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate lt_to_le_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt n m) -> (__1 : Leq m p) -> Lt n p
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate eq_plus_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate mem_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem B b (matita_basics_lists_list.map A B f l))) -> cic.Term cic.prop (matita_basics_logic.ex A (\ a : cic.Term univs.Type0 A -> matita_basics_logic.And (matita_basics_lists_list.mem A a l) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f a) b)))
postulate let_previous_prime2 : (n : Nat) -> (m : Nat) -> Nat
postulate primeb : (_n : Nat) -> bool
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate ACop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1608 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1609 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate increasing_to_monotonic : (f : (_ : Nat) -> Nat) -> (_ : increasing f) -> monotonic Nat Lt f
postulate let_previous_prime6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n
postulate lstar_step : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b1 : B) -> (b2 : B) -> (_ : R b1 b2) -> lstar B R 1 b1 b2
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate lstar_ind_r : (B : Set) -> (R : relation B) -> (b1 : B) -> (P : relation2 Nat B) -> (_ : P 0 b1) -> (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (plus l 1) b2) -> (l : Nat) -> (b2 : B) -> (__2 : lstar B R l b1 b2) -> P l b2
postulate injective_to_injn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)
postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m
postulate Sig_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1176 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1177 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type4 (P Hterm)
postulate DPair_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_660)
postulate mod_cr_pair : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt a m) -> (__1 : Lt b n) -> (__2 : Eq (gcd n m) 1) -> and (Eq (mod (cr_pair m n a b) m) a) (Eq (mod (cr_pair m n a b) n) b)
postulate div_aux_mod_aux : (p : Nat) -> (n : Nat) -> (m : Nat) -> Eq n (plus (times (div_aux p n m) (plus m 1)) (mod_aux p n m))
postulate primes_all : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (plus l 1) b1 b2
postulate mk_ACop : (A : Set) -> (nil : A) -> (aop : Aop A nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A nil aop a b) (op A nil aop b a)) -> ACop A nil
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)
postulate monotonic_iter : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (b : Nat) -> (i : Nat) -> (_ : monotonic Nat Leq g) -> (__1 : Leq a b) -> Leq (iter Nat g i a) (iter Nat g i b)
postulate minus_to_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Eq (minus n m) p) -> Eq n (plus m p)
postulate div_mod_spec_rect_CProp2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)
postulate le_prim_n2 : (n : Nat) -> (_ : Leq 7 n) -> Leq (prim (plus (times 2 n) 1)) (pred n)
postulate max_cases : (f : (_ : Nat) -> bool) -> (n : Nat) -> or (and (Eq (f n) true) (Eq (max (plus n 1) f) n)) (and (Eq (f n) false) (Eq (max (plus n 1) f) (max n f)))
postulate ex_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n m) (matita_arithmetics_nat.le m (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)))) (matita_arithmetics_primes.prime m)))
postulate lt_O_to_le_theta_exp_theta : (m : Nat) -> (_ : Lt 0 m) -> Lt (theta (plus (times 2 m) 1)) (times (pow 2 (times 2 m)) (theta (plus m 1)))
postulate Psi_2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))
postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)
postulate le_gen : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) -> cic.Term cic.prop (P n)
postulate let_clause_1009 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (Hfn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false)) -> (Hmax : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n)) -> (Hmax0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) n)) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i m) (\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max m f) n))) -> (clearme : cic.Term cic.prop (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i m) (\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> matita_basics_logic
postulate mem_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate lstar_O : (B : Set) -> (R : relation B) -> (b : B) -> lstar B R 0 b b
postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\ y : cic.Term univs.Type0 (matita_basics_types.option A) -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B)) (\ E : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> matita_basics_logic.match_False univs.Type0 (\ _0 : cic.Term cic.prop matita_basics_logic.False -> B) (H E)) (\ v : cic.Term univs.Type0 A -> __ v __)))
postulate divides_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> (__3 : divisible d m) -> (__4 : divisible d n) -> divisible d (gcd_aux p m n)
postulate Aop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)
postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (_clearme : ex Nat (\ a : Nat -> or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (_clearme0 : or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1))) -> (Hn : Eq n0 (plus (times 2 a) 1)) -> Eq n0 (plus a (plus a 1))
postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\ b : B -> lstar B R l b1 b) (\ b : B -> R b b2)
postulate commutative : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop
postulate le_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (_Hterm : Leq x1 x2) -> (P : (_z724 : Nat) -> Prop) -> (_H1 : (_z725 : Eq x2 x1) -> P x1) -> (_H2 : (m : Nat) -> (_x_419 : Leq x1 m) -> (_x_421 : (_z725 : Eq x2 m) -> P m) -> (_z725 : Eq x2 (plus m 1)) -> P (plus m 1)) -> P x2
postulate tri_relation : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> (__2 : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate max' : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate div_mod_spec_rect_CProp5_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate bigop_iso : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> Eq (bigop n1 (\ i : Nat -> p1 i) B nil (aop__o__op B nil op) (\ i : Nat -> f1 i)) (bigop n2 (\ i : Nat -> p2 i) B nil (aop__o__op B nil op) (\ i : Nat -> f2 i))
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate andb_true : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true))
postulate false_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : Eq (f b) false) -> Eq (min (plus n 1) b f) (min n (plus b 1) f)
postulate Aop_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1512 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1513 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P Hterm)
postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0
postulate And_inv_rect_Type1 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z347 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (x_140 : cic.Term cic.prop x1) -> (x_139 : cic.Term cic.prop x2) -> (_z348 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_140 x_139))) -> cic.Term univs.Type1 (P (matita_basics_logic.conj x1 x2 x_140 x_139))) -> cic.Term univs.Type1 (P Hterm)
postulate option_rect_Type5 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type5) -> (_H_None : cic.Term univs.Type5 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_595 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.Some _A x_595))) -> (x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type5 (Q_ x_594)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) true) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (op (f k) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)))
postulate Dop_rect_CProp2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963
postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_915 : range _A) -> Q_ x_915
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate not_eq_n_Sn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S n)))
postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))
postulate let_clause_16001 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate nat_rect_CProp0_body : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413
postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate range_rect_CProp3 : (_A : Set) -> (Q_ : (_x_933 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_933 : range _A) -> Q_ x_933
postulate range_rect_CProp4 : (_A : Set) -> (Q_ : (_x_929 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_929 : range _A) -> Q_ x_929
postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> Leq p n
postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m
postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.times qa qb) (
postulate gcd_O_l : (m : Nat) -> Eq (gcd 0 m) m
postulate ACop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type1 (Q_ x_899)
postulate div_mod_spec_inv_rect_Type4 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1440 : div_mod_spec x1 x2 x3 x4) -> Type4) -> (_H1 : (x_815 : Lt x4 x2) -> (x_814 : Eq x1 (plus (times x3 x2) x4)) -> (_z1441 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P Hterm
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))
postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate filter_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (return : (z : range _A) -> return_type z) -> (z : range _A) -> return_type z
postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1
postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)
postulate False_rect_Type5 : (Q_ : (_x_68 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type5) -> (x_68 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ x_68)
postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)
postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)
postulate ACop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_913)
postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate eq_minus_S_pred : (n : Nat) -> (m : Nat) -> Eq (minus n (plus m 1)) (pred (minus n m))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (gcd n m) n
postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m
postulate increasing_to_le2 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i)))))
postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m
postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Lt (plus x y) z) -> and (Lt x z) (Lt y (minus z x))
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate aop__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : ACop x0 x1) -> (_x_887 : x0) -> (_x_888 : x0) -> x0
postulate let_aop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> ACop B nil
postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate le_exp_Psi2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))
postulate let_mop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> (_x_969 : cic.Term univs.Type0 B) -> (_x_970 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B
postulate lt_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) m) -> Lt n m
postulate eq_mod_to_divides : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Eq (mod n q) (mod m q)) -> divisible q (minus n m)
postulate Sum_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)
postulate start_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (option_hd Nat (list_of_primes n)) (Some Nat 2)
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate ACop_rect_Type1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_899 : ACop A _nil) -> Type1) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_899 : ACop A _nil) -> Q_ x_899
postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\ p : Nat -> transpose i j (f p)) n
postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (_ : Nat) -> bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> (_ : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 0) -> P 0) -> P x3
postulate range_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_933)
postulate le_prim_n3 : (n : Nat) -> (_ : Leq 15 n) -> Leq (prim n) (pred (div n 2))
postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate eq_log_exp : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> Eq (log p (pow p n)) n
postulate divides_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)
postulate lt_div_S_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Leq (pow m 2) n) -> Lt (div n (plus m 1)) (div n m)
postulate let_clause_1013 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (i : Nat) -> (Hind : (_ : Eq (max i f) m) -> (__1 : Eq (f m) false) -> Eq m 0) -> (fi : Eq (f i) true) -> (eqm : Eq i m) -> (fm : Eq (f m) false) -> Eq false true
postulate prime_to_not_divides_fact : (p : Nat) -> (_ : prime p) -> (n : Nat) -> (__1 : Lt n p) -> not (divisible p (factorial n))
postulate let_previous_prime : (_ : Nat) -> (p : Nat) -> Nat
postulate Prod_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_714)
postulate Sig_rect_Type3 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate Aop_rect_Type0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate let_clause_15624 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> cic.Univ univs.Type0
postulate eq_times_plus_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : Eq n (plus (times r p) m)) -> congruent n m p
postulate bool_rect_Type3_body : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)
postulate divides_smallest_factor_n : (n : Nat) -> (_ : Lt 0 n) -> divisible (smallest_factor n) n
postulate prime_to_not_divides_fact : (p : Nat) -> (_ : prime p) -> (n : Nat) -> (__1 : Lt n p) -> not (divisible p (factorial n))
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate le_times_div_m_m : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (times (div n m) m) n
postulate max_spec_to_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : max_spec n f m) -> Eq (max n f) m
postulate eq_times_plus_to_congruent : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m))) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)
postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Lt (plus x y) z) -> and (Lt x z) (Lt y (minus z x))
postulate unit_rect_Type0 : (Q_ : (_x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0) -> (_H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it)) -> (x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type0 (Q_ x_507)
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate not_le_to_not_le_S_S : (n : Nat) -> (m : Nat) -> (_ : not (Leq n m)) -> not (Leq (plus n 1) (plus m 1))
postulate range_rect_Type4_body : (_A : Set) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_917 : range _A) -> Q_ x_917
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate list : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\ _ : Aop a1 a2 -> univ Type2) (\ t0 : ((_ : a1) -> (__1 : a1) -> a1) -> \ t1 : ((a : a1) -> Eq (t0 a2 a) a) -> \ t2 : ((a : a1) -> Eq (t0 a a2) a) -> \ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) -> match_Aop a1 a2 (plus Type2 1) (\ _ : Aop a1 a2 -> univ Type2) (\ u0 : ((_ : a1) -> (__1 : a1) -> a1) -> \ u1 : ((a : a1) -> Eq (u0 a2 a) a) -> \ u2 : ((a : a1) -> Eq (u0 a a2) a) -> \ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0) u0) (\ e0 : Eq (R0 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0 (\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \ _x_
postulate bigop_iso : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> Eq (bigop n1 (\ i : Nat -> p1 i) B nil (aop__o__op B nil op) (\ i : Nat -> f1 i)) (bigop n2 (\ i : Nat -> p2 i) B nil (aop__o__op B nil op) (\ i : Nat -> f2 i))
postulate checker_abl : (a : Nat) -> (b : Nat) -> (l : list Nat) -> (_ : Eq (checker (cons Nat a (cons Nat b l))) true) -> and (and (Lt a b) (Leq b (times 2 a))) (Eq (checker (cons Nat b l)) true)
postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true
postulate Dop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967
postulate let_clause_1033 : (n : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919
postulate decidable_eq_nat : (n : Nat) -> (m : Nat) -> decidable (Eq n m)
postulate min_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (t : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m t)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m)
postulate Sum_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_556)
postulate Aop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_883 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_883 : Aop A _nil) -> Q_ x_883
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate bigop_commute : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p11 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p12 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p21 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p22 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> (__4 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.n
postulate minus_n_O : (n : Nat) -> Eq n (minus n 0)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate ACop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_911 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_911 : ACop A _nil) -> Q_ x_911
postulate filter_DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)
postulate list_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) -> (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_776)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate min_f_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) (g i)) -> Eq (min n b f) (min n b g)
postulate ACop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1590 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1591 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type1 (P Hterm)
postulate ex_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) -> (P : (_z455 : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x : cic.Term univs.Type0 x1) -> (x_236 : cic.Term cic.prop (x2 x)) -> (_z456 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2)) Hterm (matita_basics_logic.ex_intro x1 x2 x x_236))) -> cic.Term cic.prop (P (matita_basics_logic.ex_intro x1 x2 x x_236))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate le_to_mod : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq n (mod n m)
postulate lt_times_n_to_lt_l : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times p n) (times q n)) -> Lt p q
postulate Dop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate pair_eq1 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2)
postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate range_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_931)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate append_l2_injective : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)
postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p
postulate upto_body : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate mem_filter_l : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l)) -> cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l))
postulate DPair_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1164 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1165 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)
postulate ACop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1602 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1603 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)
postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\ i : Nat -> 1))
postulate nat_case : (n : Nat) -> (P : (_ : Nat) -> Prop) -> (_ : (_ : Eq n 0) -> P 0) -> (__1 : (m : Nat) -> (__1 : Eq n (plus m 1)) -> P (plus m 1)) -> P n
postulate max_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> Eq (max n f) m
postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate ge : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate minus_pred_pred : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (minus (pred n) (pred m)) (minus n m)
postulate bool_rect_CProp3_body : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate le_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (times 2 n) (times (plus (log 2 (times 2 n)) 1) (plus (prim (times 2 n)) 1))
postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (plus l 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z
postulate le_exp_B : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (times (times 2 n) (B (times 2 n)))
postulate lt_to_log_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt m n) -> Eq (log n m) 0
postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)
postulate p_ord_aux_false : (p : Nat) -> (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Eq (mod n m) (plus a 1)) -> Eq (p_ord_aux p n m) (mk_Prod Nat Nat 0 n)
postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool
postulate divides_exp_to_eq : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : prime q) -> (__2 : divisible p (pow q m)) -> Eq p q
postulate le_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> (__1 : Leq a (minus b c)) -> Leq (plus a c) b
postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d
postulate divides_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq m n) -> (__2 : divisible p (minus n m)) -> congruent n m p
postulate let_clause_1532 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m 0
postulate range_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1638 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type4) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1639 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type4 (P Hterm)
postulate pred : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885
postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369
postulate true_min : (f : (_ : Nat) -> bool) -> (b : Nat) -> (_ : Eq (f b) true) -> (n : Nat) -> Eq (min n b f) b
postulate le_plus_mod : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> Leq (mod (plus m n) q) (plus (mod m q) (mod n q))
postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z
postulate divides_gcd_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)))
postulate or_div_mod1 : (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> or (and (divisible q (plus n 1)) (Eq (plus n 1) (times (plus (div n q) 1) q))) (and (not (divisible q (plus n 1))) (Eq (plus n 1) (plus (times (div n q) q) (plus (mod n q) 1))))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate let_clause_1009 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (Hfn : Eq (f n) false) -> (Hmax : Leq (max m f) n) -> (Hmax0 : Eq (max m f) n) -> (_clearme : and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i m) (\ _ : Lt i m -> Eq (f i) false))) (Eq (max m f) 0)) -> (auto : (i : Nat) -> (_ : Lt i m) -> Eq (f i) false) -> (auto' : Eq (max m f) 0) -> Eq 0 n
postulate Not_rect_CProp5_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)
postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))))
postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))
postulate le_times_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Leq (times a n) (times a m)) -> Leq n m
postulate ACop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_913 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_913 : ACop A _nil) -> Q_ x_913
postulate sameF_p_le : (A : cic.Univ univs.Type0) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p m p A f g)) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_p n p A f g)
postulate match_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) -> (case_found_min_spec : (m : Nat) -> (_ : Leq _b m) -> (__1 : Lt m (plus _n _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> (case_not_found_min_spec : (_ : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> (_ : Nat) -> (z : min_spec _n _b _f __) -> return_type __ z
postulate match_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (case_ex2_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)
postulate range_rect_CProp1 : (_A : Set) -> (Q_ : (_x_937 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937
postulate bigop_iso : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> Eq (bigop n1 (\ i : Nat -> p1 i) B nil (aop__o__op B nil op) (\ i : Nat -> f1 i)) (bigop n2 (\ i : Nat -> p2 i) B nil (aop__o__op B nil op) (\ i : Nat -> f2 i))
postulate let_clause_1572 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m 0
postulate enum_body : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A
postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (plus n 1) (times 2 n)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate filter_Dop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Dop A _nil) -> return_sort) -> (return : (z : Dop A _nil) -> return_type z) -> (z : Dop A _nil) -> return_type z
postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)
postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate prime_to_nth_prime : (p : Nat) -> (_ : prime p) -> ex Nat (\ i : Nat -> Eq (nth_prime i) p)
postulate f_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : permut f n) -> Eq (f (invert_permut n f m)) m
postulate congruent_n_mod_n : (n : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> congruent n (mod n p) p
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate le_prim_n3 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))
postulate ACop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1596 : ACop x1 x2) -> Set) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1597 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate prime_to_lt_O : (p : Nat) -> (_ : prime p) -> Lt 0 p
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate div_mod_spec_inv_rect_CProp3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1476 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_847 : Lt x4 x2) -> (x_846 : Eq x1 (plus (times x3 x2) x4)) -> (_z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm
postulate Not_rect_Type0_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) -> (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type0 (Q_ x_97)
postulate ACop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_901 : ACop A _nil) -> Set) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_901 : ACop A _nil) -> Q_ x_901
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate prop60 : (n : Nat) -> Eq (plus n 0) n
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate dpi1_body : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) -> cic.Term univs.Type0 A
postulate lt_O_n_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)
postulate fmax_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq (f m) false) -> Eq m 0
postulate Not_rect_CProp1 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_113 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))) -> (x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_112)
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate bigop : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate le_exp_to_le1 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq (pow n p) (pow m p)) -> Leq n m
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate p_ord_to_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Eq (p_ord n p) (mk_Prod Nat Nat q r)) -> and (not (divisible p r)) (Eq n (times (pow p q) r))
postulate match_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> (case_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)
postulate let_clause_73 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> (x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))
postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\ i : Nat -> 1))
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\ t : Nat -> times c t)
postulate let_clause_1033 : (n : Nat) -> (le_n : Leq (pow 2 4) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0
postulate filter_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)
postulate bigop_commute : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p11 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p12 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p21 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p22 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> (__4 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.n
postulate le_max_f_max_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g))
postulate Sig_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1218 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1219 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)
postulate False_rect_CProp1 : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)
postulate not_divides_to_dividesb_false : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (dividesb n m) false
postulate nat_case : (n : Nat) -> (P : (_ : Nat) -> Prop) -> (_ : (_ : Eq n 0) -> P 0) -> (__1 : (m : Nat) -> (__1 : Eq n (plus m 1)) -> P (plus m 1)) -> P n
postulate filter_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0
postulate divides_SO_n : (n : Nat) -> divisible 1 n
postulate mod_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat
postulate eqb_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Aop_rect_CProp0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_805 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_805 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_805)
postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T1) a1))) -> cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T1) a1) a2 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T2) a2))
postulate mk_Aop : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)
postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate prop140 : (x : Int) -> (y : Int) -> iff (same_parity x y) (even (plus x y))
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate theta_def : (n : Nat) -> Eq (theta n) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> p))
postulate le_Psi_BPsi1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (Psi (times 2 n)) (times (B (times 2 n)) (Psi n))
postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z
postulate nat_rect_Type1_body : (Q_ : (_x_385 : Nat) -> Type1) -> (_H_O : Q_ 0) -> (_H_S : (x_386 : Nat) -> (_x_388 : Q_ x_386) -> Q_ (plus x_386 1)) -> (x_385 : Nat) -> Q_ x_385
postulate le_plus_n_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n))
postulate p_ord_aux_to_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 m) -> (__1 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> Eq n (times (pow m q) r)
postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Eq (mod n m) 0) -> (__1 : Eq (p_ord_aux p (div n m) m) (mk_Prod Nat Nat q r)) -> Eq (p_ord_aux (plus p 1) n m) (mk_Prod Nat Nat (plus q 1) r)
postulate DPair_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type4 (Q_ x_640)
postulate dpi1__o__aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0
postulate not_eq_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))
postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))
postulate lt_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) m) -> Lt n m
postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> Leq m (max n f)
postulate p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (qa : Nat) -> (ra : Nat) -> (qb : Nat) -> (rb : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> (__3 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra)) -> (__4 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb)) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb))
postulate divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux p m n) n)
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.match_bool (p1 i) (p2 i)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.n
postulate eq_rect_Type1_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) -> (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_16 : cic.Term univs.Type2 A) -> (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Term univs.Type1 (Q_ x_16 x_17)
postulate filter : (A : Set) -> (_xxx : range A) -> (_x_941 : Nat) -> bool
postulate mod_cr_pair : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt b n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) m) a) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) n) b))
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1
postulate False_rect_Type4 : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)
postulate range_rect_CProp0 : (_A : Set) -> (Q_ : (_x_939 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_939 : range _A) -> Q_ x_939
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959
postulate Dop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_967)
postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n) (\ __1 : Lt i n -> P i)))) -> ex Nat (\ i : Nat -> and (Lt i n) (not (P i)))
postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate divides_pi_p_M : (m : Nat) -> divisible (bigop (plus (times 2 m) 2) (\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\ p : Nat -> p)) (M m)
postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus p m)) -> Lt (minus n m) p
postulate eq_ind : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_1 : cic.Term univs.Type2 A) -> (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Term cic.prop (Q_ x_1 x_2)
postulate div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) b) a)
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
postulate p_ord_aux_to_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 m) -> (__1 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> Eq n (times (pow m q) r)
postulate lt_n_nth_prime_n : (n : Nat) -> Lt n (nth_prime n)
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate divides_fact_to_divides : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> ex Nat (\ m : Nat -> and (and (Lt 0 m) (Leq m n)) (divisible p m))
postulate Sum_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) -> (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type0 (Q_ x_551)
postulate bijn_transpose : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n)
postulate let_clause_15591 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m n
postulate lt_mod_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.mod n m) m)
postulate option_map_none : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))
postulate min_not_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))
postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)
postulate lstar_ind_r : (B : Set) -> (R : relation B) -> (b1 : B) -> (P : relation2 Nat B) -> (_ : P 0 b1) -> (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (plus l 1) b2) -> (l : Nat) -> (b2 : B) -> (__2 : lstar B R l b1 b2) -> P l b2
postulate let_clause_1573 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq n m
postulate div_mod_spec_rect_Type5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_817 : div_mod_spec _n _m _q _r) -> Type5) -> (_H_div_mod_spec_intro : (x_819 : Lt _r _m) -> (x_818 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_819 x_818)) -> (x_817 : div_mod_spec _n _m _q _r) -> Q_ x_817
postulate range_rect_CProp4_body : (_A : Set) -> (Q_ : (_x_929 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_929 : range _A) -> Q_ x_929
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate prime_to_gcd_1 : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : not (divisible n m)) -> Eq (gcd n m) 1
postulate Dop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)
postulate And_inv_rect_CProp4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_148 : cic.Term cic.prop x1) -> (x_147 : cic.Term cic.prop x2) -> (_z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate le_plus : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))
postulate gcd_aux : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat
postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Lt (plus x y) z) -> and (Lt x z) (Lt y (minus z x))
postulate append_l1_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)
postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus p m)) -> Lt (minus n m) p
postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (mat
postulate B2_def : (n : Nat) -> Eq (B2 n) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> pow p (times (bool_to_nat (leb 2 (k n p))) (k n p))))
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (f1 i) (f2 (h i))
postulate plus_n_O : (n : Nat) -> Eq n (plus n 0)
postulate option_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)
postulate nat_inv_rect_CProp0 : (Hterm : Nat) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm
postulate primeb_false_to_not_prime : (n : Nat) -> (_ : Eq (primeb n) false) -> not (prime n)
postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : Eq (checker l) true) -> (__1 : Eq l (cons Nat a tl)) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))
postulate div_mod_spec_inv_rect_CProp3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1476 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_847 : Lt x4 x2) -> (x_846 : Eq x1 (plus (times x3 x2) x4)) -> (_z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate range_rect_Type5 : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919
postulate hd : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_d : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate le_Psi_BPsi1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (Psi (times 2 n)) (times (B (times 2 n)) (Psi n))
postulate monotonic_le_plus_r : (n : Nat) -> monotonic Nat Leq (\ m : Nat -> plus n m)
postulate le_to_le_to_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : Leq m n) -> Eq n m
postulate breakup_pair : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (R : (__ : cic.Term univs.Type0 C) -> cic.Univ cic.prop) -> (P : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (__ : cic.Term cic.prop (R (P (matita_basics_types.fst A B x) (matita_basics_types.snd A B x)))) -> cic.Term cic.prop (R (matita_basics_types.match_Prod A B univs.Type0 (\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\ a : cic.Term univs.Type0 A -> \ b : cic.Term univs.Type0 B -> P a b) x))
postulate Not_rect_Type5 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type5) -> (_H_nmk : (x_86 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> (x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type5 (Q_ x_85)
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate True_inv_rect_Type4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z131 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H1 : (_z132 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type4 (P matita_basics_logic.I)) -> cic.Term univs.Type4 (P Hterm)
postulate divides_fact_to_divides : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> ex Nat (\ m : Nat -> and (and (Lt 0 m) (Leq m n)) (divisible p m))
postulate le_pred_n : (n : Nat) -> Leq (pred n) n
postulate filter_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : min_spec _n _b _f __) -> return_sort) -> (return : (z : min_spec _n _b _f __) -> return_type z) -> (z : min_spec _n _b _f __) -> return_type z
postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate option_map_none : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))
postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n p) -> (__4 : divisible d (times c m)) -> (__5 : divisible d (times c n)) -> divisible d (times c (gcd_aux p m n))
postulate not_prime_times_2 : (n : Nat) -> (_ : Lt 1 n) -> not (prime (times 2 n))
postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate bigop_op : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (aop__o__op B nil op (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> g i))) (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> aop__o__op B nil op (f i) (g i)))
postulate let_clause_1692 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))
postulate upto : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
postulate match_max_spec : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : max_spec _n _f __) -> return_sort) -> (case_found_max_spec : (m : Nat) -> (_ : Lt m _n) -> (__1 : Eq (_f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i _n) -> Eq (_f i) false) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> (case_not_found_max_spec : (_ : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> return_type 0 (not_found_max_spec _n _f __)) -> (_ : Nat) -> (z : max_spec _n _f __) -> return_type __ z
postulate divides_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides n matita_arithmetics_nat.O)
postulate le_to_le_to_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : Leq m n) -> Eq n m
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z
postulate log_i_2n : (n : Nat) -> (i : Nat) -> (_ : Lt 1 n) -> (__1 : Lt n i) -> (__2 : Leq i (times 2 n)) -> Eq (log i (times 2 n)) 1
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate bool_rect_Type2_body : (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) -> (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ x_338)
postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (mat
postulate p_ord_O_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O r))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n))
postulate range_inv_rect_Type0 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1662 : range x1) -> Set) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1663 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm
postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m
postulate nat_rect_CProp1 : (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_409)
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate eq_length_to_mem_all : (n : Nat) -> (l : list Nat) -> (_ : Eq (length Nat l) n) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) -> (i : Nat) -> (__3 : Lt i n) -> mem Nat i l
postulate ACop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_ACop a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> \ t1 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_arithmetics_bigops.op a1 a2 t0 a b) (matita_arithmetics_bigops.op a1 a2 t0 b a))) -> matita_arithmetics_bigops.match_ACop a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> \ u1 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_arithmetics_bigops.op a1 a2 u0 a b) (matita_arithmetics_bigops.op a1 a2 u0 b a))) -> cic
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate congruent_ab : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\ x : Nat -> and (congruent x a m) (congruent x b n))
postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z
postulate let_clause_1033 : (n : Nat) -> (le_n : Leq (pow 2 4) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15441 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.posn n)) -> (H : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (mat
postulate lt_times_n : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> Leq m (times n m)
postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)
postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)
postulate let_clause_1569 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m
postulate divides_to_divides_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p))
postulate not_eq_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))
postulate eq_rect_CProp2_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_31 : cic.Term univs.Type2 A) -> (x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Term cic.prop (Q_ x_31 x_32)
postulate list_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1320 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type2) -> (_H1 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_738 : cic.Term univs.Type0 x1) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_740 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_737)) -> cic.Term univs.Type2 (P x_737)) -> (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P Hterm)
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm
postulate bigop_I : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (minus n 0) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i 0)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i 0))) (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate Aop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_797)
postulate bool_rect_Type3 : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)
postulate fst_eq : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_types.fst A B (matita_basics_types.mk_Prod A B a b)) a)
postulate ACop_inv_rect_CProp0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1626 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1627 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate let_clause_1047 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (lenk : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (leup : cic.Term cic.prop (matita_arithmetics_nat.le n j)) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i j)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs
postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate monotonic_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_div_and_mod.div m n))
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate lt_O_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq p n) -> Lt 0 (log p n)
postulate divides_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (Hterm : divisible x1 x2) -> (P : (_z2006 : divisible x1 x2) -> Prop) -> (_H1 : (q : Nat) -> (x_1193 : Eq x2 (times x1 q)) -> (_z2007 : Eq Hterm (quotient x1 x2 q x_1193)) -> P (quotient x1 x2 q x_1193)) -> P Hterm
postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i
postulate lstar_inv_step : (B : Set) -> (R : relation B) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R 1 b1 b2) -> R b1 b2
postulate let_clause_15591 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m n
postulate Nat : cic.Univ univs.Type0
postulate le_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> (__1 : Leq a (minus b c)) -> Leq (plus a c) b
postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875
postulate ltn_to_ltO : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Lt 0 m
postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)
postulate range_inv_rect_Type0 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1662 : range x1) -> Set) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1663 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm
postulate nth_primeS : (n : Nat) -> Eq (nth_prime (plus n 1)) (min (let_upper_bound1 n) (plus (let_previous_prime1 n) 1) primeb)
postulate pair_elim : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\ lft : cic.Term univs.Type0 A -> \ rgt : cic.Term univs.Type0 B -> T lft rgt) p))
postulate div_mod_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)
postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (plus l 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0
postulate nat_rect_Type3 : (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type3 (Q_ x_377)
postulate Dop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate lstar_ind_l_aux : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (__3 : Eq b b2) -> P l b1
postulate prime_nth_prime : (n : Nat) -> prime (nth_prime n)
postulate pair_eq2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b1 b2)
postulate ACop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_893 : ACop A _nil) -> Type5) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_893 : ACop A _nil) -> Q_ x_893
postulate lt_plus_to_minus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus c b))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate le_times_to_le_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : Leq (times b c) a) -> Leq c (div a b)
postulate cr_pair2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))
postulate nill_body : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a
postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate prime_to_not_divides_fact : (p : Nat) -> (_ : prime p) -> (n : Nat) -> (__1 : Lt n p) -> not (divisible p (factorial n))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate Or_inv_ind : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> (P : (_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_171 : cic.Term cic.prop x1) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_introl x1 x2 x_171))) -> cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))) -> (_H2 : (x_172 : cic.Term cic.prop x2) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P Hterm)
postulate option_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1086 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1087 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_627 : cic.Term univs.Type0 x1) -> (_z1087 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_627))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_627))) -> cic.Term cic.prop (P Hterm)
postulate bigop_iso : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> Eq (bigop n1 (\ i : Nat -> p1 i) B nil (aop__o__op B nil op) (\ i : Nat -> f1 i)) (bigop n2 (\ i : Nat -> p2 i) B nil (aop__o__op B nil op) (\ i : Nat -> f2 i))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate div_mod_spec_rect_Type1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_829 : div_mod_spec _n _m _q _r) -> Type1) -> (_H_div_mod_spec_intro : (x_831 : Lt _r _m) -> (x_830 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)) -> (x_829 : div_mod_spec _n _m _q _r) -> Q_ x_829
postulate le_div_times_m : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div m i)) m) (matita_arithmetics_div_and_mod.div a i))
postulate Aop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_877 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_877 : Aop A _nil) -> Q_ x_877
postulate checker : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate assoc_body : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> (b : A) -> (c : A) -> Eq (op A nil xxx a (op A nil xxx b c)) (op A nil xxx (op A nil xxx a b) c)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate eq_minus_gcd : (m : Nat) -> (n : Nat) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd n m)) (Eq (minus (times b m) (times a n)) (gcd n m))))
postulate le_plus_to_minus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq (plus a b) c) -> Leq a (minus c b)
postulate Dop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)
postulate lt_exp_to_lt1 : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow n a) (pow m a)) -> Lt n m
postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m
postulate Aop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1554 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1555 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate le_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (_Hterm : Leq x1 x2) -> (P : (_z724 : Nat) -> Prop) -> (_H1 : (_z725 : Eq x2 x1) -> P x1) -> (_H2 : (m : Nat) -> (_x_419 : Leq x1 m) -> (_x_421 : (_z725 : Eq x2 m) -> P m) -> (_z725 : Eq x2 (plus m 1)) -> P (plus m 1)) -> P x2
postulate fact_minus : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (times (factorial (minus n (plus k 1))) (minus n k)) (factorial (minus n k))
postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (_ : Nat) -> bool) -> (p12 : (_ : Nat) -> (__1 : Nat) -> bool) -> (p21 : (_ : Nat) -> bool) -> (p22 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\ i : Nat -> bigop m (\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\ j : Nat -> f i j))) (bigop m (\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\ j : Nat -> bigop n (\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\ i : Nat -> f i j)))
postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)
postulate range_rect_CProp2_body : (_A : Set) -> (Q_ : (_x_935 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_935 : range _A) -> Q_ x_935
postulate bigop_op : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (aop__o__op B nil op (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> g i))) (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> aop__o__op B nil op (f i) (g i)))
postulate permut_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f n)) m)
postulate divides_gcd_r : (n : Nat) -> (m : Nat) -> divisible (gcd n m) m
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate checker_ab : (a : Nat) -> (b : Nat) -> (l : list Nat) -> Eq (checker (cons Nat a (cons Nat b l))) (andb (andb (leb (plus a 1) b) (leb b (times 2 a))) (checker (cons Nat b l)))
postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0
postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338
postulate And_rect_CProp5_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_152 : cic.Term cic.prop _A) -> (x_151 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) -> (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_150)
postulate match_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (case_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)
postulate smallest_factor_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n))))
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate match_div_mod_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ return_sort) -> (case_div_mod_spec_intro : (__ : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term return_sort (return_type (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r __ __1))) -> (z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term return_sort (return_type z)
postulate le_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Leq (max n f) (max m f)
postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))))
postulate let_clause_10331 : (p : Nat) -> (n : Nat) -> (n1 : Nat) -> (q : Nat) -> (p1 : Nat) -> (p2 : Nat) -> (qa : Nat) -> (ra : Nat) -> (H : Eq (p_ord_aux (plus n1 1) (plus n1 1) (plus p2 2)) (mk_Prod Nat Nat qa ra)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Eq n (plus m p)) -> Eq (minus n m) p
postulate eq_gcd_SO_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))
postulate not_divides_to_dividesb_false : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (dividesb n m) false
postulate not_bertrand_to_le_B : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))
postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate commutative_gcd : (n : Nat) -> (m : Nat) -> Eq (gcd n m) (gcd m n)
postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (bigop n (\ i : Nat -> false) B nil op (\ i : Nat -> f i)) nil
postulate list_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) -> (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) -> (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type3 (Q_ x_731)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate div_mod_spec_inv_rect_CProp1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (plus (times x3 x2) x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm
postulate plus_minus : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Leq m n) -> Eq (plus (minus n m) p) (minus (plus n p) m)
postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> Leq p n
postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true
postulate ltn_to_ltO : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Lt 0 m
postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate or_div_mod : (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> or (and (Eq (plus (mod n q) 1) q) (Eq (plus n 1) (times (plus (div n q) 1) q))) (and (Lt (plus (mod n q) 1) q) (Eq (plus n 1) (plus (times (div n q) q) (plus (mod n q) 1))))
postulate B_SSSSO : Eq (B 4) 6
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate le_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq n m) -> Leq (pow p n) (pow p m)
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate div_mod_spec_inv_rect_CProp0 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1494 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1495 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_859 x_858))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_859 x_858))) -> cic.Term cic.prop (P Hterm)
postulate injn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : injn f (plus n 1)) -> injn f n
postulate let_upper_bound5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat
postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1
postulate let_clause_15621 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate DPair_rect_Type5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type5 (Q_ x_642)
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate range_rect_Type3_body : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921
postulate Dop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> cic.univ univs.Type2) (\ t0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \ t1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) -> \ t2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) -> \ t3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) -> matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> cic.univ univs.Type2)
postulate ACop_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1626 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1627 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)
postulate lt_O_to_le_theta_exp_theta : (m : Nat) -> (_ : Lt 0 m) -> Lt (theta (plus (times 2 m) 1)) (times (pow 2 (times 2 m)) (theta (plus m 1)))
postulate pi_p_primeb4 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))
postulate let_previous_prime5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat
postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred a))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times a (matita_arithmetics_nat
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate ACop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_899 : ACop A _nil) -> Type1) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_899 : ACop A _nil) -> Q_ x_899
postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)
postulate lt_O_exp : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> Lt 0 (pow n m)
postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)
postulate let_clause_16 : (n : Nat) -> (m : Nat) -> (auto : Lt (plus n 1) (plus m 1)) -> (x32 : Nat) -> Eq (plus x32 1) (plus x32 1)
postulate Prod_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_690)
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate let_clause_15591 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m n
postulate le_Psi_BPsi1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (Psi (times 2 n)) (times (B (times 2 n)) (Psi n))
postulate theta_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))
postulate checker_abl : (a : Nat) -> (b : Nat) -> (l : list Nat) -> (_ : Eq (checker (cons Nat a (cons Nat b l))) true) -> and (and (Lt a b) (Leq b (times 2 a))) (Eq (checker (cons Nat b l)) true)
postulate max : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate same_bigop : (k : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\ i : Nat -> p1 i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p2 i) B nil op (\ i : Nat -> g i))
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate Aop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_861 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_861 : Aop A _nil) -> Q_ x_861
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_1572 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m 0
postulate divides_exp_to_eq : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : prime q) -> (__2 : divisible p (pow q m)) -> Eq p q
postulate div_mod_spec_rect_CProp1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate le_iter : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (i : Nat) -> Leq a (iter Nat g i a)
postulate divides_fact_to_divides : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> ex Nat (\ m : Nat -> and (and (Lt 0 m) (Leq m n)) (divisible p m))
postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (plus (mod n m) 1) m) -> Eq (mod (plus n 1) m) (plus (mod n m) 1)
postulate nat_rect_CProp4 : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393
postulate div_mod_spec_rect_CProp2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849
postulate lt_length_to_not_mem : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> (__2 : Lt (length Nat l) n) -> ex Nat (\ i : Nat -> and (Lt i n) (not (mem Nat i l)))
postulate lt_4_to_le_B_exp : (n : Nat) -> (_ : Lt 4 n) -> Leq (B (times 2 n)) (pow 2 (minus (times 2 n) 2))
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate le_ind : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate lt_sqrt_to_lt_times_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_sqrt.sqrt m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n n) m)
postulate le_exp_priml : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate nat_rect_Type0 : (Q_ : (_x_389 : Nat) -> Set) -> (_H_O : Q_ 0) -> (_H_S : (x_390 : Nat) -> (_x_392 : Q_ x_390) -> Q_ (plus x_390 1)) -> (x_389 : Nat) -> Q_ x_389
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n
postulate let_clause_1033 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (ndivpr : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> (q0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S q1) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S q1)))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate prime_to_not_divides_fact : (p : Nat) -> (_ : prime p) -> (n : Nat) -> (__1 : Lt n p) -> not (divisible p (factorial n))
postulate let_previous_prime4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate reverse_single : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))
postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T1) a1))) -> cic.Univ univs.Type0
postulate plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate False_rect_Type3_body : (Q_ : (_x_69 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type3) -> (x_69 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ x_69)
postulate lt_times_n_to_lt_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)
postulate not_eq_to_le_to_lt : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> (__1 : Leq n m) -> Lt n m
postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1
postulate minus_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq p m) -> (__1 : Leq m n) -> Eq (plus p (minus n m)) (minus n (minus m p))
postulate max_spec_to_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : max_spec n f m) -> Eq (max n f) m
postulate ACop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895
postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891
postulate nat_case : (n : Nat) -> (P : (_ : Nat) -> Prop) -> (_ : (_ : Eq n 0) -> P 0) -> (__1 : (m : Nat) -> (__1 : Eq n (plus m 1)) -> P (plus m 1)) -> P n
postulate append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate lstar_ltransitive : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> cic.Term cic.prop (matita_arithmetics_lstar.ltransitive B (matita_arithmetics_lstar.lstar B R))
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1600 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m
postulate plus_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))
postulate times_Sn_m : (n : Nat) -> (m : Nat) -> Eq (plus m (times n m)) (times (plus n 1) m)
postulate nill : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a
postulate match_eq : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) -> (case_refl : cic.Term return_sort (return_type _x (matita_basics_logic.refl A _x))) -> (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type __ z)
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate pair_destruct_1 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> (c : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c))
postulate let_clause_1033 : (n : Nat) -> (le_n : Leq (pow 2 4) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Dop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957
postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate prod_body : (A : Set) -> (nil : A) -> (_xxx : Dop A nil) -> (_x_969 : A) -> (_x_970 : A) -> A
postulate times_mod : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (mod (times a c) (times b c)) (times c (mod a b))
postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i
postulate dividesb_true_to_lt_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible m n) -> Lt 0 m
postulate let_clause_15611 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S (matita_arithmetics_nat.times p b)))))) -> (H : matita_basics_logic.eq (c
postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)
postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (plus n i)
postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)
postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate eq_log_exp : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> Eq (log p (pow p n)) n
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate lt_or_ge : (m : Nat) -> (n : Nat) -> or (Lt m n) (Leq n m)
postulate primeb_false_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))
postulate Aop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865
postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_867)
postulate Dop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1746 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1747 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate filter_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)
postulate DPair_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_654)
postulate Bk : (_n : Nat) -> Nat
postulate divides_gcd_mod : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> divisible (gcd m n) (gcd n (mod m n))
postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (plus l 1) b1 b2
postulate Dop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1740 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1741 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate sameF_p_le : (A : Set) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_p m p A f g) -> sameF_p n p A f g
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate let_clause_1575 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m
postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))
postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0
postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (plus n i)
postulate range_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_933)
postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true
postulate eq_to_bijn : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Leq i n) -> Eq (f i) (g i)) -> (__1 : bijn f n) -> bijn g n
postulate Dop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959
postulate le_B_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))
postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905
postulate f2_ind : (A1 : Set) -> (A2 : Set) -> (f : (_ : A1) -> (__1 : A2) -> Nat) -> (P : relation2 A1 A2) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (_ : Lt (f a1 a2) n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> (__1 : Eq (f a1 a2) n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> P a1 a2
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate p_ord_aux_to_not_mod_O : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 m) -> (__1 : Lt 0 n) -> (__2 : Leq n p) -> (__3 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> not (Eq (mod r m) 0)
postulate div_mod_spec_rect_Type0 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_833 : div_mod_spec _n _m _q _r) -> Set) -> (_H_div_mod_spec_intro : (x_835 : Lt _r _m) -> (x_834 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_835 x_834)) -> (x_833 : div_mod_spec _n _m _q _r) -> Q_ x_833
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1532 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m 0
postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\ b : B -> lstar B R l b1 b) (\ b : B -> R b b2)
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\ x : Nat -> x) (\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)
postulate nat_rect_Type2 : (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) -> (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type2 (Q_ x_381)
postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n1 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate noLabel_14 : all Int (\ n -> if (even n) (odd (neg (minus (times 5 n) 3))))
postulate match_max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort) -> (case_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))) -> (case_not_found_max_spec : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.not_found_max_spec _n _f m __))) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.match_max_spec _n _f m __))
postulate Aop_rect_Type0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate DPair_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_654)
postulate R1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)
postulate nat_inv_rect_Type4 : (Hterm : Nat) -> (P : (_z659 : Nat) -> Type4) -> (_H1 : (_z660 : Eq Hterm 0) -> P 0) -> (_H2 : (x_370 : Nat) -> (_x_372 : (_z660 : Eq Hterm x_370) -> P x_370) -> (_z660 : Eq Hterm (plus x_370 1)) -> P (plus x_370 1)) -> P Hterm
postulate minus_Sn_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n))
postulate nat_inv_rect_CProp3 : (Hterm : Nat) -> (P : (_z695 : Nat) -> Prop) -> (_H1 : (_z696 : Eq Hterm 0) -> P 0) -> (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Eq Hterm x_402) -> P x_402) -> (_z696 : Eq Hterm (plus x_402 1)) -> P (plus x_402 1)) -> P Hterm
postulate Aop_ind_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_781)
postulate Sig_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1222 : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> (hd : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> (Hind : (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : (x : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) x tl)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A x) n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A a) n)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 (matita_basics_lists_list.append A a (matita_basics_lists_list.list (matita_basics_lists_list.list A) tl)))) n)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n)) -> cic.Term
postulate noLabel_14 : all Int (\ n -> if (even n) (odd (neg (minus (times 5 n) 3))))
postulate Dop_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)
postulate le_n_fact_n : (n : Nat) -> Leq n (factorial n)
postulate Dop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_955 : Dop A _nil) -> Set) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_955 : Dop A _nil) -> Q_ x_955
postulate find : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option B)
postulate range_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1680 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1681 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate Prod_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1258 : (b : Nat) -> (lt1b : Lt 1 b) -> (n : Nat) -> (H : Eq (times (pow b n) b) 1) -> Eq (times b (pow b n)) 1
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate option_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1056 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type2) -> (_H1 : (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type2 (P (matita_basics_types.None x1))) -> (_H2 : (x_603 : cic.Term univs.Type0 x1) -> (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P Hterm)
postulate match_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> (case_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus (plus b 1) a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f (succ i0)) (plus i a))) (f a))
postulate lstar_inv_step : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) -> cic.Term cic.prop (R b1 b2)
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate match_nat : (return_sort : Sort) -> (return_type : (z : Nat) -> return_sort) -> (case_O : return_type 0) -> (case_S : (_ : Nat) -> return_type (plus __ 1)) -> (z : Nat) -> return_type z
postulate Aop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_805 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_805 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_805)
postulate Sum_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_556)
postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)
postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0
postulate let_clause_1532 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m 0
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate not_bertrand_to_le_B : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (B (times 2 n)) (times (pow 2 (times 2 (div (times 2 n) 3))) (pow (times 2 n) (pred (div (sqrt (times 2 n)) 2))))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Sum_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2) -> (_H_inl : (x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> (_H_inr : (x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> (x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type2 (Q_ x_541)
postulate cr_pair5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate Dop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate lt_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : ex Nat (\ i : Nat -> and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true))) -> Lt (min n b f) (plus n b)
postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))
postulate lt_O_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_ord.ord_rem n p))
postulate Dop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_963)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate div_mod_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)
postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m
postulate div_mod_spec_inv_rect_Type3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1446 : div_mod_spec x1 x2 x3 x4) -> Type3) -> (_H1 : (x_823 : Lt x4 x2) -> (x_822 : Eq x1 (plus (times x3 x2) x4)) -> (_z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm
postulate nat_elim2 : (R : (_ : Nat) -> (__1 : Nat) -> Prop) -> (_ : (n : Nat) -> R 0 n) -> (__1 : (n : Nat) -> R (plus n 1) 0) -> (__2 : (n : Nat) -> (m : Nat) -> (__2 : R n m) -> R (plus n 1) (plus m 1)) -> (n : Nat) -> (m : Nat) -> R n m
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0
postulate match_max_spec : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : max_spec _n _f __) -> return_sort) -> (case_found_max_spec : (m : Nat) -> (_ : Lt m _n) -> (__1 : Eq (_f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i _n) -> Eq (_f i) false) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> (case_not_found_max_spec : (_ : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> return_type 0 (not_found_max_spec _n _f __)) -> (_ : Nat) -> (z : max_spec _n _f __) -> return_type __ z
postulate Type5 : cic.Sort
postulate range_rect_Type1_body : (_A : Set) -> (Q_ : (_x_925 : range _A) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925
postulate injn_Sn_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)
postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (op B nil op (bigop k1 (\ i : Nat -> p1 i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k2 (\ i : Nat -> p2 i) B nil (op B nil op) (\ i : Nat -> g i))) (bigop (plus k1 k2) (\ i : Nat -> match_bool Set (\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\ i : Nat -> match_bool Set (\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i)))
postulate lt_1_max_prime : (n : Nat) -> (_ : Lt 1 n) -> Lt 1 (max (plus n 1) (\ i : Nat -> andb (primeb i) (dividesb i n)))
postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0
postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm
postulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate not_found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> min_spec n b f (plus n b)
postulate div_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))
postulate ACop_ind_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_889)
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m
postulate not_le_to_not_le_S_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))
postulate lt_1_max_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i n))))
postulate null : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate div_mod_spec_rect_CProp0_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857
postulate le_inv_S1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S x) y)) -> cic.Term cic.prop (matita_basics_logic.ex2 matita_arithmetics_nat.nat (\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.le x z) (\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y (matita_arithmetics_nat.S z)))
postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\ p : Nat -> transpose i j (f p)) n
postulate bool_rect_Type0_body : (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) -> (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ x_344)
postulate noLabel_1 : (x : Real) -> if (Lt x 0) (Gt (plus (pow x 2) 1) 0)
postulate ACop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate snd_eq : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b)
postulate nat_rect_CProp1_body : (Q_ : (_x_409 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_410 : Nat) -> (_x_412 : Q_ x_410) -> Q_ (plus x_410 1)) -> (x_409 : Nat) -> Q_ x_409
postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (__1 : Eq (plus l0 1) l) -> ex2 B (\ b : B -> R b1 b) (\ b : B -> lstar B R l0 b b2)
postulate Sum_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) -> (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) -> (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_556)
postulate bool_rect_Type3_body : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0
postulate unit_rect_CProp3 : (Q_ : (_x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_513)
postulate exp_n_O : (n : Nat) -> (_ : Lt 0 n) -> Eq (pow 0 n) 0
postulate p_ord : (_n : Nat) -> (_m : Nat) -> Prod Nat Nat
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)
postulate Aop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm)
postulate div_mod_spec_rect_Type2 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825
postulate divides_exp_to_eq : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : prime q) -> (__2 : divisible p (pow q m)) -> Eq p q
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_previous_prime5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat
postulate nat_inv_rect_CProp3 : (Hterm : Nat) -> (P : (_z695 : Nat) -> Prop) -> (_H1 : (_z696 : Eq Hterm 0) -> P 0) -> (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Eq Hterm x_402) -> P x_402) -> (_z696 : Eq Hterm (plus x_402 1)) -> P (plus x_402 1)) -> P Hterm
postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3
postulate eq_rect_CProp3_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)
postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))
postulate option_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type4) -> (_H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_591 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> (x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type4 (Q_ x_590)
postulate nat_rect_CProp1_body : (Q_ : (_x_409 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_410 : Nat) -> (_x_412 : Q_ x_410) -> Q_ (plus x_410 1)) -> (x_409 : Nat) -> Q_ x_409
postulate match_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (case_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)
postulate range_rect_Type4_body : (_A : Set) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_917 : range _A) -> Q_ x_917
postulate div_mod_spec_rect_Type3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) -> (_H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> (x_821 : div_mod_spec _n _m _q _r) -> Q_ x_821
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)
postulate ACop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_893 : ACop A _nil) -> Type5) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_893 : ACop A _nil) -> Q_ x_893
postulate lt_log_n_n : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_log.log p n) n)
postulate divides_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> divisible (ord_rem n p) n
postulate eq_rect_Type1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) -> (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_16 : cic.Term univs.Type2 A) -> (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Term univs.Type1 (Q_ x_16 x_17)
postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate divides_to_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p)))
postulate Aop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_789)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate div_times : (a : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> Eq (div (times a b) b) a
postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate sameF_upto_le : (A : Set) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_upto m A f g) -> sameF_upto n A f g
postulate lt_smallest_factor_to_not_divides : (n : Nat) -> (i : Nat) -> (_ : Lt 1 n) -> (__1 : Lt 1 i) -> (__2 : Lt i (smallest_factor n)) -> not (divisible i n)
postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n
postulate Dop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)
postulate not_found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (_ : (i : Nat) -> (_ : Lt i n) -> Eq (f i) false) -> max_spec n f 0
postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate ACop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903
postulate let_clause_1692 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))
postulate exists_forall_lt : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate Aop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_877 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_877 : Aop A _nil) -> Q_ x_877
postulate div_mod_spec_rect_CProp5_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate div_mod_spec_rect_CProp5_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate eq_div_div_div_times : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div q (times n m))
postulate min_prim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (\ __ : cic.Term cic.prop (matita_arithmetics_primes.prime q) -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (\ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p) -> matita_arithmetics_nat.le q n))))))
postulate div_mod_spec_rect_Type3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) -> (_H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> (x_821 : div_mod_spec _n _m _q _r) -> Q_ x_821
postulate nat_rect_CProp4 : (Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : cic.Term cic.prop (Q_ x_394)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) -> (x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_393)
postulate minus_pred_pred : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (minus (pred n) (pred m)) (minus n m)
postulate range_rect_CProp2 : (_A : Set) -> (Q_ : (_x_935 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_935 : range _A) -> Q_ x_935
postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate lt_exp_to_lt1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n a) (matita_arithmetics_exp.exp m a))) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)
postulate list_divides_true : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) true) -> ex Nat (\ p : Nat -> and (mem Nat p l) (divisible p n))
postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0
postulate div_mod_spec_rect_Type5 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate eq_prim_prim_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate lt_exp_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> Lt n (pow p (plus (log p n) 1))
postulate p_ord_aux_to_not_mod_O : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O))
postulate range_rect_CProp0_body : (_A : Set) -> (Q_ : (_x_939 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_939 : range _A) -> Q_ x_939
postulate iff_trans : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) -> cic.Term cic.prop (matita_basics_logic.iff A C)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate sameF_upto_le : (A : Set) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_upto m A f g) -> sameF_upto n A f g
postulate tech : (n : Nat) -> (_ : Leq (times 2 (plus (log 2 (times 2 n)) 1)) (sqrt (times 2 n))) -> Leq (times (div (sqrt (times 2 n)) 2) (plus (log 2 (times 2 n)) 1)) (div (times 2 n) 4)
postulate sameF_upto_le : (A : Set) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_upto m A f g) -> sameF_upto n A f g
postulate exp_exp_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))
postulate max_to_max_spec : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> max_spec n f m
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate Dop_rect_CProp1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965
postulate lt_1_max_prime : (n : Nat) -> (_ : Lt 1 n) -> Lt 1 (max (plus n 1) (\ i : Nat -> andb (primeb i) (dividesb i n)))
postulate le_minl : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq i (min n m)) -> Leq i n
postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\ _ : Aop a1 a2 -> univ Type2) (\ t0 : ((_ : a1) -> (__1 : a1) -> a1) -> \ t1 : ((a : a1) -> Eq (t0 a2 a) a) -> \ t2 : ((a : a1) -> Eq (t0 a a2) a) -> \ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) -> match_Aop a1 a2 (plus Type2 1) (\ _ : Aop a1 a2 -> univ Type2) (\ u0 : ((_ : a1) -> (__1 : a1) -> a1) -> \ u1 : ((a : a1) -> Eq (u0 a2 a) a) -> \ u2 : ((a : a1) -> Eq (u0 a a2) a) -> \ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0) u0) (\ e0 : Eq (R0 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t0 (\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \ _x_
postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)
postulate eq_rect_Type2_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type2 (P x p)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate div_theta_theta : (m : Nat) -> Eq (div (theta (plus (times 2 m) 1)) (theta (plus m 1))) (bigop (plus (times 2 m) 2) (\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\ p : Nat -> p))
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Aop_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_801)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate not_found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (_ : (i : Nat) -> (_ : Lt i n) -> Eq (f i) false) -> max_spec n f 0
postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate nat_inv_rect_CProp0 : (Hterm : Nat) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_previous_prime6 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> (x : Nat) -> Nat
postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)
postulate lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_relations.relation B)
postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (__1 : Eq (plus l0 1) l) -> ex2 B (\ b : B -> R b1 b) (\ b : B -> lstar B R l0 b b2)
postulate lt_plus_to_lt_l : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (plus p n) (plus q n)) -> Lt p q
postulate divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux p m n) n)
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_mod : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p m) -> (__2 : divisible p n) -> divisible p (mod m n)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate le_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 4) n) -> Leq (log 2 n) (sqrt n)
postulate Sig_rect_Type4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type4) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type4 (Q_ x_666)
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)
postulate Aop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865
postulate lstar_Conf3 : (A : Set) -> (B : Set) -> (succ : relation2 A B) -> (R : relation A) -> (_ : Conf3 A B succ R) -> (l : Nat) -> Conf3 A B succ (lstar A R l)
postulate congruent_times : (n : Nat) -> (m : Nat) -> (n1 : Nat) -> (m1 : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : congruent n n1 p) -> (__2 : congruent m m1 p) -> congruent (times n m) (times n1 m1) p
postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (q : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)
postulate filter_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)
postulate primes_below_to_bertrand : (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) -> (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ pp : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)
postulate plus_le_0 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O))
postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))
postulate mk_Aop : (A : Set) -> (nil : A) -> (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op nil a) a) -> (_nilr : (a : A) -> Eq (op a nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Aop A nil
postulate let_clause_16005 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate le_Psi_BPsi1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))
postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_to_div_mod_spec : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> div_mod_spec m n (div m n) 0
postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate log_SO : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) matita_arithmetics_nat.O)
postulate le_log_n_n : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> Leq (log p n) n
postulate times_div_le : (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (_ : Lt 0 b) -> (__1 : Lt 0 d) -> Leq (times (div a b) (div c d)) (div (times a c) (times b d))
postulate distr_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> (b : A) -> (c : A) -> Eq (prod A nil xxx a (aop__o__op A nil (sum A nil xxx) b c)) (aop__o__op A nil (sum A nil xxx) (prod A nil xxx a b) (prod A nil xxx a c))
postulate lt_O_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt 0 (ord_rem n p)
postulate le_exp_primr : (n : Nat) -> Leq (pow n (prim n)) (pow 2 (times 2 (minus (times 2 n) 3)))
postulate B2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate ACop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type5 (Q_ x_893)
postulate divides_exp_to_eq : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : prime q) -> (__2 : divisible p (pow q m)) -> Eq p q
postulate pi_p_primeb1 : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> dividesb (pow p (plus i 1)) n) Nat 1 times (\ i : Nat -> p)))
postulate Sig_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f (plus n 1)) -> (__1 : Eq (f (plus n 1)) (plus n 1)) -> bijn f n
postulate divides_ind_body : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192
postulate le_S_S : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Leq (plus n 1) (plus m 1)
postulate max_spec_to_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : max_spec n f m) -> Eq (max n f) m
postulate range_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_939)
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate refl : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> cic.Term cic.prop (matita_basics_logic.eq A x x)
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate lt_O_to_le_theta_exp_theta : (m : Nat) -> (_ : Lt 0 m) -> Lt (theta (plus (times 2 m) 1)) (times (pow 2 (times 2 m)) (theta (plus m 1)))
postulate log_times_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)))
postulate le_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq n m) -> Leq (pow p n) (pow p m)
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate plus_n_O : (n : Nat) -> Eq n (plus n 0)
postulate eq_Psi_Psi' : (n : Nat) -> Eq (Psi n) (Psi' n)
postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (minus (times 2 n) 3))
postulate list_divides_body : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate lstar_inv_S : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> (l0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S matita_arithmetics_nat.O)) l)) -> cic.Term cic.prop (matita_basics_logic.ex2 B (\ b : cic.Term univs.Type0 B -> R b1 b) (\ b : cic.Term univs.Type0 B -> matita_arithmetics_lstar.lstar B R l0 b b2))
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_m1 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_x_365 : Nat) -> (b : Nat) -> Nat
postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus _n _b))) -> (x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f (matita_arithmetics_nat.plus _n _b))) -> cic.Term cic.prop (Q_ _n)
postulate Dop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)
postulate unit_ind_body : (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_495)
postulate let_upper_bound6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate sameF_p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\ __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> A)))
postulate Aop_ind_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_861 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_861 : Aop A _nil) -> Q_ x_861
postulate times_mod : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (mod (times a c) (times b c)) (times c (mod a b))
postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)
postulate le_times_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Leq (times a n) (times a m)) -> Leq n m
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate comm : (A : Set) -> (nil : A) -> (xxx : ACop A nil) -> (a : A) -> (b : A) -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a)
postulate m : Nat -> Nat -> Nat
postulate nat_inv_rect_Type4 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z659 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type4) -> (_H1 : (_z660 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type4 (P matita_arithmetics_nat.O)) -> (_H2 : (x_370 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_372 : (_z660 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_370)) -> cic.Term univs.Type4 (P x_370)) -> (_z660 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_370))) -> cic.Term univs.Type4 (P (matita_arithmetics_nat.S x_370))) -> cic.Term univs.Type4 (P Hterm)
postulate Aop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate log_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))
postulate let_upper_bound7 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate not_le_to_lt : (n : Nat) -> (m : Nat) -> (_ : not (Leq n m)) -> Lt m n
postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1531 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (eqm : Eq m (times n 0)) -> Eq m 0
postulate nat_rect_Type0_body : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)
postulate f2_ind_aux : (A1 : cic.Univ univs.Type0) -> (A2 : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)
postulate permut_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> (__1 : permut g n) -> permut (\ m : Nat -> f (g m)) n
postulate Sum_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 a1 -> matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 a1 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\ _e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> P)) (\ _z33 : ((_e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0)) -> cic.Term univs.Type1 P) -> P))) (\ u0 : cic.Term univs.Type0 a2 -> cic.prod (cic
postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\ b -> even (plus (times a b) (times b c)))
postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m
postulate f_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : permut f n) -> Eq (f (invert_permut n f m)) m
postulate le_times_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Leq (times a n) (times a m)) -> Leq n m
postulate prime_nth_prime : (n : Nat) -> prime (nth_prime n)
postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate divides_div : (d : Nat) -> (n : Nat) -> (_ : divisible d n) -> divisible (div n d) n
postulate True_rect_CProp3_body : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)
postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)
postulate le_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> (__1 : Leq a (minus b c)) -> Leq (plus a c) b
postulate op_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (_x_807 : cic.Term univs.Type0 A) -> (_x_808 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A
postulate eq_div_div_div_times : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div q (times n m))
postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)
postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate nat_inv_rect_Type2 : (Hterm : Nat) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm
postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Eq (mod n m) 0) -> (__1 : Eq (p_ord_aux p (div n m) m) (mk_Prod Nat Nat q r)) -> Eq (p_ord_aux (plus p 1) n m) (mk_Prod Nat Nat (plus q 1) r)
postulate smallest_factor_to_prime : (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (smallest_factor n) n) -> prime n
postulate nth : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Univ univs.Type0) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H
postulate div_mod_spec_rect_CProp1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853
postulate le_plus_to_le_r : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus n a) (plus m a)) -> Leq n m
postulate match_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_min _n _b _f __ m __1 __2 __3))) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.not_found_min _n _b _f __ m __1 __2 __3))
postulate Not_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P Hterm)
postulate nill_body : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a
postulate le_plus_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus a n) (plus a m)) -> Leq n m
postulate exp_sigma_l : (n : Nat) -> (a : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> pow a (f i))) (pow a (bigop n (\ i : Nat -> p i) Nat 0 plus (\ i : Nat -> f i)))
postulate Aop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_871)
postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m
postulate eq_gcd_SO_to_not_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (gcd n m) 1) -> not (divisible n m)
postulate divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (times n m)) -> or (divisible p n) (divisible p m)
postulate prime_to_lt_SO : (p : Nat) -> (_ : prime p) -> Lt 1 p
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) b) a)
postulate pi_p_primeb : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> pow p (ord n p)))
postulate not_eq_to_eqb_false : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> Eq (eqb n m) false
postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))
postulate f_false_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p)
postulate list_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_753 : cic.Term univs.Type0 _A) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_755 : cic.Term cic.prop (Q_ x_752)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_753 x_752))) -> (x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_751)
postulate Sum_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (x_547 : cic.Term univs.Type0 x1) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547))) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) -> (_H2 : (x_548 : cic.Term univs.Type0 x2) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P Hterm)
postulate Dop_rect_CProp2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963
postulate Bk_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_bertrand.k n p))))
postulate ACop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1566 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1567 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1
postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)
postulate congruent_n_mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> congruent n (mod n (times m p)) p
postulate range_rect_Type4 : (_A : Set) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_917 : range _A) -> Q_ x_917
postulate lt_O_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq p n) -> Lt 0 (log p n)
postulate not_divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))
postulate ACop_discr : (a1 : Set) -> (a2 : a1) -> (x : ACop a1 a2) -> (y : ACop a1 a2) -> (_e : Eq x y) -> match_ACop a1 a2 (plus Type2 1) (\ _ : ACop a1 a2 -> univ Type2) (\ t0 : Aop a1 a2 -> \ t1 : ((a : a1) -> (b : a1) -> Eq (op a1 a2 t0 a b) (op a1 a2 t0 b a)) -> match_ACop a1 a2 (plus Type2 1) (\ _ : ACop a1 a2 -> univ Type2) (\ u0 : Aop a1 a2 -> \ u1 : ((a : a1) -> (b : a1) -> Eq (op a1 a2 u0 a b) (op a1 a2 u0 b a)) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Aop a1 a2) t0) u0) (\ e0 : Eq (R0 (Aop a1 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Aop a1 a2) t0 (\ x_19 : Aop a1 a2 -> \ _x_20 : Eq t0 x_19 -> (\ x0 : Aop a1 a2 -> \ p0 : Eq t0 x0 -> prod Set Prop a1 (\ a : a1 -> prod Set Prop a1 (\ b : a1 -> Eq (op a1 a2 x0 a b) (op a1 a2 x0 b a)))) x_19 _x_20) t1 u0 e0) u1) (\ _e1 : Eq (R1 (Aop a1 a2) t0 (\ x_19 : Aop a1 a2 -> \ _x_20 : Eq t0 x_19 -> (\ x0 : Aop a1 a2 -> \ p0 : Eq t0 x0 -> prod Set Prop a1 (\ a : a1 -> prod Set Prop a1 (\ b : a1 ->
postulate injective_to_injn : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : injective Nat Nat f) -> injn f n
postulate False_rect_Type5_body : (Q_ : (_x_68 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type5) -> (x_68 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ x_68)
postulate eq_prim_prim_pred : (n : Nat) -> (_ : Lt 1 n) -> Eq (prim (times 2 n)) (prim (pred (times 2 n)))
postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Aop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1374 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1375 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)
postulate range_rect_Type0_body : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927
postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))
postulate ACop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)
postulate option_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)
postulate bceq : (n : Nat) -> (k : Nat) -> Eq (bc n k) (div (factorial n) (times (factorial k) (factorial (minus n k))))
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_mod_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_div_and_mod.mod m n))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides p m)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (__1 : Leq i n) -> not (divisible i (plus (factorial n) 1))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate ord_rem : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (_ : Nat) -> bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> (_ : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 0) -> P 0) -> P x3
postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true
postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div (div q m) n)
postulate lt_div_to_times : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Lt (div n q) m) -> Lt n (times q m)
postulate congruent_ab : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\ x : Nat -> and (congruent x a m) (congruent x b n))
postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate range_rect_CProp4_body : (_A : Set) -> (Q_ : (_x_929 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_929 : range _A) -> Q_ x_929
postulate lt_1_max_prime : (n : Nat) -> (_ : Lt 1 n) -> Lt 1 (max (plus n 1) (\ i : Nat -> andb (primeb i) (dividesb i n)))
postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (_ : Nat) -> bool) -> (p12 : (_ : Nat) -> (__1 : Nat) -> bool) -> (p21 : (_ : Nat) -> bool) -> (p22 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\ i : Nat -> bigop m (\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\ j : Nat -> f i j))) (bigop m (\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\ j : Nat -> bigop n (\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\ i : Nat -> f i j)))
postulate nat_elim2 : (R : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R matita_arithmetics_nat.O n)) -> (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)) -> (__2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (R n m)) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R n m)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate True_inv_rect_CProp3 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z167 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)
postulate let_clause_16 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S m))) -> (x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O)))
postulate lstar_r_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1)) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 x1) -> (x5 : cic.Term univs.Type0 x1) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r x1 x2 x3 x4 x5)) -> (P : (_z2386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_z2385 : cic.Term univs.Type0 x1) -> (_z2384 : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (_H1 : (b : cic.Term univs.Type0 x1) -> (_z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> (_z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b)) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)) -> (_H2 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 (matita_arithmetics_nat.plus l matita_arithmetics_nat.O))) -> (Hterm0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b1)) -> (Hterm1 : cic.Term cic.prop (matita
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate Prod_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type1) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type1 (Q_ x_700)
postulate ACop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1614 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1615 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)
postulate range_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1680 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1681 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate inv_eq_minus_O : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)
postulate lstar_lstar_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)
postulate bc_n_n : (n : Nat) -> Eq (bc n n) 1
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate mk_Prod : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_fst : cic.Term univs.Type0 A) -> (_snd : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod A B)
postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2
postulate divides_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (Hterm : divisible x1 x2) -> (P : (_z2006 : divisible x1 x2) -> Prop) -> (_H1 : (q : Nat) -> (x_1193 : Eq x2 (times x1 q)) -> (_z2007 : Eq Hterm (quotient x1 x2 q x_1193)) -> P (quotient x1 x2 q x_1193)) -> P Hterm
postulate lt_1_to_le_exp_B : (n : Nat) -> (_ : Lt 1 n) -> Leq (pow 2 (times 2 n)) (times (times 2 n) (B (times 2 n)))
postulate eq_to_eqb_true : (n : Nat) -> (m : Nat) -> (_ : Eq n m) -> Eq (eqb n m) true
postulate let_clause_1572 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m 0
postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate make_list_body : (A : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)
postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n p) -> (__4 : divisible d (times c m)) -> (__5 : divisible d (times c n)) -> divisible d (times c (gcd_aux p m n))
postulate let_clause_1531 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (eqm : Eq m (times n 0)) -> Eq m 0
postulate Aop_rect_Type0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate nilr_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a nil) a)
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate True_rect_CProp0_body : (Q_ : (_x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_64)
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate lt_O_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n))
postulate range_rect_CProp5 : (_A : Set) -> (Q_ : (_x_931 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931
postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1
postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)
postulate monotonic_div : (n : Nat) -> (_ : Lt 0 n) -> monotonic Nat Leq (\ m : Nat -> div m n)
postulate match_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate range_rect_Type3_body : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921
postulate pi_p_primeb : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> pow p (ord n p)))
postulate le_min_r : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate void_rect_CProp1 : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)
postulate noLabel_68 : (n : Int) -> if (odd (minus (times 3 n) 8)) (odd n)
postulate Dop_rect_Type1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953
postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p
postulate div_mod_spec_inv_rect_CProp0 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1494 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1495 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_859 x_858))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_859 x_858))) -> cic.Term cic.prop (P Hterm)
postulate mk_range : (A : Set) -> (_enum : (_ : Nat) -> A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> range A
postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825
postulate f_ind_aux : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)
postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (dividesb d n) true) -> Eq (dividesb (div n d) n) true
postulate eq_rect_CProp5 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)
postulate f_min_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : ex Nat (\ i : Nat -> and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true))) -> Eq (f (min n b f)) true
postulate lt_plus_to_lt_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus n q))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)
postulate exp_Sn : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp b (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times b (matita_arithmetics_exp.exp b n)))
postulate le_B_Psi4 : (n : Nat) -> (_ : Lt 0 n) -> Leq (times 2 (B (times 4 n))) (Psi (times 4 n))
postulate match_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (case_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)
postulate nat_elim1 : (n : Nat) -> (P : (_ : Nat) -> Prop) -> (_ : (m : Nat) -> (_ : (p : Nat) -> (_ : Lt p m) -> P p) -> P m) -> P n
postulate Aop_inv_rect_CProp0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1560 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate permut_to_bijn : (n : Nat) -> (f : (_ : Nat) -> Nat) -> (_ : permut f n) -> bijn f n
postulate match_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) -> (case_found_min_spec : (m : Nat) -> (_ : Leq _b m) -> (__1 : Lt m (plus _n _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> (case_not_found_min_spec : (_ : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> (_ : Nat) -> (z : min_spec _n _b _f __) -> return_type __ z
postulate Sig_rect_Type5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type5) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type5 (Q_ x_668)
postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> (__1 : Lt m (nth_prime (plus n 1))) -> not (prime m)
postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate leb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Leq n m) -> P true) -> (__1 : (__1 : not (Leq n m)) -> P false) -> P (leb n m)
postulate let_clause_1531 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (eqm : Eq m (times n 0)) -> Eq m 0
postulate R4 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T1) a1))) -> cic.Univ univs.Type0
postulate filter_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)
postulate p_ord_aux_false : (p : Nat) -> (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Eq (mod n m) (plus a 1)) -> Eq (p_ord_aux p n m) (mk_Prod Nat Nat 0 n)
postulate Sum_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1) -> (_H_inl : (x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))) -> (_H_inr : (x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))) -> (x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type1 (Q_ x_546)
postulate eq_mod_to_divides : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Eq (mod n q) (mod m q)) -> divisible q (minus n m)
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate mk_range : (A : Set) -> (_enum : (_ : Nat) -> A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> range A
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate example4 : Eq (primeb 3) true
postulate eq_plus_to_le : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Eq n (plus m p)) -> Leq m n
postulate nat_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z671 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H1 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type2 (P matita_arithmetics_nat.O)) -> (_H2 : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_382)) -> cic.Term univs.Type2 (P x_382)) -> (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P Hterm)
postulate mem_single : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b)
postulate lt_sigma_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt n 0)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n (matita_arithmetics_nat.times (matita_arithmetics_nat.div n 2) 2)) 0)
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate match_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) -> (case_found_min_spec : (m : Nat) -> (_ : Leq _b m) -> (__1 : Lt m (plus _n _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> (case_not_found_min_spec : (_ : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> (_ : Nat) -> (z : min_spec _n _b _f __) -> return_type __ z
postulate Aop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_869 : Aop A _nil) -> Type2) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_869 : Aop A _nil) -> Q_ x_869
postulate Sig_rect_Type5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type5) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type5 (Q_ x_668)
postulate divides_to_div_mod_spec : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> div_mod_spec m n (div m n) 0
postulate div_mod_spec_inv_rect_CProp1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P Hterm)
postulate nat_rect_CProp0 : (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_413)
postulate let_clause_1009 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (Hfn : Eq (f n) false) -> (Hmax : Leq (max m f) n) -> (Hmax0 : Eq (max m f) n) -> (_clearme : and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i m) (\ _ : Lt i m -> Eq (f i) false))) (Eq (max m f) 0)) -> (auto : (i : Nat) -> (_ : Lt i m) -> Eq (f i) false) -> (auto' : Eq (max m f) 0) -> Eq 0 n
postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\ x : Nat -> p x) B nil (aop__o__op B nil op) (\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\ x : Nat -> f x)))
postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (plus (mod n m) 1) m) -> Eq (mod (plus n 1) m) (plus (mod n m) 1)
postulate ACop_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)
postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : Eq (checker l) true) -> (__1 : Eq l (cons Nat a tl)) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))
postulate le_times_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Leq (times a n) (times a m)) -> Leq n m
postulate fst_eq : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_types.fst A B (matita_basics_types.mk_Prod A B a b)) a)
postulate filter_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate decidable_mem_nat : (n : Nat) -> (l : list Nat) -> decidable (mem Nat n l)
postulate let_clause_16 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S m))) -> (x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O)))
postulate eq_minus_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux p m n)) (Eq (minus (times b m) (times a n)) (gcd_aux p m n))))
postulate distributive_times_plus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.plus b c) a) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times b a) (matita_arithmetics_nat.times c a)))
postulate p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (qa : Nat) -> (ra : Nat) -> (qb : Nat) -> (rb : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> (__3 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra)) -> (__4 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb)) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb))
postulate iter_body : (H : Set) -> (_ : (_ : H) -> H) -> (__1 : Nat) -> (__2 : H) -> H
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate nat_inv_rect_CProp3 : (Hterm : Nat) -> (P : (_z695 : Nat) -> Prop) -> (_H1 : (_z696 : Eq Hterm 0) -> P 0) -> (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Eq Hterm x_402) -> P x_402) -> (_z696 : Eq Hterm (plus x_402 1)) -> P (plus x_402 1)) -> P Hterm
postulate not_found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (_ : (i : Nat) -> (_ : Lt i n) -> Eq (f i) false) -> max_spec n f 0
postulate nat_ind : (Q_ : (_x_365 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_366 : Nat) -> (_x_368 : Q_ x_366) -> Q_ (plus x_366 1)) -> (x_365 : Nat) -> Q_ x_365
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)
postulate gcd_1_to_lt_O : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (gcd i n) 1) -> Lt 0 i
postulate Aop_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1428 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1429 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate ACop_rect_Type1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_899 : ACop A _nil) -> Type1) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_899 : ACop A _nil) -> Q_ x_899
postulate le_inv_S1 : (x : Nat) -> (y : Nat) -> (_ : Leq (plus x 1) y) -> ex2 Nat (\ z : Nat -> Leq x z) (\ z : Nat -> Eq y (plus z 1))
postulate divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 n) -> (__2 : divisible n m) -> Eq (gcd_aux p m n) n
postulate leq_sqrt_n : (n : Nat) -> Leq (times (sqrt n) (sqrt n)) n
postulate not_lt_to_le : (n : Nat) -> (m : Nat) -> (_ : not (Lt n m)) -> Leq m n
postulate times : (_ : Nat) -> (__1 : Nat) -> Nat
postulate filter_DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)
postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)
postulate eq_length_to_mem : (n : Nat) -> (l : list Nat) -> (_ : Eq (length Nat l) (plus n 1)) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Leq x n) -> mem Nat n l
postulate p_ord_aux_to_not_mod_O : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 m) -> (__1 : Lt 0 n) -> (__2 : Leq n p) -> (__3 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> not (Eq (mod r m) 0)
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m
postulate divides_to_mod_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (mod m n) 0
postulate Dop_ind_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_943)
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate plus_n_Sm : (n : Nat) -> (m : Nat) -> Eq (plus (plus n m) 1) (plus n (plus m 1))
postulate lt_O_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq p n) -> Lt 0 (log p n)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0
postulate noLabel_15 : all Int (\ n -> if (odd n) (odd (minus (plus (times 4 (pow n 3)) (times 2 n)) 1)))
postulate Sum_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Eq (mod n m) 0) -> (__1 : Eq (p_ord_aux p (div n m) m) (mk_Prod Nat Nat q r)) -> Eq (p_ord_aux (plus p 1) n m) (mk_Prod Nat Nat (plus q 1) r)
postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_873)
postulate Sig_rect_Type5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type5) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type5 (Q_ x_668)
postulate lstar_ind_l_aux : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (__3 : Eq b b2) -> P l b1
postulate Sig_rect_Type2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type2 (Q_ x_672)
postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))
postulate ACop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1566 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1567 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)
postulate False_rect_CProp5_body : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)
postulate divides_to_divides_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p q))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides q n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times p q) n)
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))
postulate list_cases2 : (T1 : cic.Univ univs.Type0) -> (T2 : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (P : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length T1 l1) (matita_basics_lists_list.length T2 l2))) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T1)) l1 (matita_basics_lists_list.nil T1))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T2)) l2 (matita_basics_lists_list.nil T2))) -> cic.Term cic.prop P) -> (__2 : (hd1 : cic.Term univs.Type0 T1) -> (hd2 : cic.Term univs.Type0 T2) -> (tl1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (tl2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T1)) l1 (matita_basics_lists_list.cons T1 hd1 tl1))) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T2)) l2 (matita_basics_lists_list.cons T2 hd2 tl2))) -> cic.Term cic.prop P) -> cic.Term cic.prop P
postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)
postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1))
postulate And_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_156 : cic.Term cic.prop x1) -> (x_155 : cic.Term cic.prop x2) -> (_z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm)
postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))
postulate not_bertrand_to_le_B : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (B (times 2 n)) (times (pow 2 (times 2 (div (times 2 n) 3))) (pow (times 2 n) (pred (div (sqrt (times 2 n)) 2))))
postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1
postulate pi1 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term univs.Type0 A
postulate lt_to_le_times_to_lt_S_to_div : (a : Nat) -> (c : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> (__1 : Leq (times b c) a) -> (__2 : Lt a (times b (plus c 1))) -> Eq (div a b) c
postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus (plus b 1) a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f (succ i0)) (plus i a))) (f a))
postulate bertrand_down : (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n (pow 2 8)) -> bertrand n
postulate le_S_times_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))
postulate transpose_i_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j i) j)
postulate congruent_to_divides : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : congruent n m p) -> divisible p (minus n m)
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate DPair_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type3 (Q_ x_644)
postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n
postulate let_clause_1033 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate f_ind_aux : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate noLabel_21 : (n : Int) -> if (Gt (minus 1 (pow n 2)) 0) (even (minus (times 3 n) 2))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate iff_or_r : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or A C) (matita_basics_logic.Or B C))
postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))
postulate filter_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)
postulate gcd_n_times_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Eq (gcd n (times n m)) n
postulate fact_pi_p : (n : Nat) -> Eq (factorial n) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (div n (pow p (plus i 1))))))
postulate True_rect_Type0 : (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) -> (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) -> (x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type0 (Q_ x_52)
postulate lt_or_ge : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt m n) (matita_arithmetics_nat.le n m))
postulate le_times_to_le_div2 : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Leq n (times m q)) -> Leq (div n q) m
postulate divides_minus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (minus p q)
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate Not_rect_CProp4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)
postulate tech_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq (log p n) (max (plus n 1) (\ x : Nat -> leb (pow p x) n))
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate invert_permut_body : (_ : Nat) -> (__1 : (__1 : Nat) -> Nat) -> (__2 : Nat) -> Nat
postulate divides_gcd_nm : (n : Nat) -> (m : Nat) -> and (divisible (gcd n m) m) (divisible (gcd n m) n)
postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool
postulate let_clause_1585 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)
postulate bool_rect_Type5 : (Q_ : (_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5) -> (_H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false)) -> (x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ x_332)
postulate lt_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Lt p q) -> Lt (plus n p) (plus m q)
postulate iter_iter : (A : Set) -> (g : (_ : A) -> A) -> (a : A) -> (b : Nat) -> (c : Nat) -> Eq (iter A g c (iter A g b a)) (iter A g (plus b c) a)
postulate lt_smallest_factor_to_not_divides : (n : Nat) -> (i : Nat) -> (_ : Lt 1 n) -> (__1 : Lt 1 i) -> (__2 : Lt i (smallest_factor n)) -> not (divisible i n)
postulate let_clause_16921 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate absurd : (A : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not A)) -> cic.Term cic.prop matita_basics_logic.False
postulate lt_to_not_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate upto_body : (A : Set) -> (_xxx : range A) -> Nat
postulate comm_body : (A : Set) -> (nil : A) -> (xxx : ACop A nil) -> (a : A) -> (b : A) -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a)
postulate DPair_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1164 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1165 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)
postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_16 : (n : Nat) -> (m : Nat) -> (auto : Lt (plus n 1) (plus m 1)) -> (x32 : Nat) -> Eq (plus x32 1) (plus x32 1)
postulate Aop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863
postulate iso : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))
postulate bigop_sumI : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le b c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i b)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arith
postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n
postulate pi2 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term cic.prop (f (matita_basics_types.pi1 A f xxx))
postulate lstar_O : (B : Set) -> (R : relation B) -> (b : B) -> lstar B R 0 b b
postulate let_clause_1531 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1544 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (lenm : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (lenS : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\ b : B -> lstar B R l b1 b) (\ b : B -> R b b2)
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393
postulate congruent_exp_pred_SO : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a))) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_exp.exp a (matita_arithmetics_nat.pred p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)
postulate lop_Sfalse : (m : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Eq (list_divides acc i) false) -> Eq (lprim (plus m 1) i acc) (lprim m (plus i 1) (append Nat acc (cons Nat i (nil Nat))))
postulate div_mod_spec_discr : (a1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (y : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\ t0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \ t1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a3 a2) a4)) -> matita_arithmetics_div_and_mod.match_div_mod_spec a1 a2 a3 a4 (cic.succ univs.Type2) (\ __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a1 a2 a3 a4) -> cic.univ univs.Type2) (\ u0 : cic.Term cic.prop (matita_arithmetics_nat.lt a4 a2) -> \ u1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a
postulate match_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) -> (case_found_min_spec : (m : Nat) -> (_ : Leq _b m) -> (__1 : Lt m (plus _n _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> (case_not_found_min_spec : (_ : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> (_ : Nat) -> (z : min_spec _n _b _f __) -> return_type __ z
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n
postulate DPair_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type5 (Q_ x_642)
postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n
postulate lt_to_log_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt m n) -> Eq (log n m) 0
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate True_inv_rect_CProp3 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z167 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)
postulate divides_fact_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) (matita_arithmetics_nat.le m n)) (matita_arithmetics_primes.divides p m)))
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)
postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\ x : Nat -> and (and (congruent x a m) (congruent x b n)) (Lt x (times m n)))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate nat_rect_Type0_body : (Q_ : (_x_389 : Nat) -> Set) -> (_H_O : Q_ 0) -> (_H_S : (x_390 : Nat) -> (_x_392 : Q_ x_390) -> Q_ (plus x_390 1)) -> (x_389 : Nat) -> Q_ x_389
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate max_spec : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (_ : Nat) -> Prop
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate same_bigop : (k : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\ i : Nat -> p1 i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p2 i) B nil op (\ i : Nat -> g i))
postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> (__1 : sub_hk h k A J I) -> (i : Nat) -> (__2 : Lt i (upto A J)) -> Eq (filter A J i) false
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate permut_transpose_l : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\ n : Nat -> transpose i j (f n)) m
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate not_divides_ord_rem : (m : Nat) -> (p : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 1 p) -> not (divisible p (ord_rem m p))
postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875
postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m
postulate let_clause_16004 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate Dop_rect_CProp3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961
postulate log_i_2n : (n : Nat) -> (i : Nat) -> (_ : Lt 1 n) -> (__1 : Lt n i) -> (__2 : Leq i (times 2 n)) -> Eq (log i (times 2 n)) 1
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate Aop_inv_rect_CProp0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1560 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate filter_unit : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)
postulate let_clause_73 : (x : Nat) -> (y : Nat) -> (z : Nat) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))
postulate le_Psi_exp : (n : Nat) -> Leq (Psi (times 2 n)) (times (pow 2 (pred (times 2 n))) (Psi n))
postulate le_n_8_to_le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))
postulate p_ord_to_not_eq_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime p)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r matita_arithmetics_nat.O))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate invert_permut_body : (_ : Nat) -> (__1 : (__1 : Nat) -> Nat) -> (__2 : Nat) -> Nat
postulate binomial_law : (a : Nat) -> (b : Nat) -> (n : Nat) -> Eq (pow (plus a b) n) (bigop (plus n 1) (\ k : Nat -> true) Nat 0 plus (\ k : Nat -> times (times (bc n k) (pow a (minus n k))) (pow b k)))
postulate f_ind_aux : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)
postulate filter_max_spec : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : max_spec _n _f __) -> return_sort) -> (return : (z : max_spec _n _f __) -> return_type z) -> (z : max_spec _n _f __) -> return_type z
postulate Univ : (s : Sort) -> Set
postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1))
postulate divides_to_mod_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (mod m n) 0
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate divides_gcd_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) m)
postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : Eq (checker l) true) -> (__1 : Eq l (cons Nat a tl)) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))
postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate divides_d_times_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd n m)))
postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\ p : Nat -> transpose i j (f p)) n
postulate Aop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885
postulate exp_plus_times : (n : Nat) -> (p : Nat) -> (q : Nat) -> Eq (pow n (plus p q)) (times (pow n p) (pow n q))
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate smallest_factor_to_prime : (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (smallest_factor n) n) -> prime n
postulate ACop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1608 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1609 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate p_ord_degenerate : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat p n))
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate minus_plus_plus_l : (x : Nat) -> (y : Nat) -> (h : Nat) -> Eq (minus (plus x h) (plus y h)) (minus x y)
postulate monotonic_lt_plus_l : (n : Nat) -> monotonic Nat Lt (\ m : Nat -> plus m n)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (f1 n1) (f2 (h n1))
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))
postulate minus_pred_pred : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (minus (pred n) (pred m)) (minus n m)
postulate transitive_divides : transitive Nat divisible
postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2
postulate le_sqrt_to_le_times_l : (m : Nat) -> (n : Nat) -> (_ : Leq n (sqrt m)) -> Leq (times n n) m
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate upto : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate let_clause_1692 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))
postulate plus : (_ : Nat) -> (__1 : Nat) -> Nat
postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m
postulate True_rect_CProp1_body : (Q_ : (_x_62 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_62 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_62)
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1
postulate div_mod_spec_inv_rect_CProp1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (plus (times x3 x2) x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm
postulate Not_rect_Type4 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4) -> (_H_nmk : (x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) -> (x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type4 (Q_ x_82)
postulate lstar_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar x1 x2 x3 x4 x5) -> (P : (_z2089 : Nat) -> (_z2088 : x1) -> (_z2087 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2092 : Eq x3 0) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b) -> P 0 b b) -> (_H2 : (b1 : x1) -> (b : x1) -> (_x_1236 : x2 b1 b) -> (l : Nat) -> (b2 : x1) -> (_x_1235 : lstar x1 x2 l b b2) -> (_x_1238 : (_z2092 : Eq x3 l) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b2) -> P l b b2) -> (_z2092 : Eq x3 (plus l 1)) -> (_z2091 : Eq x4 b1) -> (_z2090 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate list_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) -> (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type2 (Q_ x_736)
postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\ p : Nat -> transpose i j (f p)) n
postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (bigop n (\ i : Nat -> false) B nil op (\ i : Nat -> f i)) nil
postulate le_ord_log : (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 1 p) -> Leq (ord n p) (log p n)
postulate range_inv_rect_CProp4 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1668 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1669 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm
postulate mod_mod : (n : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod n p) (mod (mod n p) p)
postulate nat_rect_CProp0 : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413
postulate filter_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (return : (z : div_mod_spec _n _m _q _r) -> return_type z) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885
postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus (plus b 1) a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f (succ i0)) (plus i a))) (f a))
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (_clearme : ex Nat (\ a : Nat -> or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (_clearme0 : or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1))) -> (Hn : Eq n0 (plus (times 2 a) 1)) -> Eq n0 (plus a (plus a 1))
postulate minus_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus p (matita_arithmetics_nat.minus n m)) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.minus m p)))
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate lt_to_eq_mod : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (mod n m) n
postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div (div q m) n)
postulate let_clause_10331 : (p : Nat) -> (n : Nat) -> (n1 : Nat) -> (q : Nat) -> (p1 : Nat) -> (p2 : Nat) -> (qa : Nat) -> (ra : Nat) -> (H : Eq (p_ord_aux (plus n1 1) (plus n1 1) (plus p2 2)) (mk_Prod Nat Nat qa ra)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Sig_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_686)
postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (_ : Nat) -> bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> (_ : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 0) -> P 0) -> P x3
postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)
postulate prop100 : (a : Int) -> (b : Int) -> (c : Int) -> Eq (plus (plus a b) c) 0 -> Lt (times (times a b) c) 0
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate unit_rect_CProp5 : (Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_511)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n) (\ __1 : Lt i n -> P i)))) -> ex Nat (\ i : Nat -> and (Lt i n) (not (P i)))
postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)
postulate le_x_times_x : (x : Nat) -> Leq x (times x x)
postulate le_ind : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate prime_to_lt_O : (p : Nat) -> (_ : prime p) -> Lt 0 p
postulate pi_p_primeb_dividesb : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p n)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p))))
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate times_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times matita_arithmetics_nat.O n))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate not_found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> min_spec n b f (plus n b)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate le_n_fact_n : (n : Nat) -> Leq n (factorial n)
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0
postulate list_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1
postulate f2_ind_aux : (A1 : cic.Univ univs.Type0) -> (A2 : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)
postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1))
postulate Not_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z305 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_110 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z306 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_110))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_110))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate Sum_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)
postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate DPair_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P Hterm)
postulate max_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> Eq (max n f) m
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_arithmetics_nat.le a c))
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate lstar_ind_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b2)
postulate fact_pi_p3 : (n : Nat) -> Eq (factorial (times 2 n)) (times (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (mod (div (times 2 n) (pow p (plus i 1))) 2)))))
postulate lstar_inv_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b1 b2)
postulate divides_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible m q) -> divisible (times n m) (times p q)
postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : Eq (p_ord n p) (mk_Prod Nat Nat a b)) -> (__5 : Eq (p_ord m p) (mk_Prod Nat Nat c d)) -> and (divisible b d) (Leq a c)
postulate le_sqrt_n : (n : Nat) -> Leq (sqrt n) n
postulate lt_times_to_lt_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times m q))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m)
postulate bc : (_n : Nat) -> (_k : Nat) -> Nat
postulate div_mod_spec_ind : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809
postulate noLabel_66 : all Int (\ m -> if (even m) (all Int (\ n -> if (odd n) (odd (plus (times 3 m) (times 5 n))))))
postulate div_mod_spec_intro : (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> (__1 : Eq n (plus (times q m) r)) -> div_mod_spec n m q r
postulate coerc_pair_sigma : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (P (matita_basics_types.snd A B p))) -> cic.Term univs.Type0 (matita_basics_types.Prod A (matita_basics_types.Sig B (\ x : cic.Term univs.Type0 B -> P x)))
postulate permut_transpose : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.transpose i j) n)
postulate lstar_lstar_r : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> lstar_r B R l b1 b2
postulate Not_rect_Type5_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type5) -> (_H_nmk : (x_86 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> (x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type5 (Q_ x_85)
postulate decidable_eq_nat : (n : Nat) -> (m : Nat) -> decidable (Eq n m)
postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)
postulate let_clause_15491 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 n) -> (x1106 : Nat) -> Eq x1106 (minus x1106 n)
postulate bigop_sumI : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le b c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i b)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arith
postulate let_clause_10131 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m)) -> (fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0))) -> (x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7))
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate lstar_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar x1 x2 x3 x4 x5) -> (P : (_z2089 : Nat) -> (_z2088 : x1) -> (_z2087 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2092 : Eq x3 0) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b) -> P 0 b b) -> (_H2 : (b1 : x1) -> (b : x1) -> (_x_1236 : x2 b1 b) -> (l : Nat) -> (b2 : x1) -> (_x_1235 : lstar x1 x2 l b b2) -> (_x_1238 : (_z2092 : Eq x3 l) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b2) -> P l b b2) -> (_z2092 : Eq x3 (plus l 1)) -> (_z2091 : Eq x4 b1) -> (_z2090 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
postulate DPair_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type2) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type2 (Q_ x_646)
postulate nat_rect_CProp1 : (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_409)
postulate div : (_ : Nat) -> (__1 : Nat) -> Nat
postulate unit_rect_CProp4_body : (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_509)
postulate split_eq : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))))
postulate Dop_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)
postulate nat_rect_CProp4 : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393
postulate bertrand_down : (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n (pow 2 8)) -> bertrand n
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate list_ind : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_718 : cic.Term univs.Type0 _A) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_720 : cic.Term cic.prop (Q_ x_717)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> (x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_716)
postulate null : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)
postulate decidable_or : (P : Prop) -> (Q : Prop) -> (_ : decidable P) -> (__1 : decidable Q) -> decidable (or P Q)
postulate pi_p_primeb5 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))
postulate congruent : (_n : Nat) -> (_m : Nat) -> (_p : Nat) -> Prop
postulate bijn_transpose_r : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\ p : Nat -> f (transpose i j p)) n
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate prop40 : all Nat (\ n -> or (even n) (odd n))
postulate leb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Leq n m) -> P true) -> (__1 : (__1 : not (Leq n m)) -> P false) -> P (leb n m)
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate Dop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1734 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1735 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate le_ind : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate lstar_r_ind_body : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop) -> (_H_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (_H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339 _x_1342))) -> (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (
postulate Aop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_861 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_861 : Aop A _nil) -> Q_ x_861
postulate match_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (case_ex_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)
postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) true) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (op (f k) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)))
postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)
postulate pi_p_primeb : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> pow p (ord n p)))
postulate ACop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1596 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1597 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type0 (P Hterm)
postulate div_mod : (n : Nat) -> (m : Nat) -> Eq n (plus (times (div n m) m) (mod n m))
postulate nat_rect_CProp3 : (Q_ : (_x_401 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_402 : Nat) -> (_x_404 : Q_ x_402) -> Q_ (plus x_402 1)) -> (x_401 : Nat) -> Q_ x_401
postulate le_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> (__1 : Leq a (minus b c)) -> Leq (plus a c) b
postulate prod_body : (A : Set) -> (nil : A) -> (_xxx : Dop A nil) -> (_x_969 : A) -> (_x_970 : A) -> A
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate DPair_rect_Type1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type1) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type1 (Q_ x_648)
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate exp_n_O : (n : Nat) -> (_ : Lt 0 n) -> Eq (pow 0 n) 0
postulate let_clause_1704 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)
postulate Aop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879
postulate permut_to_bijn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)
postulate permut_transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> permut (transpose i j) n
postulate let_clause_1595 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m)))) -> (H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate nill_body : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a
postulate bc_n_n : (n : Nat) -> Eq (bc n n) 1
postulate match_ACop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : ACop A _nil) -> return_sort) -> (case_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> return_type (mk_ACop A _nil aop _comm)) -> (z : ACop A _nil) -> return_type z
postulate times_2_pred : (n : Nat) -> Leq (times 2 (pred n)) (pred (times 2 n))
postulate div_mod_spec_to_eq : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (__1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q q1)
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate increasing_to_le : (f : (_ : Nat) -> Nat) -> (_ : increasing f) -> (m : Nat) -> ex Nat (\ i : Nat -> Leq m (f i))
postulate let_clause_1571 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m n
postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i
postulate pos_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : Eq (mod n m) 0) -> Lt 0 (div n m)
postulate bool_rect_CProp4 : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)
postulate option_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) -> (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_586)
postulate let_clause_15311 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (p : Nat) -> (eqm : Eq m (times n (plus p 1))) -> Eq m (plus n (times n p))
postulate bertrand : (n : Nat) -> (_ : Lt 0 n) -> bertrand n
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate le_Psi_exp1 : (n : Nat) -> Leq (Psi (pow 2 n)) (pow 2 (minus (times 2 (pow 2 n)) (plus n 2)))
postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool
postulate nat_rect_Type4 : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369
postulate nat_rect_CProp0_body : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413
postulate range_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type5) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type5 (Q_ x_919)
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate unit_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)
postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (_ : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (__1 : Leq (plus m1 n1) (plus m2 n2)) -> Leq n1 n2
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate nat_inv_rect_Type3 : (Hterm : Nat) -> (P : (_z665 : Nat) -> Type3) -> (_H1 : (_z666 : Eq Hterm 0) -> P 0) -> (_H2 : (x_378 : Nat) -> (_x_380 : (_z666 : Eq Hterm x_378) -> P x_378) -> (_z666 : Eq Hterm (plus x_378 1)) -> P (plus x_378 1)) -> P Hterm
postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_867)
postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div (div q m) n)
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))
postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times (pow p q) r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate lt_sqrt_to_lt_times_r : (m : Nat) -> (n : Nat) -> (_ : Lt (sqrt m) n) -> Lt m (times n n)
postulate div_mod_spec_to_eq : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (__1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q q1)
postulate Aop_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1512 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1513 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P Hterm)
postulate And_inv_rect_CProp1 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate le_SO_smallest_factor : (n : Nat) -> (_ : Leq n 1) -> Eq (smallest_factor n) n
postulate min_body : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat
postulate list_divides_true : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) true) -> ex Nat (\ p : Nat -> and (mem Nat p l) (divisible p n))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate range_rect_Type4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type4 (Q_ x_917)
postulate lt_exp_to_lt1 : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow n a) (pow m a)) -> Lt n m
postulate let_clause_16004 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate congruent_ab : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\ x : Nat -> and (congruent x a m) (congruent x b n))
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate Sum_rect_Type1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1) -> (_H_inl : (x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))) -> (_H_inr : (x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))) -> (x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type1 (Q_ x_546)
postulate Dop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1704 : Dop x1 x2) -> Type4) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1
postulate Prod_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)
postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))
postulate eq_Psi_2_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (Psi (times 2 n)) (times (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (bool_to_nat (leb (plus n 1) (pow p (plus i 1))))))) (Psi n))
postulate min_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (t : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m t)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) t (matita_arithmetics_nat.plus k b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min k b f) m)
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
postulate DPair_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)
postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n
postulate div_mod_spec_inv_rect_Type0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1464 : div_mod_spec x1 x2 x3 x4) -> Set) -> (_H1 : (x_835 : Lt x4 x2) -> (x_834 : Eq x1 (plus (times x3 x2) x4)) -> (_z1465 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834)) -> P Hterm
postulate not_eq_to_eqb_false : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> Eq (eqb n m) false
postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))
postulate Prod_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P Hterm)
postulate lt_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Lt p q) -> Lt (plus n p) (plus m q)
postulate divides_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.minus p q))
postulate not_exists_to_forall : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.Not (P i))
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate not_lt_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)
postulate min : (_ : Nat) -> (__1 : Nat) -> Nat
postulate unit_rect_Type5 : (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) -> (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) -> (x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type5 (Q_ x_499)
postulate divides_ind_body : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192
postulate minus_minus_m_m : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus m (matita_arithmetics_nat.minus m n)) n)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate eq_rect_Type0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)
postulate congruent_n_mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> congruent n (mod n (times m p)) p
postulate lstar_r_S : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)
postulate not_bertrand_to_le1 : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (pow 2 (div (times 2 n) 3)) (pow (times 2 n) (div (sqrt (times 2 n)) 2))
postulate list_elim_left : (S : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (P (matita_basics_lists_list.nil S))) -> (__1 : (a : cic.Term univs.Type0 S) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__1 : cic.Term cic.prop (P tl)) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (P l)
postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate le_div_times_m : (a : Nat) -> (i : Nat) -> (m : Nat) -> (_ : Lt 0 i) -> (__1 : Lt 0 m) -> Leq (div (times a (div m i)) m) (div a i)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p
postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)
postulate void_rect_CProp1_body : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)
postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)
postulate True_rect_CProp1 : (Q_ : (_x_62 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_62 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_62)
postulate log_times1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Lt 0 m) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)
postulate fact_pi_p2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times (matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.pr
postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (max (plus m 1) (\ i : Nat -> andb (primeb i) (dividesb i m))) q) -> Eq m (bigop q (\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\ p : Nat -> pow p (ord m p)))
postulate permut_transpose_r : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\ n : Nat -> f (transpose i j n)) m
postulate lstar_singlevalued : (B : Set) -> (R : relation2 B B) -> (_ : singlevalued B B R) -> (l : Nat) -> singlevalued B B (lstar B R l)
postulate option_inv_ind : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1038 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_587 : cic.Term univs.Type0 x1) -> (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P Hterm)
postulate lstar_r_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338
postulate DPair_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type2) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type2 (Q_ x_646)
postulate True_rect_Type3 : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)
postulate ACop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type0 (Q_ x_901)
postulate dpi1_body : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) -> cic.Term univs.Type0 A
postulate times_2_pred : (n : Nat) -> Leq (times 2 (pred n)) (pred (times 2 n))
postulate le_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq n m) -> Leq (pow p n) (pow p m)
postulate log_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> Eq (log p (times (pow p n) m)) (plus n (log p m))
postulate let_clause_1573 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq n m
postulate bc_n_O : (n : Nat) -> Eq (bc n 0) 1
postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\ b -> even (plus (times a b) (times b c)))
postulate not_divides_ord_rem : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_ord.ord_rem m p)))
postulate le_exp_Psi2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))
postulate filter_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (return : (z : div_mod_spec _n _m _q _r) -> return_type z) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate lt_O_nth_prime_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_primes.nth_prime n))
postulate Not_rect_Type2_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type2) -> (_H_nmk : (x_92 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))) -> (x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type2 (Q_ x_91)
postulate div_p_ord_inv : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord_rem x p))
postulate congruent_ab : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate void_rect_CProp0 : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)
postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))
postulate nat_rect_CProp0 : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413
postulate divides_to_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) n)
postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m
postulate divides_gcd_nm : (n : Nat) -> (m : Nat) -> and (divisible (gcd n m) m) (divisible (gcd n m) n)
postulate not_not_bertrand_to_bertrand : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n))) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate div_mod_spec_inv_rect_Type1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1458 : div_mod_spec x1 x2 x3 x4) -> Type1) -> (_H1 : (x_831 : Lt x4 x2) -> (x_830 : Eq x1 (plus (times x3 x2) x4)) -> (_z1459 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) -> P Hterm
postulate Prod_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_708)
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate div_times_times : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (div a b) (div (times a c) (times b c))
postulate permut_transpose_r : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\ n : Nat -> f (transpose i j n)) m
postulate Sig_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_680)
postulate le_prim_n : (n : Nat) -> Leq (prim n) n
postulate divides_ind_body : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192
postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)
postulate mod_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (__1 : Leq i n) -> Eq (mod (plus (factorial n) 1) i) 1
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate plus_body : (_ : Nat) -> (__1 : Nat) -> Nat
postulate eq_rect_CProp5_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p
postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m
postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate nat_inv_rect_Type4 : (Hterm : Nat) -> (P : (_z659 : Nat) -> Type4) -> (_H1 : (_z660 : Eq Hterm 0) -> P 0) -> (_H2 : (x_370 : Nat) -> (_x_372 : (_z660 : Eq Hterm x_370) -> P x_370) -> (_z660 : Eq Hterm (plus x_370 1)) -> P (plus x_370 1)) -> P Hterm
postulate div_mod_spec_rect_Type1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_829 : div_mod_spec _n _m _q _r) -> Type1) -> (_H_div_mod_spec_intro : (x_831 : Lt _r _m) -> (x_830 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)) -> (x_829 : div_mod_spec _n _m _q _r) -> Q_ x_829
postulate le_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max m f))
postulate And_rect_CProp2 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) -> (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_158)
postulate div_mod_spec_rect_Type4_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4) -> (_H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) -> (x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type4 (Q_ x_813)
postulate Prod_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)
postulate div_mod_spec_rect_CProp3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_847 : Lt _r _m) -> (x_846 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> (x_845 : div_mod_spec _n _m _q _r) -> Q_ x_845
postulate plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Eq n (plus m p)) -> Eq (minus n m) p
postulate minus_plus_minus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le y z)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.plus x y))
postulate p_ord_aux_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)
postulate sum : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (lt1p : Lt 1 p) -> (m : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1549 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (eqm0 : Eq 0 m) -> (x1106 : Nat) -> Eq x1106 (minus x1106 m)
postulate div_mod_spec_to_eq2 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq r r1
postulate Psi_3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate null : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil
postulate lprim_invariant : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i))
postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (_ : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (__1 : Leq (plus m1 n1) (plus m2 n2)) -> Leq n1 n2
postulate lstar_ltransitive : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> cic.Term cic.prop (matita_arithmetics_lstar.ltransitive B (matita_arithmetics_lstar.lstar B R))
postulate exp_Sn : (b : Nat) -> (n : Nat) -> Eq (pow b (plus n 1)) (times b (pow b n))
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate match_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (case_ex_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)
postulate Dop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type0 (Q_ x_955)
postulate bool_inv_rect_CProp3 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z629 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z630 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z630 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)
postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (op B nil op (bigop k1 (\ i : Nat -> p1 i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k2 (\ i : Nat -> p2 i) B nil (op B nil op) (\ i : Nat -> g i))) (bigop (plus k1 k2) (\ i : Nat -> match_bool Set (\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\ i : Nat -> match_bool Set (\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i)))
postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : Eq (checker l) true) -> (__1 : Eq l (cons Nat a tl)) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))
postulate le_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (times 2 n) (times (plus (log 2 (times 2 n)) 1) (plus (prim (times 2 n)) 1))
postulate le_Psi_exp : (n : Nat) -> Leq (Psi (times 2 n)) (times (pow 2 (pred (times 2 n))) (Psi n))
postulate option_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1092 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_631 : cic.Term univs.Type0 x1) -> (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_631))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_631))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))
postulate noLabel_49 : (x : Int) -> (y : Int) -> if (odd (times x y)) (and (odd x) (odd y))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_1572 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate min_to_min_spec : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : Eq (min n b f) m) -> min_spec n b f m
postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n
postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n
postulate filter_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)
postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate DPair_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1122 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1123 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type2 (P Hterm)
postulate div_mod_spec_rect_Type4 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))
postulate range_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1686 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1687 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate Sum_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))) -> (_H_inr : (x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))) -> (x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_571)
postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus _n _b))) -> cic.Term cic.prop (Q_ m)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (plus l 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate noLabel_70 : (x : Int) -> (y : Int) -> if (or (even x) (even y)) (even (times x (pow y 2)))
postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)
postulate bool_ind : (Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_326)
postulate ACop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate eq_rect_CProp0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_37 : cic.Term univs.Type2 A) -> (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Term cic.prop (Q_ x_37 x_38)
postulate Sig_rect_Type1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type1 (Q_ x_674)
postulate tail : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate let_clause_1544 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (lenm : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (lenS : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat
postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)
postulate le_exp_to_le1 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq (pow n p) (pow m p)) -> Leq n m
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393
postulate le_div_times_m : (a : Nat) -> (i : Nat) -> (m : Nat) -> (_ : Lt 0 i) -> (__1 : Lt 0 m) -> Leq (div (times a (div m i)) m) (div a i)
postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate Sum_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1014 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_567 : cic.Term univs.Type0 x1) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_567))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_567))) -> (_H2 : (x_568 : cic.Term univs.Type0 x2) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true
postulate nill_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a)
postulate list_inv_ind : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1302 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_718 : cic.Term univs.Type0 x1) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_720 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_717)) -> cic.Term cic.prop (P x_717)) -> (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_718 x_717))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_718 x_717))) -> cic.Term cic.prop (P Hterm)
postulate notb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))
postulate nat_rect_CProp1 : (Q_ : (_x_409 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_410 : Nat) -> (_x_412 : Q_ x_410) -> Q_ (plus x_410 1)) -> (x_409 : Nat) -> Q_ x_409
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true
postulate max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate list_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1338 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_753 : cic.Term univs.Type0 x1) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_755 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_752)) -> cic.Term cic.prop (P x_752)) -> (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_753 x_752))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_753 x_752))) -> cic.Term cic.prop (P Hterm)
postulate match_max_spec : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : max_spec _n _f __) -> return_sort) -> (case_found_max_spec : (m : Nat) -> (_ : Lt m _n) -> (__1 : Eq (_f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i _n) -> Eq (_f i) false) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> (case_not_found_max_spec : (_ : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> return_type 0 (not_found_max_spec _n _f __)) -> (_ : Nat) -> (z : max_spec _n _f __) -> return_type __ z
postulate max_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop) -> (_H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.false)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__
postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)
postulate filter_Or : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)
postulate fst : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A
postulate Sum_rect_Type4 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type4) -> (_H_inl : (x_527 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inl _A _B x_527))) -> (_H_inr : (x_528 : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inr _A _B x_528))) -> (x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type4 (Q_ x_526)
postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (max (plus m 1) (\ i : Nat -> andb (primeb i) (dividesb i m))) q) -> Eq m (bigop q (\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\ p : Nat -> pow p (ord m p)))
postulate lstar_inv_step : (B : Set) -> (R : relation B) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R 1 b1 b2) -> R b1 b2
postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate Aop_rect_CProp2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_881 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_881 : Aop A _nil) -> Q_ x_881
postulate eq_times_div_minus_mod : (a : Nat) -> (b : Nat) -> Eq (times (div a b) b) (minus a (mod a b))
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate not_bertrand_to_le2 : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (div (times 2 n) 3) (times (div (sqrt (times 2 n)) 2) (plus (log 2 (times 2 n)) 1))
postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))))
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate div_mod_spec_rect_Type4 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate range_rect_Type2 : (_A : Set) -> (Q_ : (_x_923 : range _A) -> Type2) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_923 : range _A) -> Q_ x_923
postulate le_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> Leq (div m n) m
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate Prod_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_712)
postulate Not_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z287 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type0) -> (_H1 : (x_98 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z288 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P Hterm)
postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))
postulate Dop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1740 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1741 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate match_eq : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) -> (case_refl : cic.Term return_sort (return_type _x (matita_basics_logic.refl A _x))) -> (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type __ z)
postulate filter_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)
postulate le_times_to_le_div2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.times m q))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div n q) m)
postulate bigop_Sfalse : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))
postulate lt_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Lt p q) -> Lt (plus n p) (plus m q)
postulate Psidef : (n : Nat) -> Eq (Psi' n) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> p)))
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate lstar_ind_r : (B : Set) -> (R : relation B) -> (b1 : B) -> (P : relation2 Nat B) -> (_ : P 0 b1) -> (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (plus l 1) b2) -> (l : Nat) -> (b2 : B) -> (__2 : lstar B R l b1 b2) -> P l b2
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (minus (times 2 n) 3))
postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))
postulate Not_rect_Type0 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) -> (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type0 (Q_ x_97)
postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381
postulate div_mod_spec_rect_Type5_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_817 : div_mod_spec _n _m _q _r) -> Type5) -> (_H_div_mod_spec_intro : (x_819 : Lt _r _m) -> (x_818 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_819 x_818)) -> (x_817 : div_mod_spec _n _m _q _r) -> Q_ x_817
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> pow (f i) m)) (pow (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> f i)) m)
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)
postulate div_mod_spec_rect_Type3 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3) -> (_H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> (x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type3 (Q_ x_821)
postulate list_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_773 : cic.Term univs.Type0 _A) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_775 : cic.Term cic.prop (Q_ x_772)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_773 x_772))) -> (x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_771)
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate noLabel_29 : (x : Int) -> if (odd (minus (times 5 x) 7)) (even x)
postulate div_mod_spec_rect_Type3 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) -> (_H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> (x_821 : div_mod_spec _n _m _q _r) -> Q_ x_821
postulate Sum_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1008 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_557 : cic.Term univs.Type0 x1) -> (_z1009 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_557))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_557))) -> (_H2 : (x_558 : cic.Term univs.Type0 x2) -> (_z1009 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_558))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_558))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2
postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate option_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate singlevalued : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B))
postulate not_le_Sn_n : (n : Nat) -> not (Leq (plus n 1) n)
postulate ACop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905
postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate bool_rect_CProp5 : (Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_350)
postulate Aop_rect_Type5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865
postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : divisible p m) -> not (Eq (ord m p) 0)
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))
postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> 1)) 1
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n p) -> (__4 : divisible d (times c m)) -> (__5 : divisible d (times c n)) -> divisible d (times c (gcd_aux p m n))
postulate div_mod_spec_inv_rect_CProp4 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1470 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_839 : Lt x4 x2) -> (x_838 : Eq x1 (plus (times x3 x2) x4)) -> (_z1471 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_839 x_838)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_839 x_838)) -> P Hterm
postulate le_B_Psi : (n : Nat) -> Leq (B n) (Psi n)
postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate Not_inv_rect_CProp1 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_113 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z312 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_113))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) -> cic.Term cic.prop (P Hterm)
postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate option_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type5) -> (_H_None : cic.Term univs.Type5 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_595 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.Some _A x_595))) -> (x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type5 (Q_ x_594)
postulate div_mod_spec_rect_Type0 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_833 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type0) -> (_H_div_mod_spec_intro : (x_835 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_834 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_835 x_834))) -> (x_833 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type0 (Q_ x_833)
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n
postulate p_ord_degenerate : (p : Nat) -> (n : Nat) -> Eq (p_ord_aux p n 1) (mk_Prod Nat Nat p n)
postulate And_rect_Type4_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4) -> (_H_conj : (x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> (x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type4 (Q_ x_122)
postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m
postulate mk_Aop : (A : Set) -> (nil : A) -> (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op nil a) a) -> (_nilr : (a : A) -> Eq (op a nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Aop A nil
postulate unit_inv_ind : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z906 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1258 : (b : Nat) -> (lt1b : Lt 1 b) -> (n : Nat) -> (H : Eq (times (pow b n) b) 1) -> Eq (times b (pow b n)) 1
postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (_ : ex Nat (\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p
postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true
postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i
postulate le_B_Psi : (n : Nat) -> Leq (B n) (Psi n)
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate le_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (_Hterm : Leq x1 x2) -> (P : (_z724 : Nat) -> Prop) -> (_H1 : (_z725 : Eq x2 x1) -> P x1) -> (_H2 : (m : Nat) -> (_x_419 : Leq x1 m) -> (_x_421 : (_z725 : Eq x2 m) -> P m) -> (_z725 : Eq x2 (plus m 1)) -> P (plus m 1)) -> P x2
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1532 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m 0
postulate lt_to_not_eq : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not (Eq n m)
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate match_Sum : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ return_sort) -> (case_inl : (__ : cic.Term univs.Type0 _A) -> cic.Term return_sort (return_type (matita_basics_types.inl _A _B __))) -> (case_inr : (__ : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.inr _A _B __))) -> (z : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term return_sort (return_type z)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n
postulate exp_sigma : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O))))
postulate primes_below : (_l : list Nat) -> (_n : Nat) -> Prop
postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))
postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338
postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))
postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate let_clause_1572 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m 0
postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate lop_Strue : (m : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Eq (list_divides acc i) true) -> Eq (lprim (plus m 1) i acc) (lprim m (plus i 1) acc)
postulate let_clause_1617 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S (matita_arithmetics_nat.times p c)))))) -> (H : matita_basics_logic.eq (cic
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate eqb_body : (_ : Nat) -> (__1 : Nat) -> bool
postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0
postulate ord_O_to_not_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : Eq (ord m p) 0) -> not (divisible p m)
postulate noLabel_50 : (a : Int) -> (b : Int) -> if (odd (times a b)) (even (plus (pow a 2) (pow b 2)))
postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (op B nil op (bigop k1 (\ i : Nat -> p1 i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k2 (\ i : Nat -> p2 i) B nil (op B nil op) (\ i : Nat -> g i))) (bigop (plus k1 k2) (\ i : Nat -> match_bool Set (\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\ i : Nat -> match_bool Set (\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i)))
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate theta_pi_p_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))
postulate range_rect_Type0_body : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate square_double : (n : Nat) -> (_ : Lt 2 n) -> Leq (times (plus n 1) (plus n 1)) (times (times 2 n) n)
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate bigop_prod : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> Eq (bigop k1 (\ x : Nat -> p1 x) B nil (op B nil op) (\ x : Nat -> bigop k2 (\ i : Nat -> p2 x i) B nil (op B nil op) (\ i : Nat -> f x i))) (bigop (times k1 k2) (\ i : Nat -> andb (p1 (div i k2)) (p2 (div i k2) (mod i k2))) B nil (op B nil op) (\ i : Nat -> f (div i k2) (mod i k2)))
postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)
postulate not_eq_n_Sn : (n : Nat) -> not (Eq n (plus n 1))
postulate div_mod_spec_rect_CProp0_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857
postulate let_clause_16 : (n : Nat) -> (m : Nat) -> (auto : Lt (plus n 1) (plus m 1)) -> (x32 : Nat) -> Eq (plus x32 1) (plus x32 1)
postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_minimization.max_specification (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 x2 m) matita_basics_bool.true)) -> cic.Term cic.prop (P (matita_arithmetics_minimization.max_specification (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 x2 m))) -> cic.Term cic.prop (P x3)
postulate f2_ind_aux : (A1 : Set) -> (A2 : Set) -> (f : (_ : A1) -> (__1 : A2) -> Nat) -> (P : relation2 A1 A2) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (_ : Lt (f a1 a2) n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> (__1 : Eq (f a1 a2) n) -> P a1 a2) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (__1 : Eq (f a1 a2) n) -> P a1 a2
postulate fact_to_exp1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (factorial (times 2 n)) (times (times (pow 2 (pred (times 2 n))) (factorial n)) (factorial n))
postulate lt_to_log_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt m n) -> Eq (log n m) 0
postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : divisible p m) -> not (Eq (ord m p) 0)
postulate Sig_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)
postulate le_ind : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate Not_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z269 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type3) -> (_H1 : (x_89 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z270 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_89))) -> cic.Term univs.Type3 (P (matita_basics_logic.nmk x1 x_89))) -> cic.Term univs.Type3 (P Hterm)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_upper_bound : (_ : Nat) -> (p : Nat) -> Nat
postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))
postulate exp_to_eq_O : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (pow n m) 1) -> Eq m 0
postulate let_clause_1562 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m
postulate length_append : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 l2)) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2)))
postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> Leq m (max n f)
postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959
postulate range_inv_ind : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1632 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1633 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm
postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate sameF_p : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (A : Set) -> relation (prod Set Set Nat (\ __2 : Nat -> A))
postulate let_clause_15591 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m n
postulate Aop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)
postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate hint_declaration_Type0 : (A : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ univs.Type0
postulate eq_length_to_mem_all : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__2 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat i l)
postulate minus_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq p m) -> (__1 : Leq m n) -> Eq (plus p (minus n m)) (minus n (minus m p))
postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (plus (pred n) 1) n
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate fmax_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq (f m) false) -> Eq m 0
postulate filter_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : min_spec _n _b _f __) -> return_sort) -> (return : (z : min_spec _n _b _f __) -> return_type z) -> (z : min_spec _n _b _f __) -> return_type z
postulate divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 n) -> (__2 : divisible n m) -> Eq (gcd_aux p m n) n
postulate divides_mod : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p m) -> (__2 : divisible p n) -> divisible p (mod m n)
postulate div_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_div_and_mod.div n d)) d)
postulate range_rect_Type2 : (_A : Set) -> (Q_ : (_x_923 : range _A) -> Type2) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_923 : range _A) -> Q_ x_923
postulate nat_inv_rect_CProp4 : (Hterm : Nat) -> (P : (_z689 : Nat) -> Prop) -> (_H1 : (_z690 : Eq Hterm 0) -> P 0) -> (_H2 : (x_394 : Nat) -> (_x_396 : (_z690 : Eq Hterm x_394) -> P x_394) -> (_z690 : Eq Hterm (plus x_394 1)) -> P (plus x_394 1)) -> P Hterm
postulate R3 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T1) a1))) -> cic.Univ univs.Type0
postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1
postulate let_clause_1033 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Aop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1398 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1399 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P Hterm)
postulate div_mod_spec_rect_CProp2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849
postulate lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_relations.relation B)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate filter_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)
postulate Not_ind : (_A : cic.Univ cic.prop) -> (Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_80 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> (x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_79)
postulate p_ord_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O))) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le i p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m i) n) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat i n))
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)
postulate fst_p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p)))
postulate append_l1_injective : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)
postulate And_rect_CProp4 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_146)
postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)
postulate f_min_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : ex Nat (\ i : Nat -> and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true))) -> Eq (f (min n b f)) true
postulate range_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type5) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type5 (Q_ x_919)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate minus_Sn_n : (n : Nat) -> Eq 1 (minus (plus n 1) n)
postulate prime_to_divides_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S m) p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_binomial.M m))
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate eq_rect_Type1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) -> (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_16 : cic.Term univs.Type2 A) -> (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Term univs.Type1 (Q_ x_16 x_17)
postulate ACop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_893 : ACop A _nil) -> Type5) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_893 : ACop A _nil) -> Q_ x_893
postulate Dop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)
postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (plus n 1) (times 2 n)
postulate congruent_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n n p)
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate ex_intro : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P x)) -> cic.Term cic.prop (matita_basics_logic.ex A P)
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate option_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) -> (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_586)
postulate let_upper_bound6 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> (x : Nat) -> Nat
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate nat_rect_CProp2 : (Q_ : (_x_405 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_406 : Nat) -> (_x_408 : Q_ x_406) -> Q_ (plus x_406 1)) -> (x_405 : Nat) -> Q_ x_405
postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate Aop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_871 : Aop A _nil) -> Type1) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_871 : Aop A _nil) -> Q_ x_871
postulate pi_p_primeb : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> pow p (ord n p)))
postulate Aop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_783)
postulate Aop_rect_Type1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_871 : Aop A _nil) -> Type1) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_871 : Aop A _nil) -> Q_ x_871
postulate iso : (A : Set) -> relation (range A)
postulate injective : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop
postulate Dop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type3 (Q_ x_949)
postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)
postulate pi_p_primeb4 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))
postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f (plus n 1)) -> (__1 : Eq (f (plus n 1)) (plus n 1)) -> bijn f n
postulate le_gen : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) -> cic.Term cic.prop (P n)
postulate square_double : (n : Nat) -> (_ : Lt 2 n) -> Leq (times (plus n 1) (plus n 1)) (times (times 2 n) n)
postulate divides_exp_to_eq : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : prime q) -> (__2 : divisible p (pow q m)) -> Eq p q
postulate lt_mod_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.mod n m) m)
postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1554 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1555 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate div_mod_spec_rect_CProp1 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853
postulate exp_to_eq_O : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (pow n m) 1) -> Eq m 0
postulate Dop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_951 : Dop A _nil) -> Type2) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_951 : Dop A _nil) -> Q_ x_951
postulate match_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z
postulate Aop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate f_min_true : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.min n b f)) matita_basics_bool.true)
postulate let_clause_1532 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m 0
postulate let_clause_10334 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : Eq (p_ord n p) (mk_Prod Nat Nat a b)) -> (__5 : Eq (p_ord m p) (mk_Prod Nat Nat c d)) -> and (divisible b d) (Leq a c)
postulate reflexive_divides : cic.Term cic.prop (matita_basics_relations.reflexive matita_arithmetics_nat.nat matita_arithmetics_primes.divides)
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate Dop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1734 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1735 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate lt_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not (Leq m n)
postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate Aop_inv_rect_Type2 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1518 : Aop x1 x2) -> Type2) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1519 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (_ : Nat) -> bool) -> (p12 : (_ : Nat) -> (__1 : Nat) -> bool) -> (p21 : (_ : Nat) -> bool) -> (p22 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\ i : Nat -> bigop m (\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\ j : Nat -> f i j))) (bigop m (\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\ j : Nat -> bigop n (\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\ i : Nat -> f i j)))
postulate bigop_sumI : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le b c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i b)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arith
postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> pow (f i) m)) (pow (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> f i)) m)
postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i
postulate Sum_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) -> (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type0 (Q_ x_551)
postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate find : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option B)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate permut_mod : (p : Nat) -> (a : Nat) -> (_ : prime p) -> (__1 : not (divisible p a)) -> permut (\ n : Nat -> mod (times a n) p) (pred p)
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq m n) -> (__2 : divisible p (minus n m)) -> congruent n m p
postulate min0 : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat
postulate match_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) -> (case_found_min_spec : (m : Nat) -> (_ : Leq _b m) -> (__1 : Lt m (plus _n _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> (case_not_found_min_spec : (_ : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> (_ : Nat) -> (z : min_spec _n _b _f __) -> return_type __ z
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate lt_div_to_times : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Lt (div n q) m) -> Lt n (times q m)
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m
postulate match_Dop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Dop A _nil) -> return_sort) -> (case_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> return_type (mk_Dop A _nil sum prod _null _distr)) -> (z : Dop A _nil) -> return_type z
postulate min_f_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) (g i)) -> Eq (min n b f) (min n b g)
postulate Sig_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_686)
postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate not_prime_to_primeb_false : (n : Nat) -> (_ : not (prime n)) -> Eq (primeb n) false
postulate noLabel_1 : (x : Real) -> if (Lt x 0) (Gt (plus (pow x 2) 1) 0)
postulate le_exp_Psi2 : (n : Nat) -> (_ : Lt 1 n) -> Leq (pow 2 (div n 2)) (Psi n)
postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\ x : Nat -> x) (\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate nat_inv_rect_Type1 : (Hterm : Nat) -> (P : (_z677 : Nat) -> Type1) -> (_H1 : (_z678 : Eq Hterm 0) -> P 0) -> (_H2 : (x_386 : Nat) -> (_x_388 : (_z678 : Eq Hterm x_386) -> P x_386) -> (_z678 : Eq Hterm (plus x_386 1)) -> P (plus x_386 1)) -> P Hterm
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate transpose_i_i : (i : Nat) -> (n : Nat) -> Eq (transpose i i n) n
postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_861)
postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (plus l 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z
postulate le_times_div_div_times : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (times a (div n m)) (div (times a n) m)
postulate pred : (_n : Nat) -> Nat
postulate eq_length_to_mem_all : (n : Nat) -> (l : list Nat) -> (_ : Eq (length Nat l) n) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) -> (i : Nat) -> (__3 : Lt i n) -> mem Nat i l
postulate mk_Dop : (A : Set) -> (nil : A) -> (sum : ACop A nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil
postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0
postulate p_ord_aux_to_not_mod_O : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 m) -> (__1 : Lt 0 n) -> (__2 : Leq n p) -> (__3 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> not (Eq (mod r m) 0)
postulate Allr : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop
postulate not_bertrand_to_le2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))
postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))
postulate let_clause_10331 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate congruent_n_n : (n : Nat) -> (p : Nat) -> congruent n n p
postulate Aop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_881 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_881 : Aop A _nil) -> Q_ x_881
postulate bigop_distr : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> Eq (let_mop n p B nil R f a a (bigop n (\ i : Nat -> p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (\ i : Nat -> f i))) (bigop n (\ i : Nat -> p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (\ i : Nat -> let_mop n p B nil R f a a (f i)))
postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n) (\ __1 : Lt i n -> P i)))) -> ex Nat (\ i : Nat -> and (Lt i n) (not (P i)))
postulate lop_Strue : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S m) i acc) (matita_arithmetics_chebyshev_bertrand256.lprim m (matita_arithmetics_nat.S i) acc))
postulate Aop_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_795)
postulate filter_lstar_r : (B : Set) -> (_R : relation B) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (return_sort : Sort) -> (return_type : (z : lstar_r B _R __ __1 __2) -> return_sort) -> (return : (z : lstar_r B _R __ __1 __2) -> return_type z) -> (z : lstar_r B _R __ __1 __2) -> return_type z
postulate let_clause_1033 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (ndivpr : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> (q0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S q1) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S q1)))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate lstar : (B : Set) -> (_R : relation B) -> (_ : Nat) -> relation B
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1
postulate True_rect_Type5 : (Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type5) -> (_H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I)) -> (x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type5 (Q_ x_44)
postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)
postulate le_plus : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))
postulate let_clause_15625 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate congruent_ab : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\ x : Nat -> and (congruent x a m) (congruent x b n))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate Aop_inv_rect_Type3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1512 : Aop x1 x2) -> Type3) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1513 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate Sum_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)
postulate True_inv_rect_Type0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z155 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) -> (_H1 : (_z156 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type0 (P matita_basics_logic.I)) -> cic.Term univs.Type0 (P Hterm)
postulate mk_DPair : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (f dpi1)) -> cic.Term univs.Type0 (matita_basics_types.DPair A f)
postulate le_max_n : (f : (_ : Nat) -> bool) -> (n : Nat) -> Leq (max n f) n
postulate let_clause_15691 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate checker_abl : (a : Nat) -> (b : Nat) -> (l : list Nat) -> (_ : Eq (checker (cons Nat a (cons Nat b l))) true) -> and (and (Lt a b) (Leq b (times 2 a))) (Eq (checker (cons Nat b l)) true)
postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)
postulate Not_rect_Type5_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type5) -> (_H_nmk : (x_86 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> (x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type5 (Q_ x_85)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (plus (pred n) 1) n
postulate le_sqrt_nl : (n : Nat) -> (m : Nat) -> (_ : Lt 3 n) -> Leq (times (times m (pred m)) n) (pow (sqrt (times (pow m 2) n)) 2)
postulate option : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n
postulate fst_p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p)))
postulate And_rect_CProp4 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_146)
postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate inv : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ cic.prop
postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate eq_to_bijn : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Leq i n) -> Eq (f i) (g i)) -> (__1 : bijn f n) -> bijn g n
postulate fmin_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> prod Prop Prop (Eq (f (let_m f n b)) false) (\ _ : Eq (f (let_m f n b)) false -> Eq (let_m f n b) (plus n b))
postulate permut_S_to_permut_transpose : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (_clearme : ex Nat (\ a : Nat -> or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (_clearme0 : or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1))) -> (Hn : Eq n0 (plus (times 2 a) 1)) -> Eq n0 (plus a (plus a 1))
postulate mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p)
postulate match_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z
postulate p_ord_degenerate : (p : Nat) -> (n : Nat) -> Eq (p_ord_aux p n 1) (mk_Prod Nat Nat p n)
postulate times_div_le : (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (_ : Lt 0 b) -> (__1 : Lt 0 d) -> Leq (times (div a b) (div c d)) (div (times a c) (times b d))
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate not_eq_to_le_to_lt : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> (__1 : Leq n m) -> Lt n m
postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))
postulate prim : (_n : Nat) -> Nat
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate lt_sqrt : (n : Nat) -> Lt n (pow (plus (sqrt n) 1) 2)
postulate pad_bigop : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> match_bool Set (\ _0 : bool -> bool) false (p i) (leb n i)) B nil op (\ i : Nat -> f i))
postulate lt_exp1 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt n m) -> Lt (pow n p) (pow m p)
postulate div_mod_spec_rect_Type0 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_833 : div_mod_spec _n _m _q _r) -> Set) -> (_H_div_mod_spec_intro : (x_835 : Lt _r _m) -> (x_834 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_835 x_834)) -> (x_833 : div_mod_spec _n _m _q _r) -> Q_ x_833
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate le_exp_B : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (times (times 2 n) (B (times 2 n)))
postulate lt_or_ge : (m : Nat) -> (n : Nat) -> or (Lt m n) (Leq n m)
postulate nat_discr : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x y)) -> cic.Term univs.Type2 (matita_arithmetics_nat.match_nat (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.univ univs.Type2) (matita_arithmetics_nat.match_nat (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 P (\ _z23 : cic.Term univs.Type1 P -> P))) (\ u0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> P)) y) (\ t0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.match_nat (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> P)) (\ u0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type
postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1))
postulate let_clause_10131 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m)) -> (fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0))) -> (x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7))
postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))
postulate antisymmetric_divides : (n : Nat) -> (m : Nat) -> (_ : divisible n m) -> (__1 : divisible m n) -> Eq n m
postulate And_inv_rect_Type4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (x_124 : cic.Term cic.prop x1) -> (x_123 : cic.Term cic.prop x2) -> (_z330 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P Hterm)
postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825
postulate Dop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type3 (Q_ x_949)
postulate le_exp_B : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (times (times 2 n) (B (times 2 n)))
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate filter_lstar : (B : Set) -> (_R : relation B) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (return_sort : Sort) -> (return_type : (z : lstar B _R __ __1 __2) -> return_sort) -> (return : (z : lstar B _R __ __1 __2) -> return_type z) -> (z : lstar B _R __ __1 __2) -> return_type z
postulate nat_elim1 : (n : Nat) -> (P : (_ : Nat) -> Prop) -> (_ : (m : Nat) -> (_ : (p : Nat) -> (_ : Lt p m) -> P p) -> P m) -> P n
postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n1 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (\ i : cic.Term univs.Type0 matita_arithmetics
postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1422 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1423 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate not_bertrand_to_le1 : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (pow 2 (div (times 2 n) 3)) (pow (times 2 n) (div (sqrt (times 2 n)) 2))
postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)
postulate divides_to_divides_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p q))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides q n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times p q) n)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate le_n : (n : Nat) -> Leq n n
postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))
postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate prop150 : (n : Nat) -> even (minus (pow n 3) n)
postulate log_times1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Lt 0 m) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate not_eq_to_le_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)
postulate Not_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z317 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_116 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z318 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_116))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_116))) -> cic.Term cic.prop (P Hterm)
postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1
postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate fmax_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq (f m) false) -> Eq m 0
postulate append_cons : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l (matita_basics_lists_list.cons A a l1)) (matita_basics_lists_list.append A (matita_basics_lists_list.append A l (matita_basics_lists_list.cons A a (matita_basics_lists_list.nil A))) l1))
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate let_clause_15491 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 n) -> (x1106 : Nat) -> Eq x1106 (minus x1106 n)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)
postulate le_ord_log : (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 1 p) -> Leq (ord n p) (log p n)
postulate let_clause_10333 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate nat_inv_rect_CProp1 : (Hterm : Nat) -> (P : (_z707 : Nat) -> Prop) -> (_H1 : (_z708 : Eq Hterm 0) -> P 0) -> (_H2 : (x_410 : Nat) -> (_x_412 : (_z708 : Eq Hterm x_410) -> P x_410) -> (_z708 : Eq Hterm (plus x_410 1)) -> P (plus x_410 1)) -> P Hterm
postulate ord_O_to_not_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : Eq (ord m p) 0) -> not (divisible p m)
postulate divides_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> (__3 : divisible d m) -> (__4 : divisible d n) -> divisible d (gcd_aux p m n)
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate filter_And : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term return_sort (return_type z)
postulate sub0_to_false : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A J I)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_bigops.upto A J))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_bigops.filter A J i) matita_basics_bool.false)
postulate op_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (_x_887 : cic.Term univs.Type0 A) -> (_x_888 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A
postulate increasing_to_le : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.le m (f i)))
postulate list_cases2 : (T1 : cic.Univ univs.Type0) -> (T2 : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (P : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length T1 l1) (matita_basics_lists_list.length T2 l2))) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T1)) l1 (matita_basics_lists_list.nil T1))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T2)) l2 (matita_basics_lists_list.nil T2))) -> cic.Term cic.prop P) -> (__2 : (hd1 : cic.Term univs.Type0 T1) -> (hd2 : cic.Term univs.Type0 T2) -> (tl1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (tl2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T1)) l1 (matita_basics_lists_list.cons T1 hd1 tl1))) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list T2)) l2 (matita_basics_lists_list.cons T2 hd2 tl2))) -> cic.Term cic.prop P) -> cic.Term cic.prop P
postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3
postulate eq_rect_Type0 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)
postulate pair_destruct_1 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 B) -> (c : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate True_inv_rect_CProp2 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z173 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)
postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (minus n m) 0
postulate le_times_div_div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m))
postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate option_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1074 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_615 : cic.Term univs.Type0 x1) -> (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P Hterm)
postulate div_mod_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate let_clause_1573 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)
postulate le_min_r : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> Leq (min n b f) (plus n b)
postulate lt_plus_Sn_r : (a : Nat) -> (x : Nat) -> (n : Nat) -> Lt a (plus (plus a x) (plus n 1))
postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n
postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\ t : Nat -> times c t)
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_795)
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate bertrand_down : (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n (pow 2 8)) -> bertrand n
postulate bertrand_down : (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n (pow 2 8)) -> bertrand n
postulate let_clause_1033 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate mk_Aop : (A : Set) -> (nil : A) -> (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op nil a) a) -> (_nilr : (a : A) -> Eq (op a nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Aop A nil
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m
postulate lt_to_eq_mod : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (mod n m) n
postulate le_plus_b : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus n b) m) -> Leq n m
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate fold_filter : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (nil : cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (\ i : cic.Term univs.Type0 A -> p i) (\ i : cic.Term univs.Type0 A -> f i) l) (matita_basics_lists_list.fold A B op nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.filter A p l)))
postulate DPair_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type4 (Q_ x_640)
postulate Prod_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)
postulate prop20 : (n : Nat) -> even n -> odd (plus n 1)
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p)
postulate Dop_discr : (a1 : Set) -> (a2 : a1) -> (x : Dop a1 a2) -> (y : Dop a1 a2) -> (_e : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\ _ : Dop a1 a2 -> univ Type2) (\ t0 : ACop a1 a2 -> \ t1 : ((_ : a1) -> (__1 : a1) -> a1) -> \ t2 : ((a : a1) -> Eq (t1 a a2) a2) -> \ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t1 a (aop__o__op a1 a2 t0 b c)) (aop__o__op a1 a2 t0 (t1 a b) (t1 a c))) -> match_Dop a1 a2 (plus Type2 1) (\ _ : Dop a1 a2 -> univ Type2) (\ u0 : ACop a1 a2 -> \ u1 : ((_ : a1) -> (__1 : a1) -> a1) -> \ u2 : ((a : a1) -> Eq (u1 a a2) a2) -> \ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u1 a (aop__o__op a1 a2 u0 b c)) (aop__o__op a1 a2 u0 (u1 a b) (u1 a c))) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (ACop a1 a2) t0) u0) (\ e0 : Eq (R0 (ACop a1 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (ACop a1 a2) t0 (\ x0 : ACop a1 a2 -> \ p0 : Eq t0 x0 -> prod Set Set a1 (\ _ : a1 -> prod Set Set a1 (\ __1 : a1 -> a1))) t1 u0 e0) u1) (\ e1 :
postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)
postulate div_mod_spec_inv_rect_Type1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1458 : div_mod_spec x1 x2 x3 x4) -> Type1) -> (_H1 : (x_831 : Lt x4 x2) -> (x_830 : Eq x1 (plus (times x3 x2) x4)) -> (_z1459 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) -> P Hterm
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate let_upper_bound5 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)
postulate filter_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : min_spec _n _b _f __) -> return_sort) -> (return : (z : min_spec _n _b _f __) -> return_type z) -> (z : min_spec _n _b _f __) -> return_type z
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate sub_hkO : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> sub_hk h k A I J
postulate prime_to_smallest_factor : (n : Nat) -> (_ : prime n) -> Eq (smallest_factor n) n
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0
postulate list_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) -> (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P Hterm)
postulate min_to_min_spec : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)
postulate div_mod_spec_rect_Type5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_817 : div_mod_spec _n _m _q _r) -> Type5) -> (_H_div_mod_spec_intro : (x_819 : Lt _r _m) -> (x_818 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_819 x_818)) -> (x_817 : div_mod_spec _n _m _q _r) -> Q_ x_817
postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)
postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate Dop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1704 : Dop x1 x2) -> Type4) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate Aop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_869 : Aop A _nil) -> Type2) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_869 : Aop A _nil) -> Q_ x_869
postulate bc_n_n : (n : Nat) -> Eq (bc n n) 1
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate extract_pair : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (D : cic.Univ univs.Type0) -> (u : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (Q : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> (x : cic.Term univs.Type0 C) -> (y : cic.Term univs.Type0 D) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> matita_basics_types.Prod C D) (\ a : cic.Term univs.Type0 A -> \ b : cic.Term univs.Type0 B -> Q a b) u) (matita_basics_types.mk_Prod C D x y))) -> cic.Term cic.prop (matita_basics_logic.ex A (\ a : cic.Term univs.Type0 A -> matita_basics_logic.ex B (\ b : cic.Term univs.Type0 B -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (Q a b) (matita_basics_types.mk_Prod C D x y)))))
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate Sig_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P Hterm)
postulate permut_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> permut (invert_permut n f) n
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate min_not_exists : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))
postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))
postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate bigop_body : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate Aop_rect_CProp3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879
postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_upper_bound6 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> (x : Nat) -> Nat
postulate le_ord_log : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_log.log p n))
postulate bertrand_up : (n : Nat) -> (_ : Leq (pow 2 8) n) -> bertrand n
postulate bigop_op : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (aop__o__op B nil op (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> g i))) (bigop k (\ i : Nat -> p i) B nil (aop__o__op B nil op) (\ i : Nat -> aop__o__op B nil op (f i) (g i)))
postulate rev_append : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate true_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Leq b m) -> (__1 : Eq (f m) true) -> Leq (min n b f) m
postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true
postulate prime_smallest_factor_n : (n : Nat) -> (_ : Lt 1 n) -> prime (smallest_factor n)
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate lt_exp_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> Lt n (pow p (plus (log p n) 1))
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate f2_ind : (A1 : Set) -> (A2 : Set) -> (f : (_ : A1) -> (__1 : A2) -> Nat) -> (P : relation2 A1 A2) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (_ : Lt (f a1 a2) n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> (__1 : Eq (f a1 a2) n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> P a1 a2
postulate dividesb_false_to_not_divides : (n : Nat) -> (m : Nat) -> (_ : Eq (dividesb n m) false) -> not (divisible n m)
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate prop60 : all Nat (\ n -> Eq (plus n 0) n)
postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i
postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (plus l 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)
postulate Eq : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> cic.Univ cic.prop
postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)
postulate div_mod_spec_to_eq : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq q q1
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (f1 n1) (f2 (h n1))
postulate lstar_r_ind : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335)) -> cic.Univ cic.prop) -> (_H_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (_H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (x_1339 : cic.Term cic.prop (_R b b2)) -> (_x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339 _x_1342))) -> (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1336 : cic.Term univs.Type0 B) -> (x_1335 : cic.Term univs.Type0 B) -> (_x_1338 : cic.Term cic.prop (mat
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m
postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (plus n i)
postulate bigop : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H
postulate eq_plus_to_le : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Eq n (plus m p)) -> Leq m n
postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)
postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (plus n 1) (\ i : Nat -> true) B nil (op B nil op) (\ i : Nat -> f i)) (op B nil op (bigop n (\ i : Nat -> true) B nil (op B nil op) (\ i : Nat -> f (plus i 1))) (f 0))
postulate start_lprim : (n : Nat) -> (m : Nat) -> (a : Nat) -> (acc : list Nat) -> Eq (option_hd Nat (lprim n m (cons Nat a acc))) (Some Nat a)
postulate le_exp_to_le1 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq (pow n p) (pow m p)) -> Leq n m
postulate le_log_n_n : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) n)
postulate dpi1__o__aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0
postulate unit_rect_Type4 : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)
postulate injective_times_r : (n : Nat) -> (_ : Lt 0 n) -> injective Nat Nat (\ m : Nat -> times n m)
postulate le_squareS_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))
postulate exteqF : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate filter_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)
postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0
postulate le_smallest_factor_n : (n : Nat) -> Leq (smallest_factor n) n
postulate Aop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_881 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_881 : Aop A _nil) -> Q_ x_881
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate divides_to_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> and (divisible (ord_rem n p) (ord_rem m p)) (Leq (ord n p) (ord m p))
postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m
postulate Dop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate prime_to_gcd_1 : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : not (divisible n m)) -> Eq (gcd n m) 1
postulate ACop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895
postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)
postulate le_ind : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate le_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate option_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type4) -> (_H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_591 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> (x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type4 (Q_ x_590)
postulate Aop_rect_Type0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate Dop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963
postulate list_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate Aop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_883)
postulate eq_rect_Type5 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_7 : cic.Term univs.Type2 A) -> (_x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7)) -> cic.Univ univs.Type5) -> (_H_refl : cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_7 : cic.Term univs.Type2 A) -> (x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7)) -> cic.Term univs.Type5 (Q_ x_7 x_8)
postulate eq_rect_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> (P : (x0 : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x0 a)) -> cic.Univ univs.Type3) -> (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) -> cic.Term univs.Type3 (P x p)
postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m
postulate lt_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Lt p q) -> Lt (times n p) (times m q)
postulate minus_minus_m_m : (m : Nat) -> (n : Nat) -> (_ : Leq n m) -> Eq (minus m (minus m n)) n
postulate Prod_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_706)
postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891
postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))
postulate or_div_mod1 : (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> or (and (divisible q (plus n 1)) (Eq (plus n 1) (times (plus (div n q) 1) q))) (and (not (divisible q (plus n 1))) (Eq (plus n 1) (plus (times (div n q) q) (plus (mod n q) 1))))
postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus p m)) -> Lt (minus n m) p
postulate append_l2_injective : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)
postulate eq_ind_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_1 : cic.Term univs.Type2 A) -> (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Term cic.prop (Q_ x_1 x_2)
postulate Psi_2 : Eq (Psi 2) 2
postulate permut_transpose_l : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\ n : Nat -> transpose i j (f n)) m
postulate bigop_diff : (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p x) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x)) (matita_arithmetics_bigops.aop__o__op B nil op (f i) (matita_arithmetics_bigops.bigop n (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.eqb i x)) (p x)) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x))))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (f1 i) (f2 (h i))
postulate lt_to_log_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)
postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2
postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)
postulate permut_S_to_permut_transpose : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m)
postulate unit_rect_Type0_body : (Q_ : (_x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0) -> (_H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it)) -> (x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type0 (Q_ x_507)
postulate And_rect_CProp2 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) -> (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_158)
postulate minus_to_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Eq (minus n m) p) -> Eq n (plus m p)
postulate true_min : (f : (_ : Nat) -> bool) -> (b : Nat) -> (_ : Eq (f b) true) -> (n : Nat) -> Eq (min n b f) b
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate nat_ind_plus : (R : predicate Nat) -> (_ : R 0) -> (__1 : (n : Nat) -> (__1 : R n) -> R (plus n 1)) -> (n : Nat) -> R n
postulate let_clause_1704 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)
postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0
postulate not_eq_S : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> not (Eq (plus n 1) (plus m 1))
postulate Aop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885
postulate plus_div : (n : Nat) -> (m : Nat) -> (d : Nat) -> (_ : Lt 0 d) -> (__1 : divisible d n) -> (__2 : divisible d m) -> Eq (div (plus n m) d) (plus (div n d) (div m d))
postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> Leq (min n b f) (min m b f)
postulate bool_ind : (Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_326)
postulate nill_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)
postulate let_clause_17041 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate le_sqrt_to_le_times_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_sqrt.sqrt m))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n n) m)
postulate minus_to_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Eq (minus n m) p) -> Eq n (plus m p)
postulate le_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> or (Lt n m) (Eq n m)
postulate injective_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn (matita_arithmetics_permutation.invert_permut n f) n)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate False_rect_Type0 : (Q_ : (_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0) -> (x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ x_72)
postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0
postulate dividesb_false_to_not_divides : (n : Nat) -> (m : Nat) -> (_ : Eq (dividesb n m) false) -> not (divisible n m)
postulate ord_rem : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_aop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> ACop B nil
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate div_mod_spec_rect_CProp4 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_839 : Lt _r _m) -> (x_838 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> (x_837 : div_mod_spec _n _m _q _r) -> Q_ x_837
postulate times_times : (x : Nat) -> (y : Nat) -> (z : Nat) -> Eq (times x (times y z)) (times y (times x z))
postulate ACop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903
postulate gcd_1_to_lt_O : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate And_inv_rect_Type2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z341 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (x_136 : cic.Term cic.prop x1) -> (x_135 : cic.Term cic.prop x2) -> (_z342 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_136 x_135))) -> cic.Term univs.Type2 (P (matita_basics_logic.conj x1 x2 x_136 x_135))) -> cic.Term univs.Type2 (P Hterm)
postulate monotonic_iter : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (b : Nat) -> (i : Nat) -> (_ : monotonic Nat Leq g) -> (__1 : Leq a b) -> Leq (iter Nat g i a) (iter Nat g i b)
postulate fold_filter : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (nil : cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (\ i : cic.Term univs.Type0 A -> p i) (\ i : cic.Term univs.Type0 A -> f i) l) (matita_basics_lists_list.fold A B op nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.filter A p l)))
postulate aop : (A : Set) -> (nil : A) -> (_xxx : ACop A nil) -> Aop A nil
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate range_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type4 (Q_ x_917)
postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))
postulate lt_plus_Sn_r : (a : Nat) -> (x : Nat) -> (n : Nat) -> Lt a (plus (plus a x) (plus n 1))
postulate let_clause_1573 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq n m
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\ x : Nat -> p x) B nil (aop__o__op B nil op) (\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\ x : Nat -> f x)))
postulate Prod_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)
postulate range_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_929)
postulate le_min_f_min_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f))
postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate monotonic_lt_minus_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n))
postulate div_mod_spec_ind : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809
postulate le_times_to_le_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : Leq (times b c) a) -> Leq c (div a b)
postulate range_rect_Type2_body : (_A : Set) -> (Q_ : (_x_923 : range _A) -> Type2) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_923 : range _A) -> Q_ x_923
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)
postulate divides_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq m n) -> (__2 : divisible p (minus n m)) -> congruent n m p
postulate minus_plus_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y))
postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n
postulate le_log : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Leq n m) -> Leq (log p n) (log p m)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate ex_prime : (n : Nat) -> (_ : Leq 1 n) -> ex Nat (\ m : Nat -> and (and (Lt n m) (Leq m (plus (factorial n) 1))) (prime m))
postulate le_prim_log : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log b (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_nat.S (matita_arithmetics_log.log b n))))
postulate le_sqrt_log_n : (n : Nat) -> (b : Nat) -> (_ : Lt 2 b) -> Leq (times (sqrt n) (log b n)) n
postulate noLabel_22 : (x : Int) -> if (odd (pow 2 (times 2 x))) (odd (pow 2 (neg (times 2 x))))
postulate div_mod_spec_rect_CProp4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_839 : Lt _r _m) -> (x_838 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> (x_837 : div_mod_spec _n _m _q _r) -> Q_ x_837
postulate exp_to_log_r : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Lt n m) -> (__2 : Leq (pow b n) m) -> Leq n (log b m)
postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z
postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate bertrand_down : (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n (pow 2 8)) -> bertrand n
postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> Eq (min n b f) (plus n b)
postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (mat
postulate tri_symmetric : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.tri_relation A B C)) -> cic.Univ cic.prop
postulate gcd_1_to_lt_O : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (gcd i n) 1) -> Lt 0 i
postulate nat_rect_CProp2 : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)
postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z
postulate nill_body : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a
postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\ b -> even (plus (times a b) (times b c)))
postulate range_inv_ind : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1632 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1633 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate Sum_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))) -> (_H2 : (x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P Hterm)
postulate p_ord_aux_body : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Prod Nat Nat
postulate sqrt_def : (n : Nat) -> Eq (sqrt n) (max (plus n 1) (\ x : Nat -> leb (times x x) n))
postulate let_clause_1571 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m n
postulate or_div_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n q)) q))) (matita_basics_logic.And (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n q) q) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q))))))
postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)
postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192
postulate eq_length_to_mem_all : (n : Nat) -> (l : list Nat) -> (_ : Eq (length Nat l) n) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) -> (i : Nat) -> (__3 : Lt i n) -> mem Nat i l
postulate match_Or : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort) -> (case_or_introl : (__ : cic.Term cic.prop _A) -> cic.Term return_sort (return_type (matita_basics_logic.or_introl _A _B __))) -> (case_or_intror : (__ : cic.Term cic.prop _B) -> cic.Term return_sort (return_type (matita_basics_logic.or_intror _A _B __))) -> (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate void_rect_CProp5_body : (Q_ : (_x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_490)
postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)
postulate gcd_O_to_eq_O : (m : Nat) -> (n : Nat) -> (_ : Eq (gcd m n) 0) -> and (Eq m 0) (Eq n 0)
postulate log_times1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Lt 0 m) -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) 1)
postulate split_eq : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n)) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))))
postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (bigop b (\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\ i : Nat -> f i))
postulate let_clause_1013 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (i : Nat) -> (Hind : (_ : Eq (max i f) m) -> (__1 : Eq (f m) false) -> Eq m 0) -> (fi : Eq (f i) true) -> (eqm : Eq i m) -> (fm : Eq (f m) false) -> Eq false true
postulate match_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)
postulate gcd : (_ : Nat) -> (__1 : Nat) -> Nat
postulate option_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)
postulate Sum_rect_Type1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1) -> (_H_inl : (x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))) -> (_H_inr : (x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))) -> (x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type1 (Q_ x_546)
postulate divides_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) n)
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true
postulate le_iter : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate filter_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)
postulate void_rect_CProp1 : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)
postulate le_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate divides_smallest_factor_n : (n : Nat) -> (_ : Lt 0 n) -> divisible (smallest_factor n) n
postulate divides_gcd_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate not_divides_to_dividesb_false : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (dividesb n m) false
postulate pi2 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term cic.prop (f (matita_basics_types.pi1 A f xxx))
postulate div_mod_spec_rect_Type5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_817 : div_mod_spec _n _m _q _r) -> Type5) -> (_H_div_mod_spec_intro : (x_819 : Lt _r _m) -> (x_818 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_819 x_818)) -> (x_817 : div_mod_spec _n _m _q _r) -> Q_ x_817
postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq n q) -> (__1 : Lt q p) -> Lt (minus q n) (minus p n)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate noLabel_14 : all Int (\ n -> if (even n) (odd (neg (minus (times 5 n) 3))))
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> (__3 : divisible d m) -> (__4 : divisible d n) -> divisible d (gcd_aux p m n)
postulate filter_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)
postulate lstar_inv_ltransitive : (B : Set) -> (R : relation B) -> inv_ltransitive B (lstar B R)
postulate mod_mod : (n : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod n p) (mod (mod n p) p)
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
postulate permut_S_to_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_arithmetics_permutation.permut f m)
postulate option_map_none : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))
postulate range_rect_Type1 : (_A : Set) -> (Q_ : (_x_925 : range _A) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925
postulate not_to_not : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop B) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not B)) -> cic.Term cic.prop (matita_basics_logic.Not A)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate divides_pi_p_M1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate ACop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891
postulate let_clause_1573 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq n m
postulate nat_inv_rect_Type0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) -> (_H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390)) -> cic.Term univs.Type0 (P x_390)) -> (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P Hterm)
postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> 1)) 1
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_791)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate bool_to_nat : (_b : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))
postulate div_mod_spec_rect_CProp3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_847 : Lt _r _m) -> (x_846 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> (x_845 : div_mod_spec _n _m _q _r) -> Q_ x_845
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate eq_fact_pi_p : (n : Nat) -> Eq (factorial n) (bigop (plus n 1) (\ i : Nat -> leb 1 i) Nat 1 times (\ i : Nat -> i))
postulate noLabel_20 : all Int (\ b -> all Int (\ a -> all Int (\ c -> if (and (odd a) (odd c)) (even (plus (times a b) (times b c))))))
postulate let_clause_10331 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n
postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate let_clause_15591 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m n
postulate same_bigop : (k : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\ i : Nat -> p1 i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p2 i) B nil op (\ i : Nat -> g i))
postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\ i : Nat -> 1))
postulate Sig_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1182 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1183 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type3 (P Hterm)
postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1
postulate lt_sqrt_n : (n : Nat) -> (_ : Lt 1 n) -> Lt (sqrt n) n
postulate nat_rect_CProp2_body : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)
postulate Dop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957
postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)
postulate Not_ind_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_80 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> (x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_79)
postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) true) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (op (f k) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)))
postulate max_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> Eq (max n f) m
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_1222 : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> (hd : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> (Hind : (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : (x : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) x tl)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A x) n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A a) n)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 (matita_basics_lists_list.append A a (matita_basics_lists_list.append A (matita_basics_lists_list.map A (\ x0 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> a) l2)))))) n)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2
postulate distributive2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_g : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n
postulate same_bigop : (k : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\ i : Nat -> p1 i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p2 i) B nil op (\ i : Nat -> g i))
postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate div_mod_spec_rect_CProp1_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853
postulate lt_times_to_lt_div : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt n (times m q)) -> Lt (div n q) m
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate lt_div_to_times : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Lt (div n q) m) -> Lt n (times q m)
postulate transitive_congruent : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat (\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_congruence.congruent n m p))
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate range_rect_Type4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type4 (Q_ x_917)
postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Leq (pow n a) (pow m a)
postulate mod_n_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (mod n n) 0
postulate And_rect_Type3_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type3) -> (_H_conj : (x_132 : cic.Term cic.prop _A) -> (x_131 : cic.Term cic.prop _B) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) -> (x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type3 (Q_ x_130)
postulate div_mod_spec_inv_rect_Type0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1464 : div_mod_spec x1 x2 x3 x4) -> Set) -> (_H1 : (x_835 : Lt x4 x2) -> (x_834 : Eq x1 (plus (times x3 x2) x4)) -> (_z1465 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834)) -> P Hterm
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate primeb_true_to_prime : (n : Nat) -> (_ : Eq (primeb n) true) -> prime n
postulate not_found_max_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f matita_arithmetics_nat.O)
postulate Dop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1728 : Dop x1 x2) -> Set) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1729 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate True_discr : (x : cic.Term cic.prop matita_basics_logic.True) -> (y : cic.Term cic.prop matita_basics_logic.True) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x y)) -> cic.Term univs.Type2 (matita_basics_logic.match_True (cic.succ univs.Type2) (\ __ : cic.Term cic.prop matita_basics_logic.True -> cic.univ univs.Type2) (matita_basics_logic.match_True (cic.succ univs.Type2) (\ __ : cic.Term cic.prop matita_basics_logic.True -> cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 P (\ _z5 : cic.Term univs.Type1 P -> P))) y) x)
postulate eq_to_bijn : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Leq i n) -> Eq (f i) (g i)) -> (__1 : bijn f n) -> bijn g n
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate lePsi_r2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))
postulate lt_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 1 p) -> (__1 : Lt n m) -> Lt (pow p n) (pow p m)
postulate divides_fact_to_le : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n))) -> cic.Term cic.prop (matita_arithmetics_nat.le p n)
postulate true_to_andb_true : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)
postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m
postulate let_clause_15624 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate Dop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> cic.univ univs.Type2) (\ t0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \ t1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) -> \ t2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) -> \ t3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) -> matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2) -> cic.univ univs.Type2)
postulate injective_to_injn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f)) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)
postulate let_clause_1532 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m 0
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate le_exp_Psi2 : (n : Nat) -> (_ : Lt 1 n) -> Leq (pow 2 (div n 2)) (Psi n)
postulate le_times_div_div_times : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (times a (div n m)) (div (times a n) m)
postulate Dop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type3 (Q_ x_949)
postulate let_mop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> (_x_969 : cic.Term univs.Type0 B) -> (_x_970 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B
postulate bigop : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H
postulate filter_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : min_spec _n _b _f __) -> return_sort) -> (return : (z : min_spec _n _b _f __) -> return_type z) -> (z : min_spec _n _b _f __) -> return_type z
postulate eq_Bk_B1_B2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_bertrand.B1 n) (matita_arithmetics_chebyshev_bertrand.B2 n)))
postulate mod_cr_pair : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt a m) -> (__1 : Lt b n) -> (__2 : Eq (gcd n m) 1) -> and (Eq (mod (cr_pair m n a b) m) a) (Eq (mod (cr_pair m n a b) n) b)
postulate false_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : Eq (f b) false) -> Eq (min (plus n 1) b f) (min n (plus b 1) f)
postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (plus (mod n m) 1) m) -> Eq (mod (plus n 1) m) (plus (mod n m) 1)
postulate M : (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate Aop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1386 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P Hterm)
postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)
postulate list_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_753 : cic.Term univs.Type0 _A) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_755 : cic.Term cic.prop (Q_ x_752)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_753 x_752))) -> (x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_751)
postulate divides_to_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p)))
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate fmax_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq (f m) false) -> Eq m 0
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate div_mod_spec_rect_Type3 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) -> (_H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> (x_821 : div_mod_spec _n _m _q _r) -> Q_ x_821
postulate le_S_S : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Leq (plus n 1) (plus m 1)
postulate le_max_f_max_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (f i) true) -> Eq (g i) true) -> Leq (max n f) (max n g)
postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate option_map_def : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 (matita_basics_types.option A)) -> cic.Term univs.Type0 B
postulate le_ord_log : (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 1 p) -> Leq (ord n p) (log p n)
postulate le_plus : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (plus n1 m1) (plus n2 m2)
postulate le_S_S_to_le : (n : Nat) -> (m : Nat) -> (_ : Leq (plus n 1) (plus m 1)) -> Leq n m
postulate divides_to_dividesb_true : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (dividesb n m) true
postulate unit_ind : (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_495)
postulate filter_Dop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Dop A _nil) -> return_sort) -> (return : (z : Dop A _nil) -> return_type z) -> (z : Dop A _nil) -> return_type z
postulate prop90 : (n : Nat) -> if (and (even n) (prime n)) (Eq n 2)
postulate sub_hk : (_ : (_ : Nat) -> Nat) -> (__1 : (__1 : Nat) -> Nat) -> (A : Set) -> relation (range A)
postulate divides_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)
postulate let_clause_1692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))
postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)
postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_795)
postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate let_aop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> ACop B nil
postulate let_clause_1531 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate False_rect_Type2 : (Q_ : (_x_70 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type2) -> (x_70 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ x_70)
postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m
postulate le_min_f_min_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> (__2 : Eq (f i) true) -> Eq (g i) true) -> Leq (min n b g) (min n b f)
postulate divides_to_dividesb_true : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (dividesb n m) true
postulate le_div_S_S_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m)))
postulate s : Nat -> Nat
postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times (pow p q) r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)
postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\ x : Nat -> and (and (congruent x a m) (congruent x b n)) (Lt x (times m n)))
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate Dop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)
postulate prime_to_not_divides_fact : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))
postulate eq_times_div_minus_mod : (a : Nat) -> (b : Nat) -> Eq (times (div a b) b) (minus a (mod a b))
postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m
postulate permut_S_to_permut_transpose : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> permut (\ n : Nat -> transpose (f (plus m 1)) (plus m 1) (f n)) m
postulate lt_to_not_eq : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not (Eq n m)
postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate le_exp_priml : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))
postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate And_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (x_144 : cic.Term cic.prop x1) -> (x_143 : cic.Term cic.prop x2) -> (_z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P Hterm)
postulate B_SSSO : Eq (B 3) 6
postulate option_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type4) -> (_H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_591 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> (x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type4 (Q_ x_590)
postulate bool_inv_rect_Type4 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z593 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) -> (_H1 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type4 (P matita_basics_bool.true)) -> (_H2 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type4 (P matita_basics_bool.false)) -> cic.Term univs.Type4 (P Hterm)
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate lt_S_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)
postulate theta_def : (n : Nat) -> Eq (theta n) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> p))
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate list_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)
postulate list_inv_ind : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1302 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_718 : cic.Term univs.Type0 x1) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_720 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_717)) -> cic.Term cic.prop (P x_717)) -> (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_718 x_717))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_718 x_717))) -> cic.Term cic.prop (P Hterm)
postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)
postulate eq_log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_exp.exp p n)) n)
postulate eq_to_bijn : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Leq i n) -> Eq (f i) (g i)) -> (__1 : bijn f n) -> bijn g n
postulate increasing_to_le2 : (f : (_ : Nat) -> Nat) -> (_ : increasing f) -> (m : Nat) -> (__1 : Leq (f 0) m) -> ex Nat (\ i : Nat -> and (Leq (f i) m) (Lt m (f (plus i 1))))
postulate dpi1__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : Aop x0 x1) -> Set) -> (x3 : DPair (Aop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0
postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)
postulate Dop_inv_rect_Type3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1710 : Dop x1 x2) -> Type3) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1711 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate Dexp : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))
postulate congruent_exp_pred_SO : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a))) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_exp.exp a (matita_arithmetics_nat.pred p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate null : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)
postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate let_clause_10333 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1692 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905
postulate sqrt_bound : (n : Nat) -> (_ : Leq (pow 2 8) n) -> Leq (times 2 (plus (log 2 (times 2 n)) 1)) (sqrt (times 2 n))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate le_2_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))
postulate div_times_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)))
postulate list_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)
postulate bigop_distr : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> Eq (let_mop n p B nil R f a a (bigop n (\ i : Nat -> p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (\ i : Nat -> f i))) (bigop n (\ i : Nat -> p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (\ i : Nat -> let_mop n p B nil R f a a (f i)))
postulate f3_ind : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> P a1 a2 a3
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate monotonic_le_plus_l : (m : Nat) -> monotonic Nat Leq (\ n : Nat -> plus n m)
postulate Not_inv_rect_Type2 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) -> (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P Hterm)
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))
postulate div_mod_spec_inv_rect_CProp2 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1482 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_851 : Lt x4 x2) -> (x_850 : Eq x1 (plus (times x3 x2) x4)) -> (_z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate nat_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z677 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type1) -> (_H1 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type1 (P matita_arithmetics_nat.O)) -> (_H2 : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_388 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_386)) -> cic.Term univs.Type1 (P x_386)) -> (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_386))) -> cic.Term univs.Type1 (P (matita_arithmetics_nat.S x_386))) -> cic.Term univs.Type1 (P Hterm)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate Aop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_797)
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate option_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type4) -> (_H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_591 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> (x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type4 (Q_ x_590)
postulate Not : (_A : cic.Univ cic.prop) -> cic.Univ cic.prop
postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) -> (divq : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> (Hind1 :
postulate Aop_rect_CProp3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879
postulate permut_transpose_r : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\ n : Nat -> f (transpose i j n)) m
postulate ACop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type5 (Q_ x_893)
postulate eq_length_to_mem_all : (n : Nat) -> (l : list Nat) -> (_ : Eq (length Nat l) n) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) -> (i : Nat) -> (__3 : Lt i n) -> mem Nat i l
postulate let_clause_1553 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs
postulate rewrite_l : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (P : (__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P x)) -> (y : cic.Term univs.Type2 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term univs.Type2 (P y)
postulate let_clause_16921 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0
postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338
postulate eq_sigma_p_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n q))
postulate noLabel_8 : (n : Nat) -> if (Lt (plus n (div 1 n)) 2) (Lt (plus (pow n 2) (div 1 (pow n 2))) 4)
postulate lhd_cons_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)
postulate div_times_times : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (div a b) (div (times a c) (times b c))
postulate eq_f3 : (A : cic.Univ univs.Type2) -> (B : cic.Univ univs.Type2) -> (C : cic.Univ univs.Type2) -> (D : cic.Univ univs.Type2) -> (f : (__ : cic.Term univs.Type2 A) -> (__1 : cic.Term univs.Type2 B) -> (__2 : cic.Term univs.Type2 C) -> cic.Term univs.Type2 D) -> (x1 : cic.Term univs.Type2 A) -> (x2 : cic.Term univs.Type2 A) -> (y1 : cic.Term univs.Type2 B) -> (y2 : cic.Term univs.Type2 B) -> (z1 : cic.Term univs.Type2 C) -> (z2 : cic.Term univs.Type2 C) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq C z1 z2)) -> cic.Term cic.prop (matita_basics_logic.eq D (f x1 y1 z1) (f x2 y2 z2))
postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate div_times_times : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (div a b) (div (times a c) (times b c))
postulate Aop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_869)
postulate Aop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1548 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1549 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate lprim_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)
postulate eq_rect_Type0 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)
postulate And_rect_CProp3 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_154)
postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_minimization.max_spec_hspec x1 x2 m) matita_basics_bool.true)) -> cic.Term cic.prop (P (matita_arithmetics_minimization.max_spec_img x1 x2 m))) -> cic.Term cic.prop (P x3)
postulate div_theta_theta : (m : Nat) -> Eq (div (theta (plus (times 2 m) 1)) (theta (plus m 1))) (bigop (plus (times 2 m) 2) (\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\ p : Nat -> p))
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate injective_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> injn (invert_permut n f) n
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
postulate range_rect_CProp1 : (_A : Set) -> (Q_ : (_x_937 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937
postulate let_clause_10332 : (n : Nat) -> (le_n : Leq (pow 2 6) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965
postulate sameF_upto : (_ : Nat) -> (A : Set) -> relation (prod Set Set Nat (\ __1 : Nat -> A))
postulate max : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat
postulate mem_map_forward : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l)) -> cic.Term cic.prop (matita_basics_lists_list.mem B (f a) (matita_basics_lists_list.map A B f l))
postulate log_exp1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Leq (log p (pow n m)) (times m (plus (log p n) 1))
postulate max_f_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> Eq (f i) (g i)) -> Eq (max n f) (max n g)
postulate filter_nat : (return_sort : Sort) -> (return_type : (z : Nat) -> return_sort) -> (return : (z : Nat) -> return_type z) -> (z : Nat) -> return_type z
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_15591 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m n
postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate filter_unit : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)
postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)
postulate lt_mod_m_m : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt (mod n m) m
postulate increasing_nth_prime : (n : Nat) -> Lt (nth_prime n) (nth_prime (plus n 1))
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate nat_ind_body : (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) -> (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_365)
postulate not_found_min_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b))
postulate nat_inv_rect_Type1 : (Hterm : Nat) -> (P : (_z677 : Nat) -> Type1) -> (_H1 : (_z678 : Eq Hterm 0) -> P 0) -> (_H2 : (x_386 : Nat) -> (_x_388 : (_z678 : Eq Hterm x_386) -> P x_386) -> (_z678 : Eq Hterm (plus x_386 1)) -> P (plus x_386 1)) -> P Hterm
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate nat_rect_CProp3 : (Q_ : (_x_401 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_402 : Nat) -> (_x_404 : Q_ x_402) -> Q_ (plus x_402 1)) -> (x_401 : Nat) -> Q_ x_401
postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate lt_minus_to_plus : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt (minus a b) c) -> Lt a (plus c b)
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate let_clause_1009 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (Hfn : Eq (f n) false) -> (Hmax : Leq (max m f) n) -> (Hmax0 : Eq (max m f) n) -> (_clearme : and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i m) (\ _ : Lt i m -> Eq (f i) false))) (Eq (max m f) 0)) -> (auto : (i : Nat) -> (_ : Lt i m) -> Eq (f i) false) -> (auto' : Eq (max m f) 0) -> Eq 0 n
postulate div_mod_spec_rect_Type3 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3) -> (_H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> (x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type3 (Q_ x_821)
postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate increasing_nth_prime : (n : Nat) -> Lt (nth_prime n) (nth_prime (plus n 1))
postulate div_mod_spec_inv_rect_Type4 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1440 : div_mod_spec x1 x2 x3 x4) -> Type4) -> (_H1 : (x_815 : Lt x4 x2) -> (x_814 : Eq x1 (plus (times x3 x2) x4)) -> (_z1441 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P Hterm
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate Not_rect_CProp4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)
postulate fact_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt k n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S k))) (matita_arithmetics_nat.minus n k)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k)))
postulate Not_rect_Type3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) -> (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) -> (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type3 (Q_ x_88)
postulate Prod_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1254 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1255 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type2 (P Hterm)
postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1
postulate let_clause_15591 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m n
postulate lstar_ind_body : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231)) -> cic.Univ cic.prop) -> (_H_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> (_H_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1236 : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> (_x_1238 : cic.Term cic.prop (Q_ l b b2 x_1235)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b x_1236 l b2 x_1235 x_1238))) -> (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.l
postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_861)
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate Aop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863
postulate le_1_fact : (n : Nat) -> Leq 1 (factorial n)
postulate prop30 : (n : Nat) -> odd n -> even (plus n 1)
postulate or_div_mod1 : (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> or (and (divisible q (plus n 1)) (Eq (plus n 1) (times (plus (div n q) 1) q))) (and (not (divisible q (plus n 1))) (Eq (plus n 1) (plus (times (div n q) q) (plus (mod n q) 1))))
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0
postulate injective_plus_r : (n : Nat) -> injective Nat Nat (\ m : Nat -> plus n m)
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (mat
postulate nat_rect_CProp1_body : (Q_ : (_x_409 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_410 : Nat) -> (_x_412 : Q_ x_410) -> Q_ (plus x_410 1)) -> (x_409 : Nat) -> Q_ x_409
postulate range_rect_CProp0 : (_A : Set) -> (Q_ : (_x_939 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_939 : range _A) -> Q_ x_939
postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate list_ind2 : (T1 : cic.Univ univs.Type0) -> (T2 : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length T1 l1) (matita_basics_lists_list.length T2 l2))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil T1) (matita_basics_lists_list.nil T2))) -> (__2 : (tl1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (tl2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (hd1 : cic.Term univs.Type0 T1) -> (hd2 : cic.Term univs.Type0 T2) -> (__2 : cic.Term cic.prop (P tl1 tl2)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons T1 hd1 tl1) (matita_basics_lists_list.cons T2 hd2 tl2))) -> cic.Term cic.prop (P l1 l2)
postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)
postulate let_clause_1033 : (n : Nat) -> (le_n : Leq (pow 2 4) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1
postulate not_divides_to_p_ord_O : (n : Nat) -> (i : Nat) -> (_ : not (divisible (nth_prime i) n)) -> Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 n)
postulate Sig_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_686)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate invert_permut : (_ : Nat) -> (__1 : (__1 : Nat) -> Nat) -> (__2 : Nat) -> Nat
postulate gcd_1_to_divides_times_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p m)
postulate divides_minus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (minus p q)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_10332 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate nat_rect_CProp1 : (Q_ : (_x_409 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_410 : Nat) -> (_x_412 : Q_ x_410) -> Q_ (plus x_410 1)) -> (x_409 : Nat) -> Q_ x_409
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate void_rect_Type1 : (Q_ : (_x_487 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type1) -> (x_487 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type1 (Q_ x_487)
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate match_max_spec : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : max_spec _n _f __) -> return_sort) -> (case_found_max_spec : (m : Nat) -> (_ : Lt m _n) -> (__1 : Eq (_f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i _n) -> Eq (_f i) false) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> (case_not_found_max_spec : (_ : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> return_type 0 (not_found_max_spec _n _f __)) -> (_ : Nat) -> (z : max_spec _n _f __) -> return_type __ z
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\ b -> even (plus (times a b) (times b c)))
postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (max (plus m 1) (\ i : Nat -> andb (primeb i) (dividesb i m))) q) -> Eq m (bigop q (\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\ p : Nat -> pow p (ord m p)))
postulate transpose_i_j_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose j i n))
postulate start_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (option_hd Nat (list_of_primes n)) (Some Nat 2)
postulate DPair_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1164 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1165 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)
postulate lstar_ind : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231)) -> cic.Univ cic.prop) -> (_H_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> (_H_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1236 : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> (_x_1238 : cic.Term cic.prop (Q_ l b b2 x_1235)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b x_1236 l b2 x_1235 x_1238))) -> (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate prime_to_gcd_1 : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : not (divisible n m)) -> Eq (gcd n m) 1
postulate nat_inv_rect_CProp1 : (Hterm : Nat) -> (P : (_z707 : Nat) -> Prop) -> (_H1 : (_z708 : Eq Hterm 0) -> P 0) -> (_H2 : (x_410 : Nat) -> (_x_412 : (_z708 : Eq Hterm x_410) -> P x_410) -> (_z708 : Eq Hterm (plus x_410 1)) -> P (plus x_410 1)) -> P Hterm
postulate unit_rect_Type0_body : (Q_ : (_x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0) -> (_H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it)) -> (x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type0 (Q_ x_507)
postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate iter_iter : (A : Set) -> (g : (_ : A) -> A) -> (a : A) -> (b : Nat) -> (c : Nat) -> Eq (iter A g c (iter A g b a)) (iter A g (plus b c) a)
postulate lstar_r_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b)
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n
postulate noLabel_41 : all Int (\ n -> odd (plus (plus (pow n 2) (times 3 n)) 5))
postulate prime_to_primeb_true : (n : Nat) -> (_ : prime n) -> Eq (primeb n) true
postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))
postulate div_mod_spec_rect_Type4 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate filter_Or : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_10335 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (f1 i) (f2 (h i))
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1
postulate list_divides_body : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate iter : (H : Set) -> (_ : (_ : H) -> H) -> (__1 : Nat) -> (__2 : H) -> H
postulate monotonic_lt_plus_r : (n : Nat) -> monotonic Nat Lt (\ m : Nat -> plus n m)
postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate let_clause_1033 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (ndivpr : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> (q0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S q1) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S q1)))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate le_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m))
postulate permut_S_to_permut_transpose : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> permut (\ n : Nat -> transpose (f (plus m 1)) (plus m 1) (f n)) m
postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\ k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod univs.Type0 univs.Type0 matita_arithmetics
postulate nat_ind_body : (Q_ : (_x_365 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_366 : Nat) -> (_x_368 : Q_ x_366) -> Q_ (plus x_366 1)) -> (x_365 : Nat) -> Q_ x_365
postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q)))
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate monotonic_le_plus_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))
postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2)) -> (_x_807 : cic.Term univs.Type0 x0) -> (_x_808 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0
postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967
postulate lt_times_to_lt_div : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt n (times m q)) -> Lt (div n q) m
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate square_double : (n : Nat) -> (_ : Lt 2 n) -> Leq (times (plus n 1) (plus n 1)) (times (times 2 n) n)
postulate monotonic_div : (n : Nat) -> (_ : Lt 0 n) -> monotonic Nat Leq (\ m : Nat -> div m n)
postulate match_min_spec : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) -> (case_found_min_spec : (m : Nat) -> (_ : Leq _b m) -> (__1 : Lt m (plus _n _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> (case_not_found_min_spec : (_ : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> (_ : Nat) -> (z : min_spec _n _b _f __) -> return_type __ z
postulate void_rect_Type4_body : (Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type4 (Q_ x_483)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m
postulate And_rect_Type1 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)
postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)
postulate match_unit : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort) -> (case_it : cic.Term return_sort (return_type matita_basics_types.it)) -> (z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)
postulate increasing_to_le2 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i)))))
postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))
postulate divides_exp_to_eq : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : prime q) -> (__2 : divisible p (pow q m)) -> Eq p q
postulate let_clause_1531 : (n : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (_clearme : divisible n m) -> (d : Nat) -> (eqm : Eq m (times n 0)) -> Eq m 0
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate Dop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate Aop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_789)
postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) true) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (op (f k) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)))
postulate let_clause_1013 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (i : Nat) -> (Hind : (_ : Eq (max i f) m) -> (__1 : Eq (f m) false) -> Eq m 0) -> (fi : Eq (f i) true) -> (eqm : Eq i m) -> (fm : Eq (f m) false) -> Eq false true
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate div_mod_spec_inv_rect_Type4 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1440 : div_mod_spec x1 x2 x3 x4) -> Type4) -> (_H1 : (x_815 : Lt x4 x2) -> (x_814 : Eq x1 (plus (times x3 x2) x4)) -> (_z1441 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P Hterm
postulate not_prime_to_primeb_false : (n : Nat) -> (_ : not (prime n)) -> Eq (primeb n) false
postulate divides_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible m q) -> divisible (times n m) (times p q)
postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)
postulate checker_abl : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true))
postulate unit_rect_CProp2_body : (Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_515)
postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil
postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate f_ind : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (a : A) -> P a
postulate ACop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type2 (Q_ x_897)
postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (_ : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (__1 : Leq (plus m1 n1) (plus m2 n2)) -> Leq n1 n2
postulate sym_eq : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (y : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x y)) -> cic.Term cic.prop (matita_basics_logic.eq A y x)
postulate Dop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)
postulate minus : (_ : Nat) -> (__1 : Nat) -> Nat
postulate nat_inv_rect_CProp2 : (Hterm : Nat) -> (P : (_z701 : Nat) -> Prop) -> (_H1 : (_z702 : Eq Hterm 0) -> P 0) -> (_H2 : (x_406 : Nat) -> (_x_408 : (_z702 : Eq Hterm x_406) -> P x_406) -> (_z702 : Eq Hterm (plus x_406 1)) -> P (plus x_406 1)) -> P Hterm
postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)
postulate Aop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863
postulate lt_to_log_O : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt m n) -> Eq (log n m) 0
postulate lhd : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)
postulate div_mod_spec_rect_Type2 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825
postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))
postulate gcd_SO_n : (n : Nat) -> Eq (gcd 1 n) 1
postulate dividesb_true_to_divides : (n : Nat) -> (m : Nat) -> (_ : Eq (dividesb n m) true) -> divisible n m
postulate inr : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)
postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> (__1 : sub_hk h k A J I) -> (i : Nat) -> (__2 : Lt i (upto A J)) -> Eq (filter A J i) false
postulate exp_fact_2 : (n : Nat) -> Eq (pow (factorial n) 2) (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))
postulate length_unique_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n)
postulate match_And : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ return_sort) -> (case_conj : (__ : cic.Term cic.prop _A) -> (__1 : cic.Term cic.prop _B) -> cic.Term return_sort (return_type (matita_basics_logic.conj _A _B __ __1))) -> (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term return_sort (return_type z)
postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate lt_smallest_factor_to_not_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n))
postulate let_clause_1571 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m n
postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)
postulate pi_p_primeb5 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p :
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate tech_log : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq (log p n) (max (plus n 1) (\ x : Nat -> leb (pow p x) n))
postulate not_prime_SO : not (prime 1)
postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (__1 : Eq (plus l0 1) l) -> ex2 B (\ b : B -> R b1 b) (\ b : B -> lstar B R l0 b b2)
postulate unit_rect_CProp4_body : (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_509)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate fold_true : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (nil : cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (\ i : cic.Term univs.Type0 A -> p i) (\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.cons A a l)) (op (f a) (matita_basics_lists_list.fold A B op nil (\ i : cic.Term univs.Type0 A -> p i) (\ i : cic.Term univs.Type0 A -> f i) l)))
postulate ACop_rect_CProp3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_907 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_907 : ACop A _nil) -> Q_ x_907
postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927
postulate f_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_permutation.invert_permut n f m)) m)
postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\ x : Nat -> p x) B nil (aop__o__op B nil op) (\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\ x : Nat -> f x)))
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (times (pow p q) r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus q1 1) (pow p (plus q1 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1572 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (H : Eq (gcd m n) 0) -> (auto : Eq m 0) -> (auto' : Eq n 0) -> Eq m 0
postulate lt_1_max_prime : (n : Nat) -> (_ : Lt 1 n) -> Lt 1 (max (plus n 1) (\ i : Nat -> andb (primeb i) (dividesb i n)))
postulate option_ind : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) -> (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_586)
postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\ x : Nat -> x) (\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)
postulate let_clause_15441 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a
postulate True_rect_CProp5_body : (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_56)
postulate injn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : injn f (plus n 1)) -> injn f n
postulate let_clause_16003 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate DPair_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_654)
postulate le_ind : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate eq_ind_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term cic.prop (P x p)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate range_discr : (a1 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\ t0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \ t1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \ t2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\ u0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \ u1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \ u2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_ar
postulate lt_1_max_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i n))))
postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2
postulate list_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1326 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_743 : cic.Term univs.Type0 x1) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_745 : (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_742)) -> cic.Term univs.Type1 (P x_742)) -> (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_743 x_742))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.cons x1 x_743 x_742))) -> cic.Term univs.Type1 (P Hterm)
postulate div_plus_times : (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> Eq (div (plus (times q m) r) m) q
postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate eq_to_bijn : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Leq i n) -> Eq (f i) (g i)) -> (__1 : bijn f n) -> bijn g n
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))
postulate eq_minus_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux p m n)) (Eq (minus (times b m) (times a n)) (gcd_aux p m n))))
postulate p_ord_aux_body : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Prod Nat Nat
postulate DPair_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1152 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1153 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)
postulate filter_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (return : (z : div_mod_spec _n _m _q _r) -> return_type z) -> (z : div_mod_spec _n _m _q _r) -> return_type z
postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d
postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 (plus Type2 1) (\ _ : range a1 -> univ Type2) (\ t0 : ((_ : Nat) -> a1) -> \ t1 : Nat -> \ t2 : ((_ : Nat) -> bool) -> match_range a1 (plus Type2 1) (\ _ : range a1 -> univ Type2) (\ u0 : ((_ : Nat) -> a1) -> \ u1 : Nat -> \ u2 : ((_ : Nat) -> bool) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\ _ : Nat -> a1)) t0) u0) (\ e0 : Eq (R0 (prod Set Set Nat (\ _ : Nat -> a1)) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\ _ : Nat -> a1)) t0 (\ x0 : ((_ : Nat) -> a1) -> \ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) (\ e1 : Eq (R1 (prod Set Set Nat (\ _ : Nat -> a1)) t0 (\ x0 : ((_ : Nat) -> a1) -> \ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\ _ : Nat -> a1)) t0 (\ x0 : ((_ : Nat) -> a1) -> \ p0 : Eq t0 x0 -> Nat) t1 (\ x0 : ((_ : Nat) -> a1) -> \ p0 : Eq t0 x0 -> \ x1 : Nat -> \ p1 : Eq (R1 (prod Set Set Nat (\ _ : Nat -> a1)) t0 (\ x00 : ((_ : Nat) -> a1) -> \ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) (\
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0
postulate let_m1 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))
postulate max_to_max_spec : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> max_spec n f m
postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A
postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3
postulate void_rect_CProp1_body : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)
postulate congruent_pi : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> congruent (bigop n (\ i : Nat -> true) Nat 1 times (\ i : Nat -> f i)) (bigop n (\ i : Nat -> true) Nat 1 times (\ i : Nat -> mod (f i) p)) p
postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a))))
postulate lt_O_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt 0 (ord_rem n p)
postulate ACop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1572 : ACop x1 x2) -> Type4) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1573 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate fact : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> (__1 : sub_hk h k A J I) -> (i : Nat) -> (__2 : Lt i (upto A J)) -> Eq (filter A J i) false
postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))
postulate gcd_O_to_eq_O : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))
postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate nat_inv_ind : (Hterm : Nat) -> (P : (_z653 : Nat) -> Prop) -> (_H1 : (_z654 : Eq Hterm 0) -> P 0) -> (_H2 : (x_366 : Nat) -> (_x_368 : (_z654 : Eq Hterm x_366) -> P x_366) -> (_z654 : Eq Hterm (plus x_366 1)) -> P (plus x_366 1)) -> P Hterm
postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Aop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)
postulate divides_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) n)
postulate filter_option : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate lstar_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar x1 x2 x3 x4 x5) -> (P : (_z2089 : Nat) -> (_z2088 : x1) -> (_z2087 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2092 : Eq x3 0) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b) -> P 0 b b) -> (_H2 : (b1 : x1) -> (b : x1) -> (_x_1236 : x2 b1 b) -> (l : Nat) -> (b2 : x1) -> (_x_1235 : lstar x1 x2 l b b2) -> (_x_1238 : (_z2092 : Eq x3 l) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b2) -> P l b b2) -> (_z2092 : Eq x3 (plus l 1)) -> (_z2091 : Eq x4 b1) -> (_z2090 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate let_clause_1075 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (bijf : cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))) -> (fS : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.S n))) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i a)
postulate f2_ind_aux : (A1 : Set) -> (A2 : Set) -> (f : (_ : A1) -> (__1 : A2) -> Nat) -> (P : relation2 A1 A2) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (_ : Lt (f a1 a2) n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> (__1 : Eq (f a1 a2) n) -> P a1 a2) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (__1 : Eq (f a1 a2) n) -> P a1 a2
postulate nat_rect_Type1_body : (Q_ : (_x_385 : Nat) -> Type1) -> (_H_O : Q_ 0) -> (_H_S : (x_386 : Nat) -> (_x_388 : Q_ x_386) -> Q_ (plus x_386 1)) -> (x_385 : Nat) -> Q_ x_385
postulate noLabel_4 : (x : Real) -> if (and (Lt 0 x) (Lt x 1)) (Neq (plus (minus (pow x 2) (times 2 x)) 2) 0)
postulate bijn_transpose_r : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\ p : Nat -> f (transpose i j p)) n
postulate minus_Sn_m : (m : Nat) -> (n : Nat) -> (_ : Leq m n) -> Eq (minus (plus n 1) m) (plus (minus n m) 1)
postulate option_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) -> (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_586)
postulate times_mod : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (mod (times a c) (times b c)) (times c (mod a b))
postulate divides_fact_to_divides : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> ex Nat (\ m : Nat -> and (and (Lt 0 m) (Leq m n)) (divisible p m))
postulate length_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.ltl A l n)) (matita_arithmetics_nat.minus (matita_basics_lists_list.length A l) n))
postulate lt_to_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0
postulate congruent_n_mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> congruent n (mod n (times m p)) p
postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate max_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> Eq (max n f) m
postulate list_ind2 : (T1 : cic.Univ univs.Type0) -> (T2 : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length T1 l1) (matita_basics_lists_list.length T2 l2))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil T1) (matita_basics_lists_list.nil T2))) -> (__2 : (tl1 : cic.Term univs.Type0 (matita_basics_lists_list.list T1)) -> (tl2 : cic.Term univs.Type0 (matita_basics_lists_list.list T2)) -> (hd1 : cic.Term univs.Type0 T1) -> (hd2 : cic.Term univs.Type0 T2) -> (__2 : cic.Term cic.prop (P tl1 tl2)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons T1 hd1 tl1) (matita_basics_lists_list.cons T2 hd2 tl2))) -> cic.Term cic.prop (P l1 l2)
postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate True_rect_CProp5 : (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_56)
postulate Aop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> (P : (_z1416 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1417 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1034 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516))))
postulate ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0
postulate ACop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type3 (Q_ x_895)
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate exp_n_O : (n : Nat) -> Eq 1 (pow n 0)
postulate div_mod_spec_rect_CProp4 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_837 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_839 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_838 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_839 x_838))) -> (x_837 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_837)
postulate eq_times_plus_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : Eq n (plus (times r p) m)) -> congruent n m p
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate let_clause_1572 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> Leq (min n b f) (min m b f)
postulate le_plus_to_minus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b))
postulate eq_rect_Type5_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_7 : cic.Term univs.Type2 A) -> (_x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7)) -> cic.Univ univs.Type5) -> (_H_refl : cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_7 : cic.Term univs.Type2 A) -> (x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7)) -> cic.Term univs.Type5 (Q_ x_7 x_8)
postulate filter_And : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term return_sort (return_type z)
postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)
postulate let_m : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> Nat
postulate nilr_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a nil) a)
postulate filter_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)
postulate eq_gcd_SO_to_not_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (gcd n m) 1) -> not (divisible n m)
