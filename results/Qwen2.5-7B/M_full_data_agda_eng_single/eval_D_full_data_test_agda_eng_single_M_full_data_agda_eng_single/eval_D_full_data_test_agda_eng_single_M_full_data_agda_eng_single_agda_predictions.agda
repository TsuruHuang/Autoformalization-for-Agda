postulate min : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat
postulate divides_gcd_nm : (n : Nat) -> (m : Nat) -> and (divisible (gcd n m) m) (divisible (gcd n m) n)
postulate not : (_A : cic.Univ cic.prop) -> cic.Univ cic.prop
postulate invert_permut : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate reflexive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop
postulate commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min)
postulate Aop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate prop90 : (n : Nat) -> if (and (even n) (prime n)) (Eq n 2)
postulate match_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)
postulate gcd : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate iso : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))
postulate eq_rect_CProp2_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_31 : cic.Term univs.Type2 A) -> (x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Term cic.prop (Q_ x_31 x_32)
postulate nat_rect_CProp3_body : (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_401)
postulate unit_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm)
postulate Sum_rect_Type5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)
postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)
postulate not_divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))
postulate monotonic_le_times_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times n m))
postulate le_gen : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Leq i n) -> P i) -> P n
postulate primes_below_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))
postulate max : Sort -> Sort -> Sort
dpostulate extract_pair : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (D : cic.Univ univs.Type0) -> (u : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (Q : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> (x : cic.Term univs.Type0 C) -> (y : cic.Term univs.Type0 D) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> matita_basics_types.Prod C D) (\ a : cic.Term univs.Type0 A -> \ b : cic.Term univs.Type0 B -> Q a b) u) (matita_basics_types.mk_Prod C D x y))) -> cic.Term cic.prop (matita_basics_logic.ex A (\ a : cic.Term univs.Type0 A -> matita_basics_logic.ex B (\ b : cic.Term univs.Type0 B -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) u) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.mk_Prod C D (Q a b) x) y))))
postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))
postulate range_rect_Type0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type0 (Q_ x_927)
postulate Psi : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate Aop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_861 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_861 : Aop A _nil) -> Q_ x_861
postulate And_inv_rect_CProp1 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm)
postulate lt_O_bc : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m))
postulate f2_ind_aux : (A1 : cic.Univ univs.Type0) -> (A2 : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A1) -> (__1 : cic.Term univs.Type0 A2) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 A1 A2)) -> (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a1 : cic.Term univs.Type0 A1) -> (a2 : cic.Term univs.Type0 A2) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2) n)) -> cic.Term cic.prop (P a1 a2)
postulate distributive2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_g : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop
postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (minus n m) 0
postulate log_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))
postulate le_sqrt_n : (n : Nat) -> Leq (sqrt n) n
postulate div_mod_spec_rect_CProp3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)
postulate match_ex2 : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort) -> (case_ex2_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))) -> (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)
postulate example13 : Eq (nth_prime 4) 11
postulate le_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> (__1 : Leq a (minus b c)) -> Leq (plus a c) b
postulate lstar_lstar_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)
postulate le_n_O_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P n)
postulate B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))
postulate andb_true_r : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)
postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (H : Eq (max (plus n0 1) f) m) -> (H0 : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (H1 : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)
postulate eq_rect_Type0_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type0 (P x p)
postulate Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0
postulate le_Psil1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n)))
postulate monotonic_Psi : monotonic Nat Leq Psi
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate div_mod_spec_inv_rect_CProp3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1476 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_847 : Lt x4 x2) -> (x_846 : Eq x1 (plus (times x3 x2) x4)) -> (_z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm
postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A
postulate not_prime_O : not (prime 0)
postulate void_ind_body : (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_482)
postulate True_rect_CProp3 : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)
postulate match_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)
postulate cons_injective_r : (A : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)
postulate Not_inv_rect_Type2 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) -> (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P Hterm)
postulate mod_mod : (n : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod n p) (mod (mod n p) p)
postulate le_prim_n2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.pred n))
postulate checker_ab : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) (matita_basics_bool.andb (matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S a) b) (matita_arithmetics_nat.leb b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))))
postulate filter_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)
postulate True_rect_Type4 : (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) -> (x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type4 (Q_ x_42)
postulate unit : cic.Univ univs.Type0
postulate le_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n (plus p m)) -> Leq (minus n m) p
postulate let_clause_16 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> (x32 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S x32) (matita_arithmetics_nat.plus x32 (matita_arithmetics_nat.S matita_arithmetics_nat.O)))
postulate void_rect_CProp0_body : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)
postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\ x : Nat -> p x) B nil (aop__o__op B nil op) (\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\ x : Nat -> f x)))
postulate ACop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_913 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_913 : ACop A _nil) -> Q_ x_913
postulate max_O : (f : (_ : Nat) -> bool) -> Eq (max 0 f) 0
postulate mod_aux_body : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate to_max : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n i) -> (__1 : Leq m i) -> Leq (max n m) i
postulate nat_rect_CProp2_body : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)
postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)
postulate div_mod_spec_rect_CProp4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_839 : Lt _r _m) -> (x_838 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> (x_837 : div_mod_spec _n _m _q _r) -> Q_ x_837
postulate injn_Sn_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.injn f n)
postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)
postulate DPair_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1110 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1111 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type4 (P Hterm)
postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (_ : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (__1 : Leq (plus m1 n1) (plus m2 n2)) -> Leq n1 n2
postulate bool_rect_Type0_body : (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) -> (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ x_344)
postulate Aop_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate Dop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_967)
postulate times_n_1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))
postulate sub_hkO : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A I J)
postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)
postulate monotonic_iter : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (b : Nat) -> (i : Nat) -> (_ : monotonic Nat Leq g) -> (__1 : Leq a b) -> Leq (iter Nat g i a) (iter Nat g i b)
postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)
postulate noLabel_20 : all Int (\ b -> all Int (\ a -> all Int (\ c -> if (odd a) (odd c) (even (plus (times a b) (times b c))))))
postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (H : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate iso : (A : Set) -> relation (range A)
postulate minus_Sn_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n))
postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875
postulate sub_hk : (_ : (_ : Nat) -> Nat) -> (__1 : (__1 : Nat) -> Nat) -> (A : Set) -> relation (range A)
postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_863)
postulate eqnot_to_noteq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))
postulate Dop_rect_Type1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)
postulate plus_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n))
postulate le_inv_S1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S x) y)) -> cic.Term cic.prop (matita_basics_logic.ex2 matita_arithmetics_nat.nat (\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.le x z) (\ z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y (matita_arithmetics_nat.S z)))
postulate le_exp_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))
postulate iff_or_l : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (C : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or C A) (matita_basics_logic.Or C B))
postulate filter_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)
postulate And_rect_CProp4 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_146)
postulate All_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l1)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2)) -> cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))
postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> 1)) 1
postulate div_mod_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1434 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_811 : Lt x4 x2) -> (x_810 : Eq x1 (plus (times x3 x2) x4)) -> (_z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm
postulate eq_rect_Type0_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)
postulate let_upper_bound2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))
postulate min_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate le_2_fact : (n : Nat) -> (_ : Lt 1 n) -> Leq 2 (factorial n)
postulate exists_max_forall_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> ex Nat (\ i : Nat -> and (Lt i n) (Eq (f i) true)) (Eq (f (max n f)) true) or (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n) (\ _ : Lt i n -> Eq (f i) false)) (Eq (max n f) 0))
postulate commutative_plus : commutative Nat plus
postulate Prod_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1296 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1297 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)
postulate nat_rect_Type2_body : (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) -> (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type2 (Q_ x_381)
postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)
postulate let_clause_1692 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))
postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 a1 -> \ t1 : cic.Term cic.prop (a2 t0) -> matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 a1 -> \ u1 : cic.Term cic.prop (a2 u0) -> cic.prod (cic.lift univs.Type0 univs.Type2 a1) (cic.lift univs.Type0 univs.Type2 cic.prop) (\ v0 : cic.Term univs.Type0 a1 -> \ v1 : cic.Term cic.prop (a2 v0) -> cic.prod (cic.prop) (cic.prop) (\ P : cic.prop -> cic.prod (cic.prop) (cic.prop) (\ Q : cic.prop -> cic.prod (cic.prop) (cic.prop) (\ R : cic.prop -> cic.prod (cic.prop) (cic.prop) (\ S : cic.prop -> cic.prod (cic.prop) (cic.prop) (\ T : cic.prop -> cic.prod (cic.prop) (cic.prop) (\ U : cic.prop -> cic.prod (cic.prop) (cic.prop) (\ V : cic.prop -> cic.prod (cic.prop
postulate max : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)
postulate mk_Aop : (A : Set) -> (nil : A) -> (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op nil a) a) -> (_nilr : (a : A) -> Eq (op a nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Aop A nil
postulate unit_rect_Type5_body : (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) -> (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) -> (x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type5 (Q_ x_499)
postulate congruent_n_mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> congruent n (mod n (times m p)) p
postulate congruent : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate congruent_ab : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)))
postulate le_plus_to_le : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus a n) (plus a m)) -> Leq n m
postulate Prod_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type0 (Q_ x_702)
postulate plus_plus_comm_23 : (x : Nat) -> (y : Nat) -> (z : Nat) -> Eq (plus (plus x y) z) (plus (plus x z) y)
postulate null_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil)
postulate Sum_rect_Type3 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)
postulate false_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : Eq (f b) false) -> Eq (min (plus n 1) b f) (min n (plus b 1) f)
postulate not_bertrand_to_le2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))
postulate nth_primeS : (n : Nat) -> Eq (nth_prime (plus n 1)) (min (let_upper_bound1 n) (plus (let_previous_prime1 n 1) primeb))
postulate or_div_mod1 : (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> or (divisible q (plus n 1)) (Eq (plus n 1) (times (plus (div n q) 1) q))
postulate lt_plus_to_lt_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)
postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
postulate lt_S_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)
postulate not_prime_to_primeb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)
postulate append_l2_injective : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)
postulate le_B_Psi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))
postulate bigop_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.false) B nil op (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) nil)
postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)
postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil
postulate prop30 : (n : Nat) -> odd n -> even (plus n 1)
postulate Prod_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type5) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type5 (Q_ x_694)
postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P
postulate Prod_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 a1 -> \ t1 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 a1 -> \ u1 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.univ univs.Type1) (\ Q : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.univ univs.Type1) (\ R : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.univ univs.Type1) (\ S : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.univ univs.Type1) (\ T : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.univ univs.Type1) (\ U : cic.Un
postulate exp_to_fact1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))
postulate le_n_Sn : (n : Nat) -> Leq n (plus n 1)
postulate Allr : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop
postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)
postulate exp_sigma_l : (n : Nat) -> (a : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> pow a (f i))) (pow a (bigop n (\ i : Nat -> p i) Nat 0 plus (\ i : Nat -> f i)))
postulate bertrand : (_n : Nat) -> Prop
postulate injn : (_ : (_ : Nat) -> Nat) -> (__1 : Nat) -> Prop
postulate B_SSSSO : Eq (B 4) 6
postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate prim : (_n : Nat) -> Nat
postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m))) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) -> (divq : cic.Term cic.prop (matita_basics_bool.eqb (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> cic.Term cic.prop (matita_basics_bool.eqb n1 (matita_arithmetics_nat.plus (matita_arithmetics
postulate DPair_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type5) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_642 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type5 (Q_ x_642)
postulate log : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate lt_to_not_zero : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not_zero m
postulate option_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_631 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_631))) -> (x_630 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_630)
postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))
postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2
postulate lstar_ind_r : (B : Set) -> (R : relation B) -> (b1 : B) -> (P : relation2 Nat B) -> (_ : P 0 b1) -> (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (plus l 1) b2) -> (l : Nat) -> (b2 : B) -> (__2 : lstar B R l b1 b2) -> P l b2
postulate same_parity : (x : Int) -> (y : Int) -> or (even x) (even y) (or (odd x) (odd y))
postulate predicate : (__ : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate le_exp_to_le1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)
postulate And_ind : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_120 : cic.Term cic.prop _A) -> (x_119 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) -> (x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_118)
postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))
postulate lt_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 6) n) -> Lt (log 2 n) (sqrt n)
postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> (__1 : Lt m (nth_prime (plus n 1))) -> not (prime m)
postulate lt_4_to_le_B_exp : (n : Nat) -> (_ : Lt 4 n) -> Leq (B (times 2 n)) (pow 2 (minus (times 2 n) 2))
postulate lt_to_le_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt n m) -> (__1 : Leq m p) -> Lt n p
postulate le_maxr : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)) -> cic.Term cic.prop (matita_arithmetics_nat.le m i)
postulate Leq : (_ : Nat) -> (__1 : Nat) -> Prop
postulate Prod_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P Hterm)
postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (q : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))
postulate le_Psi_BPsi1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))
postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (plus l 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5
postulate le_times_to_le_div2 : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Leq n (times m q)) -> Leq (div n q) m
postulate noLabel_68 : (n : Int) -> if (odd (minus (times 3 n) 8)) (odd n)
postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate le_to_le_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)
postulate filter_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)
postulate void_rect_Type3 : (Q_ : (_x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type3) -> (x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type3 (Q_ x_485)
postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961
postulate Aop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_789)
postulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)
postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)
postulate Dop_rect_CProp2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_963 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_963 : Dop A _nil) -> Q_ x_963
postulate False_rect_CProp1_body : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)
postulate lt_times_to_lt_div : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt n (times m q)) -> Lt (div n q) m
postulate eq_to_eqb_true : (n : Nat) -> (m : Nat) -> (_ : Eq n m) -> Eq (eqb n m) true
postulate le_2_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))
postulate le_prim_n3 : (n : Nat) -> (_ : Leq 15 n) -> Leq (prim n) (pred (div n 2))
postulate div_times_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)))
postulate B_SSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))))))))
postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)
postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)
postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))
postulate Sum_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 a1 -> matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\ _e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> P)) (\ _z33 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 u0) -> P)) (\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 u0) -> P))) (\ _z3
postulate DPair_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)
postulate div_mod_spec_rect_Type1_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type1) -> (_H_div_mod_spec_intro : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_831 x_830))) -> (x_829 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type1 (Q_ x_829)
postulate le_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))
postulate lists_length_split : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (\ la : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.ex (matita_basics_lists_list.list A) (\ lb : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb))))))
postulate eq_rect_CProp4 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_22 : cic.Term univs.Type2 A) -> (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Term cic.prop (Q_ x_22 x_23)
postulate range_rect_CProp0_body : (_A : Set) -> (Q_ : (_x_939 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_939 : range _A) -> Q_ x_939
postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)
postulate upto_body : (A : Set) -> (_xxx : range A) -> Nat
postulate nat_inv_rect_CProp3 : (Hterm : Nat) -> (P : (_z695 : Nat) -> Prop) -> (_H1 : (_z696 : Eq Hterm 0) -> P 0) -> (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Eq Hterm x_402) -> P x_402) -> (_z696 : Eq Hterm (plus x_402 1)) -> P (plus x_402 1)) -> P Hterm
postulate leb : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate Prod_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)
postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\ _ : Aop a1 a2 -> univ Type2) (\ t : Aop a1 a2 -> univ Type2) x y
postulate nat_rect_CProp0_body : (Q_ : (_x_413 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_414 : Nat) -> (_x_416 : Q_ x_414) -> Q_ (plus x_414 1)) -> (x_413 : Nat) -> Q_ x_413
postulate increasing_to_le2 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i)))))
postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 4) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate div_mod_spec_inv_rect_Type1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1) -> (_H1 : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P Hterm)
postulate inv : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_a : cic.Term univs.Type0 A) -> (_b : cic.Term univs.Type0 A) -> cic.Univ cic.prop
postulate let_clause_10334 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate filter_eq : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (__ : cic.Term univs.Type2 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)
postulate option_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) -> (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_618)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate nat_rect_Type0 : (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) -> (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (Q_ x_389)
postulate let_previous_prime6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate lstar_inv_step : (B : Set) -> (R : relation B) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R 1 b1 b2) -> R b1 b2
postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate nat_rect_Type3 : (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) -> (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type3 (Q_ x_377)
postulate Dop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)
postulate p_ord : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)
postulate eq_rect_CProp1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_34 : cic.Term univs.Type2 A) -> (_x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_34 : cic.Term univs.Type2 A) -> (x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Term cic.prop (Q_ x_34 x_35)
postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))
postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m
postulate pad_bigop_nil : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f i) nil))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n k op f p) nil)
postulate divides_n_n : (n : Nat) -> divisible n n
postulate minus_S_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m))
postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)
postulate le_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> or (Lt n m) (Eq n m)
postulate transitive_lt : transitive Nat Lt
postulate le_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))
postulate exp_1_n : (n : Nat) -> Eq 1 (pow 1 n)
postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)
postulate op_body : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A
postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m
postulate B_SSSSSSSSO : Eq (B 8) 70
postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))
postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_781)
postulate distributive : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop
postulate eq_fact_pi_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))
postulate not_le_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt m n)
postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true
postulate Prod_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_708 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_708)
postulate let_clause_1572 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1))
postulate not_bertrand : (_n : Nat) -> Prop
postulate Dop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)
postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (minus (times 2 n) 3))
postulate pow : (_ : Nat) -> (__1 : Nat) -> Nat
postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n
postulate to_max : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m i)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)
postulate div_mod_spec_rect_CProp2 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_849 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_851 : Lt _r _m) -> (x_850 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> (x_849 : div_mod_spec _n _m _q _r) -> Q_ x_849
postulate match_nat : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ return_sort) -> (case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O)) -> (case_S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term return_sort (return_type z)
postulate map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list B)
postulate flatten : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)
postulate permut_S_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n) n) n)
postulate mem_append_l2 : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2)) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))
postulate lt_smallest_factor_to_not_divides : (n : Nat) -> (i : Nat) -> (_ : Lt 1 n) -> (__1 : Lt 1 i) -> (__2 : Lt i (smallest_factor n)) -> not (divisible i n)
postulate pi_p_primeb1 : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> dividesb (pow p (plus i 1)) n) Nat 1 times (\ i : Nat -> p)))
postulate streicherK : (T : cic.Univ univs.Type2) -> (t : cic.Term univs.Type2 T) -> (P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t))) -> (p : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Term univs.Type2 (P p)
postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat
postulate lt_O_nth_prime_n : (n : Nat) -> Lt 0 (nth_prime n)
postulate divides_fact_to_le : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n))) -> cic.Term cic.prop (matita_arithmetics_nat.le p n)
postulate le_n_Sn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n))
postulate min_prim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (\ __ : cic.Term cic.prop (matita_arithmetics_primes.prime q) -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (\ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p) -> matita_arithmetics_nat.le q n)))))
postulate match_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)
postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m
postulate distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus)
postulate mod_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> Eq (mod (times n m) p) (times (mod n p) (mod m p))
postulate aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0
postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))
postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n
postulate lstar_ind_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b2)
postulate filter_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (return : (z : range _A) -> return_type z) -> (z : range _A) -> return_type z
postulate lenght_to_nil : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))
postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)
postulate le_Psil : (n : Nat) -> Leq (Psi n) (pow n (prim n))
postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (dividesb d n) true) -> Eq (dividesb (div n d) n) true
postulate divides_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))
postulate Aop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867
postulate not_exists_to_forall : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.Not (P i))
postulate Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0
postulate let_clause_15624 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arith
postulate snd : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 B
postulate sub_reflexive : (T : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation T)) -> cic.Term cic.prop (matita_basics_relations.subR T R R)
postulate Exists_forall_lt : (f : (_ : Nat) -> bool) -> (n : Nat) -> ex Nat (\ i : Nat -> and (Lt i n) (Eq (f i) true)) or (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n) (\ _ : Lt i n -> Eq (f i) false)))
postulate ACop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm)
postulate p_ord_inv : (_p : Nat) -> (_m : Nat) -> (_x : Nat) -> Nat
postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)
postulate bceq : (n : Nat) -> (k : Nat) -> Eq (bc n k) (div (factorial n) (times (factorial k) (factorial (minus n k))))
postulate list_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) -> (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) -> (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type3 (Q_ x_731)
postulate reverse_cons : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))
postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)
postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_783 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_783)
postulate lprim_invariant : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i)) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i))
postulate div_theta_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))
postulate not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false))
postulate le_S_S_to_le : (n : Nat) -> (m : Nat) -> (_ : Leq (plus n 1) (plus m 1)) -> Leq n m
postulate nat_rect_CProp0_body : (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_413)
postulate exp_exp_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))
postulate mod_p_ord_inv : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p))
postulate orb_true_r1 : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true)
postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)
postulate divides_d_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : divisible d m) -> (__1 : divisible d n) -> divisible d (gcd n m)
postulate factS : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_factorial.fact n)))
postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : divisible p m) -> not (Eq (ord m p) 0)
postulate minus_S_S : (n : Nat) -> (m : Nat) -> Eq (minus (plus n 1) (plus m 1)) (minus n m)
postulate noLabel_17 : all Int (\ n -> if (even n) (even (times 3 (pow n 5))))
postulate transpose : (_ : Nat) -> (__1 : Nat) -> (__2 : Nat) -> Nat
postulate injn : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\ x : Nat -> x) (\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)
postulate ex2_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) -> (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term cic.prop (Q_ x_274)
postulate le_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)
postulate False_rect_Type0 : (Q_ : (_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0) -> (x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ x_72)
postulate Type2 : cic.Sort
postulate gcd_n_n : (n : Nat) -> Eq (gcd n n) n
postulate exp_Sn : (b : Nat) -> (n : Nat) -> Eq (pow b (plus n 1)) (times b (pow b n))
postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate max_f_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g))
postulate Aop_inv_rect_CProp0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1560 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate Aop_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_885)
postulate Dop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1752 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1753 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\ y : cic.Term univs.Type0 A -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B)) (\ E : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> Q (P (matita_basics_types.fromNone A E)))) x)
postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)
postulate not_zero : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate primes_below_to_bertrand : (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) -> (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ pp : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp)))))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.S pm n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat pm l)
postulate Aop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P Hterm)
postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0
postulate False_rect_CProp1 : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)
postulate Dop : (A : Set) -> (_nil : A) -> Set
postulate square_double : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))
postulate Type3 : cic.Sort
postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369
postulate div_times : (a : Nat) -> (b : Nat) -> (_ : Lt 0 b) -> Eq (div (times a b) b) a
postulate le_theta_M_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_binomial.M m) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m))))
postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate div_mod_spec_rect_CProp5 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) -> (x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_841)
postulate nat_case : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)
postulate not_lt_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)
postulate ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))
postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381
postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_879)
postulate lt_1_to_le_exp_B : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))
postulate B_SSSSSSO : Eq (B 6) 20
