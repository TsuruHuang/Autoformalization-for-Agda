asics_logic.False$ and $matita_basics_lists_list.nil$ applied to $A$, for all elements $Hcons$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $n$, for all elements $Hl1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $n$, for all elements $Hl2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $n$, for all elements $Hposn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $posn$ and $n$, for all elements $Hlen$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $n$, for all elements $Ha$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arith
 postulate Le_iter : (g : Nat -> Nat) -> (a : Nat) -> (f : Nat -> Leq a (g a)) -> (i : Nat) -> Leq a (iter Nat g i a)
 postulate theta_def : (n : Nat) -> theta n == bigop (sum n 1) (\p -> primeb p Nat 1) (\p -> times p)
 postulate Bk : forall n : Nat ->
 postulate minus_to_plus : (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x : cic.Term univs.Type2 matita_arithmetics_nat.le m n) (y : cic.Term univs.Type2 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat n) (matita_arithmetics_nat.minus n m p)) → cic.Term univs.Type2 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat n) (matita_arithmetics_nat.plus m p).
 postulate Sig : (A : Univ univs.Type0) (f : Term univs.Type0 A -> Univ univs.Type0) -> Univ univs.Type0
 postulate Nat_rect_CProp3 : {Q_ : cic.Term univs.Type0 matita_arithmetics_nat.nat cic.prop} (H_O : cic.Term cic.prop) (H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_404 : cic.Term cic.prop) Q_ (matita_arithmetics_nat.S x_402) x_404) (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) Q_ x_401.
 postulate Sig_rect_Type2_body : {A : cic.Univ} {A1 : cic.Univ} {A2 : cic.Univ} {A3 : cic.Univ} {A4 : cic.Univ} {A5 : cic.Univ} {A6 : cic.Univ} {A7 : cic.Univ} {A8 : cic.Univ} {A9 : cic.Univ} {A10 : cic.Univ} {A11 : cic.Univ} {A12 : cic.Univ} {A13 : cic.Univ} {A14 : cic.Univ} {A15 : cic.Univ} {A16 : cic.Univ} {A17 : cic.Univ} {A18 : cic.Univ} {A19 : cic.Univ} {A20 : cic.Univ} {A21 : cic.Univ} {A22 : cic.Univ} {A23 : cic.Univ} {A24 : cic.Univ} {A25 : cic.Univ} {A26 : cic.Univ} {A27 : cic.Univ} {A28 : cic.Univ} {A29 : cic.Univ} {A30 : cic.Univ} {A31 : cic.Univ} {A32 : cic.Univ} {A33 : cic.Univ} {A34 : cic.Univ} {A35 : cic.Univ} {A36 : cic.Univ} {A37 : cic.Univ} {A38 : cic.Univ} {A39 : cic.Univ} {A40 : cic.Univ} {A41 : cic.Univ} {A42 : cic.Univ} {A43 : cic.Univ} {A44 : cic.Univ} {A45 : cic.Univ} {A46 : cic.Univ} {A47 : cic.Univ} {A48 : cic.Univ} {A49 : cic.Univ} {A50 : cic.Univ} {A51 : cic.Univ} {A52 : cic.Univ} {A53 : cic.Univ} {A54 : cic.Univ} {A55 : cic.Univ} {A56 : cic.Univ} {A
 postulate times_2_pred : (n : ℕ) → (2 * (pred n) ≤ (pred (2 * n)))
 postulate Bool_to_nat : {b : cic.Term univs.Type0 matita_basics_bool.bool} -> cic.Term univs.Type0 matita_arithmetics_nat.nat
 postulate Div_mod_spec_rect_CProp0 : \n  (n : cic.Term of cic.prop)\n  (m : cic.Term of cic.prop)\n  (q : cic.Term of cic.prop)\n  (r : cic.Term of cic.prop)\n  (Q : (x : cic.Term of cic.prop) -> \n    matita_arithmetics_div_and_mod.div_mod_spec (eval n) (eval m) (eval q) (eval r) x -> \n    cic.Term of cic.prop) -> \n  (H_div_mod_spec_intro : (x : cic.Term of cic.prop) -> \n    matita_arithmetics_nat.lt (eval r) (eval m) -> \n    (x_858 : cic.Term of cic.prop) -> \n    matita_arithmetics_nat.eq (cic.lift univs.Type0) (cic.lift univs.Type2) (cic.lift matita_arithmetics_nat.nat) (eval n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (eval q) (eval m)) (eval r)) x -> \n    Q x (matita_arithmetics_div_and_mod.div_mod_spec_intro (eval n) (eval m) (eval q) (eval r) x_859 x_858)) -> \n  cic.Term of cic.prop
 postulate Nat_elim1 : {n : Nat} {P : Nat -> Prop} {f : Nat -> (m : Nat) -> (p : Lt m n) -> (x : P p) -> P m} -> P n
 postulate increasing_nth_prime : (n : ℕ) → nth_prime n < nth_prime (suc n)
 postulate let_clause_1692 : \n  (\ m : Nat ) → \n  ( m > 0 ) → \n  (\ a x358 x359 : Nat ) → \n  ( aop__o__op Nat 0 plusAC x358 (x358 * x359) ) ≡ \n  ( x358 * (x359 + 1) )
 postulate Injective_exp_r : (b : Nat) -> (1 < b) -> (injective (Nat -> Nat) (Nat -> Nat) (nat_pow b))
 postulate Le_S_S : ∀ (n m : ℕ) → n ≤ m → n + 1 ≤ m + 1
 postulate gcd_mod : (m n : ℕ) → (0 < n) → gcd n (mod m n) ≡ gcd m n
 postulate Fmax_false : (f : (cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (cic.Term univs.Type0 matita_basics_bool.bool)) -> (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (cic.Term univs.Type0 matita_arithmetics_minimization.max n (f) m) -> (y : cic.Term univs.Type0 matita_basics_bool.bool) -> (cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2) (matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n (f) m) (matita_arithmetics_nat.O)) -> (cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2) (matita_basics_bool.bool) (f) (matita_basics_bool.false)) -> (cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2) (matita_arithmetics_nat.nat) m (matita_arithmetics_nat.O)).
 postulate reverse_reverse : \n  {S : Univ.{0}} {l : Term.{0} S (List S)}\n  (eq : Term.{0} S (lift univs.Type0 univs.Type2) (reverse (reverse S) l) l)\n  → Prop
 postulate le_to_mod : ∀ n m → n < m → n ≡ mod n m
 postulate range_rect_CProp1_body : {A : Set} → (Q : range A → Set) → ((H_mk_range : (enum : ℕ → A) → (upto : ℕ) → (filter : ℕ → Bool) → Q (mk_range A enum upto filter))) → (x_937 : range A) → Q x_937
 of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ and functions $prod$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and functions $prod$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ and functions $prod$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_zero$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and functions $prod$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $un
 postulate Pair_elim : forall (A : Univ) (B : Univ) (C : Univ) (T : Term Univ A B -> Term Univ A B -> Univ) (p : Term Univ A (Prod Univ A B)) (P : Term Univ A (Prod Univ A B) -> Univ) (lft : Term Univ A A) (rgt : Term Univ A B) (pr : eq Univ Type0 (Prod Univ A B) p (mk_Prod Univ A B lft rgt)) (pr' : eq Univ Type2 (Prod Univ A B) p (mk_Prod Univ A B lft rgt)) (pr'' : P (mk_Prod Univ A B lft rgt) -> T lft rgt p (match_Prod Univ A B univs.Type0 (fun lft => C) (fun lft rgt => T lft rgt p) pr' pr'') (eq_fun Univ Type2 (mk_Prod Univ A B) (mk_Prod Univ A B) pr' pr'')) : Univ
 postulate lt_1_max_prime : ∀ (n : ℕ) → 1 < n → 1 < max (n + 1) (λ i → andb (primeb i) (dividesb i n))
 postulate smallest_factor_to_min : {n : cic.Term univs.Type0} {__ : cic.Term (cic.prop univs.Type2 matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))} (H : matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) n) -> cic.Term (cic.prop univs.Type2 matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))) (matita_arithmetics_primes.smallest_factor n (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))) (lambda m -> matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))
 postulate lt_times : (n m p q : ℕ) → (n < m) → (p < q) → (n * p) < (m * q)
.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$, we can prove that $P$ applied to $a$ and $op$ applied to $x2$ and $a$ is equal to $P$ applied to $a$ and $op$ applied to $x2$ and $a$.\nOutput:\n\nAssistant: postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ) (x2 : cic.Term x1) (Hterm : cic.Term x1) (matita_arithmetics_bigops.Aop x1 x2) (P : cic.Term x1 matita_arithmetics_bigops.Aop x1 x2 cic.Univ cic.prop) (H : (op : cic.Term x1 x2 cic.Term x1 x2) (nill : cic.Term x1 (matita_arithmetics_bigops.Aop x1 x2) cic.prop) (nilr : cic.Term x1 (matita_arithmetics_bigops.Aop x1 x2) cic.prop) (a : cic.Term x1 x2) (op (x2 : cic.Term x1 x2) a) (a) (P a (op x2 a)) (op (x2 : cic.Term x1 x2) a) (a) (P a (op x2 a)) (a) (P a (op x2 a))) → P a (op x2 a) (P a (op x2 a)).
 postulate Sig_rect_Type5_body : \n  {A : cic.Univ} \n  {H_A : univs.Type0 A} \n  {f : cic.Term A} \n  {H_f : univs.Type0 f} \n  {Q : cic.Term A f} \n  {H_Q : univs.Type5 A f Q} \n  {H_H_mk_Sig : \n    (pi1 : cic.Term A) \n    (H_pi1 : univs.Type0 pi1) \n    (pi2 : cic.Term A) \n    (H_pi2 : univs.Type5 pi1 f pi2) \n    (x_668 : cic.Term A) \n    (H_x_668 : univs.Type0 x_668) \n    (H_Q_x_668 : univs.Type5 x_668 f (Q x_668)) \n    (H_f_x_668 : univs.Type0 (f x_668)) \n    (H_Q_x_668_f_x_668 : univs.Type5 x_668 f (Q x_668) (f x_668)) \n    (H_Q_x_668_f_x_668_pi2 : univs.Type5 x_668 f (Q x_668) pi2) \n    (H_Q_x_668_f_x_668_pi2_x_668 : univs.Type5 x_668 f (Q x_668) (x_668)) \n    (H_Q_x_668_f_x_668_pi2_x_668_pi2 : univs.Type5 x_668 f (Q x_668) pi2) \n    (H_Q_x_668_f_x_668_pi2_x_668_pi2_pi2 : univs.Type5 x_668 f (Q x_668) pi2) \n    (H_Q_x_668_f_x_668_pi2_x_668_pi2_pi2_pi2 : univs.Type5 x_668 f (Q x_668) pi2)
 postulate prime_to_not_divides_fact : \n  {p : cic.Term univs.Type0 matita_arithmetics_nat.nat} {p : matita_arithmetics_primes.prime p} \n  {n : cic.Term univs.Type0 matita_arithmetics_nat.nat} {n : matita_arithmetics_nat.lt n p} \n  (cic.Term : cic.prop) (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))
 postulate B : ∀ (n : cic.Term univs.Type0) (m : matita_arithmetics_nat.nat) → cic.Term univs.Type0 matita_arithmetics_nat.nat
 postulate Let_clause_1560 : forall (n m : Nat) (d : Nat), Divisible m n -> n = 0 -> m = n * d -> n = 0
 postulate lt_to_le : \n  {x y : cic.Term univs.Type0 matita_arithmetics_nat.nat} \n  {P : cic.Term univs.Type0 cic.prop matita_arithmetics_nat.lt x y} \n  -> cic.Term univs.Type0 cic.prop (matita_arithmetics_nat.le x y)
 postulate True_inv_rect_Type2 : (Hterm : Term prop) (P : (z143 : Term prop) (T : Univ Type2) (H : (lift prop) (Type2) T I (eq (lift prop) (Type2) T I Hterm I)) → Univ Type2) (H : (lift prop) (Type2) (Type2) I T) → Term Type2 (P Hterm T H)
 postulate Mk_ACop : {A : Set} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop A nil} {nil : A} {aop : Aop A nil} {a b : A} {op : Aop
 postulate void_rect_CProp3_body : (Q_ : (cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ) -> (x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_491)
 postulate divides_to_le : ∀ (n m : ℕ) → 0 < m → Divides m n → n ≤ m
 postulate filter_false : forall {A : Univ} {l : List A} {a : A} {p : A -> Bool}, (p a) == False -> List A == filter p l
 postulate R1 : \n  forall A : cic.Univ univs.Type2,\n    forall x : cic.Term univs.Type2 A,\n    forall Q_ : (x_19 : cic.Term univs.Type2 A) -> \n      (x_20 : cic.Term univs.Type0 (matita_basics_logic.eq A x x_19)) -> \n      cic.Term univs.Type0 (Q_ x (matita_basics_logic.refl A x)),\n    forall x_19 : cic.Term univs.Type2 A,\n    forall x_20 : cic.Term univs.Type0 (matita_basics_logic.eq A x x_19),\n    cic.Term univs.Type0 (Q_ x_19 x_20).
 postulate lt_sigma_p : forall (n : Nat) (p1 p2 : Nat -> Bool) (g1 g2 : Nat -> Nat) (i : Nat) (l : Lt i n) (e1 : Eq (p1 i) true) (e2 : Eq (p2 i) true) (e3 : Lt (g1 i) (g2 i)) (e4 : Ex (Nat) (fun i => Lt i n /\ (Eq (p1 i) true \/ Lt (g1 i) (g2 i)) /\ (Eq (p1 i) absurdity /\ Eq (p2 i) true /\ Lt 0 (g2 i)))) -> (i : Nat) -> (p1 i : Bool) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (g1 i : Nat) -> (i : Nat) -> (p2 i : Bool) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (g2 i : Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (plus : Nat -> Nat -> Nat) -> (Nat : Set) -> (0 : Nat) -> (
 postulate Rev_append_body : \n  forall {H : cic.Univ} {__ : cic.Term} {__1 : cic.Term} {xs : matita_basics_lists_list.list H},\n  cic.Term univs.Type0 (matita_basics_lists_list.list H) __ __1 xs
 $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$
 postulate bc1 : \n  (n k : cic.Term univs.Type0 matita_arithmetics_nat.nat) \n  (p : cic.Term cic.prop matita_arithmetics_nat.lt k n) \n  (q : cic.Term cic.prop matita_basics_logic.eq \n    (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat \n      (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S k) \n        (matita_arithmetics_nat.plus (matita_arithmetics_binomial.bc n k) (matita_arithmetics_binomial.bc n (matita_arithmetics_nat.S k))))) \n    p)
 postulate ord_exp : (p m : ℕ) → (1 < p) → (ord (p ^ m) p) ≡ m
 postulate Lhd_cons_ltl : \n  {A : cic.Univ} {n : matita_arithmetics_nat.nat} \n  {l : cic.Term} {l' : matita_basics_lists_list.list A} \n  (H : cic.Term A (univs.Type0)) \n  (H' : cic.Term A (univs.Type0)) \n  (H'' : cic.Term A (univs.Type0)) \n  (H''' : cic.Term A (univs.Type0)) \n  (H'''' : cic.Term A (univs.Type0)) \n  (H''''' : cic.Term A (univs.Type0)) \n  (H'''''' : cic.Term A (univs.Type0)) \n  (H''''''' : cic.Term A (univs.Type0)) \n  (H'''''''' : cic.Term A (univs.Type0)) \n  (H''''''''' : cic.Term A (univs.Type0)) \n  (H'''''''''' : cic.Term A (univs.Type0)) \n  (H''''''''''' : cic.Term A (univs.Type0)) \n  (H'''''''''''' : cic.Term A (univs.Type0)) \n  (H''''''''''''' : cic.Term A (univs.Type0)) \n  (H'''''''''''''' : cic.Term A (univs.Type0)) \n  (H''''''''''''''' : cic.Term A (univs.Type0)) \n  (H'''''''''''''''' : cic.Term A (univs.Type0)) \n  (H''''''''''''''''' : cic.Term A (univs.Type0)) \n  (H'''''''''''''''''' : cic.Term A (univs.Type0)) \n  (H''''''''''''''''''' : cic.Term A (univs.Type0)) \n  (H'''''''''''''''''''' : cic.Term A (univs.Type0)) \n  (H''''''''''''''''''''' : cic.Term A (univs.Type0)) \n  (H'''''''''''''''''''''' : cic.Term A (un
 postulate Le_smallest_factor_n : (n : ℕ) → smallest_factor n ≤ n
 postulate associative_times : cic.Term (cic.prop) (matita_basics_relations.associative (matita_arithmetics_nat.nat) (matita_arithmetics_nat.times))
 postulate Mem_append : \n  forall (A : Univ) (a : Term A) (l1 l2 : List A),\n  mem A a (append A l1 l2) <-> mem A a l1 \/ mem A a l2.
 postulate Le : {a b : cic.Term} {t : univs.Type0} {n m : matita_arithmetics_nat.nat} {A : cic.Univ} (a : cic.Term) (b : cic.Term) (t : univs.Type0) (n m : matita_arithmetics_nat.nat) (A : cic.Univ) → cic.Univ
 postulate eq_mod_to_divides : {n : cic.Term univs.Type0} {m : cic.Term univs.Type0} {q : cic.Term univs.Type0} {n' : matita_arithmetics_nat.nat} {m' : matita_arithmetics_nat.nat} {q' : matita_arithmetics_nat.nat} {P : cic.Term cic.prop matita_arithmetics_nat.lt matita_arithmetics_nat.O q} {P1 : cic.Term cic.prop matita_arithmetics_nat.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q)} (n'' : matita_arithmetics_nat.nat) (m'' : matita_arithmetics_nat.nat) (q'' : matita_arithmetics_nat.nat) (P'' : cic.Term cic.prop matita_arithmetics_nat.lt matita_arithmetics_nat.O q'') (P1' : cic.Term cic.prop matita_arithmetics_nat.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n'' q'') (matita_arithmetics_div_and_mod.mod m'' q'')) (cic.Term cic.prop (matita_arithmetics_primes.divides q'' (matita_arithmetics_nat.minus n'' m''))).
 postulate ACop_rect_CProp4_body : \n  forall {A : Set} {_nil : A} {Q_ : (x_903 : ACop A _nil) -> Prop}\n  {_H_mk_ACop : (aop : Aop A _nil) -> (a : A) -> (b : A) -> (op : Eq A _nil) (aop : Aop A _nil) (a : A) (b : A) -> (op : Eq A _nil) (aop : Aop A _nil) (a : A) (b : A) -> (op : Eq A _nil) (aop : Aop A _nil) (a : A) (b : A) -> Q_ (mk_ACop A _nil aop) \n  ACop_rect_CProp4_body {A} {_nil} {Q_} {_H_mk_ACop} {x_903} = Q_ x_903
 postulate example12 : nth_prime 3 ≡ 7
 postulate Permut_to_bijn : {n : ℕ} {f : ℕ → ℕ} {p : permut f n} → bijn f n
 postulate List_rect_Type2 : {A : Univ} {Q : Term A Type0 -> List A -> Univ} {H_nil : Term (Q (nil A) []) Type2} {H_cons : (x : Term A Type0) (xs : List A) (x' : Term (Q x xs) Type2) (x'' : Term (Q (cons A x xs) (x' : Term (Q x xs) Type2) (xs : List A) (x' : Term (Q x xs) Type2) -> Univ) -> Term (Q (cons A x xs) (x' : Term (Q x xs) Type2) (xs : List A) (x' : Term (Q x xs) Type2) -> Univ) -> Univ) -> Term (Q (cons A x xs) (x' : Term (Q x xs) Type2) (xs : List A) (x' : Term (Q x xs) Type2) -> Univ) -> Univ} -> (x : Term A Type0) (xs : List A) -> Term (Q x xs) Type2
 postulate Lt_to_le_to_lt_times : {n : cic.Term univs.Type0} {m : cic.Term univs.Type0} {p : cic.Term univs.Type0} {q : cic.Term univs.Type0} {__ : cic.Term univs.Type0} {__1 : cic.Term univs.Type0} {__2 : cic.Term univs.Type0} (lt_n_m : matita_arithmetics_nat.lt n m) (le_p_q : matita_arithmetics_nat.le p q) (lt_O_q : matita_arithmetics_nat.lt matita_arithmetics_nat.O q) => matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times m q)
s.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$ and $a$ to $P$ applied to $a$ and $op$ applied to $x2$
 postulate permut_S_to_permut_transpose : \n  {f : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat}\n  {m : cic.Term univs.Type0 matita_arithmetics_nat.nat}\n  {P : cic.Term univs.Type0 matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m)}\n  {n : cic.Term univs.Type0 matita_arithmetics_nat.nat}\n  {P' : cic.Term univs.Type0 matita_arithmetics_permutation.permut (matita_arithmetics_permutation.transpose f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n) m}\n  P -> P'.
 postulate Aop_rect_Type5_body : \n  (A : Set) \n  (_nil : A) \n  (Q_ : (x_865 : Aop A) (nil : A) → Set) \n  (_H_mk_Aop : (op : A → A → A) (nill : A → Eq (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _) (op _nil _)
 postulate unit_ind_body : {Q : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop} {H_it : cic.Term cic.prop} {x_495 : cic.Term univs.Type0 matita_basics_types.unit} -> Q x_495 H_it -> cic.Term cic.prop Q x_495
 postulate divides_minus : (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (h : matita_arithmetics_primes.divides n p) (h1 : matita_arithmetics_primes.divides n q) -> cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.minus p q))
 postulate Le_times_to_le : {a : Term prop} {n m : nat} {lt0 : lt O a} {le0 : le (times a n) (times a m)} → le n m
 postulate le_to_leb_true : \n  {n m : cic.Term univs.Type0 matita_arithmetics_nat.nat}\n  {p : cic.Term univs.Type2 matita_arithmetics_nat.le n m} \n  {q : cic.Term univs.Type2 matita_basics_bool.bool} \n  (H : p) \n  (H1 : q) \n  (H2 : matita_arithmetics_nat.leb n m q) \n  (H3 : matita_basics_bool.true q) \n  (H4 : matita_arithmetics_nat.leb n m matita_basics_bool.true) \n  (H5 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m q matita_basics_bool.true) \n  (H6 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m matita_basics_bool.true matita_basics_bool.true) \n  (H7 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m q matita_basics_bool.true) \n  (H8 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m matita_basics_bool.true matita_basics_bool.true) \n  (H9 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m q matita_basics_bool.true) \n  (H10 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m matita_basics_bool.true matita_basics_bool.true) \n  (H11 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m q matita_basics_bool.true) \n  (H12 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m matita_basics_bool.true matita_basics_bool.true) \n  (H13 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics_nat.leb n m q matita_basics_bool.true) \n  (H14 : matita_basics_bool.eq matita_basics_bool.bool matita_arithmetics
 postulate Bool_rect_Type3_body : {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type3 matita_basics_bool.true -> cic.Term univs.Type3} -> {cic.Term univs.Type3 matita_basics_bool.false -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3} -> {cic.Term
 postulate le_x_times_x : {x : Term Type0} {n : nat} -> prop le x (times x x)
 postulate Range_rect_CProp4_body : ∀ {A : Set} → (Q : (x_929 : range A) → Set) → ((H_mk_range : (H_enum : (n : ℕ) → A) → (upto : ℕ) → (filter : (n : ℕ) → Bool) → Q (mk_range A H_enum upto filter))) → ((x_929 : range A) → Q x_929)
 postulate prop80 : even 2
 postulate axiom : ∀ (_l : List ℕ) (_n : ℕ) → primes_below _l _n
 postulate Le_div : ∀ (n m : ℕ) → 0 < n → n ≤ m → n ≤ m
 postulate Unit_rect_Type3_body : (Q_ : (x_501 : cic.Term univs.Type0) (matita_basics_types.unit) -> cic.Term univs.Type3) (H_it : cic.Term univs.Type3 (Q_ matita_basics_types.it)) (x_501 : cic.Term univs.Type0) (H_it_0 : matita_basics_types.unit) -> cic.Term univs.Type3 (Q_ x_501)
 postulate not_le_to_leb_false : forall (n m : Nat), not (le n m) -> leb n m = absurdity
 postulate Divides_to_not_ord_O : (p m : cic.Term) (p_type m_type : univs.Type0) (m_nat : matita_arithmetics_nat.nat) (m_lt : matita_arithmetics_nat.lt matita_arithmetics_nat.O m) (p_prime : matita_arithmetics_primes.prime p) (p_divides_m : matita_arithmetics_primes.divides p m) : cic.Term (cic.prop) (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0) univs.Type2 matita_arithmetics_nat.nat (matita_arithmetics_ord.ord m p matita_arithmetics_nat.O)))
 postulate monotonic_le_plus_l : (m : cic.Term univs.Type0) (n : matita_arithmetics_nat.nat) → cic.Term (cic.prop) (matita_basics_relations.monotonic (matita_arithmetics_nat.nat) (matita_arithmetics_nat.le) (λ n → matita_arithmetics_nat.plus n m))
 postulate Z : Nat
 postulate injective_plus_l : {n : Term (univs.Type0)} {m : matita_arithmetics_nat.nat} (p : cic.prop) (i : matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\m' -> matita_arithmetics_nat.plus m' n)) -> p
 postulate True_to_le_min : {n : ℕ} {m : ℕ} {b : Bool} {f : ℕ → Bool} → b ≤ m → f m ≡ true → min n b (f) ≤ m
 postulate Lstar_r_O : \n  {B : cic.Univ} {R : cic.Term B} {b : cic.Term B} \n  {p : matita_basics_relations.relation B R} \n  {q : cic.prop B} {r : cic.prop B} {s : cic.prop B} \n  {t : cic.prop B} {u : cic.prop B} {v : cic.prop B} \n  {w : cic.prop B} {x : cic.prop B} {y : cic.prop B} \n  {z : cic.prop B} {aa : cic.prop B} {ab : cic.prop B} \n  {ac : cic.prop B} {ad : cic.prop B} {ae : cic.prop B} \n  {af : cic.prop B} {ag : cic.prop B} {ah : cic.prop B} \n  {ai : cic.prop B} {aj : cic.prop B} {ak : cic.prop B} \n  {al : cic.prop B} {am : cic.prop B} {an : cic.prop B} \n  {ao : cic.prop B} {ap : cic.prop B} {aq : cic.prop B} \n  {ar : cic.prop B} {as : cic.prop B} {at : cic.prop B} \n  {au : cic.prop B} {av : cic.prop B} {aw : cic.prop B} \n  {ax : cic.prop B} {ay : cic.prop B} {az : cic.prop B} \n  {ba : cic.prop B} {bb : cic.prop B} {bc : cic.prop B} \n  {bd : cic.prop B} {be : cic.prop B} {bf : cic.prop B} \n  {bg : cic.prop B} {bh : cic.prop B} {bi : cic.prop B} \n  {bj : cic.prop B} {bk : cic.prop B} {bl : cic.prop B} \n  {bm : cic.prop B} {bn : cic.prop B} {bo : cic.prop B} \n  {bp : cic.prop B} {bq : cic.prop B} {br : cic.prop B} \n  {bs : cic.prop B} {bt : cic.prop B} {bu : cic.prop B} \n  {bv : cic.prop B} {bw : cic.prop B} {bx : cic.prop B} \n  {by : cic
n$ and $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_gcd.gcd
 postulate Divides_gcd_mod : \n  (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  (h : cic.Term univs.Type0 matita_arithmetics_nat.lt matita_arithmetics_nat.O n)\n  (h1 : cic.Term univs.Type0 matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)))
$ and the function that maps $i$ to $g$ applied to $i$ and $B$ and $nil$.\n\nAssistant: postulate bigop_op : (k : cic.Term univs.Type0) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) (f g : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term univs.Type0 B
 postulate lt_O_exp : (n m : cic.Term) (p : cic.prop) (lt_O_n : matita_arithmetics_nat.lt matita_arithmetics_nat.O n) (lt_O_exp_nm : matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_exp.exp n m)) : cic.Term
 postulate Fact_body : (n : Nat) -> True
 postulate symmetric : (A : Univ) (R : Univ → Univ → Univ) → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ
 postulate minus_n_n : ∀ (n : ℕ) → 0 ≡ n - n
 postulate xorb : (a b : cic.Term univs.Type0 matita_basics_bool.bool) → cic.Term univs.Type0 matita_basics_bool.bool
 postulate Range_inv_rect_Type0 : \n  {x1 : Set} {Hterm : range x1} \n  {P : (z1662 : range x1) → Set} \n  (_H1 : (n : ℕ) → _enum n → x1 × ℕ) \n  (_upto : ℕ) \n  (_filter : ℕ → Bool) \n  (_z1663 : Eq Hterm (mk_range x1 _enum _upto _filter)) \n  (P_mk_range : (n : ℕ) → P (mk_range x1 _enum _upto _filter n)) \n  → P Hterm
 postulate Unit_rect_Type3 : (Q_ : (cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type3)) -> (H_it : cic.Term univs.Type3 (Q_ matita_basics_types.it)) -> (x_501 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type3 (Q_ x_501)
 postulate bigop_prod : \n  ∀ k1 k2 p1 p2 B nil op f → \n  bigop k1 (λ x → p1 x B nil op) B nil op (λ x → bigop k2 (λ i → p2 x i B nil op) B nil op (λ i → f x i)) ≡ \n  bigop (k1 * k2) (λ i → andb (p1 (quot i k2) B nil op) (p2 (quot i k2) (mod i k2) B nil op) (f (quot i k2) (mod i k2))) B nil op
 postulate checker_abl : (a b : Nat) (l : List Nat) → checker (cons Nat a) (cons Nat b) l ≡ true → a < b ∧ b ≤ 2 * a ∧ checker (cons Nat b) l ≡ true
 postulate exists_mid : \n  {A : cic.Univ univs.Type0} \n  {P : cic.Term univs.Type0 A -> cic.Univ univs.Type0} \n  {l1 : cic.Term univs.Type0 A} \n  {l2 : matita_basics_lists_list.list univs.Type0 A} \n  {x : cic.Term univs.Type0 A} \n  {p : cic.Term univs.Type0 (cic.prop univs.Type0)} \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n  (l1 : l1 : A) \n  (l2 : l2 : A) \n  (p : P x) \n
 postulate Nat_rect_CProp2 : (Q_ : (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) → (x_408 : cic.Term cic.prop) → Q_ (matita_arithmetics_nat.O)) → (H_O : Q_ (matita_arithmetics_nat.O)) → ((x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_408 : cic.Term cic.prop) → Q_ (matita_arithmetics_nat.S x_406) → Q_ x_406) → (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) → cic.Term cic.prop (Q_ x_405)
 postulate Lstar_inv_S : \n  (B : cic.Univ) (R : cic.Term B) (l : cic.Term B) (b1 b2 : cic.Term B) \n  (p : cic.Term B) (l0 : cic.Term B) \n  (h : matita_arithmetics_lstar.lstar B R l b1 b2 p) \n  (h0 : matita_arithmetics_nat.nat) \n  (h1 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h2 : matita_arithmetics_nat.nat) \n  (h3 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h4 : matita_arithmetics_nat.nat) \n  (h5 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h6 : matita_arithmetics_nat.nat) \n  (h7 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h8 : matita_arithmetics_nat.nat) \n  (h9 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h10 : matita_arithmetics_nat.nat) \n  (h11 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h12 : matita_arithmetics_nat.nat) \n  (h13 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h14 : matita_arithmetics_nat.nat) \n  (h15 : matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) l) \n  (h16 : matita_arithmetics_nat.nat) \n  (h17 : matita_arithmetics_nat.plus l0 (mat
 and $b$ and $c$ and $prod$ applied to $a$ and $c$ and $prod$ applied to $a$ and $b$ and $_nil$ and functions $_cancel$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $d$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $b$ and $c$ and $d$ and $prod$ applied to $a$ and $c$ and $prod$ applied to $a$ and $d$ and $prod$ applied to $b$ and $c$ and $prod$ applied to $b$ and $d$ and $_nil$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $b$ and $c$ and $prod$ applied to $a$ and $prod$ applied to $b$ and $c$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$
 postulate commutative2 : \n  ∀ (A B : Univ) (f : Term A → Term B) (x : Term A) (y : Term B) → Univ (prop)
16$ and $ra$ and $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $ra$ and $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $ra$ and $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $ra$ and $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $ra$ and $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $ra$ and $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and
 postulate le_plus_minus_m_m : {n : cic.Term (univs.Type0)} {m : matita_arithmetics_nat.nat} : cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m))
 postulate bc2 : (n k : ℕ) → k ≤ n → (factorial k) * (factorial (n - k)) ≡ (factorial n)
 postulate Decidable_forall : \n  {P : Nat -> Set} -> \n  {dec : Nat -> Dec (P _)} -> \n  (n : Nat) -> \n  Dec (prod Set Prop Nat (lambda i -> prod Prop Prop Lt i n (lambda _ -> P i)))
 postulate fact_pi_p : (n : ℕ) → fact n ≡ ∏ (p : ℕ) (primeb p ℕ 1) × (∏ (i : ℕ) (true ℕ 1) × (p ^ (n / (p ^ (i + 1)))))
 postulate Nat_inv_rect_CProp0 : (Hterm : Nat) (P : Nat → Set) (H1 : ∀ x_414 → P 0) (H2 : ∀ x_414 (x_416 : Eq Hterm x_414 (suc x_414)) → P x_414 → P (suc x_414)) → P Hterm
 postulate prop80 : even 2
 postulate eq_psi_psi' : {n : cic.Term univs.Type0} {m : matita_arithmetics_nat.nat} -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2) (matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi' n))
 postulate Nat_elim1 : (n : cic.Term univs.Type0) (P : cic.Term univs.Type0) (m : cic.Term univs.Type0) (p : cic.Term univs.Type0) (lt_p_m : matita_arithmetics_nat.lt p m) (P_p : cic.Term univs.Type0) (P_m : cic.Term univs.Type0) (P_n : cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (cic.Term univs.Type0) (
 postulate match_div_mod_spec : \n  {n : cic.Term (univs.Type0) matita_arithmetics_nat.nat}\n  {m : cic.Term (univs.Type0) matita_arithmetics_nat.nat}\n  {q : cic.Term (univs.Type0) matita_arithmetics_nat.nat}\n  {r : cic.Term (univs.Type0) matita_arithmetics_nat.nat}\n  {return_sort : cic.Sort}\n  {return_type : cic.Term (cic.prop) (matita_arithmetics_div_and_mod.div_mod_spec n m q r) -> return_sort}\n  {case_div_mod_spec_intro : \n    (z : cic.Term (cic.prop) (matita_arithmetics_nat.lt r m))\n    (z1 : cic.Term (cic.prop) (matita_arithmetics_nat.eq (cic.lift univs.Type0) (cic.lift univs.Type2) matita_arithmetics_nat.nat n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)))\n    (case_div_mod_spec_intro : \n      (z2 : cic.Term (cic.prop) (matita_arithmetics_div_and_mod.div_mod_spec_intro n m q r z z1)))\n    (z3 : cic.Term (cic.prop) (matita_arithmetics_div_and_mod.div_mod_spec n m q r))\n    (z4 : cic.Term (cic.prop) (return_type z3))\n    (z5 : cic.Term (cic.prop) (return_type z3))\n    (z6 : cic.Term (cic.prop) (return_type z3))\n    (z7 : cic.Term (cic.prop) (return_type z3))\n    (z8 : cic.Term (cic.prop) (return_type z3))\n    (z9 : cic.Term (cic.prop) (return_type z3))\n    (z10 : cic.Term (cic.prop) (return_type z3))\n    (z11 : cic.Term (cic.prop) (return_type z3))\n    (z12 : cic.Term (cic.prop) (return_type z3))\n    (z13 : cic.Term (cic.prop) (return_type z3))\n    (z14 : cic.Term (cic.prop) (return_type z3))\n
 postulate lop_sfalse : \n  (m : Nat) (i : Nat) (acc : List Nat) ->\n  list_divides acc i == absurdity ->\n  lprim (m + 1) i acc == lprim m (i + 1) (append Nat acc (cons Nat i nil Nat))
 postulate Lt_1_to_le_exp_B : (n : ℕ) → 1 < n → 2^n ≤ 2 * n * (B (2 * n))
 postulate le_S_S : ∀ {n m : matita_arithmetics_nat.nat} → (P : matita_arithmetics_nat.le n m → matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) → matita_arithmetics_nat.le n m → matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)
 postulate Permut_transpose_r : \n  {cic.Term : univs.Type0} {matita_arithmetics_nat.nat : univs.Type0} \n  {f : cic.Term -> cic.Term} \n  {m : cic.Term} {i : matita_arithmetics_nat.nat} {j : matita_arithmetics_nat.nat} \n  {p : cic.Term} {q : matita_arithmetics_nat.le i m} {r : cic.Term} {s : matita_arithmetics_nat.le j m} \n  {t : cic.Term} {u : matita_arithmetics_permutation.permut f m} \n  {v : matita_arithmetics_permutation.permut (λ n, f (matita_arithmetics_permutation.transpose i j n)) m} \n  {w : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j i) m} \n  {x : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j j) m} \n  {y : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j i) m} \n  {z : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j j) m} \n  {aa : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j i) m} \n  {ab : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j j) m} \n  {ac : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j i) m} \n  {ad : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j j) m} \n  {ae : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j i) m} \n  {af : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j j) m} \n  {ag : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j i) m} \n  {ah : matita_arithmetics_nat.le (matita_arithmetics_permutation.transpose i j j) m} \n  {ai : matita_arithmetics_nat
 postulate orb_true_l : (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2 matita_basics_bool.true))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)).
 postulate and_rect_CProp0_body : {A : Univ} {B : Univ} {Q : Term prop} {H_conj : ∀ x_168 : Term prop, A → ∀ x_167 : Term prop, B → Q (conj A B x_168 x_167)} {x_166 : Term prop} (H_and : And A B) → Term prop (Q x_166)
 postulate congruent_times : \n  ∀ (n m n1 m1 p : cic.Term univs.Type0) (p_lt : matita_arithmetics_nat.lt matita_arithmetics_nat.O p) \n  (p_congruent_n : matita_arithmetics_congruence.congruent n n1 p) \n  (p_congruent_m : matita_arithmetics_congruence.congruent m m1 p) \n  → cic.Term univs.Type0 (cic.prop) (matita_arithmetics_congruence.congruent (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times n1 m1) p)
 postulate log_times_l : (p n m : cic.Term univs.Type0) (p__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (p__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (p__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.S matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)))
 postulate Le_div_times_m : (a i m : cic.Term univs.Type0) (h1 : matita_arithmetics_nat.lt matita_arithmetics_nat.O i) (h2 : matita_arithmetics_nat.lt matita_arithmetics_nat.O m) → cic.Term (cic.prop matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a i) m) (matita_arithmetics_div_and_mod.div a i)).
 postulate prod_rect_Type3 : {A : Univ} {B : Univ} {Q : Term (Type 0) -> (Prod A B) -> Univ} {H_mk_Prod : (Term (Type 0) -> A -> Term (Type 0) -> B -> Term (Type 3)) -> Prod A B -> Term (Type 3) -> Q (mk_Prod A B) -> Univ} (x_696 : Term (Type 0)) (P : Prod A B) (x : Term (Type 3)) (Q_x_696 : Q x_696 P) -> Univ
2$ and $x1$ and $x5$ and $b$ and elements $_z2383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x2$ and $b$ and elements $_z2382$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x2$ and $b$ and elements $_z2381$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x2$ and $b$ and elements $_z2380$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x2$ and $b$ and elements $_z2379$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x2$ and $b$ and elements $_z2378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x2$ and $b$ and elements $_z2377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x2$ and $b$ and elements $_z2376$ of $cic.Term$ of $cic.prop
 postulate le_k : (n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) → cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_log.log p n))
 postulate Bool_to_decidable_eq : {b1 b2 : univs.Type0} -> (b1 : matita_basics_bool.bool) -> (b2 : matita_basics_bool.bool) -> cic.prop (cic.lift (univs.Type0) (univs.Type2) matita_basics_bool.bool b1 b2) (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift (univs.Type0) (univs.Type2) matita_basics_bool.bool) b1 b2))
 postulate exp_n_1 : \n  forall (n : cic.Term univs.Type0 matita_arithmetics_nat.nat),\n  cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O))))
 postulate le_pi : (n : ℕ) (p : ℕ → Bool) (g1 g2 : ℕ → ℕ) (l : (i : ℕ) → (p i = true) → (i < n) → (j : (i < n) → p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) → (p i = true) → (i < n) →
 postulate congruent_n_mod_n : forall n p : ℕ, (0 < p) → congruent n (mod n p) p
 postulate True_rect_CProp5_body : (Q_ : (x_56 : cic.Term (cic.prop)) -> (matita_basics_logic.True) -> cic.Univ (cic.prop)) -> (H_I : cic.Term (cic.prop)) -> (Q_ H_I (matita_basics_logic.I)) -> (x_56 : cic.Term (cic.prop)) -> (matita_basics_logic.True) -> cic.Term (cic.prop) -> cic.prop
 postulate aop : ∀ {A : Univ} {nil : Term A} → Univ {A} {nil}
 postulate le_Psi_exp5 : (n : ℕ) → Psi n ≤ 2 ^ (2 * n - 3)
 postulate compose : {A B C : Univ} {f : Term A B} {g : Term B C} {x : Term A} -> Term C
 postulate StreicherK : {T : cic.Univ univs.Type2} {t : cic.Term univs.Type2 T} {P : cic.Term univs.Type2 T → cic.prop (matita_basics_logic.eq T t t)} {p : cic.Term univs.Type2 (matita_basics_logic.eq T t t)} → cic.Term univs.Type2 P p.
 postulate let_clause_15623 : \n  (m : Nat) (n : Nat) (a : Nat) (b : Nat) (h1 : 0 < n) (h2 : 0 < m) (h3 : gcd n m = 1) (c : Nat) (x : ex Nat) (f : Nat -> Disj (Eq (prod c n - prod d m) 1) (Eq (prod d m - prod c n) 1)) (d : Nat) (h4 : prod c n - prod d m = 1 \/ prod d m - prod c n = 1) (h5 : prod d m - prod c n = 1) -> prod m d - prod n c = 1
 postulate exp_to_eq_O : (n m : ℕ) → S (S zero) < n → (n ^ m ≡ 1) → m ≡ zero
 postulate le_minus_to_plus_r : \n  {a b c : cic.Term univs.Type0}\n  {__ : cic.Term univs.Type0 (cic.prop (matita_arithmetics_nat.le c b))}\n  {__1 : cic.Term univs.Type0 (cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus b c)))}\n  (H : cic.Term univs.Type0 (cic.prop (matita_arithmetics_nat.le c b))) \n  (H1 : cic.Term univs.Type0 (cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus b c)))) \n  : cic.Term univs.Type0 (cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a c) b))
 postulate Dividesb_div_true : (d n : ℕ) → 0 < n → dividesb d n true → dividesb (n / d) n true
 postulate prime_to_gcd_1 : ∀ {n m : ℕ} → prime n → ¬ divides n m → gcd n m ≡ 1
 postulate Sig_rect_CProp5 : \n  forall (A : Univ), \n  forall (_f : Term A -> Univ), \n  forall (Q_ : (x_680 : Term) -> Sig A _f -> Univ), \n  forall (_H_mk_Sig : (pi1 : Term) -> A -> (pi2 : Term) -> _f pi1 -> (Q_ matita_basics_types.mk_Sig A _f pi1 pi2)), \n  forall (x_680 : Term) -> Sig A _f -> Univ
 postulate Option_rect_Type3 : (A : Univ Type0) -> (Q : Term A -> Option A -> Univ Type3) -> (H_None : Term A -> Option A -> Term Type3) -> (H_Some : (x : Term A) -> A -> Term Type3) -> (x : Term A) -> Option A -> Term Type3
 postulate Sig_rect_CProp2 : \n  {A : Univ}\n  {f : Term A -> Univ}\n  {Q_ : (x_684 : Term A) -> Sig A f -> Univ}\n  {H_mk_Sig : \n    (pi1 : Term A)\n    (A : Univ)\n    (f : Term A -> Univ)\n    (pi2 : Term (Prop A f))\n    (Q_ : (x_684 : Term A) -> Sig A f -> Univ)\n    (H_ : pi2 = Q_ (mk_Sig A f pi1) pi2)\n    -> Univ}\n  -> (x_684 : Term A)\n  -> Sig A f -> Univ
 postulate Length_unique_le : \n  {n : Nat} \n  {l : List Nat} \n  {x : Nat} \n  {p : mem x l} \n  {q : Nat -> Lt x n} \n  -> length Nat l <= n
 postulate Dop_rect_CProp1_body : {A : Set} {a : A} {nil : A} {Q_ : Dop A nil -> Prop} {H_mk_Dop : forall {sum : ACop A nil} {prod : A -> A -> A} {null : forall {a : A} -> Eq a nil -> Prop} {distr : forall {a b c : A} -> Eq (prod a nil) (sum nil nil) -> Eq (prod (aop__o__op A nil sum a nil) (aop__o__op A nil sum b c)) (aop__o__op A nil sum (aop__o__op A nil sum a nil) (prod b c))} -> Q_ (mk_Dop A nil sum prod null distr)} {x_965 : Dop A nil} -> Q_ x_965
 postulate not_exists_to_forall : (P : (cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prop) -> cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P n) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P i) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex (matita_arithmetics_nat.nat) (λ i. matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))
 postulate Divides_smallest_factor_n : (n : ℕ) → 0 < n → smallest_factor n | n
ita_basics_types.some$ applied to $y$ and $t0$ and the function that maps $P$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $x$ and the function that maps $t0$ to $matita_basics_types.some$ applied to $x$ and $t0$ and the function that maps $P$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $t0$ to $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.some$ applied to $y$ and $t0$ and the function that maps $P$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $x$ and the function that maps $t0$ to $matita_basics_types.some$ applied to $x$ and $t0$ and the function that maps $P$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $t0
 postulate f_ind_aux : \n  {A : Set} {f : A -> Nat} {P : A -> Set} \n  (g : Nat -> (a : A) (b : Lt (f a) n) -> P a) \n  (h : (a : A) (b : Eq (f a) n) -> P a) -> \n  (a : A) (n : Nat) -> f a == n -> P a
 postulate Div_mod_spec_rect_CProp2_body : (n m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (x_849 : cic.Term univs.Type0 cic.prop) → (matita_arithmetics_div_and_mod.div_mod_spec n m q r) → cic.Term univs.Type0 cic.prop) (H_div_mod_spec_intro : (x_851 : cic.Term univs.Type0 cic.prop) (x_850 : cic.Term univs.Type0 cic.prop) (x_852 : cic.Term univs.Type0 matita_arithmetics_nat.lt r m) (x_853 : cic.Term univs.Type0 matita_arithmetics_nat.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)) (x_854 : Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro n m q r x_851 x_850 x_852 x_853)) (x_855 : matita_arithmetics_div_and_mod.div_mod_spec n m q r) : cic.Term univs.Type0 cic.prop) (x_849 : cic.Term univs.Type0 cic.prop) (x_856 : matita_arithmetics_div_and_mod.div_mod_spec n m q r) : cic.Term univs.Type0 cic.prop
 postulate Le_B_exp : \n  ∀ (n : cic.Term univs.Type0) (m : matita_arithmetics_nat.nat),\n  cic.Term univs.Type0 (cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))
 postulate le_log_S : forall (p n : cic.Term of univs.Type0) (m : matita_arithmetics_nat.nat), cic.Term holds for cic.prop and matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)
 postulate lt_1_max_prime : {n : cic.Term univs.Type0} {__ : cic.Term (cic.prop) univs.Type0} {__ : matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) n} -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic.prop) univs.Type0 -> cic.Term (cic
 postulate nth_prime : (n : matita_arithmetics_nat.nat) → cic.Term univs.Type0 matita_arithmetics_nat.nat
 postulate Le_to_leb_true : (n m : ℕ) → (n ≤ m) → (leb n m ≡ true)
 postulate Bool_rect_CProp1 : (Q_ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop) (H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_359 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_359)
 postulate log_div : (p n m : cic.Term univs.Type0) (p_lt_S_O : matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.O)) p) (m_lt_O : matita_arithmetics_nat.lt matita_arithmetics_nat.O m) (m_le_n : matita_arithmetics_nat.le m n) -> cic.Term univs.Type0 (cic.prop) (matita_arithmetics_nat.le (matita_arithmetics_log.log p) (matita_arithmetics_div_and_mod.div n m (matita_arithmetics_nat.minus (matita_arithmetics_log.log p) n (matita_arithmetics_log.log p) m))).
 postulate Range_rect_Type2 : \n  {A : Univ} {Q : Term Univ Type0 -> Range A -> Univ} \n  {H_mk_range : (enum : Term Univ Type0 -> Nat -> Term Univ Type0) \n    -> (upto : Term Univ Type0 -> Nat -> Term Univ Type0) \n    -> (filter : Term Univ Type0 -> Nat -> Bool -> Term Univ Type0) \n    -> (Q (mk_range A enum upto filter))} \n  {x_923 : Term Univ Type0} {x_923_range : Range A} \n  -> Term Univ Type2 \n  -> Q x_923 x_923_range
 postulate Sum_rect_CProp3 : (A : Univ) (B : Univ) (Q : Term Univ (Prop0) -> Sum A B -> Univ) (H_inl : (x : Term Univ (Prop0)) (a : A) -> Term Univ (Prop0) -> Q (inl a) x) (H_inr : (x : Term Univ (Prop0)) (b : B) -> Term Univ (Prop0) -> Q (inr b) x) (x : Term Univ (Prop0)) (s : Sum A B) -> Term Univ (Prop0) -> Q s x
 postulate Let_clause_1571 : ∀ {m n : ℕ} → n > 0 → gcd m n = 0 → m = 0 → n = 0 → m = n
 postulate prop80 : even 2  \npostulate op : Set -> Set \npostulate nil : forall (A : Set) -> Aop A nil \npostulate x887 : forall (A : Set) -> forall (Aop : Set -> Set -> Set) -> forall (a : A) -> forall (nil : Aop A nil) -> Aop A (nil a) nil \npostulate x888 : forall (A : Set) -> forall (Aop : Set -> Set -> Set) -> forall (a : A) -> forall (nil : Aop A nil) -> Aop A (nil a) nil
.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$, we can prove that $Q_$ applied to $_x_873$ and $A$ and $op$ applied to $_nil$ and $_x_873$ and $Q_$ applied to $_x_873$ and $A$ and $op$ applied to $_x_873$ and $A$ and $_H_mk_Aop$ applied to $op$ and $_nil$ and $_x_873$ and $_nilr$ applied to $_x_873$ and $A$ and $_nill$ applied to $_x_873$ and $A$ and $_assoc$ applied to $_x_873$ and $A$ and $A$ and $op$ applied to $_nil$ and $A$ and $op$ applied to $_nil$ and $A$ and $op$ applied to $A$ and $_nil$ and $A$ and $A$ and $A$ and $op$ applied to $_nil$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $A$ and $A$ and $A$ and $op$ applied to $A$ and $
 Axiom Le_plus : forall n1 n2 m1 m2 : cic.Term of univs.Type0 and matita_arithmetics_nat.nat, forall __ : cic.Term of cic.prop and matita_arithmetics_nat.le n1 n2, forall __1 : cic.Term of cic.prop and matita_arithmetics_nat.le m1 m2, cic.Term holds for cic.prop and matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2).
 postulate Range_rect_CProp3 : \n  {A : Univ} {Q : Term A Univ prop} \n  {H_mk_range : (enum : Term A Univ Nat) (upto : Nat) \n    (filter : Term A Univ Nat Nat Bool) \n    (x : Term A Univ Nat) \n    (P : Term A Univ Nat Bool) \n    (Q : Term A Univ Nat Nat Nat Bool) \n    (R : Term A Univ Nat Nat Nat Nat Bool) \n    (S : Term A Univ Nat Nat Nat Nat Nat Bool) \n    (T : Term A Univ Nat Nat Nat Nat Nat Nat Bool) \n    (U : Term A Univ Nat Nat Nat Nat Nat Nat Nat Bool) \n    (V : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (W : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (X : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (Y : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (Z : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A1 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A2 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A3 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A4 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A5 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A6 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A7 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A8 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A9 : Term A Univ Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Nat Bool) \n    (A10 : Term
 postulate B1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) → cic.Term univs.Type0 matita_arithmetics_nat.nat
 postulate let_clause_10333 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term univs.Type0 cic.prop matita_arithmetics_nat.lt matita_arithmetics_nat.O n) (x2515 x2516 : cic.Term univs.Type0 univs.Type2 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
 postulate Range_rect_Type5 : (A : Univ) (Q : Term A → Univ) (H_mk_range : (enum : Term A → Univ) → (upto : Term A → Univ) → (filter : Term A → Univ) → (enum x_919 upto filter) → (A → Univ)) → (x_919 : Term A) → (range A x_919) → Term A
2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $a$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $b$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posd$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $d$, for all elements $d1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $d2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $p$ and $b$, for all elements $c1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $c2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $c3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics
 postulate lt_mod_m_m : \n  {univs : UniverseLevels} \n  {matita_arithmetics_nat : UniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevelsUniverseLevels
 postulate Or_ind_body : forall {A B : Univ} (Q : Term A prop -> Univ) (x : Term A prop -> Univ -> Univ) (H_or_introl : (x171 : Term A prop) -> (H : A) -> Q (or_introl A B x171 H) (x x171 H)) (H_or_intror : (x172 : Term A prop) -> (H : B) -> Q (or_intror A B x172 H) (x x172 H)) (x170 : Term A prop) -> Or A B -> Term A prop -> Univ -> Univ
 postulate Nat_rect_CProp4 : {Q_ : (x_393 : cic.Term (univs.Type0)) (x_394 : matita_arithmetics_nat.nat) → cic.Term (cic.prop)} (H_O : cic.Term (cic.prop)) (H_S : (x_394 : cic.Term (univs.Type0)) (x_396 : cic.Term (cic.prop)) → Q_ x_394 (matita_arithmetics_nat.S x_394) x_396 → cic.Term (cic.prop)) (x_393 : cic.Term (univs.Type0)) (x_394 : matita_arithmetics_nat.nat) → cic.Term (cic.prop)
 postulate sub_lt : (A : Set) -> (e : Nat -> A) -> (p : Nat -> Bool) -> (n : Nat) -> (m : Nat) -> (n <= m) -> sub_hk (λ x -> x) (λ x -> x) A (mk_range A e n p) (mk_range A e m p)
 postulate Let_clause_1575 : ∀ (m n : ℕ) (a b : _clearme) → (0 < n) → (0 < m) → (gcd n m = 1) → ∀ (c : ℕ) → (ex : _clearme) → (λ d → (Eq (c * n - d * m) 1) ∨ (Eq (d * m - c * n) 1)) → ∀ (d : ℕ) → (c * n - d * m ≡ 1) ∨ (d * m - c * n ≡ 1) → (c * n - d * m ≡ 1) → ∀ (x1029 : ℕ) → x1029 ≡ x1029 * (n * c - m * d)
 postulate Prod_ind_body : {A : cic.Univ} {B : cic.Univ} {Q : cic.Term A B -> cic.prop} {H_mk_Prod : (fst : cic.Term A) (snd : cic.Term B) -> Q (matita_basics_types.mk_Prod A B fst snd)} {x_690 : cic.Term A} (x_690_prod : matita_basics_types.Prod A B) -> cic.Term x_690_prod -> cic.prop
 postulate congruent_ab_lt : {m n : cic.Term univs.Type0} {a b : cic.Term (cic.prop univs.Type0)} {__ : cic.Term (cic.prop univs.Type0) (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)} {__1 : cic.Term (cic.prop univs.Type0) (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)} {__2 : cic.Term (cic.prop univs.Type0) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_gcd.gcd n m (matita_arithmetics_nat.S matita_arithmetics_nat.O))} (cic.Term (cic.prop univs.Type0) (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n)))).
 postulate not_eq_O_S : ∀ {n : cic.Term univs.Type0} → cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0) univs.Type2 matita_arithmetics_nat.nat matita_arithmetics_nat.O (matita_arithmetics_nat.S n)))
 postulate not_prime_to_primeb_false : (n : ℕ) → (¬ prime n) → primeb n ≡ absurdity
 postulate times_pi : (n : ℕ) (p : ℕ → Bool) (f g : ℕ → ℕ) → (bigop n (λ i → p i) Nat 1 times (λ i → f i * g i)) ≡ (bigop n (λ i → p i) Nat 1 times f) * (bigop n (λ i → p i) Nat 1 times g)
 postulate sum : ∀ {A : Univ} {nil : Term A} {_xxx : Term A} (dop : Term (A ⊗ nil)) (ACop : Term (A ⊗ nil)) → Term A
 postulate Leb_body : (n n1 : ℕ) → Bool
 postulate Distributive2 : \n  (A B : Univ) -> (f : Term A -> Term B -> Term B) -> \n  (g : Term B -> Term B -> Term B) -> Univ prop
 postulate unit_inv_rect_Type1 : {Hterm : cic.Term univs.Type0} {matita_basics_types.unit} {P : (_z930 : cic.Term univs.Type0) (matita_basics_types.unit) → cic.Univ univs.Type1} {_H1 : (_z931 : cic.Term (cic.prop univs.Type1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) → cic.Term univs.Type1 P Hterm} → cic.Term univs.Type1 P Hterm
 postulate bigop_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 B -> cic.Term univs.Type0 B -> cic.Term univs.Type0 B) (f : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term univs.Type0 (cic.prop B) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) B nil op (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) nil (f i) nil) (matita_basics_bool.false B))
 postulate Eq_rect_Type5_body : \n  (A : Univ (Type2 univs)) (x : Term (Type2 univs) A) \n  (Q_ : (x_7 : Term (Type2 univs) A) (x_8 : Term (Type2 univs) prop) \n  (eq : eq (Type5 univs) A x x_7) -> Univ (Type5 univs)) \n  (H_refl : Term (Type5 univs) Q_ x (refl (Type5 univs) A x)) \n  (x_7 : Term (Type2 univs) A) (x_8 : Term (Type2 univs) prop) \n  (eq : eq (Type5 univs) A x x_7) -> Term (Type5 univs) (Q_ x_7 x_8)
 postulate NoLabel_30 : (x : ℕ) → odd (5 * x - 7) → even (9 * x + 2)
 postulate lstar_lstar_r : {B : Set} {R : relation B} {l : ℕ} {b1 b2 : B} {__ : lstar B R l b1 b2} → lstar_r B R l b1 b2
.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $g2$ applied to $i$ and $matita_arithmetics_nat.nat$ to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $g1$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $g2$ applied to $i$ and $matita_arithmetics_nat.nat$.\n\nAssistant: postulate Le_pi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat → cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : cic.Term univs.Type0 matita_arithmetics_nat.nat → cic.Term univs.Type0 matita_arithmetics_nat.nat) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i5 : cic.Term
 postulate nth_body : {cic.Term univs.Type0} {cic.Univ univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univs.Type0} {cic.Term univ
 postulate Eq_minus_S_pred : ∀ (n m : ℕ) → (n - (S m)) ≡ (pred (n - m))
 postulate mod_S : {n m : ℕ} {m>0 : 0 < m} (h : (mod (n + 1) m) + 1 < m) → mod (n + 1) m ≡ (mod n m + 1)
ivs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and functions $_idr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_idl$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $A$, we have $Q_$ applied to $a$ and $A$ and $_nil$ and $A$ and $Q_$ applied to $b$ and $A$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and $_nil$ and $a$ and $Q_$ applied to $c$ and $A$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and $_nil$ and $a$ and $b$ and $c$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and $_nil$ and $a$ and $b$ and $c$ and $Q_$ applied to $c$ and $A$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and $matita_basics_lists_cons.mk_Aop$ applied to $A$ and
 postulate iff_trans : \n  {A B C : cic.Univ} \n  {t : cic.Term A} \n  {u : cic.Term B} \n  {v : cic.Term C} \n  {h1 : matita_basics_logic.iff A B} \n  {h2 : matita_basics_logic.iff B C} \n  {h3 : cic.Term A} \n  {h4 : cic.Term B} \n  {h5 : cic.Term C} \n  {h6 : matita_basics_logic.iff A C} \n  {h7 : cic.Term A} \n  {h8 : cic.Term B} \n  {h9 : cic.Term C} \n  {h10 : matita_basics_logic.iff A C} \n  {h11 : cic.Term A} \n  {h12 : cic.Term B} \n  {h13 : cic.Term C} \n  {h14 : matita_basics_logic.iff A C} \n  {h15 : cic.Term A} \n  {h16 : cic.Term B} \n  {h17 : cic.Term C} \n  {h18 : matita_basics_logic.iff A C} \n  {h19 : cic.Term A} \n  {h20 : cic.Term B} \n  {h21 : cic.Term C} \n  {h22 : matita_basics_logic.iff A C} \n  {h23 : cic.Term A} \n  {h24 : cic.Term B} \n  {h25 : cic.Term C} \n  {h26 : matita_basics_logic.iff A C} \n  {h27 : cic.Term A} \n  {h28 : cic.Term B} \n  {h29 : cic.Term C} \n  {h30 : matita_basics_logic.iff A C} \n  {h31 : cic.Term A} \n  {h32 : cic.Term B} \n  {h33 : cic.Term C} \n  {h34 : matita_basics_logic.iff A C} \n  {h35 : cic.Term A} \n  {h36 : cic.Term B} \n  {h37 : cic.Term C} \n  {h38 : matita_basics
 postulate P_ord_aux_body : \n  {A : univs.Type0} \n  {a : matita_arithmetics_nat.nat} \n  {b : matita_arithmetics_nat.nat} \n  {c : matita_arithmetics_nat.nat} \n  {d : matita_arithmetics_nat.nat} \n  {e : matita_arithmetics_nat.nat} \n  {f : matita_arithmetics_nat.nat} \n  {g : matita_arithmetics_nat.nat} \n  {h : matita_arithmetics_nat.nat} \n  {i : matita_arithmetics_nat.nat} \n  {j : matita_arithmetics_nat.nat} \n  {k : matita_arithmetics_nat.nat} \n  {l : matita_arithmetics_nat.nat} \n  {m : matita_arithmetics_nat.nat} \n  {n : matita_arithmetics_nat.nat} \n  {o : matita_arithmetics_nat.nat} \n  {p : matita_arithmetics_nat.nat} \n  {q : matita_arithmetics_nat.nat} \n  {r : matita_arithmetics_nat.nat} \n  {s : matita_arithmetics_nat.nat} \n  {t : matita_arithmetics_nat.nat} \n  {u : matita_arithmetics_nat.nat} \n  {v : matita_arithmetics_nat.nat} \n  {w : matita_arithmetics_nat.nat} \n  {x : matita_arithmetics_nat.nat} \n  {y : matita_arithmetics_nat.nat} \n  {z : matita_arithmetics_nat.nat} \n  {a1 : matita_arithmetics_nat.nat} \n  {b1 : matita_arithmetics_nat.nat} \n  {c1 : matita_arithmetics_nat.nat} \n  {d1 : matita_arithmetics_nat.nat} \n  {e1 : matita_arithmetics_nat.nat} \n  {f1 : matita_arithmetics_nat.nat} \n  {g1 : matita_arithmetics_nat.nat} \n  {h1 : matita_arithmetics_nat.nat} \n  {i1 : matita_arith
 postulate prop80 : even 2  \npostulate div_mod_spec_to_divides : {n : cic.Term univs.Type0} {m : cic.Term univs.Type0} {q : cic.Term univs.Type0} {__ : cic.Term univs.Type0} (h : matita_arithmetics_div_and_mod.div_mod_spec m n q matita_arithmetics_nat.O) : cic.Term univs.Type0
 postulate length_ltl : \n  (A : cic.Univ univs.Type0) (n : matita_arithmetics_nat.nat) \n  (l : cic.Term univs.Type0 matita_basics_lists_list.list A) \n  (cic.Term univs.Type0 matita_basics_lists_list.length A l n) \n  (cic.Term univs.Type0 matita_basics_lists_list.ltl A l n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term univs.Type0 matita_arithmetics_nat.minus \n    (matita_basics_lists_list.length A l) n) \n  (cic.Term
 postulate Let_clause_1033 : ∀ (n : ℕ) → 1 < n → ∀ (x2515 x2516 : ℕ) → x2515 ≡ (x2516 * (x2515 / x2516) + mod x2515 x2516)
 postulate Eq_rect_CProp3 : {A : cic.Univ} {A_0 : univs.Type2} (x : cic.Term A_0) (Q_ : (x_28 : cic.Term A_0) (A_1 : univs.Type2) (x_29 : cic.Term A_1) (H : matita_basics_logic.eq A A_0 x_28) (H_refl : matita_basics_logic.refl A A_0 x) (x_28_0 : cic.Term A_1) (x_29_0 : cic.Term A_1) (H_0 : matita_basics_logic.eq A_1 A_0 x_28_0) (H_refl_0 : matita_basics_logic.refl A_1 A_0 x_28_0) (x_28_1 : cic.Term A_1) (x_29_1 : cic.Term A_1) (H_1 : matita_basics_logic.eq A_1 A_0 x_28_1) (H_refl_1 : matita_basics_logic.refl A_1 A_0 x_28_1) (x_28_2 : cic.Term A_1) (x_29_2 : cic.Term A_1) (H_2 : matita_basics_logic.eq A_1 A_0 x_28_2) (H_refl_2 : matita_basics_logic.refl A_1 A_0 x_28_2) (x_28_3 : cic.Term A_1) (x_29_3 : cic.Term A_1) (H_3 : matita_basics_logic.eq A_1 A_0 x_28_3) (H_refl_3 : matita_basics_logic.refl A_1 A_0 x_28_3) (x_28_4 : cic.Term A_1) (x_29_4 : cic.Term A_1) (H_4 : matita_basics_logic.eq A_1 A_0 x_28_4) (H_refl_4 : matita_basics_logic.refl A_1 A_0 x_28_4) (x_28_5 : cic.Term A_1
 postulate False_rect_Type1_body : (Q_ : (cic.Term (cic.prop) matita_basics_logic.False) -> univs.Type1) -> (x_71 : cic.Term (cic.prop) matita_basics_logic.False) -> cic.Term univs.Type1 Q_ x_71
 postulate Le_S_times_2 : (n : ℕ) → (0 < n) → (n + 1) ≤ (2 * n)
 postulate ab_times_cd : \n  ∀ (a b c d : ℕ) → (a * b) * (c * d) ≡ (a * c) * (b * d)
 Axiom (prop80 : even 2) .
 postulate hint_declaration_Type1 : ∀{A : Univ} → (a b : Term A) → Univ A
 postulate eq_to_eqb_true : \n  ∀ (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) \n  (p : cic.Term (cic.prop (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) \n  (q : matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m matita_basics_bool.true) \n  → cic.Term (cic.prop (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) p
 postulate ProdF : {A : cic.Univ} {B : cic.Univ} {f : cic.Term A} {g : cic.Term B} {m : cic.Term A} {x : cic.Term B} -> cic.Term univs.Type0 (cic.Prod A B)
 postulate Divides_to_divides_ord_rem : ∀ (p n m : ℕ) → 0 < n → 0 < m → is_prime p → Divides n m → Divides (ord_rem n p) (ord_rem m p)
 postulate Lt_4_to_le_B_exp : (n : ℕ) → (4 < n) → (B (2 * n) ≤ 2 ^ (2 * n - 2))
 postulate Range_rect_Type5_body : (A : Set) (Q : range A → Set5) (H_mk_range : (enum : ℕ → A) (upto : ℕ) (filter : ℕ → Bool) → Q (mk_range A enum upto filter)) (x_919 : range A) → Q x_919
 postulate P_ord_degenerate : \n  (p : Nat) (n : Nat) -> p_ord_aux p n 1 = mk_Prod Nat Nat p n
 and $b$ and $c$ and functions $_distr_2$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $c$ and $b$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $a$ and $b$ and $c$ and functions $_left_0$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $a$ and functions $_right_0$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$
 postulate Nat_rect_CProp0 : (Q_ : Nat -> Set) -> (H_O : Q_ 0) -> ((x_414 : Nat) -> (x_416 : Q_ x_414) -> Q_ (x_414 + 1)) -> (x_413 : Nat) -> Q_ x_413
 postulate Bool_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0) (b : matita_basics_bool.bool) (P : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) (H1 : cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) (H2 : cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type0 (P Hterm)
 postulate div_mod_spec_to_eq : {a b q r q1 r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat}\n  {__ : cic.Term univs.Type2 cic.prop}\n  {__1 : cic.Term univs.Type2 cic.prop}\n  (d : matita_arithmetics_div_and_mod.div_mod_spec a b q r)\n  (d1 : matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)\n  : cic.Term univs.Type2 cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q q1)
 postulate let_clause_1531 : \n  forall {n : cic.Term univs.Type0 matita_arithmetics_nat.nat} {m : cic.Term univs.Type0 matita_arithmetics_nat.nat} {posm : cic.Term univs.Type0 matita_arithmetics_nat.lt (matita_arithmetics_nat.O) m} {_clearme : cic.Term univs.Type0 matita_arithmetics_primes.divides n m} {d : cic.Term univs.Type0 matita_arithmetics_nat.nat} {eqm : cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.O))}, cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.O)
 postulate nth_opt : ∀{A : cic.Univ} {n : matita_arithmetics_nat.nat} {l : matita_basics_lists_list.list A} → A → l
 postulate Le_SO_smallest_factor : forall (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x : cic.Term univs.Type2 matita_arithmetics_nat.le n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (y : cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term (cic.prop (matita_arithmetics_nat.eq (matita_arithmetics_nat.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.smallest_factor n n)))
 postulate permut_fg : {f : cic.Term univs.Type0 matita_arithmetics_nat.nat} {g : cic.Term univs.Type0 matita_arithmetics_nat.nat} {n : cic.Term univs.Type0 matita_arithmetics_nat.nat} {p : cic.Term univs.Type0 matita_arithmetics_permutation.permut f n} {q : cic.Term univs.Type0 matita_arithmetics_permutation.permut g n} (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) → cic.Term univs.Type0 matita_arithmetics_permutation.permut (λ m : cic.Term univs.Type0 matita_arithmetics_nat.nat, f (g m)) n.
 postulate lt : {__ : cic.Term univs.Type0} {__1 : matita_arithmetics_nat.nat} -> cic.Univ cic.prop
 postulate Eq_ind_body : {A : cic.Univ} {x : cic.Term} {Q_ : cic.Term} (H_refl : Q_ x (matita_basics_logic.refl A x)) (x1 : cic.Term) (x2 : cic.Term) (eq : matita_basics_logic.eq A x x1) (H : Q_ x2 (matita_basics_logic.refl A x1)) -> cic.Term (cic.prop) (Q_ x1 x2)
 postulate True_rect_Type0 : \n  {Q_ : (cic.Term (cic.prop) (matita_basics_logic.True) -> univs.Type0)} \n  {H_I : cic.Term (univs.Type0) (matita_basics_logic.I)} \n  {x_52 : cic.Term (cic.prop) (matita_basics_logic.True)} \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop) (matita_basics_logic.True)) \n  (x_52 : cic.Term (cic.prop)
 postulate pi1_body : forall (A : Univ), (A : Type0), (f : Term -> Univ), (A) -> (Sig A f), Term Type0 A
 postulate Mod_S_fact : (n i : ℕ) → (1 < i) → (i ≤ n) → mod (fact n + 1) i ≡ 1
 postulate Option_rect_Type2_body : {A : cic.Univ univs.Type0} {Q : cic.Term univs.Type0 (matita_basics_types.option A) cic.Univ univs.Type2} {H_None : cic.Term univs.Type2} {H_Some : cic.Term univs.Type0 A cic.Term univs.Type2 (Q (matita_basics_types.Some A) _)} {x_602 : cic.Term univs.Type0 (matita_basics_types.option A)} {x_603 : cic.Term univs.Type0 A} → cic.Term univs.Type2 (Q x_602 _)
 postulate prod_inv_rect_CProp1 : \n  {x1 : cic.Univ univs.Type0} \n  {x2 : cic.Univ univs.Type0} \n  {Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)} \n  {P : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {H : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P1 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P2 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P3 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P4 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P5 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P6 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P7 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P8 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P9 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P10 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P11 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P12 : cic.Term univs.Type0 (cic.prop (matita_basics_types.Prod x1 x2))} \n  {P13 : cic.Term univs
 postulate exists_add : forall (A : cic.Univ) (P : cic.Term A -> A -> cic.Univ) (l1 : cic.Term A) (l2 : matita_basics_lists_list.list A) (x : cic.Term A), cic.Term (cic.prop) (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2)) -> cic.Term (cic.prop) (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2))).
 postulate Permut_fg : (f g : ℕ → ℕ) (n : ℕ) (x : permut f n) (x1 : permut g n) → permut (λ m → f (g m)) n
 postulate True_rect_Type1 : {x_50 : cic.Term cic.prop matita_basics_logic.True} {H_I : cic.Term univs.Type1} (Q_ : (x_50 : cic.Term cic.prop matita_basics_logic.True) → univs.Type1) (H_I : cic.Term univs.Type1) (x_50 : cic.Term cic.prop matita_basics_logic.True) → cic.Term univs.Type1
 postulate log_exp : (p n m : ℕ) → 1 < p → 0 < m → log p (p ^ n * m) ≡ n + log p m
 postulate Bool_rect_Type4_body : \n  {Q_ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type4}\n  {H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true)}\n  {H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false)}\n  {x_329 : cic.Term univs.Type0 matita_basics_bool.bool}\n  -> cic.Term univs.Type4 (Q_ x_329)
 postulate bk_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n (matita_arithmetics_bigops.bigop matita_arithmetics_nat.S n (p : matita_arithmetics_nat.nat) -> matita_arithmetics_primes.primeb p matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.times p (matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_bertrand.k n p)))))
 postulate ACop_rect_Type2_body : \n  {A : cic.Univ univs.Type0} \n  {_nil : cic.Term univs.Type0 A} \n  {Q_ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) \n  (cic.prop univs.Type2)} \n  {aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)} \n  {_comm : cic.Term univs.Type0 (A) \n  (cic.prop univs.Type2) \n  (cic.lift univs.Type0 univs.Type2 A) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop)} \n  {x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)} \n  (H_mk_ACop : cic.Term univs.Type0 (A) \n  (cic.prop univs.Type2) \n  (cic.lift univs.Type0 univs.Type2 A) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop)) \n  (comm : cic.Term univs.Type0 (A) \n  (cic.prop univs.Type2) \n  (cic.lift univs.Type0 univs.Type2 A) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop) \n  (matita_arithmetics_bigops.op A _nil aop)) \n  (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) \n  (Q_ : cic
 postulate lop_strue : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (___ : cic.Term (cic.prop (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i matita_basics_bool.true))) matita_basics_bool.true) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (___ : cic.Term (cic.prop (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i matita_basics_bool.true))) matita_basics_bool.true) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (___ : cic.Term (cic.prop (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i matita_basics_bool.true))) matita_basics_bool.true) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (i : cic.Term univs.Type0 matita_arithmetics
 postulate monotonic_le_plus_l : ∀ m → monotonic Nat Leq (λ n → n + m)
 postulate lt_plus_to_minus : ∀ (n m p : ℕ) → m ≤ n → n < p + m → n - m < p
 postulate ex2 : (A : Univ) (P Q : Term A Univ prop) (return_sort : Sort) (return_type : Term (Term prop) (Term A Univ prop) Univ return_sort) (case_ex2_intro : Term (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A Univ prop) Univ (Term (Term prop) (Term A Univ prop) Univ return_sort) return_type)) (Term (Term Univ) (Term A Univ prop) (Term (Term prop) (Term A
 postulate And_rect_CProp5_body : \n  {A B : Univ} {Q : Term prop} {H_conj : (x152 : Term prop) (x151 : Term prop) \n  (A x152 x151 : Term prop) (Q (conj A B x152 x151) : Term prop) \n  (x150 : Term prop) (A B x150 : Term prop) : Term prop \n  -> Q x150 -> Q (conj A B x150)} \n  (A B : Univ) (Q : Term prop) (H_conj : (x152 : Term prop) (x151 : Term prop) \n  (A x152 x151 : Term prop) (Q (conj A B x152 x151) : Term prop) \n  (x150 : Term prop) (A B x150 : Term prop) : Term prop \n  -> Q x150 -> Q (conj A B x150)) \n  (x150 : Term prop) (A B x150 : Term prop) : Term prop -> Q x150 -> Q (conj A B x150)
 postulate let_upper_bound4 : ∀ {n m : cic.Term univs.Type0 matita_arithmetics_nat.nat} → cic.Term univs.Type0 matita_arithmetics_nat.nat
 postulate gcd_SO_n : (n : ℕ) → gcd 1 n ≡ 1
 postulate iff_not : {A B : cic.Univ} {t : cic.Term} (iff A B) → (iff (Not A) (Not B))
 postulate range_inv_rect_CProp1 : \n  {x1 : cic.Univ}\n  {Hterm : cic.Term univs.Type0}\n  {Hrange : matita_arithmetics_bigops.range x1}\n  {P : cic.Term univs.Type0 matita_arithmetics_bigops.range x1 → cic.Univ cic.prop}\n  {Henum : ∀ {x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat} (x3 : matita_arithmetics_nat.nat), x2 matita_arithmetics_nat.≤ x3 → P (cic.mk_term (matita_arithmetics_nat.nat.lift x2) (matita_arithmetics_nat.nat.lift x3)) x3}\n  {Hupto : ∀ {x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat} (x3 : matita_arithmetics_nat.nat), x2 matita_arithmetics_nat.≤ x3 → P (cic.mk_term (matita_arithmetics_nat.nat.lift x2) (matita_arithmetics_nat.nat.lift x3)) x3}\n  {Hfilter : ∀ {x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat} (x3 : matita_arithmetics_nat.nat), x2 matita_arithmetics_nat.≤ x3 → P (cic.mk_term (matita_arithmetics_nat.nat.lift x2) (matita_arithmetics_nat.nat.lift x3)) x3}\n  {Hz1686 : P (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat.lift (cic.mk_term (matita_arithmetics_nat.nat
 postulate bigop_0 : \n  {n : cic.Term univs.Type0}\n  {B : cic.Univ univs.Type0}\n  {nil : cic.Term univs.Type0 B}\n  {op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)}\n  {f : cic.Term univs.Type0 (matita_arithmetics_nat.nat) B}\n  → cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2) B (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ i → matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op (λ i → f i (matita_arithmetics_bigops.op B nil op (λ i → f i i)))) (matita_arithmetics_bigops.bigop n (λ i → matita_basics_bool.true) B nil (matita_arithmetics_bigops.op B nil op (λ i → f i (matita_arithmetics_bigops.op B nil op (λ i → f i i))))))
 postulate nth : {univs : cic.Univ} {A : univs.Type0} {n : matita_arithmetics_nat.nat} {H : univs.Type0} {xs : matita_basics_lists_list.list H} {x : H} → cic.Term A H → cic.Term A H
 postulate Le_n_Sm_elim : \n  (n : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  (m : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  (__ : cic.Term univs.Type0 matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))\n  (P : cic.Univ univs.Type0 cic.prop)\n  (__1 : (cic.Term univs.Type0 matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m) -> cic.Term univs.Type0 cic.prop P))\n  (__2 : (cic.Term univs.Type0 matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat n (matita_arithmetics_nat.S m)) -> cic.Term univs.Type0 cic.prop P)) ->\n  cic.Term univs.Type0 cic.prop P
 postulate true_or_false : {b : cic.Term univs.Type0} {matita_basics_bool.bool} (cic.Term univs.Type0) (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b matita_basics_bool.false))
 postulate And_ind : {A : Univ} {B : Univ} {P : A → B → Univ} (Q : ∀ x → A → B → Univ) (H_conj : ∀ x → A → B → Univ) (x : Term) (y : Term) (z : Term) (w : Term) (Q_x : P x y) → Q x y → H_conj x y z w → P x y → Term P x y
 postulate divides_to_div : forall n m : Nat -> divides m n -> (quotient m n * n) == m
 postulate ACop_inv_rect_CProp2 : forall {x1 : Set} {x2 : x1} {Hterm : ACop x1 x2} {P : forall (_z1614 : ACop x1 x2), Prop} {H : forall (aop : Aop x1 x2) (_comm : forall (a : x1) (b : x1), Eq (op x1 x2 (aop a b)) (op x1 x2 (aop b a))) (z1615 : Eq (Hterm (mk_ACop x1 x2 aop _comm)) (mk_ACop x1 x2 aop _comm)), P (mk_ACop x1 x2 aop _comm)}, P Hterm.
 postulate Let_previous_prime4 : (n m : Nat) → Nat
 and elements $b3$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $b1$ and $b$ and $l$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ and $b1$ and $b3$ and $matita_arithmetics_lstar.lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $l$, for all elements $case_lstar$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$ and $return_sort$ and $return_type$ and $case_lstar_O$ and $case_lstar_S$, for all functions $case_sort$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $b$ and $b$ and $case_lstar_O$ and $case_lstar_S$, for all functions $case_type$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $b$ and $b$ and $case_lstar_O$ and $case_lstar_S$, for all elements $case_sort$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$ and $return_sort$ and $return_type$ and $case_lstar_O$ and $case_lstar_S$, for all elements $case_type$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$ and $return_sort$ and $return_type$ and $case_lstar_O$ and $case_lstar_S$, for all functions $case_sort$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $
 postulate not_le_to_lt : (n m : ℕ) → ¬ (n ≤ m) → m < n
 and $P$ applied to $a1$ and $a2$ and $a3$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $
 postulate monotonic_sqrt : cic.Term (cic.prop matita_basics_relations.monotonic (matita_arithmetics_nat.nat) (matita_arithmetics_nat.le) (matita_arithmetics_sqrt.sqrt))
 of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $T1$ and $l1$ and $matita_basics_lists_list.nil$ applied to $T1$ and $cic.prop$, for all elements $h$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $T1$ and $l1$ and $matita_basics_lists_list.nil$ applied to $T1$ and $cic.prop$, for all elements $g$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $T2$ and $l2$ and $matita_basics_lists_list.nil$ applied to $T2$ and $cic.prop$, for all elements $f$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $T1$ and $l1$ and $matita_basics_lists_list.nil$ applied to $T1$ and $cic.prop$, for all elements $e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $T2$ and $l2$ and $matita_basics_lists_list.nil$ applied to $T2$ and $cic.prop$, for all elements $d$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $mat
 postulate Void_rect_Type2_body : (Q_ : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type2) -> (x_486 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type2 Q_ x_486
$ and $c$ and functions $_id$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $sum$ and $a$ and functions $_trans$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ and functions $prod1$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and functions $_sym$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $sum$ and $a$ and functions $_subst$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term
 postulate eq_rect_Type3_r : (A : Univ Type2) (a : Term Type2 A) (P : (x : Term Type2 A) (p : Eq A x a) → Univ Type3) (p : Term Type3) (p0 : Eq A a a) → Term Type3 P a p
 postulate prop80 : even 2
 postulate max : ∀ (n m : ℕ) → n ≤ m ∨ m ≤ n
.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ to elements of $cic.Univ$ of $cic.prop$, $Q_$ applied to $matita_arithmetics_nat.plus$ applied to $m$ and $_n$ and $matita_basics_bool.true$ and $H_found_min_spec$ applied to $matita_arithmetics_nat.plus$ applied to $m$ and $_n$ and $matita_basics_bool.true$ and $x_1078$ and $x_1079$ and $x_1080$ and $x_1077$ is an element of $cic.Univ$ of $cic.prop$, for all functions $H_induction$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1083$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $x_1082$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $x_1081$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_1084$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_
 postulate Lhd : (H : cic.Univ univs.Type0) (x : cic.Term univs.Type0 (matita_basics_lists_list.list H)) (n : matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)
 postulate prop80 : even 2  \npostulate Eq_minus_S_pred : (n m : cic.Term) (H : n ∈ univs.Type0 ∧ m ∈ univs.Type0 ∧ m ∈ matita_arithmetics_nat.nat) → (cic.Term) (cic.prop) (matita_basics_logic.eq) (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m))
 postulate Le_exp_Psi2 : forall (n : ℕ), 1 < n -> (2 ^ (n `div` 2) <= Psi n)
 postulate Let_upper_bound5 : (n : Nat) -> (m : Nat) -> (nth_prime n < m) -> Nat
 postulate Bool_to_nat_body : (b : Bool) → Nat
 postulate Lt_SO_nth_prime_n : (n : cic.Term univs.Type0) -> (m : matita_arithmetics_nat.nat) -> cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.nth_prime n))
 postulate eqb : forall {A : univs.Type0} {x y : A} (p : matita_arithmetics_nat.nat), cic.Term A (matita_basics_bool.bool) p
 postulate div_mod_spec_rect_Type5 : \n  {univs : Univr} \n  {Type0 : UnivrUnivrType0} \n  {Type2 : UnivrUnivrType2} \n  {matita_arithmetics_nat.nat : UnivrType0} \n  {matita_arithmetics_div_and_mod.div_mod_spec : UnivrType2} \n  {cic.Term : UnivrUnivrType5} \n  {cic.prop : UnivrType5} \n  {cic.Univ : UnivrUnivrType5} \n  {matita_basics_logic.eq : UnivrType5} \n  {matita_arithmetics_nat.lt : UnivrType5} \n  {univs.Type5 : UnivrType5} \n  {matita_arithmetics_nat.plus : UnivrType5} \n  {matita_arithmetics_nat.times : UnivrType5} \n  {matita_arithmetics_nat.nat : UnivrType5} \n  {matita_arithmetics_div_and_mod.div_mod_spec_intro : UnivrType5} \n  {x_817 : UnivrType5} \n  {x_818 : UnivrType5} \n  {x_819 : UnivrType5} \n  {Q_ : UnivrType5} \n  {H_div_mod_spec_intro : UnivrType5} \n  {n : UnivrType5} \n  {m : UnivrType5} \n  {q : UnivrType5} \n  {r : UnivrType5} \n  {H_div_mod_spec : UnivrType5} \n  {H_div_mod_spec_intro : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod_spec_rect_Type5 : UnivrType5} \n  {div_mod
 postulate prime_to_divides_M : (m p : ℕ) → prime p → (m + 1 < p) → (p ≤ 2 * m + 1) → (p ≡ 0)
 postulate Le_B2_exp : \n  ∀ (n : cic.Term univs.Type0) (matita_arithmetics_nat.nat)\n  → ∀ (m : cic.Term cic.prop matita_arithmetics_nat.le)\n  → matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))))))))) n →\n  cic.Term (cic.prop matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))) n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))))))
 postulate Lt_plus_to_minus_r : \n  ∀ {univs} {matita_arithmetics_nat : matita_arithmetics_nat.universe univs} {a b c : matita_arithmetics_nat.nat} {__ : cic.Term (cic.prop) (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a b c))} \n  (cic.Term : matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus c b)).
 postulate le_maxl : ∀ {i n m : ℕ} → (max n m ≤ i) → (n ≤ i)
 postulate Prod_rect_Type1_body : {A : cic.Univ} {B : cic.Univ} {Q : cic.Term A -> cic.Term B -> cic.Term (cic.Univ (univs.Type1))} {H_mk_Prod : (x_700 : cic.Term A) -> (fst : cic.Term A) -> (snd : cic.Term B) -> Q (matita_basics_types.mk_Prod A B x_700 fst snd) -> (x_700 : cic.Term A) -> (matita_basics_types.Prod A B : cic.Term (cic.Univ (univs.Type1))) -> (Q x_700 : cic.Term (cic.Univ (univs.Type1))) -> cic.Term (cic.Univ (univs.Type1))
 postulate associative_plus : prop
 postulate Le_plus_b : {b : ℕ} {n m : ℕ} → (n + b) ≤ m → n ≤ m
 postulate dpair_rect_type1 : {A : cic.Univ} {f : cic.Term A -> cic.Univ} {Q : (x : cic.Term) (d : matita_basics_types.DPair A f) -> cic.Univ} {H_mk_DPair : (dpi1 : cic.Term) (dpi2 : cic.Term) -> cic.Term (univs.Type1)} (x_648 : cic.Term) (d : matita_basics_types.DPair A f) -> cic.Term (univs.Type1) (Q x_648 d)
 postulate Minus_le_minus_minus_comm : forall (b c a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (H : matita_arithmetics_nat.le c b) (H1 : cic.Term (cic.prop matita_arithmetics_nat.le) matita_arithmetics_nat.nat), cic.Term (cic.prop matita_basics_logic.eq) (matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a c) b)
 postulate dpair : {A : Univ univs.Type0} {f : Term univs.Type0 A -> Univ univs.Type0} -> Univ univs.Type0
 postulate Unit_rect_Type2 : {Q_ : (cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2} -> {H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)} -> {x_503 : cic.Term univs.Type0 matita_basics_types.unit} -> cic.Term univs.Type2 (Q_ x_503)
 postulate mod_times : \n  (n : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  (m : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  (p : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  (p_lt_0 : cic.Term univs.Type0 matita_arithmetics_nat.lt matita_arithmetics_nat.O p)\n  (eq : cic.Term univs.Type2 cic.prop (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times n m p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod m p)) p))) \n  (cic.Term univs.Type0 cic.prop eq)
 postulate Le_n_fn : (f : ℕ → ℕ) → (increasing f) → (n : ℕ) → n ≤ f n
 postulate fact_minus : ∀ (n k : ℕ) → k < n → (fact (n - (k + 1)) * (n - k)) ≡ (fact (n - k))
 postulate div_mod_spec_rect_CProp2 : \n  {n : Nat} {m : Nat} {q : Nat} {r : Nat} {Q : div_mod_spec n m q r -> Prop} \n  {H_div_mod_spec_intro : (x_851 : Lt r m) -> (x_850 : Eq n (q * m + r)) -> \n  Q (div_mod_spec_intro n m q r x_851 x_850)} -> \n  (x_849 : div_mod_spec n m q r) -> Q x_849
 $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.true$ and functions $_x_972$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.true$ and elements $_x_971$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $x3$ and elements $_x_970$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x3$ and $x1$ and elements $_x_969$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x3$ and $x1$ and elements $_x_968$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x3$ and $x1$ and elements $_x_967$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x3$ and $x1$ and elements $_x_966$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x3$ and $x1$ and elements $_x_965$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$
 postulate Unit_rect_CProp1_body : \n  (Q_ : (cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop)\n  (H_it : cic.Term cic.prop (Q_ matita_basics_types.it))\n  (x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> \n  cic.Term cic.prop (Q_ x_517)
 postulate Le_log2_sqrt : {n : cic.Term univs.Type0} {__ : cic.Term (cic.prop matita_arithmetics_nat.le (matita_arithmetics_nat.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))} {n' : cic.Term (cic.prop matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n'))} {sqrt_n : cic.Term (cic.prop matita_arithmetics_nat.le (matita_arithmetics_sqrt.sqrt n'))} : cic.Term (cic.prop matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)
_834$ and $P$ and $_H1$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P_1$ from elements $_z1464$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_835$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_834$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1465$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_835$ and $x_834$ and $P_1$ and $_H1$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P_2$
 postulate Let_clause_15691 : (m n : Nat) (a b : _) (h1 : 0 < n) (h2 : 0 < m) (h3 : gcd n m = 1) (c : Nat) (ex : ex Nat) (f : Nat -> _clearme_ (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq (Nat -> _clearme_ (Eq
 postulate exp_plus_times : {n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat} → cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat (matita_arithmetics_exp.exp n (matita_arithmetics_nat.plus p q))) (matita_arithmetics_exp.exp n (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp n q)))
 postulate monotonic_le_minus_r : ∀ (p q n : ℕ) → (q ≤ p) → (n - p) ≤ (n - q)
 postulate Match_option : \n  {A : cic.Univ univs.Type0} \n  {return_sort : cic.Sort} \n  {return_type : cic.Term univs.Type0 matita_basics_types.option A -> cic.Univ return_sort} \n  {case_None : cic.Term return_sort} \n  {case_Some : cic.Term univs.Type0 A -> cic.Term return_sort (return_type (matita_basics_types.Some A $__))} \n  (z : cic.Term univs.Type0 A) \n  -> cic.Term return_sort (return_type (matita_basics_types.option A z))
 postulate bigop_diff : (p : ℕ → Bool) (B : Set) (nil : B) (op : ACop B nil) (f : ℕ → B) (i n : ℕ) (H : i < n) (H' : p i ≡ true) → bigop n (λ x → p x B nil op (λ x → f x)) ≡ op B nil op (f i) (bigop n (λ x → andb (notb (eqb i x)) (p x) B nil op (λ x → f x)))
metics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.le
 postulate max_spec_to_max : \n  (f : cic.Term (univs.Type0) (matita_arithmetics_nat.nat) (cic.Term (univs.Type0) (matita_arithmetics_nat.nat)))\n  (n m : cic.Term (univs.Type0) (matita_arithmetics_nat.nat))\n  (p : cic.Term (cic.prop) (matita_arithmetics_minimization.max_spec n f m)) =>\n  cic.Term (cic.prop) (matita_basics_logic.eq (cic.lift (univs.Type0) (univs.Type2) (matita_arithmetics_nat.nat)) (matita_arithmetics_minimization.max n f m))
 postulate Divides_to_divides_ord_rem : (p n m : cic.Term univs.Type0) (lt_O_n : cic.Term (cic.prop matita_arithmetics_nat.lt (matita_arithmetics_nat.O) n)) (lt_O_m : cic.Term (cic.prop matita_arithmetics_nat.lt (matita_arithmetics_nat.O) m)) (prime_p : cic.Term (cic.prop matita_arithmetics_primes.prime p)) (divides_nm : cic.Term (cic.prop matita_arithmetics_primes.divides n m)) → cic.Term (cic.prop matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p))
 postulate Nat_rect_CProp4 : {Q_ : ℕ → Set} {H_O : Q_ 0} {H_S : ∀ {x_394} (x_396 : Q_ x_394) → Q_ (x_394 + 1)} (x_393 : ℕ) → Q_ x_393
 postulate plus_minus1 : ∀ {a b c : ℕ} → c ≤ b → a + (b - c) ≡ (a + b) - c
 postulate le_maxl : ∀ i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat → ∀ __ : cic.Term cic.prop matita_arithmetics_nat.le (matita_arithmetics_nat.max n m i) → cic.Term i cic.prop (matita_arithmetics_nat.le n i)
 postulate bijn_fg : (f g : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 : cic.Term univs.Type0 matita_arithmetics_permutation.bijn f n) (p2 : cic.Term univs.Type0 matita_arithmetics_permutation.bijn g n) -> cic.Term univs.Type0 matita_arithmetics_permutation.bijn (\p -> f (g p)) n
 postulate Sum_rect_CProp2_body : {A : Univ} {B : Univ} {Q : Term Univ prop} {H_inl : (x : Term Univ Type0) (A : Univ) -> Term Univ prop} {H_inr : (x : Term Univ Type0) (B : Univ) -> Term Univ prop} {x_571 : Term Univ Type0} {s : Sum A B} -> Q (inl A x_571) -> Q (inr B x_571) -> Term Univ prop -> Q s
 postulate match_divides : \n  {n : Nat} {m : Nat} {return_sort : Sort} \n  {return_type : (z : divisible n m) -> return_sort} \n  {case_quotient : (q : Nat) (eq : Eq m (n * q)) -> return_type (quotient n m q __)} \n  (n : Nat) (m : Nat) (z : divisible n m) (eq : Eq m (n * (quotient n m (quotient n m __) __))) \n  -> return_type z
 postulate div_times_times : \n  (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) \n  (p : cic.Term univs.Type2 cic.prop matita_arithmetics_nat.lt matita_arithmetics_nat.O c) \n  (q : cic.Term univs.Type2 cic.prop matita_arithmetics_nat.lt matita_arithmetics_nat.O b) \n  -> cic.Term univs.Type2 cic.prop matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat (matita_arithmetics_div_and_mod.div a b)) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)))
 postulate P_ord_exp : \n  {n m i : ℕ} \n  {h1 : 0 < m} \n  {h2 : mod n m ≠ 0} \n  {p : ℕ} \n  {h3 : i ≤ p} \n  → p_ord_aux p (m ^ i * n) m = mk_Prod Nat Nat i n
 postulate Dop_rect_CProp2_body : \n  {A : Set} {x : A} {Q : Dop A x → Set} {H_mk_Dop : ∀ {sum : ACop A x} {prod : A → A → A} {null : ∀ {a : A} → Eq (prod a _) → Set} {distr : ∀ {a b c : A} → Eq (prod a (aop__o__op A _)) → Eq (sum (sum a b) c) → Eq (sum a (sum b c)) → Eq (prod a (aop__o__op A b)) → Set} → Set}\n  → (Q (mk_Dop A _ sum prod null distr))
 postulate Filter_div_mod_spec : \n  forall (n m q r : Nat) (return_sort : Sort) (return_type : div_mod_spec n m q r -> return_sort) (return : div_mod_spec n m q r -> return_type) (z : div_mod_spec n m q r), return_type z
 postulate decidable_lt : (n m : cic.Term) → (n : univs.Type0) → (m : matita_arithmetics_nat.nat) → cic.prop → matita_basics_logic.decidable (matita_arithmetics_nat.lt n m)
 postulate le_prim_n1 : \n  ∀ (n : cic.Term univs.Type0) (n : matita_arithmetics_nat.nat) \n  (p : cic.Term cic.prop) (le : matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) \n  → cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))) n)) n)
 postulate example11 : cic.Term (cic.prop) (matita_basics_logic.eq (cic.lift (univs.Type0)) (cic.lift (univs.Type2))) (matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))))))
 postulate distr_body : \n  forall A : cic.Univ univs.Type0,\n    forall nil : cic.Term univs.Type0 A,\n    forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil),\n    forall a b c : cic.Term univs.Type0 A,\n      cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx a) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx b) (matita_arithmetics_bigops.sum A nil xxx c))) (matita_arithmetics_bigops.prod A nil xxx) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.prod A nil xxx a) (matita_arithmetics_bigops.prod A nil xxx b) (matita_arithmetics_bigops.prod A nil xxx c)))
 postulate Nat_rect_CProp4_body : \n  {Q_ : Nat -> Set} \n  {H_O : Q_ 0} \n  {H_S : (x_394 : Nat) -> (x_396 : Q_ x_394) -> Q_ (x_394 + 1)} \n  (x_393 : Nat) -> Q_ x_393
 postulate prop80 : even 2
 postulate PlusAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat matita_arithmetics_nat.O)
 postulate Nat_rect_CProp3_body : (Q_ : (cic.Term (univs.Type0) (matita_arithmetics_nat.nat) -> cic.prop) -> cic.prop) -> (H_O : cic.prop) -> (H_S : (x_402 : cic.Term (univs.Type0) (matita_arithmetics_nat.nat)) -> (x_404 : cic.prop) -> (Q_ (matita_arithmetics_nat.S x_402)) -> cic.prop) -> (x_401 : cic.Term (univs.Type0) (matita_arithmetics_nat.nat)) -> cic.prop
$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $c$ and $i$ and the function that maps $j$ to the function that maps $j0$ to $f$ applied to $j0$ applied to $matita_arithmetics_nat.plus$ applied to $j$ and $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $c$ and $i$ and the function that maps $j$ to the function that maps $j0$ to $f$ applied to $j0$ applied to $matita_arithmetics_nat.plus$ applied to $j$ and $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $matita_arithmetics_nat.plus$ applied to $i$ and $
 postulate Let_clause_1034 : forall n m p x2515 x2516, 0 < p -> x2515 == mod x2515 x2516 + x2516 * (x2515 / x2516)
 postulate unique : ∀ {H : Univ} {__: Term H} (l : list H) → Univ (prop H)
 postulate eq_sigma_pi_SO_n : ∀ n → (Nat → Bool) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Bool) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat → Nat) → (Nat →
 postulate Pair_destruct_1 : (A : cic.Univ) (B : cic.Univ) (a : cic.Term A) (b : cic.Term B) (c : cic.Term (matita_basics_types.Prod A B)) (eq : matita_basics_logic.eq (cic.lift univs.Type0) univs.Type2 (matita_basics_types.Prod A B) c (matita_basics_types.mk_Prod A B a b c)) → cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0) univs.Type2 A a (matita_basics_types.fst A B c)).
 postulate fact_minus : ∀ (n k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term (cic.prop matita_arithmetics_nat.lt k n)) → cic.Term (cic.prop matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S k)))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k)))
 postulate primeb : ∀ (n : Term) (m : nat) → Term univs.Type0 matita_basics_bool.bool
 postulate match_bool : (return_sort : cic.Sort) -> (return_type : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term return_sort) -> (case_true : cic.Term return_sort) -> (case_false : cic.Term return_sort) -> (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort z
 postulate monotonic_div : {n : Nat} -> (0 < n) -> Monotonic (Nat, Leq) (\m -> m `quot` n)
 postulate Lt_exp1 : {n : cic.Term (univs.Type0)} {m : cic.Term (univs.Type0)} {p : matita_arithmetics_nat.nat} {__ : cic.Term (cic.prop)} {__1 : cic.Term (cic.prop)} (H : matita_arithmetics_nat.lt matita_arithmetics_nat.O p) (H1 : matita_arithmetics_nat.lt n m) : cic.Term (cic.prop) (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))
 postulate Dexp : Dop Nat 1
 postulate Lt_SO_nth_prime_n : forall (n : Nat) -> 1 < nth_prime n
 postulate monotonic_le_minus_l : \n  ∀ (p q n : Term univs.Type0 matita_arithmetics_nat.nat) (x : Term cic.prop matita_arithmetics_nat.le q p) → \n  Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n))
 postulate Plus_plus_comm_23 : ∀ {x y z : ℕ} → (x + y) + z ≡ (x + z) + y
 postulate Lt_exp : (n m p : ℕ) → (1 < p) → (n < m) → (p ^ n < p ^ m)
 postulate Le_times_div_m_m : \n  ∀ {n m : cic.Term} {m' : matita_arithmetics_nat.nat} \n  (H0 : matita_arithmetics_nat.lt matita_arithmetics_nat.O m') \n  (H1 : cic.Term n m' cic.prop matita_arithmetics_nat.le \n    (matita_arithmetics_nat.times \n      (matita_arithmetics_div_and_mod.div n m) m) m) \n  → cic.Term n m' cic.prop matita_arithmetics_nat.le \n    (matita_arithmetics_nat.times n m) m
 postulate Option_rect_CProp2 : (A : Univ) -> (Q : Term -> Univ -> Prop) -> (H_None : Term -> Prop) -> (H_Some : Term -> A -> Term -> Prop) -> (x_626 : Term) -> (x_627 : Term -> A -> Term) -> (x_628 : Option A) -> Term x_628
 postulate prime_smallest_factor_n : \n  (n : cic.Term univs.Type0) (P : cic.Term cic.prop matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.smallest_factor n))
 postulate Le_sqrt_log : (n b : ℕ) → (2 < b) → (log b n) ≤ sqrt n
 postulate or : ∀{A B : Univ} → Prop → Prop
 postulate lt_nth_prime_to_not_prime : {n : ℕ} {m : ℕ} → nth_prime n < m → m < nth_prime (suc n) → ¬prime m
 postulate axiom : ∀ (n : ℕ) → successor n ≡ n
 postulate sum_inv_rect_Type3 : {x1 : Univ} {x2 : Univ} {Hterm : Term Univ} {z984 : Sum x1 x2} {P : (x : Term Univ) (z : Sum x1 x2) -> Univ} {H1 : (x537 : Term x1) (z985 : Term (Prop)) (eq : lift Type0 = lift Type2 (Sum x1 x2) (inl x1 x2 x537)) -> P (inl x1 x2 x537) z985} {H2 : (x538 : Term x2) (z985 : Term (Prop)) (eq : lift Type0 = lift Type2 (Sum x1 x2) (inr x1 x2 x538)) -> P (inr x1 x2 x538) z985} -> Term (Type3)
$ and $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $q$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux
 postulate Mk_Sig : (A : cic.Univ cic.prop) -> (f : cic.Term cic.prop -> A -> cic.Univ cic.prop) -> (pi1 : cic.Term cic.prop) -> (pi2 : cic.Term cic.prop) -> cic.Term cic.prop -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 -> cic.Term cic.prop -> A -> f pi1 pi2 ->
 postulate Nilr_body : ∀ {A : Univ} → A ∈ Type0 → ∀ {nil : Term} → nil ∈ A → ∀ {xxx : Term} → xxx ∈ A → ∀ {a : Term} → a ∈ A → Term holds prop (eq (lift Type0 Type2) A (op A nil xxx a nil a))
 postulate times_2_pred : \n  ∀ (n : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  → cic.prop matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred n)))
 postulate sigma_p_dividesb1 : \n  (m : Nat) (n : Nat) (p : Nat) (k : Nat) -> \n  0 < n -> \n  prime p -> \n  not (divisible p n) -> \n  m <= k -> \n  m == bigop (\i : Nat. dividesb (p ^ (i + 1)) (p ^ m * n)) k
 postulate lstar_r_sn : forall {B : Set} {R : relation B} {l : ℕ} {b b2 : B} {__ : lstar_r B R l b b2} {b1 : B} {__1 : R b1 b}, lstar_r B R (l + 1) b1 b2
 postulate void_rect_Type5 : (Q_ : (cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type5) -> (x_484 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type5 Q_ x_484
 postulate And_inv_rect_Type4 : \n  {x1 : Univ} {x2 : Univ} {Hterm : Term prop} {x124 : Term prop} {x123 : Term prop} {z330 : Term prop} {z329 : Term prop} \n  (H : And x1 x2) (P : (z330 : Term prop) -> And x1 x2 -> Univ) (H1 : x124 = x1 /\ x123 = x2 /\ conj x1 x2 x124 x123 = z330) -> Term univs.Type4 (P z329 H)
 postulate s : Nat -> Nat
 postulate Le_plus_to_le_r : ∀ {a n m : ℕ} → (n + a) ≤ (m + a) → n ≤ m
 postulate True_to_le_max : (f : ℕ → Bool) (n m : ℕ) → (m < n → f m ≡ true → m ≤ max n (f n))
 and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a_neq_b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.neq$ applied to $a$ and $b$, for all elements $a_bijf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bij$ applied to $f$ applied to $a$ and $bijf$, for all elements $b_bijf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bij$ applied to $f$ applied to $b$ and $bijf$, for all elements $a_eq_b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.eq$ applied to $a$ and $b$, for all elements $a_neq_b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.neq$ applied to $a$ and $b$, for all elements $a_bijf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bij$ applied to $f$ applied to $a$ and $bijf$, for all elements $b_bijf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bij$ applied to $f$ applied to $b$ and $bijf$, for all elements $a_eq_b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.eq$ applied to $a$ and $b$, for all elements $a_neq_b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.neq$ applied to $a$ and $b$, for all elements $a_bijf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bij$ applied to $f$ applied to $a$ and $bijf$, for all elements $b
 postulate Divides_to_divides_times : \n  (p q n : ℕ) -> \n  prime p -> \n  not (divides p q) -> \n  divides p n -> \n  divides q n -> \n  divides (p * q) n
 postulate not_divides_ord_rem : ∀ m p → 0 < m → 1 < p → ¬ (divides (ord_rem m p) p)
 postulate Le_times_div_div_times : \n  {a : cic.Term univs.Type0} \n  {n : matita_arithmetics_nat.nat} \n  {m : matita_arithmetics_nat.nat} \n  {x : cic.Term univs.Type0} \n  {lt : matita_arithmetics_nat.lt matita_arithmetics_nat.O m} \n  {le : matita_arithmetics_nat.le (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m) m)} \n  {h : cic.Term univs.Type0} \n  {eq : cic.eq h (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m))} \n  {eq' : cic.eq h (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m) m)} \n  {h' : cic.Term univs.Type0} \n  {eq'' : cic.eq h' (matita_arithmetics_nat.times a n)} \n  {eq''' : cic.eq h' (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m) m)} \n  {h'' : cic.Term univs.Type0} \n  {eq'''' : cic.eq h'' (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m))} \n  {eq''''' : cic.eq h'' (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m) m)} \n  {h''' : cic.Term univs.Type0} \n  {eq'''''' : cic.eq h''' (matita_arithmetics_nat.times a n)} \n  {eq''''''' : cic.eq h''' (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m) m)} \n  {h'''' : cic.Term univs.Type0} \n  {eq'''''''' :
 postulate distributive_times_plus : ∀ (n m p : Nat) → (n * (m + p)) ≡ ((n * m) + (n * p))
 postulate Let_clause_15611 : ∀ {p m n : ℕ} → 0 < p → gcd p m ≡ 1 → p ∣ (m * n) → ∀ {c : ℕ} → m * n ≡ p * c → ∀ {a : ℕ} → ∀ {ex : ex} → ∀ {f : ℕ → Bool} → (∀ {b : ℕ} → m * b ≡ a * p → gcd p m ≡ 1 ∨ a * p ≡ b * m → (a * p ≡ b * m → 1 ≡ gcd p m) → 1 ≡ gcd p m → 1 ≡ a * p - b * m) → 1 ≡ m * b - p * a
 postulate All_below : (l : cic.Term (univs.Type0)) (n : matita_arithmetics_nat.nat) → cic.Univ (cic.prop)
 postulate let_clause_1034 : \n  (n m q : ℕ) → (0 < n) → (0 < m) → (x2515 x2516 : ℕ) → (x2515 ≡ mod x2515 x2516 + (x2516 * (x2515 / x2516)))
 postulate div_mod_spec_rect_CProp1 : \n  {n : Nat} {m : Nat} {q : Nat} {r : Nat} \n  {Q_ : (x_853 : div_mod_spec n m q r) -> Prop} \n  {H_div_mod_spec_intro : \n    (x_855 : Lt r m) (x_854 : Eq n (q * m + r)) \n    -> Q_ (div_mod_spec_intro n m q r x_855 x_854)} \n  (x_853 : div_mod_spec n m q r) -> Q_ x_853
 postulate Let_clause_1549 : (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term univs.Type0 matita_arithmetics_nat.lt (matita_arithmetics_nat.O n)) (eqm0 : cic.Term univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.O) m)) (x1106 : cic.Term univs.Type0 matita_arithmetics_nat.nat) → cic.Term univs.Type0 (cic.prop (matita_arithmetics_nat.minus x1106 m))
 postulate lt_max_n : (f : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term univs.Type0 matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f n) n
 postulate divides_gcd_r : {n : cic.Term} {m : matita_arithmetics_nat.nat} (H1 : cic.Term) (H2 : matita_arithmetics_nat.nat) (H3 : matita_arithmetics_nat.nat) (H4 : matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) m) (H5 : cic.prop) (H6 : matita_arithmetics_nat.nat) (H7 : matita_arithmetics_nat.nat) (H8 : matita_arithmetics_nat.nat) (H9 : matita_arithmetics_nat.nat) (H10 : matita_arithmetics_nat.nat) (H11 : matita_arithmetics_nat.nat) (H12 : matita_arithmetics_nat.nat) (H13 : matita_arithmetics_nat.nat) (H14 : matita_arithmetics_nat.nat) (H15 : matita_arithmetics_nat.nat) (H16 : matita_arithmetics_nat.nat) (H17 : matita_arithmetics_nat.nat) (H18 : matita_arithmetics_nat.nat) (H19 : matita_arithmetics_nat.nat) (H20 : matita_arithmetics_nat.nat) (H21 : matita_arithmetics_nat.nat) (H22 : matita_arithmetics_nat.nat) (H23 : matita_arithmetics_nat.nat) (H24 : matita_arithmetics_nat.nat) (H25 : matita_arithmetics_nat.nat) (H26 : matita_arithmetics_nat.nat) (H27 : matita_arithmetics_nat.nat) (H28 : matita_arithmetics_nat.nat) (H29 : matita_arithmetics_nat.nat) (H30 : matita_arithmetics_nat.nat) (H31 : matita_arithmetics_nat.nat) (H32 : matita_arithmetics_nat.nat) (H33 : matita_arithmetics_nat.nat) (H34 : matita_arithmetics_nat.nat) (H35 : matita_arithmetics_nat.nat) (H3
 postulate Pred : (n : cic.Term) (m : matita_arithmetics_nat.nat) → univs.Type0 → Prop
 postulate log_exp2 : ∀ (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 n1 : cic.Term cic.prop matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) (p2 n2 : cic.Term cic.prop matita_arithmetics_nat.lt matita_arithmetics_nat.O n) → cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times m (matita_arithmetics_log.log p n)) (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)))
 postulate range_rect_CProp1 : \n  {A : Set} \n  {Q : (x_937 : range A) → Prop} \n  {H_mk_range : (H_enum : (n : ℕ) → A) → (upto : ℕ) → (filter : (n : ℕ) → Bool) → Q (mk_range A H_enum upto filter)} \n  (x_937 : range A) → Q x_937
 postulate previous_prime1 : (n : ℕ) → Nat
s.Type2$ and $A$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$, $Q_$ applied to $_nil$ and $matita_basics_lists.nil$ and $matita_basics_lists.nil$ and $_H_mk_Aop$ applied to $_nil$ and $matita_basics_lists.nil$ and $matita_basics_lists.nil$ and $_nill$ and $_nilr$ and $_assoc$ is $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $A$ and $_nil$ and $matita_basics_lists.nil$.\nOutput:\n\nAssistant: postulate Aop_rect_CProp4 : \n  {A : Univ}\n  {_nil : Term A}\n  {Q_ : ∀ (_x_795 : Term A) (_Aop : Aop A _nil) → Univ → Prop}\n  {_H_mk_Aop : ∀ (_x_795 : Term A) (_Aop : Aop A _nil) → Univ → Univ → Prop}\n  {_nill : ∀ (a : Term A) → Univ → Prop}\n  {_nilr : ∀ (a : Term A) → Univ → Prop}\n  {_assoc : ∀ (a b c : Term A) → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ → Univ →
 postulate log_exp2 : (p : ℕ) (n : ℕ) (m : ℕ) → (1 < p) → (0 < n) → (m * log p n) ≤ log p (n ^ m)
