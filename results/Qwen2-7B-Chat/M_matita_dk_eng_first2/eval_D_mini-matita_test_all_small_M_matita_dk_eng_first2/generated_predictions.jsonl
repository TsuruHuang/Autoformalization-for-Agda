{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Alors si $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$, alors si $b$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $b$ est égal à $j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : (i0 : nat -> Leq i0 n -> Leq (f i0) n), forall injf : injn f n, forall Hc : a = b, f a = i -> forall Hb : b <= n -> f b = j -> forall Hb' : b <= n -> f b = j -> forall __ : (i0 : nat -> Leq i0 n -> Leq (f i0) n), forall injf : injn f n, forall Hc : a = b, f a = i -> nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDop_rect_CProp0. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_967$ de $Dop$ de $A$ et de $_nil$ à des propositions. Soit $_H_mk_Dop$ une fonction des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$. Alors pour tous les éléments $x_967$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_967$.\nassistant\n", "label": "axiom Dop_rect_CProp0 (A : Set) (_nil : A) (Q_ : (_x_967 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_967 : Dop A _nil) : Q_ x_967", "predict": "axiom Dop_rect_CProp0 (A : Set) (_nil : A) (Q_ : (_x_967 : Dop A _nil) -> Prop) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> mk_Dop A _nil sum prod _null _distr) (x_967 : Dop A _nil) : Q_ x_967"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1062. Soient $a$ et $b$ et $q$ et $r$ et $q1$ et $r1$ des nombres naturels. Soit $_clearme$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q$ et de $r$. Supposons que $r$ est inférieur à $b$. Supposons que $a$ est égal à la somme du produit de $q$ et de $b$ et de $r$. Soit $_clearme0$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q1$ et de $r1$. Supposons que $r1$ est inférieur à $b$. Supposons que $a$ est égal à la somme du produit de $q1$ et de $b$ et de $r1$. Supposons que $q$ n'est pas inférieur ou ágal à $q1$. Alors $a$ est égal à la somme de $r1$ et du produit de $b$ et de $q1$.\nassistant\n", "label": "axiom let_clause_1062 (a b q r q1 r1 : Nat) (_clearme : div_mod_spec a b q r) (ltrb : r < b) (spec : a = q * b + r) (_clearme0 : div_mod_spec a b q1 r1) (ltr1b : r1 < b) (spec1 : a = q1 * b + r1) (leqq1 : ¬ (q ≤ q1)) : a = r1 + b * q1", "predict": "axiom let_clause_1062 (a b q r q1 r1 : Nat) (_clearme : div_mod_spec a b q r) (_clearme0 : div_mod_spec a b q1 r1) : (r < b) -> (a = (q * b) + r) -> (r1 < b) -> (a = (q1 * b) + r1) -> (q ≠ q1) -> a = r1 + (b * q1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLstar_ind_body. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $Q_$ vara en funktion från naturliga tal $x_1233$ och element $x_1232$ av $B$ och element $x_1231$ av $B$ och element $_x_1234$ av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$ till påståenden. Låt $_H_lstar_O$ vara en funktion från element $b$ av $B$ till element av $Q_$ av $0$ och $b$ och $b$ och $lstar_O (B , _R , b)$. Låt $_H_lstar_S$ vara en funktion från element $b1$ av $B$ och element $b$ av $B$ och element $x_1236$ av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $x_1235$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ och element $_x_1238$ av $Q_$ av $l$ och $b$ och $b2$ och $x_1235$ till element av $Q_$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B , _R , b1 , b , x_1236 , l , b2 , x_1235)$. Låt $x_1233$ vara ett naturligt tal. Låt $x_1232$ och $x_1231$ vara element av $B$. Låt $x_1234$ vara ett element av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$. Då håller $Q_$ för $x_1233$ och $x_1232$ och $x_1231$ och $x_1234$.\nassistant\n", "label": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind_body : (B : Set) -> (_R : Set) -> (Q_ : (x_1233 : Set) -> (x_1232 : Set) -> (x_1231 : Set) -> (_x_1234 : Set) -> Set) -> (_H_lstar_O : (b : Set) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : Set) -> (b : Set) -> (x_1236 : Set) -> (l : Nat) -> (b2 : Set) -> (x_1235 : Set) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235))) -> (x_1233 : Nat) -> (x_1232 : Set) -> (x_1231 : Set) -> (x_1234 : Set) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFst_p_ord_times. Let $p$ and $a$ and $b$ be natural numbers. Assume that $p$ is prime and $0 < a$. Assume that $0 < b$. Then $fst (Nat , Nat , p_ord (a b , p))= fst (Nat , Nat , p_ord (a , p))+ fst (Nat , Nat , p_ord (b , p))$.\nassistant\n", "label": "axiom fst_p_ord_times (p a b : Nat) (x__ : prime p) (__1 : 0 < a) (__2 : 0 < b) : fst Nat Nat (p_ord (a * b) p) = fst Nat Nat (p_ord a p) + fst Nat Nat (p_ord b p)", "predict": "axiom fst_p_ord_times (p a b : Nat) : Nat :=\n  if p : Prime then\n    if 0 < a then\n      if 0 < b then\n        fst (Nat , Nat , p_ord (a b , p)) = fst (Nat , Nat , p_ord (a , p)) + fst (Nat , Nat , p_ord (b , p))\n      else\n        fst (Nat , Nat , p_ord (a , p)) = a\n    else\n      fst (Nat , Nat , p_ord (b , p)) = b\n  else\n    0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTo_max. Låt $i$ och $n$ och $m$ vara naturliga tal. Anta att $n$ är mindre än eller lika med $i$. Då om $m$ är mindre än eller lika med $i$, så är $max$ applicerat på $n$ och $m$ mindre än eller lika med $i$.\nassistant\n", "label": "axiom to_max (i n m : Nat) (x__ : n ≤ i) (__1 : m ≤ i) : max n m ≤ i", "predict": "axiom to_max (i n m : Nat) : Nat => if n <= i => if m <= i => max n m <= i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nExp_to_fact1. Låt $n \\in N$. Då om $0$ är mindre än $n$, så är produkten av produkten av potensen av $2$ och produkten av $2$ och $n$ och fakulteten av $n$ och fakulteten av $n$ mindre än fakulteten av summan av produkten av $2$ och $n$ och $1$.\nassistant\n", "label": "axiom exp_to_fact1 (n : Nat) (x__ : 0 < n) : pow 2 (2 * n) * factorial n * factorial n < factorial (2 * n + 1)", "predict": "axiom exp_to_fact1 (n : N) : Prop\n| 0 : Prop\n| n : Prop\n| _n : Prop\naxiom exp_to_fact1 (n : N) : Prop\n| 0 : Prop\n| n : Prop\n| _n : Prop\naxiom exp_to_fact1 (n : N) : Prop\n| 0 : Prop\n| n : Prop\n| _n : Prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNat_inv_rect_Type1. Pour tous les nombres naturels $Hterm$, pour toutes les fonctions $P$ des nombres naturels $_z677$ à des éléments de $Type1$, pour toutes les fonctions $_H1$ des éléments $_z678$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$, pour toutes les fonctions $_H2$ des nombres naturels $x_386$ et des fonctions $_x_388$ des éléments $_z678$ de $Eq$ de $Hterm$ et de $x_386$ à des éléments de $P$ de $x_386$ et des éléments $_z678$ de $Eq$ de $Hterm$ et de la somme de $x_386$ et de $1$ à des éléments de $P$ de la somme de $x_386$ et de $1$, $P$ tient pour $Hterm$.\nassistant\n", "label": "Axiom nat_inv_rect_Type1 : forall Hterm : nat, forall P : ((_z677 : nat) -> Type1), forall _H1 : ((_z678 : Hterm = 0) -> P 0), forall _H2 : ((x_386 : nat) -> (_x_388 : (_z678 : Hterm = x_386) -> P x_386) -> (_z678 : Hterm = x_386 + 1) -> P (x_386 + 1)), P Hterm .", "predict": "Axiom nat_inv_rect_Type1 : forall Hterm : nat, forall P : ((_z677 : nat) -> Type1), forall _H1 : ((_z678 : Eq Hterm 0) -> P 0), forall _H2 : ((x_386 : nat) -> (_x_388 : (_z678 : Eq Hterm x_386) -> P x_386) -> (_z678 : Eq Hterm (x_386 + 1)) -> P (x_386 + 1)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPermut_fg. Let $f$ and $g$ be functions from natural numbers to natural numbers. Let $n$ be a natural number. Then for all elements $__$ of $permut$ of $f$ and $n$, for all elements $__1$ of $permut$ of $g$ and $n$, $permut$ holds for the function that maps $m$ to $f$ applied to $g$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom permut_fg : forall f : ((x__ : nat) -> nat), forall g : ((x__ : nat) -> nat), forall n : nat, forall x__ : permut f n, forall __1 : permut g n, permut (fun m => f (g m)) n .", "predict": "Axiom permut_fg : forall f : nat -> nat, forall g : nat -> nat, forall n : nat, forall __ : permut f n, forall __1 : permut g n, permut (fun m => f (g m)) n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1034. Soient $n$ et $m$ et $q$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Soient $x2515$ et $x2516$ des nombres naturels. Alors $x2515 = mod (x2515 , x2516)+ x2516 (x2515 \\div x2516)$.\nassistant\n", "label": "let_clause_1034 : n : Nat -> m : Nat -> q : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516))) .", "predict": "let_clause_1034 : n : Nat -> m : Nat -> q : Nat -> 0 < n -> 0 < m -> x2515 : Nat -> x2516 : Nat -> x2515 = mod (x2515 , x2516) + x2516 (x2515 \\div x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $m$ and $b$ and the product of $p$ and $a$.\nassistant\n", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : N) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (difference (product a p) (product b m)) (greatest_common_divisor p m) || Eq (difference (product b m) (product a p)) (greatest_common_divisor p m))) -> (b : Nat) -> (_difference : (product a p) - (product b m)) -> (_clearme1 : (_difference == greatest_common_divisor p m) || (difference (product b m) (product a p) == greatest_common_divisor p m)) -> (_clearme2 : (difference (product b m) (product a p) == greatest_common_divisor p m)) -> (_clearme3 : (_difference == 1)) -> greatest_common_divisor p m == (product m b) - (product p a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$ och $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Då om $f (a)= i$, så för alla naturliga tal $b$, om $b \\leq n$ och $f (b)= j$ och $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nassistant\n", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (i : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a : b) -> f a = j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1559. Let $n$ and $m$ be natural numbers. Assume that $n$ is divisible by $m$. Then if $0$ is equal to $n$, then for all natural numbers $d$, if $m$ is equal to the product of $0$ and $d$, then $m$ is equal to $n$.\nassistant\n", "label": "Axiom let_clause_1559 : forall n : nat, forall m : nat, forall divnm : divisible n m, forall H : (0 = n), forall d : nat, forall auto : (m = 0 * d), m = n .", "predict": "Axiom let_clause_1559 : forall n : nat, forall m : nat, forall d : nat, (n = 0 -> m = 0 -> m = n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15624. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nassistant\n", "label": "let_clause_15624 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .", "predict": "let_clause_15624 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : (d : Nat -> Eq (c n - d m) 1) -> Eq (d m - c n) 1 -> d : Nat -> c n - d m = 1 -> d m - c n = 1 -> m d - n c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_plus_n. Låt $n$ och $m$ vara naturliga tal. Då $m \\leq n + m$.\nassistant\n", "label": "Axiom le_plus_n : forall n : nat, forall m : nat, Leq m (n + m) .", "predict": "Axiom le_plus_n : forall n : nat, forall m : nat, nat <= n + m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPad_bigop_nil. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Then for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $or$ of $Eq$ applied to $p$ applied to $i$ and absurdity and $Eq$ applied to $f$ applied to $i$ and $nil$, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "Axiom pad_bigop_nil : forall k : nat, forall n : nat, forall p : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : Aop B nil, forall f : ((x__ : nat) -> B), forall x__ : Leq n k, forall __1 : ((i : nat) -> (__1 : Leq n i) -> (__2 : i < k) -> p i = false \\/ f i = nil), bigop n (fun i => p i) B nil (op B nil op) (fun i => f i) = bigop k (fun i => p i) B nil (op B nil op) (fun i => f i) .", "predict": "Axiom pad_bigop_nil : forall k : nat, forall n : nat, forall p : ((i : nat) -> bool), forall B : Set, forall nil : B, forall op : Aop B nil, forall f : ((i : nat) -> B), forall n : nat, forall __1 : ((i : nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) absurdity) (Eq (f i) nil)), forall bigop : ((n : nat) -> (i : nat -> p i) -> B -> nil -> op B nil op) -> ((i : nat) -> f i), bigop n (fun i => p i) B nil (op B nil op) (fun i => f i) = bigop k (fun i => p i) B nil (op B nil op) (fun i => f i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1648. Soit $n , q \\in N$. Alors si $0$ est inférieur à $q$, alors pour tous les nombres naturels $n1$, si $n1$ est égal à la somme du produit de $bigop$ appliqué à la somme de $n1$ et de $1$ et la fonction qui envoie $m$ à $andb$ appliqué à $leb$ appliqué à $1$ et $m$ et $dividesb$ appliqué à $q$ et $m$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $m$ à $1$ et de $q$ et de $mod$ appliqué à $n1$ et $q$, alors si $q$ est divisible par la somme de $n1$ et de $1$ et la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$, alors si $q$ est divisible par la somme de $n1$ et de $1$, alors si la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$, alors la somme de $n1$ et de $1$ est égale à la somme de $q$ et du produit de $q$ et du quotient de $n1$ et de $q$.\nassistant\n", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : (n : N) -> (q : N) -> (n1 : N) -> (andb : (m : N) -> (leb : 1 -> m) -> (dividesb : q -> m) -> Nat) -> (0 : N) -> (plus : (m : N) -> 1) -> (q : N) -> (mod : n1 -> q) -> (div : (n1 : N) -> (1 : N) -> (q : N) -> Nat) -> (eq : (n1 : N) -> (1 : N) -> (q : N) -> Bool) -> (divisible : (n1 : N) -> (1 : N) -> (q : N) -> Bool) -> (divisible1 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible2 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible3 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible4 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible5 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible6 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible7 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible8 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible9 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible10 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible11 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible12 : (q : N) -> (n1 : N) -> (1 : N) -> Bool) -> (divisible13 : (q : N) -> ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c \\in N$. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Då om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med $1$, så är skillnaden mellan produkten av $m$ och $b$ och produkten av $p$ och $a$ lika med $1$.\nassistant\n", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : (b : Nat) -> Eq (skillnaden mellan produkten av a och p och produkten av b och m) (det största gemensama delaret av p och m)) -> (b : Nat) -> (_clearme1 : (skillnaden mellan produkten av a och p och produkten av b och m) == (det största gemensama delaret av p och m) || (skillnaden mellan produkten av b och m och produkten av a och p) == (det största gemensama delaret av p och m)) -> (_clearme2 : (skillnaden mellan produkten av b och m och produkten av a och p) == (det största gemensama delaret av p och m)) -> (_clearme3 : (skillnaden mellan produkten av b och m och produkten av a och p) == 1) -> (skillnaden mellan produkten av m och b och produkten av p och a) == 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nRange_inv_rect_Type1. Soit $x1$ un ensemble. Soit $Hterm$ un élément de $range$ de $x1$. Soit $P$ une fonction des éléments $_z1656$ de $range$ de $x1$ à des éléments de $Type1$. Alors pour toutes les fonctions $_H1$ des fonctions $_enum$ des nombres naturels à des éléments de $x1$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes et des éléments $_z1657$ de $Eq$ de $Hterm$ et de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $P$ de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$, $P$ tient pour $Hterm$.\nassistant\n", "label": "range_inv_rect_Type1 : x1 : Set -> Hterm : range x1 -> P : (_z1656 : range x1 -> Type1) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1657 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .", "predict": "range_inv_rect_Type1 : x1 : Set -> Hterm : range x1 -> P : (_z1656 : range x1 -> Type1) -> _H1 : (_enum : (Nat -> x1) -> _upto : Nat -> _filter : (Nat -> Bool) -> _z1657 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_not_ord_O. For all natural numbers $p$ and $m$, if $0 < m$, then if $p$ is prime, then if $p$ is divisible by $m$, then $ord (m , p)$ is not equal to $0$.\nassistant\n", "label": "axiom divides_to_not_ord_O (p m : Nat) (x__ : 0 < m) (__1 : prime p) (__2 : divisible p m) : ¬ (ord m p = 0)", "predict": "axiom divides_to_not_ord_O (p m : Nat) : (0 < m) -> p : Prime -> p : Divisible m -> ord m p ≠ 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15321. Låt $n , m \\in N$. Anta att $0 < m$. Anta att $0 = n$. Anta att $0$ är delbart med $m$. Låt $q \\in N$. Anta att $m = 0 q$. Då $m = 0$.\nassistant\n", "label": "postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0", "predict": "postulate let_clause_15321 : (n : N) -> (m : N) -> (q : N) -> (m == 0 q) -> m == 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nQuotient. Let $n$ and $m$ and $q$ be natural numbers. Assume that $m$ is equal to the product of $n$ and $q$. Then $n$ is divisible by $m$.\nassistant\n", "label": "quotient : n : Nat -> m : Nat -> q : Nat -> __ : Eq m (times n q) -> divisible n m .", "predict": "quotient : n : Nat -> m : Nat -> q : Nat -> m = n * q -> n : Divisible m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nCongruent_ab. Låt $m , n , a , b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Då om $1$ är lika med det största gemensama delaret av $n$ och $m$, så håller $ex$ för $Nat$ och funktionen som avbildar $x$ som konjunktionen av $congruent$ applicerat på $x$ och $a$ och $m$ och $congruent$ applicerat på $x$ och $b$ och $n$.\nassistant\n", "label": "axiom congruent_ab (m n a b : Nat) (x__ : 0 < n) (__1 : 0 < m) (__2 : gcd n m = 1) : ex Nat (λ x => congruent x a m ∧ congruent x b n)", "predict": "axiom congruent_ab (m n a b : N) (0 < n) (0 < m) (1 : gcd n m) : Nat (ex : Nat) (λ x => and (congruent x a m) (congruent x b n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAop_rect_Type4. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_863$ av $Aop$ av $A$ och $_nil$ till element av $Type4$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Låt $x_863$ vara ett element av $Aop$ av $A$ och $_nil$. Då håller $Q_$ för $x_863$.\nassistant\n", "label": "postulate Aop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863", "predict": "postulate Aop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Set4) -> (_H_mk_Aop : (op : (__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1012. Pour toutes les fonctions $f$ des nombres naturels à des valeurs booléennes, pour tous les nombres naturels $n$ et $i$, pour toutes les fonctions $Hind$ des nombres naturels $b$ à des éléments de $prod$ de $Prop$ et de $Prop$ et de $Eq$ appliqué à $f$ appliqué à $let_m2$ appliqué à $f$ et $n$ et $i$ et $b$ et contradiction et de la fonction qui envoie $__$ à $Eq (let_m2 (f , n , i , b), i + b)$, pour tous les nombres naturels $b$, si $f (b)= true$, alors si contradiction est égal à $f (b)$, alors $true$ est égal à contradiction.\nassistant\n", "label": "postulate let_clause_1012 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (\\ _ : Eq (f (let_m2 f n i b)) false -> Eq (let_m2 f n i b) (plus i b))) -> (b : Nat) -> (fb : Eq (f b) true) -> (eqm : Eq (f b) false) -> Eq false true", "predict": "postulate let_clause_1012 : (f : Nat -> Bool) -> (n : Nat) -> (i : Nat) -> (Hind : (b : Nat) -> Prod Prop Prop (Eq (f (let_m2 f n i b)) contradiction) -> (__ : Prod Prop Prop (Eq (f (let_m2 f n i b)) i + b)) -> Bool) -> (b : Nat) -> (f b == true) -> (contradiction : Prod Prop Prop (Eq (f b) f b)) -> true == contradiction"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nExp_body. Låt $__$ och $__1$ vara naturliga tal. Då $Nat$.\nassistant\n", "label": "axiom exp_body (x__ __1 : Nat) : Nat", "predict": "axiom exp_body (__ __1 : Nat) : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus_mod. Let $m , n , q \\in N$. Then if $0 < q$, then $mod (m + n , q)\\leq mod (m , q)+ mod (n , q)$.\nassistant\n", "label": "Axiom le_plus_mod : forall m : nat, forall n : nat, forall q : nat, forall x__ : (0 < q), Leq (mod (m + n) q) (mod m q + mod n q) .", "predict": "Axiom le_plus_mod : forall m : N, forall n : N, forall q : N, 0 < q -> mod (m + n , q) <= mod (m , q) + mod (n , q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nPrime_nth_prime. Låt $n \\in N$. Då är $nth_prime$ applicerat på $n$ primt.\nassistant\n", "label": "Axiom prime_nth_prime : forall n : nat, prime (nth_prime n) .", "predict": "Axiom prime_nth_prime : forall n : N, nth_prime n : primt ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10471. Let $n1$ and $n2$ be natural numbers. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f1$ and $f2$ be functions from natural numbers to elements of $B$. Let $_clearme$ be an element of $iso$ of $B$ and $mk_range (B , f1 , n1 , p1)$ and $mk_range (B , f2 , n2 , p2)$. Let $h$ be a function from natural numbers to natural numbers. Let $_clearme0$ be an element of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $k$ be a function from natural numbers to natural numbers. Then if $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $sub_hk$ holds for $h", "label": "Axiom let_clause_10471 : forall n1 : nat, forall n2 : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ACop B nil, forall f1 : ((x__ : nat) -> B), forall f2 : ((x__ : nat) -> B), forall _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2), forall h : ((x__ : nat) -> nat), forall _clearme0 : ex (prod Set Set nat (fun x__ => nat)) (fun k => prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop Prop (p1 i = true) (fun __1 => f1 i = f2 (h i)))) /\\ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) /\\ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)), forall k : ((x__ : nat) -> nat), forall _clearme1 : (prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop Prop (p1 i = true) (fun __1 => f1 i = f2 (h i)))) /\\ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) /\\ sub_h", "predict": "Axiom let_clause_10471 : forall n1 : Nat, forall n2 : Nat, forall p1 : ((i : Nat) -> Bool), forall p2 : ((i : Nat) -> Bool), forall B : Set, forall nil : B, forall op : ACop B nil, forall f1 : ((i : Nat) -> B), forall f2 : ((i : Nat) -> B), forall _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2), forall h : ((i : Nat) -> Nat), forall _clearme0 : ex (prod Set Set Nat (fun __ => Nat)) (fun k => conjunction (conjunction (prod Set Prop Nat (fun i => prod Prop Prop (Lt i n1) (fun __ => prod Prop Prop (Eq (p1 i) true) (fun __1 => Eq (f1 i) (f2 (h i))))) (fun sub_hk => mk_range B f1 n1 p1)) (mk_range B f2 n2 p2) (fun sub_hk => mk_range B f2 n2 p2) (mk_range B f1 n1 p1))), forall k : ((i : Nat) -> Nat), forall prod : ((i : Nat) -> Bool), forall sub_hk : ((i : Nat) -> Bool), prod i -> sub_hk i -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_Type0_body. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_955$ of $Dop$ of $A$ and $_nil$ to sets, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod (a , _nil)$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod (a , aop__o__op (A , _nil , sum , b , c))$ and $aop__o__op (A , _nil , sum , prod (a , b), prod (a , c))$ to elements of $Q_$ of $mk_Dop (A , _nil , sum , prod , _null , _distr)$, for all elements $x_955$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_955$.\nassistant\n", "label": "axiom Dop_rect_Type0_body (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955", "predict": "axiom Dop_rect_Type0_body (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nInvert_permut_body. Let $__$ be a natural number. Let $__1$ be a function from natural numbers $__1$ to natural numbers. Then for all natural numbers $__2$, $Nat$.\nassistant\n", "label": "postulate invert_permut_body : (_ : Nat) -> (__1 : (__1 : Nat) -> Nat) -> (__2 : Nat) -> Nat", "predict": "postulate invert_permut_body : (__ : Nat) -> (__1 : (__1 : Nat) -> Nat) -> (__2 : Nat) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1544. Låt $p , q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m$ och $n$ vara naturliga tal. Anta att $0 < n$. Anta att $n \\leq m$. Anta att $n \\leq q + 1$. Anta att $n$ inte är delbart med $m$. Låt $a \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Låt $b \\in N$. Anta att $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ eller $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Anta att $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$. Då $a mod (m , n)- n b = gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "let_clause_1544 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n)) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n)) .", "predict": "let_clause_1544 : p : N -> q : N -> Hind : (m : N -> n : N -> __1 : Leq n m -> __2 : Leq n q -> ex : Nat -> (a : ex Nat -> b : Eq (skillnaden (produkten a n) (produkten b m)) (gcd_aux q m n) -> gcd_aux (q m n) (b m) (produkten a n))) -> m : N -> n : N -> 0 < n -> n <= m -> n <= q + 1 -> n != delbart med m -> a : N -> _clearme : (ex : Nat -> (b : Eq (skillnaden (produkten a (mod m n)) (produkten b n)) (gcd_aux q n (mod m n)) -> gcd_aux (q n (mod m n)) (skillnaden (produkten b n) (produkten a (mod m n))) (gcd_aux q n (mod m n)))) -> b : N -> a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> a mod (m , n) - n b = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_gcd_SO_to_not_divides. Let $n , m \\in N$. Assume that $1$ is less than $n$. Then if the greatest common divisor of $n$ and $m$ is equal to $1$, then $n$ is not divisible by $m$.\nassistant\n", "label": "axiom eq_gcd_SO_to_not_divides (n m : Nat) (x__ : 1 < n) (__1 : gcd n m = 1) : ¬ divisible n m", "predict": "axiom eq_gcd_SO_to_not_divides (n m : N) : (1 < n) -> (gcd n m = 1) -> n ≠ m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_10331. Let $n$ be a natural number. Let $p$ be a function from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g2$ applied to $i$. Let $Hle$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$. Then if $p$ applied to $n1$ is equal to $true$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Set) -> (p : (i : Set) -> Set) -> (g1 : (i : Set) -> Set) -> (g2 : (i : Set) -> Set) -> (n1 : Set) -> (Hind : (i : Set) -> (__1 : Set) -> (Leq : Set) -> (bigop : Set) -> (i : Set) -> (p : (i : Set) -> Set) -> Nat -> (1 : Set) -> (times : (i : Set) -> Set) -> (g1 : (i : Set) -> Set) -> (bigop : Set) -> (i : Set) -> (p : (i : Set) -> Set) -> Nat -> (1 : Set) -> (times : (i : Set) -> Set) -> (g2 : (i : Set) -> Set)) -> (Hle : (i : Set) -> (__1 : Set) -> (Leq : Set) -> (g1 : (i : Set) -> Set) -> (g2 : (i : Set) -> Set)) -> (p_n1 : Set) -> (x2515 : Set) -> (x2516 : Set) -> x2515 == (x2516 * (x2515 / x2516)) + (mod x2515 x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_rect_Type2. Let $Q_$ be a function from natural numbers $_x_381$ to elements of $Type2$. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of $x_382 + 1$. Let $x_381$ be a natural number. Then $Q_$ holds for $x_381$.\nassistant\n", "label": "Axiom nat_rect_Type2 : forall Q_ : ((_x_381 : nat) -> Type2), forall _H_O : Q_ 0, forall _H_S : ((x_382 : nat) -> (_x_384 : Q_ x_382) -> Q_ (x_382 + 1)), forall x_381 : nat, Q_ x_381 .", "predict": "Axiom nat_rect_Type2 : forall Q_ : ((_x_381 : Nat) -> Type2), forall _H_O : Q_ 0, forall _H_S : ((x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (x_382 + 1)), forall x_381 : Nat, Q_ x_381 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nPrimes_below_to_bertrand. Låt $pm$ vara ett naturligt tal. Låt $l$ vara en lista av naturliga tal. Anta att $pm$ är primt. Låt $__1$ vara ett element av $primes_below$ av $l$ och $pm + 1$. Låt $__2$ vara en funktion från naturliga tal $p$ och element $__2$ av $mem$ av $Nat$ och $p$ och $l$ och element $__3$ av $Lt$ av $2$ och $p$ till element av $ex$ av $Nat$ och funktionen som avbildar $pp$ som konjunktionen av konjunktionen av $mem$ applicerat på $Nat$ och $pp$ och $l$ och $Lt$ applicerat på $pp$ och $p$ och $Leq$ applicerat på $p$ och produkten av $2$ och $pp$. Låt $n \\in N$. Då om $0 < n$, så om $n < pm$, så håller $bertrand$ för $n$.\nassistant\n", "label": "axiom primes_below_to_bertrand (pm : Nat) (l : list Nat) (x__ : prime pm) (__1 : primes_below l (pm + 1)) (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : 2 < p) -> ex Nat (λ pp => mem Nat pp l ∧ pp < p ∧ p ≤ 2 * pp)) (n : Nat) (__3 : 0 < n) (__4 : n < pm) : bertrand n", "predict": "axiom primes_below_to_bertrand (pm : Nat) (l : List Nat) (__1 : primes_below l (pm + 1)) (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (λ pp => conj (conj (mem Nat pp l) (Lt pp p)) (Leq p (2 * pp)))) (n : Nat) : 0 < n -> n < pm -> bertrand n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_times_to_le_div. For all natural numbers $a$ and $b$ and $c$, if $0 < b$, then if $b c \\leq a$, then $c \\leq a \\div b$.\nassistant\n", "label": "axiom le_times_to_le_div (a b c : Nat) (x__ : 0 < b) (__1 : b * c ≤ a) : c ≤ a / b", "predict": "axiom le_times_to_le_div (a b c : Nat) : (0 < b) -> (b c <= a) -> c <= a / b"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_15601. Soit $n , m \\in N$. Supposons que $0 < m$. Supposons que $0 = n$. Supposons que $0$ est divisible par $m$. Soit $q$ un nombre naturel. Supposons que $m = 0 q$. Alors $n = 0$.\nassistant\n", "label": "postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0", "predict": "postulate let_clause_15601 : (n : N) -> (m : N) -> (q : N) -> (m == 0 q) -> n == 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBigop_I_gen. Let $a$ and $b$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a \\leq b$, then $bigop$ applied to $b$ and the function that maps $i$ to $andb$ applied to $leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$.\nassistant\n", "label": "axiom bigop_I_gen (a b : Nat) (p : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : Aop B nil) (f : (x__ : Nat) -> B) (x__ : a ≤ b) : bigop (b - a) (λ i => (λ i0 => p i0) (i + a)) B nil (op B nil op) (λ i => (λ i0 => f i0) (i + a)) = bigop b (λ i => andb (leb a i) (p i)) B nil (op B nil op) (λ i => f i)", "predict": "axiom bigop_I_gen (a b : Nat) (p : Nat -> Bool) (B : Set) (nil : B) (op : Aop B nil) (f : Nat -> B) (a b : Nat) : B :=\nif a <= b then bigop b (λ i => andb (leb a i) (p i)) B nil (op B nil op) (λ i => f i)) else bigop (b - a) (λ i => (λ i0 => p i0) (i + a)) B nil (op B nil op) (λ i => (λ i0 => f i0) (i + a)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNat_inv_rect_CProp0. Soit $Hterm \\in N$. Soit $P$ une fonction des nombres naturels $_z713$ à des propositions. Soit $_H1$ une fonction des éléments $_z714$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$. Alors pour toutes les fonctions $_H2$ des nombres naturels $x_414$ et des fonctions $_x_416$ des éléments $_z714$ de $Eq$ de $Hterm$ et de $x_414$ à des éléments de $P$ de $x_414$ et des éléments $_z714$ de $Eq$ de $Hterm$ et de la somme de $x_414$ et de $1$ à des éléments de $P$ de la somme de $x_414$ et de $1$, $P$ tient pour $Hterm$.\nassistant\n", "label": "Axiom nat_inv_rect_CProp0 : forall Hterm : nat, forall P : ((_z713 : nat) -> Prop), forall _H1 : ((_z714 : Hterm = 0) -> P 0), forall _H2 : ((x_414 : nat) -> (_x_416 : (_z714 : Hterm = x_414) -> P x_414) -> (_z714 : Hterm = x_414 + 1) -> P (x_414 + 1)), P Hterm .", "predict": "Axiom nat_inv_rect_CProp0 : forall Hterm : N, forall P : ((_z713 : N) -> Prop), forall _H1 : ((_z714 : Eq Hterm 0) -> P 0), forall _H2 : ((x_414 : N) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (x_414 + 1)) -> P (x_414 + 1)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMod_O_to_divides. Låt $n , m \\in N$. Anta att $0 < n$ och $mod (m , n)= 0$. Då är $n$ delbart med $m$.\nassistant\n", "label": "mod_O_to_divides : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Eq (mod m n) 0 -> divisible n m .", "predict": "mod_O_to_divides : n : N -> m : N -> 0 < n -> mod (m , n) = 0 -> n divides m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_to_dividesb_true1. Låt $n , m \\in N$. Då om $0 < m$ och $n$ är delbart med $m$, så $dividesb (n , m)= true$.\nassistant\n", "label": "postulate divides_to_dividesb_true1 : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Eq (dividesb n m) true", "predict": "postulate divides_to_dividesb_true1 : (n : N) -> (m : N) -> (0 < m) -> (n `divides` m) -> dividesb (n , m) = true"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDiv_mod_spec_inv_rect_CProp0. Låt $x1 , x2 , x3 , x4 \\in N$. Då för alla element $Hterm$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från element $_z1494$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden, för alla funktioner $_H1$ från element $x_859$ av $Lt$ av $x4$ och $x2$ och element $x_858$ av $Eq$ av $x1$ och summan av produkten av $x3$ och $x2$ och $x4$ och element $_z1495$ av $Eq$ av $Hterm$ och $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_859$ och $x_858$ till element av $P$ av $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_859$ och $x_858$, håller $P$ för $Hterm$.\nassistant\n", "label": "div_mod_spec_inv_rect_CProp0 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1494 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_859 : Lt x4 x2 -> x_858 : Eq x1 (plus (times x3 x2) x4) -> _z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm .", "predict": "div_mod_spec_inv_rect_CProp0 : x1 : N -> x2 : N -> x3 : N -> x4 : N -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1494 : div_mod_spec x1 x2 x3 x4 -> _z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858) -> _z1496 : Eq (sum x3 x2) x4 -> _z1497 : Lt x4 x2 -> _z1498 : Eq x1 (product x3 x2) x4 -> _z1499 : _z1500 : _z1501 : _z1502 : _z1503 : _z1504 : _z1505 : _z1506 : _z1507 : _z1508 : _z1509 : _z1510 : _z1511 : _z1512 : _z1513 : _z1514 : _z1515 : _z1516 : _z1517 : _z1518 : _z1519 : _z1520 : _z1521 : _z1522 : _z1523 : _z1524 : _z1525 : _z1526 : _z1527 : _z1528 : _z1529 : _z1530 : _z1531 : _z1532 : _z1533 : _z1534 : _z1535 : _z1536 : _z1537 : _z1538 : _z1539 : _z1540 : _z1541 : _z1542 : _z1543 : _z1544 : _z1545 : _z1546 : _z1547 : _z1548 : _z1549 : _z15"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp1. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_883$ of $Aop$ of $A$ and $_nil$ to propositions. Then for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_883$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_883$.\nassistant\n", "label": "Axiom Aop_rect_CProp1 : forall A : Set, forall _nil : A, forall Q_ : ((_x_883 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_883 : Aop A _nil, Q_ x_883 .", "predict": "Axiom Aop_rect_CProp1 : forall A : Set, forall _nil : A, forall Q_ : ((_x_883 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_883 : Aop A _nil, Q_ x_883 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNot_prime_times_2. Soit $n$ un nombre naturel. Alors si $1$ est inférieur à $n$, alors le produit de $2$ et de $n$ n'est pas premier.\nassistant\n", "label": "not_prime_times_2 : n : Nat -> __ : Lt (nd 1) n -> not (prime (times (nd 2) n)) .", "predict": "not_prime_times_2 : n : Nat -> 1 < n -> 2 * n != Prime ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i$ and $j$ be natural numbers. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a$ be a natural number. Then if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (x : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a : N) -> (b : N) -> (f a : N) -> (f b : N) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (a : N) -> (b : N) -> (postulate let_clause_1068 : (f : (x : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a : N) -> (b : N) -> (f a : N) -> (f b : N) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (a : N) -> (b : N) -> (f a : N) -> (f b : N) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (a : N) -> (b : N) -> (f a : N) -> (f b : N) -> (postulate let_clause_1068 : (f : (x : N)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_10331. För alla naturliga tal $n$, om $5 < n$, så för alla naturliga tal $m$, om $6 \\leq m$, så om $(m + 1)^ 2 \\leq 2 ^ m$, så för alla naturliga tal $a$, om $6 \\leq a$, så om $2 (a + 1)+ 1 \\leq 2 ^ a$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "let_clause_10331 : n : Nat -> lt4n : Lt (nd 5) n -> m : Nat -> le4m : Leq (nd 6) m -> Hind : Leq (pow (plus m (nd 1)) (nd 2)) (pow (nd 2) m) -> a : Nat -> lea : Leq (nd 6) a -> Hinda : Leq (plus (times (nd 2) (plus a (nd 1))) (nd 1)) (pow (nd 2) a) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_10331 : n : Nat -> m : Nat -> a : Nat -> x2515 : Nat -> x2516 : Nat -> 5 < n -> 6 <= m -> (m + 1)^ 2 <= 2 ^ m -> 6 <= a -> 2 (a + 1)+ 1 <= 2 ^ a -> x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_plus. Let $n1 , n2 , m1 , m2 \\in N$. Assume that $n1$ is less than or equal to $n2$. Then if $m1$ is less than or equal to $m2$, then the sum of $n1$ and $m1$ is less than or equal to the sum of $n2$ and $m2$.\nassistant\n", "label": "axiom le_plus (n1 n2 m1 m2 : Nat) (x__ : n1 ≤ n2) (__1 : m1 ≤ m2) : n1 + m1 ≤ n2 + m2", "predict": "axiom le_plus (n1 n2 m1 m2 : N) : Prop => and (n1 <= n2) (m1 <= m2) => n1 + m1 <= n2 + m2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nRange_inv_ind. Låt $x1$ vara en mängd. Då för alla element $Hterm$ av $range$ av $x1$, för alla funktioner $P$ från element $_z1632$ av $range$ av $x1$ till påståenden, för alla funktioner $_H1$ från funktioner $_enum$ från naturliga tal till element av $x1$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden och element $_z1633$ av $Eq$ av $Hterm$ och $mk_range (x1 , _enum , _upto , _filter)$ till element av $P$ av $mk_range (x1 , _enum , _upto , _filter)$, håller $P$ för $Hterm$.\nassistant\n", "label": "range_inv_ind : x1 : Set -> Hterm : range x1 -> P : (_z1632 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1633 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .", "predict": "range_inv_ind : x1 : Set -> Hterm : range x1 -> P : (_z1632 : range x1 -> Set) -> _H1 : (_enum : nat -> x1 -> _upto : nat -> _filter : nat -> Set -> _z1633 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i \\leq n$. Assume that $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$. Assume that $a \\leq n$. Then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$, then if $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : (i : N) -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (Hc : a <= n) (Hd : f a = i) (b : N) (Hb : b <= n) (Hc' : f b = j) (b' : N) (Hb' : b' <= n) (Hc'' : f b' = j) (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) (injf : injn f n) (Ha : a = b) : f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$. Supposons que $b \\leq n$. Supposons que $f (b)= j$. Alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : N -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (b : N) (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) (injf : injn f n) : (a = b) -> f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nFst_p_ord_times. Låt $p$ och $a$ och $b$ vara naturliga tal. Anta att $p$ är primt. Anta att $0$ är mindre än $a$. Anta att $0$ är mindre än $b$. Då är $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på produkten av $a$ och $b$ och $p$ lika med summan av $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på $a$ och $p$ och $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på $b$ och $p$.\nassistant\n", "label": "Axiom fst_p_ord_times : forall p : nat, forall a : nat, forall b : nat, forall x__ : prime p, forall __1 : (0 < a), forall __2 : (0 < b), fst nat nat (p_ord (a * b) p) = fst nat nat (p_ord a p) + fst nat nat (p_ord b p) .", "predict": "Axiom fst_p_ord_times : forall p : nat, forall a : nat, forall b : nat, p : prime -> 0 : a -> 0 : b -> fst Nat Nat (p_ord (a * b) p) = (fst Nat Nat (p_ord a p) + fst Nat Nat (p_ord b p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_inv_rect_CProp2. Let $Hterm \\in N$. Let $P$ be a function from natural numbers $_z701$ to propositions. Let $_H1$ be a function from elements $_z702$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Let $_H2$ be a function from natural numbers $x_406$ and functions $_x_408$ from elements $_z702$ of $Eq$ of $Hterm$ and $x_406$ to elements of $P$ of $x_406$ and elements $_z702$ of $Eq$ of $Hterm$ and $x_406 + 1$ to elements of $P$ of $x_406 + 1$. Then $P$ holds for $Hterm$.\nassistant\n", "label": "axiom nat_inv_rect_CProp2 (Hterm : Nat) (P : (_z701 : Nat) -> Prop) (_H1 : (_z702 : Hterm = 0) -> P 0) (_H2 : (x_406 : Nat) -> (_x_408 : (_z702 : Hterm = x_406) -> P x_406) -> (_z702 : Hterm = x_406 + 1) -> P (x_406 + 1)) : P Hterm", "predict": "axiom nat_inv_rect_CProp2 (Hterm : N) (P : (_z701 : N) -> Prop) (_H1 : (_z702 : Eq Hterm 0) -> P 0) (_H2 : (x_406 : N) -> (_x_408 : (_z702 : Eq Hterm x_406) -> P x_406) -> (_z702 : Eq Hterm (x_406 + 1)) -> P (x_406 + 1)) : P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1078. För alla naturliga tal $a$ och $b$ och $q$ och $r$ och $q1$ och $r1$, för alla element $_clearme$ av $div_mod_spec$ av $a$ och $b$ och $q$ och $r$, om $r < b$, så om $a = q b + r$, så för alla element $_clearme0$ av $div_mod_spec$ av $a$ och $b$ och $q1$ och $r1$, om $r1 < b$, så om $a = q1 b + r1$, så om $q \\leq q1$, så om $q < q1$, så $a = r + b q$.\nassistant\n", "label": "axiom let_clause_1078 (a b q r q1 r1 : Nat) (_clearme : div_mod_spec a b q r) (ltrb : r < b) (spec : a = q * b + r) (_clearme0 : div_mod_spec a b q1 r1) (ltr1b : r1 < b) (spec1 : a = q1 * b + r1) (leqq1 : q ≤ q1) (ltqq1 : q < q1) : a = r + b * q", "predict": "axiom let_clause_1078 (a b q r q1 r1 : Nat) (_clearme : div_mod_spec a b q r) (_clearme0 : div_mod_spec a b q1 r1) : (r < b) -> (a = q b + r) -> (r1 < b) -> (a = q1 b + r1) -> (q <= q1) -> (q < q1) -> (a = r + b q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_inv_rect_CProp4. Let $x1$ be a set. Then for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1734$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1735$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.\nassistant\n", "label": "postulate Dop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1734 : Dop x1 x2) -> Prop) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1735 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm", "predict": "postulate Dop_inv_rect_CProp4 : (x1 : Set) -> (x2 : Set) -> (Hterm : Dop x1 x2) -> (P : (_z1734 : Dop x1 x2) -> Set) -> (_H1 : (sum : ACop x1 x2) -> (prod : (x1 : Set) -> (__1 : Set) -> Set) -> (_null : (a : Set) -> Eq (prod a x2) x2) -> (_distr : (a : Set) -> (b : Set) -> (c : Set) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1735 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nFilter_max_spec. Soit $_n \\in N$. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $__$ un nombre naturel. Soit $return_sort$ un élément de $Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $max_spec$ de $_n$ et de $_f$ et de $__$ à des éléments de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $max_spec$ de $_n$ et de $_f$ et de $__$ à des éléments de $return_type$ de $z$, pour tous les éléments $z$ de $max_spec$ de $_n$ et de $_f$ et de $__$, $return_type$ tient pour $z$.\nassistant\n", "label": "filter_max_spec : _n : Nat -> _f : (__ : Nat -> bool) -> __ : Nat -> return_sort : Sort -> return_type : (z : max_spec _n _f __ -> return_sort) -> return : (z : max_spec _n _f __ -> return_type z) -> z : max_spec _n _f __ -> return_type z .", "predict": "filter_max_spec : _n : N -> _f : (n : N -> bool) -> __ : N -> return_sort : Sort -> return_type : (z : max_spec _n _f __ -> return_sort) -> return : (z : max_spec _n _f __ -> return_type z) -> z : max_spec _n _f __ -> return_type z ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15623. Let $m , n , a , b \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Then for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.\nassistant\n", "label": "Axiom let_clause_15623 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), m * d - n * c = 1 .", "predict": "Axiom let_clause_15623 : forall m : N, forall n : N, forall a : N, forall b : N, forall c : N, forall _clearme : ((d : N) -> Eq (diff (product c n) (product d m)) 1 -> Eq (diff (product d m) (product c n)) 1), forall d : N, ((diff (product c n) (product d m)) = 1 -> (diff (product d m) (product c n)) = 1 -> (diff (product d m) (product c n)) = 1 -> (diff (product m d) (product n c)) = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nSmallest_factor_to_prime. För alla naturliga tal $n$, om $1 < n$, så om $smallest_factor (n)= n$, så är $n$ primt.\nassistant\n", "label": "Axiom smallest_factor_to_prime : forall n : nat, forall x__ : (1 < n), forall __1 : (smallest_factor n = n), prime n .", "predict": "Axiom smallest_factor_to_prime : nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_10332. Let $n \\in N$. Then if $0 < n$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "axiom let_clause_10332 (n : Nat) (posn : 0 < n) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_10332 (n : N) (x2515 x2516 : Nat) : Nat := x2516 * (x2515 / x2516) + mod x2515 x2516"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_min_spec. Let $_n , _b \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $__$ to elements of $return_sort$. Let $case_found_min_spec$ be a function from natural numbers $m$ and elements of $Leq$ of $_b$ and $m$ and elements $__1$ of $Lt$ of $m$ and $_n + _b$ and elements $__2$ of $Eq$ of $_f (m)$ and $true$ and functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $_b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f (i)$ and absurdity to elements of $return_type$ of $m$ and $found_min_spec (_n , _b , _f , m , __ , __1 , __2 , __3)$. Let $case_not_found_min_spec$ be a function from functions from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n + _b$ to elements of $Eq$ of $_f (i)$ and absurdity to elements of $return_type$ of $_n + _b$ and $not_found_min_spec (_n , _b , _f , __)$. Let $__ \\in N$. Let $z$ be an element of $min_spec$ of $_n$ and $_b$ and $_f$ and $__$. Then $return_type$ holds for $__$ and $z$.\nassistant\n", "label": "axiom match_min_spec (_n _b : Nat) (_f : (x__ : Nat) -> bool) (return_sort : Sort) (return_type : (x__ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) (case_found_min_spec : (m : Nat) -> (x__ : _b ≤ m) -> (__1 : m < _n + _b) -> (__2 : _f m = true) -> (__3 : (i : Nat) -> (__3 : _b ≤ i) -> (__4 : i < m) -> _f i = false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) (case_not_found_min_spec : (x__ : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < _n + _b) -> _f i = false) -> return_type (_n + _b) (not_found_min_spec _n _b _f __)) (x__ : Nat) (z : min_spec _n _b _f __) : return_type __ z", "predict": "axiom match_min_spec (_n _b : N) (_f : (i : N) -> Bool) (return_sort : Sort) (return_type : (z : min_spec _n _b _f __) -> return_sort) (case_found_min_spec : (m : N) -> (Leq _b m) -> (__1 : Lt m (_n + _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : N) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) absurdity) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) (case_not_found_min_spec : (__ : (i : N) -> Eq (_f i) absurdity) -> return_type (_n + _b) (not_found_min_spec _n _b _f __)) (__ : N) (z : min_spec _n _b _f __) : return_type __ z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDop_rect_Type4. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_945$ de $Dop$ de $A$ et de $_nil$ à des éléments de $Type4$. Alors pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_945$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_945$.\nassistant\n", "label": "Dop_rect_Type4 : A : Set -> _nil : A -> Q_ : (_x_945 : Dop A _nil -> Type4) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_945 : Dop A _nil -> Q_ x_945 .", "predict": "Dop_rect_Type4 : A : Set -> _nil : A -> Q_ : (_x_945 : Dop A _nil -> Type4) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (a : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_945 : Dop A _nil -> Q_ x_945 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nRange_inv_rect_Type1. För alla mängder $x1$, för alla element $Hterm$ av $range$ av $x1$, för alla funktioner $P$ från element $_z1656$ av $range$ av $x1$ till element av $Type1$, för alla funktioner $_H1$ från funktioner $_enum$ från naturliga tal till element av $x1$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden och element $_z1657$ av $Eq$ av $Hterm$ och $mk_range (x1 , _enum , _upto , _filter)$ till element av $P$ av $mk_range (x1 , _enum , _upto , _filter)$, håller $P$ för $Hterm$.\nassistant\n", "label": "postulate range_inv_rect_Type1 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1656 : range x1) -> Type1) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1657 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm", "predict": "postulate range_inv_rect_Type1 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1656 : range x1) -> Type1) -> (_H1 : (_enum : nat -> x1) -> (_upto : nat) -> (_filter : nat -> sanningsvärden) -> (_z1657 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_sigma. Let $n$ be a natural number. Let $p1$ and $p2$ be functions from natural numbers to booleans. Then for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.\nassistant\n", "label": "Axiom le_sigma : forall n : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall g1 : ((x__ : nat) -> nat), forall g2 : ((x__ : nat) -> nat), forall x__ : ((i : nat) -> (x__ : i < n) -> (__1 : p1 i = true) -> p2 i = true), forall __1 : ((i : nat) -> (__1 : i < n) -> (__2 : p1 i = true) -> Leq (g1 i) (g2 i)), Leq (bigop n (fun i => p1 i) nat 0 plus (fun i => g1 i)) (bigop n (fun i => p2 i) nat 0 plus (fun i => g2 i)) .", "predict": "Axiom le_sigma : forall n : nat, forall p1 : ((i : nat) -> bool), forall p2 : ((i : nat) -> bool), forall g1 : ((i : nat) -> nat), forall g2 : ((i : nat) -> nat), forall __ : ((i : nat) -> (__1 : Eq p1 i true) -> Eq p2 i true), forall __1 : ((i : nat) -> (__1 : Lt i n) -> (__2 : Eq p1 i true) -> Leq (g1 i) (g2 i)), forall bigop : ((i : nat) -> p1 i -> Nat -> plus -> (i : nat) -> g1 i) -> ((i : nat) -> p2 i -> Nat -> plus -> (i : nat) -> g2 i) -> Eq (bigop n (fun i => p1 i) Nat 0 plus (fun i => g1 i)) (bigop n (fun i => p2 i) Nat 0 plus (fun i => g2 i)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1545. Soient $m$ et $n$ des nombres naturels. Supposons que $0$ est égal au diviseur commun plus grand de $m$ et de $n$. Supposons que $0$ est divisible par $n$. Soit $q1$ un nombre naturel. Supposons que $n = 0 q1$. Supposons que $0$ est divisible par $m$. Soit $q2$ un nombre naturel. Supposons que $m = 0 q2$. Alors $m = 0$.\nassistant\n", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (q1 : Nat) -> (q2 : Nat) -> (x : Nat) -> (y : Nat) -> (Hc : Div x y) -> (Hd : Div y x) -> (Hb : Div n m) -> (Hd2 : Div n 0) -> (q1d : Div n q1) -> (q2d : Div m q2) -> (Hm : Div m 0) -> (let_clause_1545 : (m : Nat) -> (n : Nat) -> (q1 : Nat) -> (q2 : Nat) -> (x : Nat) -> (y : Nat) -> (Hc : Div x y) -> (Hd : Div y x) -> (Hb : Div n m) -> (Hd2 : Div n 0) -> (q1d : Div n q1) -> (q2d : Div m q2) -> (Hm : Div m 0) -> (Hn : Div n 0) -> (q3 : Nat) -> (Hq3 : Div q3 (q1 * q2)) -> (Hc2 : Div (q1 * q2) n) -> (Hd22 : Div (q1 * q2) m) -> (Hb2 : Div m n) -> (q4 : Nat) -> (Hq4 : Div q4 m) -> (q5 : Nat) -> (Hq5 : Div q5 n) -> (Hpostulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (q1 : Nat) -> (q2 : Nat) -> (x : Nat) -> (y : Nat) -> (Hc : Div x y) -> (Hd : Div y x) -> (Hb : Div n m) -> (Hd2 : Div n 0) -> (q1d : Div n q1) -> (q2d : Div m q2) -> (Hm : Div m 0) -> (let_clause_1545 : (m : Nat) -> (n : Nat) -> (q1 : Nat) -> (q2 : Nat) -> (x : Nat) -> (y : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nACop_inv_ind. Låt $x1$ vara en mängd. Låt $x2$ vara ett element av $x1$. Låt $Hterm$ vara ett element av $ACop$ av $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1566$ av $ACop$ av $x1$ och $x2$ till påståenden. Då för alla funktioner $_H1$ från element $aop$ av $Aop$ av $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $x1$ och element $b$ av $x1$ till element av $Eq$ av $op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1567$ av $Eq$ av $Hterm$ och $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $P$ av $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $P$ för $Hterm$.\nassistant\n", "label": "ACop_inv_ind : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1566 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1567 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .", "predict": "ACop_inv_ind : x1 : Set -> x2 : Element(x1) -> Hterm : Element(ACop(x1, x2) -> P : (_z1566 : ACop(x1, x2) -> _z1567 : Eq(Hterm, mk_ACop(x1, x2, aop, _comm) -> _z1568 : P(mk_ACop(x1, x2, aop, _comm))) -> _H1 : (aop : Aop(x1, x2) -> _comm : (a : x1 -> b : x1 -> Eq(op(x1, x2, aop) a b, op(x1, x2, aop) b a)) -> _z1567 : Eq(Hterm, mk_ACop(x1, x2, aop, _comm) -> P(mk_ACop(x1, x2, aop, _comm))) -> P(Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nFmax_false. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Alors pour tous les nombres naturels $n$ et $m$, si $max (n , f)= m$ et contradiction est égal à $f (m)$, alors $m = 0$.\nassistant\n", "label": "postulate fmax_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq (f m) false) -> Eq m 0", "predict": "postulate fmax_false : (f : (n : Set) -> Set) -> (n : Set) -> (m : Set) -> max (n , f) = m -> contradiction = f m) -> m = 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_plus_to_minus. Låt $n , m , p \\in N$. Anta att $m \\leq n$. Då om $n < p + m$, så $n - m < p$.\nassistant\n", "label": "lt_plus_to_minus : n : Nat -> m : Nat -> p : Nat -> __ : Leq m n -> __1 : Lt n (plus p m) -> Lt (minus n m) p .", "predict": "lt_plus_to_minus : n : N -> m : N -> p : N -> m <= n -> n < p + m -> n - m < p ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBijn_transpose_r. Let $f$ be a function from natural numbers to natural numbers. Let $n$ and $i$ and $j$ be natural numbers. Assume that $i \\leq n$. Assume that $j \\leq n$. Then for all elements $__2$ of $bijn$ of $f$ and $n$, $bijn$ holds for the function that maps $p$ to $f (transpose (i , j , p))$ and $n$.\nassistant\n", "label": "Axiom bijn_transpose_r : forall f : ((x__ : nat) -> nat), forall n : nat, forall i : nat, forall j : nat, forall x__ : Leq i n, forall __1 : Leq j n, forall __2 : bijn f n, bijn (fun p => f (transpose i j p)) n .", "predict": "Axiom bijn_transpose_r : forall f : nat -> nat, forall n : nat, forall i : nat, forall j : nat, forall __2 : bijn f n, forall p : nat, bijn (fun p => f (transpose i j p)) n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nGcd_1_to_divides_times_to_divides. Let $p , n , m \\in N$. Then if $0$ is less than $p$, then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if $p$ is divisible by the product of $n$ and $m$, then $p$ is divisible by $m$.\nassistant\n", "label": "gcd_1_to_divides_times_to_divides : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 p -> __1 : Eq (gcd p n) (nd 1) -> __2 : divisible p (times n m) -> divisible p m .", "predict": "gcd_1_to_divides_times_to_divides : p : N -> n : N -> m : N -> 0 < p -> gcd(p, n) = 1 -> p % (n * m) -> p % m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAop_rect_CProp0. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_885$ av $Aop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_885$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_885$.\nassistant\n", "label": "Aop_rect_CProp0 : A : Set -> _nil : A -> Q_ : (_x_885 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_885 : Aop A _nil -> Q_ x_885 .", "predict": "Aop_rect_CProp0 : A : Set -> _nil : A -> Q_ : (_x_885 : Aop A _nil -> Oneproof) -> _H_mk_Aop : (op : (a : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_885 : Aop A _nil -> Q_ x_885 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nassistant\n", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (n * c - m * d) 1)) -> (d : Nat) -> (m * d - n * c) == gcd m n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_15692. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Alors si $0 < n$ et $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nassistant\n", "label": "Axiom let_clause_15692 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), m * d - n * c = 1 .", "predict": "Axiom let_clause_15692 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : (d : Nat) -> Eq (div (n * c) - (d * m)) 1) -> Eq (div (d * m) - (c * n)) 1), forall d : Nat, ((c n - d m = 1) -> (d m - c n = 1) -> (d m - c n = 1)) -> m d - n c = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDpi1__o__op. Let $x0$ be a set. Let $x1$ be an element of $x0$. Let $x2$ be a function from elements of $Aop$ of $x0$ and $x1$ to sets. Let $x3$ be an element of $DPair$ of $Aop (x0 , x1)$ and $x2$. Then for all elements $_x_887$ and $_x_888$ of $x0$, $x0$.\nassistant\n", "label": "postulate dpi1__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : Aop x0 x1) -> Set) -> (x3 : DPair (Aop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0", "predict": "postulate dpi1__o__op : (x0 : Set) -> (x1 : Set) -> (x2 : (Aop x0 x1 -> Set)) -> (x3 : DPair (Aop x0 x1) x2) -> (_x_887 : Set) -> (_x_888 : Set) -> (_x_889 : (_x_890 : Aop x0 x1) -> (_x_891 : Set) -> (_x_892 : Set) -> (_x_893 : (_x_894 : Aop x0 x1) -> (_x_895 : Set) -> (_x_896 : Set) -> (_x_897 : (_x_898 : Aop x0 x1) -> (_x_899 : Set) -> (_x_900 : Set) -> (_x_901 : (_x_902 : Aop x0 x1) -> (_x_903 : Set) -> (_x_904 : Set) -> (_x_905 : (_x_906 : Aop x0 x1) -> (_x_907 : Set) -> (_x_908 : Set) -> (_x_909 : (_x_910 : Aop x0 x1) -> (_x_911 : Set) -> (_x_912 : Set) -> (_x_913 : (_x_914 : Aop x0 x1) -> (_x_915 : Set) -> (_x_916 : Set) -> (_x_917 : (_x_918 : Aop x0 x1) -> (_x_919 : Set) -> (_x_920 : Set) -> (_x_921 : (_x_922 : Aop x0 x1) -> (_x_923 : Set) -> (_x_924 : Set) -> (_x_925 : (_x_926 : Aop x0 x1) -> (_x_927 : Set) -> (_x_928 : Set) -> (_x_929 : (_x_930 : Aop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_rect_CProp0. Let $Q_$ be a function from natural numbers $_x_413$ to propositions. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_414$ and elements $_x_416$ of $Q_$ of $x_414$ to elements of $Q_$ of the sum of $x_414$ and $1$. Then for all natural numbers $x_413$, $Q_$ holds for $x_413$.\nassistant\n", "label": "Axiom nat_rect_CProp0 : forall Q_ : ((_x_413 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_414 : nat) -> (_x_416 : Q_ x_414) -> Q_ (x_414 + 1)), forall x_413 : nat, Q_ x_413 .", "predict": "Axiom nat_rect_CProp0 : forall Q_ : ((_x_413 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_414 : nat) -> (_x_416 : Q_ x_414) -> Q_ (x_414 + 1)), forall x_413 : nat, Q_ x_413 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b$ be a natural number. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Assume that $f (b)= j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : (i : N) -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (b : N) (__ : (i0 : N) -> (Leq i0 n) -> Leq (f i0) n) (injf : injn f n) : a = b -> f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_sqrt_nl. Pour tous les nombres naturels $n$ et $m$, si $3 < n$, alors $m pred (m)n \\leq (\\sqrt{ m ^ 2 n})^ 2$.\nassistant\n", "label": "Axiom le_sqrt_nl : forall n : nat, forall m : nat, forall x__ : (3 < n), Leq (m * pred m * n) (pow (sqrt (pow m 2 * n)) 2) .", "predict": "Axiom le_sqrt_nl : forall n : nat, forall m : nat, 3 < n -> m pred (m)n <= (\\sqrt{ m ^ 2 n})^ 2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n \\in N$. Anta att $2 ^ 7 \\leq n$. Låt $p$ vara ett naturligt tal. Anta att $\\sqrt{ (2 n)}+ 1 \\leq p$. Anta att $p < 2 n + 1$. Anta att $leb (2 , k (2 n , p))= true$. Då om $2 n < p ^ 2$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (p : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> (True : Bool) -> (2n < p^2) -> (x2515 = x2516 (x2515 \\div x2516) + mod x2515 x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_prime_to_primeb_false. Let $n \\in N$. Then if $n$ is not prime, then absurdity is equal to $primeb (n)$.\nassistant\n", "label": "not_prime_to_primeb_false : n : Nat -> __ : not (prime n) -> Eq (primeb n) false .", "predict": "not_prime_to_primeb_false : n : N -> absurdity = primeb (n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPermut_fg. Soient $f$ et $g$ des fonctions des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Alors pour tous les éléments $__$ de $permut$ de $f$ et de $n$, pour tous les éléments $__1$ de $permut$ de $g$ et de $n$, $permut$ tient pour la fonction qui envoie $m$ à $f (g (m))$ et $n$.\nassistant\n", "label": "Axiom permut_fg : forall f : ((x__ : nat) -> nat), forall g : ((x__ : nat) -> nat), forall n : nat, forall x__ : permut f n, forall __1 : permut g n, permut (fun m => f (g m)) n .", "predict": "Axiom permut_fg : forall f : nat -> nat, forall g : nat -> nat, forall n : nat, forall __ : permut f n, forall __1 : permut g n, permut (fun m => f (g m)) n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Alors si $b$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $b$ est égal à $j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (b : Nat) (__ : (i0 : Nat) -> (Leq i0 n) -> Leq (f i0) n) (injf : injn f n) (Hc : a = b) : f a = j) : (Hb : b ≤ n) -> (Hf : f b = j) -> (__ : (i0 : Nat) -> (Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (Ha : a = b) -> f a = j)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiv_mod_spec_rect_CProp3. Soit $_n , _m , _q , _r \\in N$. Soit $Q_$ une fonction des éléments $_x_845$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_847$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_846$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_847$ et $x_846$. Alors pour tous les éléments $x_845$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_845$.\nassistant\n", "label": "div_mod_spec_rect_CProp3 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_845 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_847 : Lt _r _m -> x_846 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> x_845 : div_mod_spec _n _m _q _r -> Q_ x_845 .", "predict": "div_mod_spec_rect_CProp3 : _n : N -> _m : N -> _q : N -> _r : N -> Q_ : (_x_845 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_847 : Lt _r _m -> x_846 : Eq _n (prod _q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> x_845 : div_mod_spec _n _m _q _r -> Q_ x_845 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_minus_to_plus_r. Låt $a , b , c \\in N$. Anta att $c$ är mindre än eller lika med $b$. Anta att $a$ är mindre än eller lika med skillnaden mellan $b$ och $c$. Då är summan av $a$ och $c$ mindre än eller lika med $b$.\nassistant\n", "label": "postulate le_minus_to_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Leq c b) -> (__1 : Leq a (minus b c)) -> Leq (plus a c) b", "predict": "postulate le_minus_to_plus_r : (a : N) -> (b : N) -> (c : N) -> c <= b -> a <= (b - c) -> a + c <= b"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1553. Let $n$ and $n0$ be natural numbers. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $a$ to the disjunction of $Eq$ applied to $n0$ and the product of $2$ and $a$ and $Eq$ applied to $n0$ and the sum of the product of $2$ and $a$ and $1$. Then for all natural numbers $a$, if $n0$ is equal to the product of $2$ and $a$ or $n0$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $n0$ is equal to the sum of the product of $2$ and $a$ and $1$, then $n0$ is equal to the sum of $a$ and the sum of $a$ and $1$.\nassistant\n", "label": "Axiom let_clause_1553 : forall n : nat, forall n0 : nat, forall _clearme : ex nat (fun a => n0 = 2 * a \\/ n0 = 2 * a + 1), forall a : nat, forall _clearme0 : (n0 = 2 * a \\/ n0 = 2 * a + 1), forall Hn : (n0 = 2 * a + 1), n0 = a + (a + 1) .", "predict": "Axiom let_clause_1553 : forall n : Nat, forall n0 : Nat, forall _clearme : (a : Nat) -> Eq n0 (2 * a) || Eq n0 (2 * a + 1)), forall a : Nat, if n0 = (2 * a) then n0 = (a + (a + 1)) else if n0 = (2 * a + 1) then n0 = (a + (a + 1)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp0. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_885$ of $Aop$ of $A$ and $_nil$ to propositions. Let $_H_mk_Aop$ be a function from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil , a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a , _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a , op (b , c))$ and $op (op (a , b), c)$ to elements of $Q_$ of $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$. Let $x_885$ be an element of $Aop$ of $A$ and $_nil$. Then $Q_$ holds for $x_885$.\nassistant\n", "label": "Axiom Aop_rect_CProp0 : forall A : Set, forall _nil : A, forall Q_ : ((_x_885 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_885 : Aop A _nil, Q_ x_885 .", "predict": "Axiom Aop_rect_CProp0 : forall A : Set, forall _nil : A, forall Q_ : ((_x_885 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (a : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op (_nil , a) a)) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_885 : Aop A _nil, Q_ x_885 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBijn_Sn_n. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $__$ be an element of $bijn$ of $f$ and $n + 1$. Assume that $f (n + 1)= n + 1$. Then $bijn$ holds for $f$ and $n$.\nassistant\n", "label": "postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f (plus n 1)) -> (__1 : Eq (f (plus n 1)) (plus n 1)) -> bijn f n", "predict": "postulate bijn_Sn_n : (f : (x : Nat) -> Nat) -> (n : Nat) -> (__ : bijn f (n + 1)) -> (f (n + 1) : n + 1) -> bijn f n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAop_rect_Type0. Soit $A$ un ensemble. Alors pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_873$ de $Aop$ de $A$ et de $_nil$ à des ensembles, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $_nil$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $_nil$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $Q_$ de $mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_873$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_873$.\nassistant\n", "label": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873", "predict": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1062. Soit $a , b , q , r , q1 , r1 \\in N$. Soit $_clearme$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q$ et de $r$. Supposons que $r < b$ et $a = q b + r$. Soit $_clearme0$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q1$ et de $r1$. Supposons que $r1 < b$ et $a = q1 b + r1$. Supposons que $q$ n'est pas inférieur ou ágal à $q1$. Alors $a = r1 + b q1$.\nassistant\n", "label": "axiom let_clause_1062 (a b q r q1 r1 : Nat) (_clearme : div_mod_spec a b q r) (ltrb : r < b) (spec : a = q * b + r) (_clearme0 : div_mod_spec a b q1 r1) (ltr1b : r1 < b) (spec1 : a = q1 * b + r1) (leqq1 : ¬ (q ≤ q1)) : a = r1 + b * q1", "predict": "axiom let_clause_1062 (a b q r q1 r1 : N) (_clearme : div_mod_spec a b q r) (_clearme0 : div_mod_spec a b q1 r1) : (q : N) -> (q1 : N) -> (a : N) -> (r : N) -> (r1 : N) -> (_clearme : div_mod_spec a b q r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (q : N) -> (q1 : N) -> (a : N) -> (r : N) -> (r1 : N) -> (_clearme : div_mod_spec a b q r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (q : N) -> (q1 : N) -> (a : N) -> (axiom let_clause_1062 (a b q r q1 r1 : N) (_clearme : div_mod_spec a b q r) (_clearme0 : div_mod_spec a b q1 r1) : (q : N) -> (q1 : N) -> (a : N) -> (r : N) -> (r1 : N) -> (_clearme : div_mod_spec a b q r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (q : N) -> (q1 : N) -> (a : N) -> (axiom let_clause_1062 (a b q r q1 r1 : N) (_clearme : div_mod_spec a b q r) (_clearme0 : div_mod_spec a b q1 r1) : (q : N) -> (q1 : N) -> (a : N) -> (r : N) -> (r1 : N) -> (_clearme : div_mod_spec a b q r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (q : N) -> (q1 : N) -> (a : N) -> (axiom let_clause_1062 (a b q r q1 r1 : N) (_clearme : div_mod_spec a b q r) (_clearme0 : div_mod_spec a b q1 r1) : (q : N) -> (q1 : N)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i , j \\in N$. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Då om $b \\leq n$ och $f (b)= j$, så om $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (b : Nat) (__ : (i0 : Nat) -> (leq : Leq i0 n) -> Nat) (injf : injn f n) (Hc : a = b) : f a = j) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) : Nat) :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_inv_rect_CProp0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1758$ of $Dop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod (a , x2)$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod (a , aop__o__op (x1 , x2 , sum , b , c))$ and $aop__o__op (x1 , x2 , sum , prod (a , b), prod (a , c))$ and elements $_z1759$ of $Eq$ of $Hterm$ and $mk_Dop (x1 , x2 , sum , prod , _null , _distr)$ to elements of $P$ of $mk_Dop (x1 , x2 , sum , prod , _null , _distr)$, $P$ holds for $Hterm$.\nassistant\n", "label": "Axiom Dop_inv_rect_CProp0 : forall x1 : Set, forall x2 : x1, forall Hterm : Dop x1 x2, forall P : ((_z1758 : Dop x1 x2) -> Prop), forall _H1 : ((sum : ACop x1 x2) -> (prod : (x__ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> prod a x2 = x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> prod a (aop__o__op x1 x2 sum b c) = aop__o__op x1 x2 sum (prod a b) (prod a c)) -> (_z1759 : Hterm = mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)), P Hterm .", "predict": "Axiom Dop_inv_rect_CProp0 : forall x1 : Set, forall x2 : x1, forall Hterm : Dop x1 x2, forall P : ((_z1758 : Dop x1 x2) -> Prop), forall _H1 : ((sum : ACop x1 x2) -> (prod : (x1 -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1759 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1648. Låt $n , q \\in N$. Anta att $0 < q$. Låt $n1 \\in N$. Anta att summan av produkten av $bigop$ applicerat på summan av $n1$ och $1$ och funktionen som avbildar $m$ som $andb$ applicerat på $leb$ applicerat på $1$ och $m$ och $dividesb$ applicerat på $q$ och $m$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $m$ som $1$ och $q$ och $mod (n1 , q)$ är lika med $n1$. Anta att $q$ är delbart med $n1 + 1$ och $n1 + 1 = (n1 \\div q + 1)q$. Anta att $q$ är delbart med $n1 + 1$. Anta att $n1 + 1 = (n1 \\div q + 1)q$. Då $n1 + 1 = q + q (n1 \\div q)$.\nassistant\n", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : (n : N) -> (q : N) -> (n1 : N) -> (andb : (m : N) -> Nat) -> (dividesb : (q : N) -> (m : N) -> Nat) -> (plus : (x : Nat) -> (y : Nat) -> Nat) -> (1 : Nat) -> (q : Nat) -> (mod : (n1 : N) -> (q : N) -> Nat) -> n1 -> q -> (sum : (m : N) -> Nat) -> (let_clause_1648 : (n : N) -> (q : N) -> (n1 : N) -> (andb : (m : N) -> Nat) -> (dividesb : (q : N) -> (m : N) -> Nat) -> (plus : (x : Nat) -> (y : Nat) -> Nat) -> (1 : Nat) -> (q : Nat) -> (mod : (n1 : N) -> (q : N) -> Nat) -> n1 -> q -> (sum : (m : N) -> Nat) -> n1 -> q -> (n1 : N) -> q -> (n1 + 1 : N) -> q -> (n1 + 1 : N) -> (n1 : N) -> q -> (n1 + 1 : N) -> qpostulate let_clause_1648 : (n : N) -> (q : N) -> (n1 : N) -> (andb : (m : N) -> Nat) -> (dividesb : (q : N) -> (m : N) -> Nat) -> (plus : (x : Nat) -> (y : Nat) -> Nat) -> (1 : Nat) -> (q : Nat) -> (mod : (n1 : N) -> (q : N) -> Nat) -> n1 -> q -> (sum : (m : N) -> Nat) -> n1 -> q -> n1 -> q -> (n1 + 1 : N) -> q -> (n1 + 1 : N) -> (n1 : N) -> q -> (n1 + 1 : N) -> q"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPad_bigop1. Soit $k , n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$. Soit $f$ une fonction des nombres naturels à des éléments de $B$. Supposons que $n$ est inférieur ou ágal à $k$. Soit $__1$ une fonction des nombres naturels $i$ et des éléments $__1$ de $Leq$ de $n$ et de $i$ et des éléments $__2$ de $Lt$ de $i$ et de $k$ à des éléments de $Eq$ de $p$ appliqué à $i$ et de contradiction. Alors $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "axiom pad_bigop1 (k n : Nat) (p : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : (x__ : B) -> (__1 : B) -> B) (f : (x__ : Nat) -> B) (x__ : n ≤ k) (__1 : (i : Nat) -> (__1 : n ≤ i) -> (__2 : i < k) -> p i = false) : bigop n (λ i => p i) B nil op (λ i => f i) = bigop k (λ i => p i) B nil op (λ i => f i)", "predict": "axiom pad_bigop1 (k n : N) (p : (i : N) -> Bool) (B : Set) (nil : B) (op : (__1 : B) -> (__1 : B) -> B) (f : (i : N) -> B) (n : N) (__1 : (i : N) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) contradiction) : B = bigop n (λ i => p i) B nil op (λ i => f i)) : B = bigop k (λ i => p i) B nil op (λ i => f i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_16003. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16003 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : Nat) -> (_clearme : ex Nat (\\ d : N -> Eq (c n - d m) 1)) -> (d : N) -> (c n - d m) -> (d m - c n) -> (d m - c n) -> m d - n c"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNot_bertrand_to_le1. För alla naturliga tal $n$, om $2 ^ 7 \\leq n$, så för alla element $__1$ av $not_bertrand$ av $n$, $2 ^ (2 n \\div 3)\\leq 2 n ^ (\\sqrt{ (2 n)}\\div 2)$.\nassistant\n", "label": "postulate not_bertrand_to_le1 : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (pow 2 (div (times 2 n) 3)) (pow (times 2 n) (div (sqrt (times 2 n)) 2))", "predict": "postulate not_bertrand_to_le1 : (n : Nat) -> (__1 : not_bertrand n) -> 2 ^ (2 n \\div 3) \\leq 2 n ^ (\\sqrt{ (2 n)}\\div 2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nPrime_to_divides_M. Låt $m , p \\in N$. Anta att $p$ är primt. Anta att summan av $m$ och $1$ är mindre än $p$. Anta att $p$ är mindre än eller lika med summan av produkten av $2$ och $m$ och $1$. Då är $p$ delbart med $M$ applicerat på $m$.\nassistant\n", "label": "Axiom prime_to_divides_M : forall m : nat, forall p : nat, forall x__ : prime p, forall __1 : (m + 1 < p), forall __2 : Leq p (2 * m + 1), divisible p (M m) .", "predict": "Axiom prime_to_divides_M : forall m : N, forall p : N, p : prime -> sum m 1 < p -> p <= (2 * m + 1) -> p | (M m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_k. Let $n$ and $p$ be natural numbers. Then $k (n , p)\\leq \\log_ p {n}$.\nassistant\n", "label": "Axiom le_k : forall n : nat, forall p : nat, Leq (k n p) (log p n) .", "predict": "Axiom le_k : forall n : nat, forall p : nat, k (n , p) <= log p n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nassistant\n", "label": "axiom let_clause_16002 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c", "predict": "axiom let_clause_16002 (m n a b : Nat) (_clearme : ex Nat (λ d => Eq (diff (c * n) (d * m)) 1)) (d : Nat) : Eq (gcd m n) (diff (m * d) (n * c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPermut_mod. Soient $p$ et $a$ des nombres naturels. Supposons que $p$ est premier. Alors si $p$ n'est pas divisible par $a$, alors $permut$ tient pour la fonction qui envoie $n$ à $mod$ appliqué à le produit de $a$ et de $n$ et $p$ et $pred$ appliqué à $p$.\nassistant\n", "label": "Axiom permut_mod : forall p : nat, forall a : nat, forall x__ : prime p, forall __1 : (~ divisible p a), permut (fun n => mod (a * n) p) (pred p) .", "predict": "Axiom permut_mod : forall p : nat, forall a : nat, p : prime -> p : not_divisible a -> forall n : nat, permut (fun n => mod (a * n) p) (pred p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1704. Soit $m \\in N$. Supposons que $0 < m$. Alors pour tous les nombres naturels $a$ et $x1029$, $x1029 = aop__o__op (Nat , 0 , plusAC , x1029 , 0)$.\nassistant\n", "label": "let_clause_1704 : m : Nat -> posm : Lt 0 m -> a : Nat -> x1029 : Nat -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0) .", "predict": "let_clause_1704 : m : N -> 0 < m -> a : N -> x1029 : N -> x1029 = aop__o__op (Nat , 0 , plusAC , x1029 , 0) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1078. Soient $a$ et $b$ et $q$ et $r$ et $q1$ et $r1$ des nombres naturels. Soit $_clearme$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q$ et de $r$. Supposons que $r < b$. Supposons que $a = q b + r$. Soit $_clearme0$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q1$ et de $r1$. Supposons que $r1 < b$. Supposons que $a = q1 b + r1$. Supposons que $q \\leq q1$. Alors si $q < q1$, alors $a = r + b q$.\nassistant\n", "label": "axiom let_clause_1078 (a b q r q1 r1 : Nat) (_clearme : div_mod_spec a b q r) (ltrb : r < b) (spec : a = q * b + r) (_clearme0 : div_mod_spec a b q1 r1) (ltr1b : r1 < b) (spec1 : a = q1 * b + r1) (leqq1 : q ≤ q1) (ltqq1 : q < q1) : a = r + b * q", "predict": "axiom let_clause_1078 (a b q r q1 r1 : Nat) (_clearme : div_mod_spec a b q r) (_clearme0 : div_mod_spec a b q1 r1) : (q < q1) -> a = r + b q"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLd_to_prime. Soit $i$ un nombre naturel. Alors pour toutes les listes $acc$ de nombres naturels, si $1 < i$, alors pour tous les éléments $__1$ de $primes_below$ de $acc$ et de $i$, si contradiction est égal à $list_divides (acc , i)$, alors $i$ est premier.\nassistant\n", "label": "postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i", "predict": "postulate ld_to_prime : (i : Nat) -> (acc : List Nat) -> (__1 : primes_below acc i) -> (contradiction : list_divides (acc , i)) -> i : Prime"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a$ un nombre naturel. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Alors si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $i$.\nassistant\n", "label": "let_clause_1068 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) i .", "predict": "let_clause_1068 : f : Nat -> Nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1561. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c \\in N$. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Alors si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$, alors si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale à $1$, alors la différence du produit de $p$ et de $a$ et du produit de $m$ et de $b$ est égale à $1$.\nassistant\n", "label": "axiom let_clause_1561 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : a * p - b * m = gcd p m) (H0 : a * p - b * m = 1) : p * a - m * b = 1", "predict": "axiom let_clause_1561 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : ex Nat (λ b => Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m))) (b : Nat) : Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m)) : Eq (diff (a * p) (b * m)) 1 (diff (b * m) (a * p)) 1) : Eq (diff (p * a) (m * b)) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNot_divides_to_ord_O. Låt $p , m \\in N$. Anta att $p$ är primt. Då om $p$ inte är delbart med $m$, så $ord (m , p)= 0$.\nassistant\n", "label": "postulate not_divides_to_ord_O : (p : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : not (divisible p m)) -> Eq (ord m p) 0", "predict": "postulate not_divides_to_ord_O : (p : N) -> (m : N) -> (p : primt) -> (p : inte delbart med m) -> ord (m , p) = 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n \\in N$. Anta att $2 ^ 7 \\leq n$. Då för alla naturliga tal $p$, om $\\sqrt{ (2 n)}+ 1 \\leq p$, så om $p < 2 n + 1$, så om $leb (2 , k (2 n , p))= true$, så om $2 n < p ^ 2$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (p : N) -> (x2515 : N) -> (x2516 : N) -> (leb : (a : N) -> (b : N) -> Bool) -> Bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNat_rect_CProp3_body. Låt $Q_$ vara en funktion från naturliga tal $_x_401$ till påståenden. Låt $_H_O$ vara ett element av $Q_$ av $0$. Låt $_H_S$ vara en funktion från naturliga tal $x_402$ och element $_x_404$ av $Q_$ av $x_402$ till element av $Q_$ av $x_402 + 1$. Då för alla naturliga tal $x_401$, håller $Q_$ för $x_401$.\nassistant\n", "label": "nat_rect_CProp3_body : Q_ : (_x_401 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_402 : Nat -> _x_404 : Q_ x_402 -> Q_ (plus x_402 (nd 1))) -> x_401 : Nat -> Q_ x_401 .", "predict": "nat_rect_CProp3_body : Q_ : (_x_401 : nat -> påstående) -> _H_O : Q_ 0 -> _H_S : (x_402 : nat -> _x_404 : Q_ x_402 -> Q_ (x_402 + 1)) -> x_401 : nat -> Q_ x_401 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15624. Låt $m , n , a , b \\in N$. Då om $0 < n$ och $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$, så $m d - n c = 1$.\nassistant\n", "label": "let_clause_15624 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .", "predict": "let_clause_15624 : m : N -> n : N -> a : N -> b : N -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (n - m) 1) -> d : Nat -> c n - d m = 1 -> m d - n c = 1 -> m d - n c = 1 -> m d - n c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMin_prim. Let $n$ be a natural number. Then $ex$ holds for $Nat$ and the function that maps $p$ to the conjunction of the conjunction of $Lt$ applied to $n$ and $p$ and $prime$ applied to $p$ and $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $q$ to $prod$ applied to $Prop$ and $Prop$ and $prime$ applied to $q$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $q$ and $p$ and the function that maps $__1$ to $Leq$ applied to $q$ and $n$.\nassistant\n", "label": "min_prim : n : Nat -> ex Nat (p : Nat => and (and (Lt n p) (prime p)) (prod Set Prop Nat (q : Nat => prod Prop Prop (prime q) (__ : prime q => prod Prop Prop (Lt q p) (__1 : Lt q p => Leq q n))))) .", "predict": "min_prim : n : Nat -> ex : Nat -> p : Nat -> Lt : n -> p -> prime : p -> prod : Set -> Prop -> Nat -> q : Nat -> prod : Prop -> Prop -> prime : q -> __ : prod : Prop -> Prop -> Lt : q -> p -> __1 : Leq : q -> n -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1075. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $bijf$ be an element of $bijn$ of $f$ and $n + 1$. Assume that $f (n + 1)= n + 1$. Let $i \\in N$. Assume that $i \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n + 1$ and $f (a)= i$ and $a \\leq n + 1$. Then if $f (a)= i$ and $a = n + 1$, then $i = a$.\nassistant\n", "label": "axiom let_clause_1075 (f : (x__ : Nat) -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (fS : f (n + 1) = n + 1) (i : Nat) (lein : i ≤ n) (a : Nat) (_clearme : a ≤ n + 1 ∧ f a = i) (lean : a ≤ n + 1) (fa : f a = i) (Hc : a = n + 1) : i = a", "predict": "axiom let_clause_1075 (f : Nat -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (i : Nat) (a : Nat) : a ≤ n + 1 -> f a = i -> a ≤ n + 1 -> f a = i -> a = n + 1 -> i = a"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nFilter_min_spec. Soit $_n , _b \\in N$. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $__$ un nombre naturel. Soit $return_sort$ un élément de $Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $__$ à des éléments de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $__$ à des éléments de $return_type$ de $z$, pour tous les éléments $z$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $__$, $return_type$ tient pour $z$.\nassistant\n", "label": "axiom filter_min_spec (_n _b : Nat) (_f : (x__ : Nat) -> bool) (x__ : Nat) (return_sort : Sort) (return_type : (z : min_spec _n _b _f __) -> return_sort) (return : (z : min_spec _n _b _f __) -> return_type z) (z : min_spec _n _b _f __) : return_type z", "predict": "axiom filter_min_spec (_n _b : N) (_f : (z : N) -> Bool) (__ : N) (return_sort : Sort) (return_type : (z : min_spec _n _b _f __) -> return_sort) (return : (z : min_spec _n _b _f __) -> return_type z) (z : min_spec _n _b _f __) : return_type z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nFst_p_ord_times. Låt $p$ och $a$ och $b$ vara naturliga tal. Då om $p$ är primt och $0 < a$, så om $0 < b$, så $fst (Nat , Nat , p_ord (a b , p))= fst (Nat , Nat , p_ord (a , p))+ fst (Nat , Nat , p_ord (b , p))$.\nassistant\n", "label": "Axiom fst_p_ord_times : forall p : nat, forall a : nat, forall b : nat, forall x__ : prime p, forall __1 : (0 < a), forall __2 : (0 < b), fst nat nat (p_ord (a * b) p) = fst nat nat (p_ord a p) + fst nat nat (p_ord b p) .", "predict": "Axiom fst_p_ord_times : forall p : nat, forall a : nat, forall b : nat, nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15692. Låt $m , n , a , b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$, så $m d - n c = 1$.\nassistant\n", "label": "let_clause_15692 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .", "predict": "let_clause_15692 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> c n - d m = 1 -> m d - n c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1607. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c$ be a natural number. Then for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (c n - d m) 1)) -> (d : Nat) -> Eq (m d - n c) (gcd m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop_discr. Pour tous les ensembles $a1$, pour tous les éléments $a2$ de $a1$, pour tous les éléments $x$ et $y$ de $Aop$ de $a1$ et de $a2$, si $x = y$, alors $match_Aop$ tient pour $a1$ et $a2$ et $Type2 + 1$ et la fonction qui envoie $__$ à $univ (Type2)$ et la fonction qui envoie $t0$ et $t", "label": "Aop_discr : a1 : Set -> a2 : a1 -> x : Aop a1 a2 -> y : Aop a1 a2 -> _e : Eq x y -> match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (t0 : (__ : a1 -> __1 : a1 -> a1) => t1 : (a : a1 -> Eq (t0 a2 a) a) => t2 : (a : a1 -> Eq (t0 a a2) a) => t3 : (a : a1 -> b : a1 -> c : a1 -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) => match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (u0 : (__ : a1 -> __1 : a1 -> a1) => u1 : (a : a1 -> Eq (u0 a2 a) a) => u2 : (a : a1 -> Eq (u0 a a2) a) => u3 : (a : a1 -> b : a1 -> c : a1 -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0) (e0 : Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0 => prod Prop Type1 (Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (e1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1", "predict": "1Aop_discr : a1 : Set -> a2 : Set -> x : Aop a1 a2 -> y : Aop a1 a2 -> x = y -> match_Aop a1 a2 Type2 + 1 (__ : Aop a1 a2 -> t0 : Aop a1 a2 -> t1 : Aop a1 a2 -> univ Type2) -> t0 = x -> t1 = y -> univ Type2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10336. Let $n$ and $m$ be natural numbers. Let $Hind$ be a function from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi (p)$ and $pred (p)\\times (2 ^ (2 p - 3))$. Let $a$ be a natural number. Assume that $m = 2 a$ or $m = 2 a + 1$. Assume that $m = 2 a + 1$. Then if $1 < 2 a + 1$, then if $0 < a$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "let_clause_10336 : n : Nat -> m : Nat -> Hind : (p : Nat -> __ : Lt p m -> __1 : Lt (nd 1) p -> Leq (Psi p) (times (pred p) (pow (nd 2) (minus (times (nd 2) p) (nd 3))))) -> a : Nat -> _clearme : or (Eq m (times (nd 2) a)) (Eq m (plus (times (nd 2) a) (nd 1))) -> Hm : Eq m (plus (times (nd 2) a) (nd 1)) -> Hlt : Lt (nd 1) (plus (times (nd 2) a) (nd 1)) -> Ha : Lt 0 a -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_10336 : n : Nat -> m : Nat -> Hind : (p : Nat -> Lt : p -> __1 : Lt 1 -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> a : Nat -> m = 2 a -> m = 2 a + 1 -> 1 < 2 a + 1 -> 0 < a -> x2515 : Nat -> x2516 : Nat -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1047. Soit $k , n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$. Soit $f$ une fonction des nombres naturels à des éléments de $B$. Supposons que $n \\leq k$. Soit $j \\in N$. Supposons que $n \\leq j$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Leq$ de $n$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $j$ à des éléments de $Eq$ de $p (i)$ et de contradiction à des éléments de $Eq$ de $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et de $bigop$ appliqué à $j$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$. Soit $Hfalse$ une fonction des nombres naturels $i$ et des éléments de $Leq$ de $n$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $j + 1$ à des éléments de $Eq$ de $p (i)$ et de contradiction. Alors pour tous les nombres naturels $x2571$ et $x2572$, $x2571 = x2572 (x2571 \\div x2572)+ mod (x2571 , x2572)$.\nassistant\n", "label": "let_clause_1047 : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> lenk : Leq n k -> j : Nat -> leup : Leq n j -> Hind : (__ : (i : Nat -> __ : Leq n i -> __1 : Lt i j -> Eq (p i) false) -> Eq (bigop n (i : Nat => p i) B nil op (i : Nat => f i)) (bigop j (i : Nat => p i) B nil op (i : Nat => f i))) -> Hfalse : (i : Nat -> __ : Leq n i -> __1 : Lt i (plus j (nd 1)) -> Eq (p i) false) -> x2571 : Nat -> x2572 : Nat -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572)) .", "predict": "let_clause_1047 : k : N -> n : N -> p : (N -> Bool) -> B : Set -> nil : B -> op : (B -> __1 : B -> B) -> f : (N -> B) -> n <= k -> j : N -> n <= j -> Hind : (i : N -> __1 : Lt i j -> Eq (p i) contradiction -> Eq (bigop n (i : N => p i) B nil op (i : N => f i)) (bigop j (i : N => p i) B nil op (i : N => f i))) -> Hfalse : (i : N -> __1 : Lt i (j + 1) -> Eq (p i) contradiction) -> x2571 : N -> x2572 : N -> x2571 = x2572 (x2571 \\div x2572) + mod (x2571 , x2572) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPad_bigop1. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $n \\leq k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $Eq$ of $p (i)$ and absurdity, $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "pad_bigop1 : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Leq n k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> Eq (p i) false) -> Eq (bigop n (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p i) B nil op (i : Nat => f i)) .", "predict": "pad_bigop1 : k : Nat -> n : Nat -> p : (i : Nat -> Bool) -> B : Set -> nil : B -> op : (__1 : B -> i : Nat -> B) -> f : (i : Nat -> B) -> n <= k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> Eq (p i) absurdity) -> bigop k (i : Nat => p i) B nil op (i : Nat => f i) = bigop n (i : Nat => p i) B nil op (i : Nat => f i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_log2_sqrt. Let $n$ be a natural number. Then if the exponentiation of $2$ and $6$ is less than or equal to $n$, then the logarithm of $2$ and $n$ is less than the square root of $n$.\nassistant\n", "label": "axiom lt_log2_sqrt (n : Nat) (x__ : pow 2 6 ≤ n) : log 2 n < sqrt n", "predict": "axiom lt_log2_sqrt (n : Nat) : Bool => and (exp 2 6 <= n) (log 2 n < sqrt n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSigma_p_dividesb1. Soit $m , n , p , k \\in N$. Alors si $0 < n$ et $p$ est premier, alors si $p$ n'est pas divisible par $n$ et $m \\leq k$, alors $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $dividesb$ appliqué à la puissance de $p$ et de la somme de $i$ et de $1$ et le produit de la puissance de $p$ et de $m$ et de $n$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $1$ est égal à $m$.\nassistant\n", "label": "postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb1 : (m : N) -> (n : N) -> (p : N) -> (k : N) -> (0 < n) -> (p : prime) -> (p : !divisible n) -> (m : !<= k) -> bigop k (\\ i : N -> dividesb (p :^ (i :+ 1)) (p :^ m) n) Nat 0 plus (\\ i : N -> 1) == m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPrimeb_false_to_not_prime. Let $n \\in N$. Assume that $primeb$ applied to $n$ is equal to absurdity. Then $n$ is not prime.\nassistant\n", "label": "postulate primeb_false_to_not_prime : (n : Nat) -> (_ : Eq (primeb n) false) -> not (prime n)", "predict": "postulate primeb_false_to_not_prime : (n : N) -> primeb n -> Set"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEq_minus_gcd_aux. Låt $p , m , n \\in N$. Anta att $0 < n$ och $n \\leq m$. Då om $n \\leq p$, så håller $ex$ för $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $p$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $p$ och $m$ och $n$.\nassistant\n", "label": "axiom eq_minus_gcd_aux (p m n : Nat) (x__ : 0 < n) (__1 : n ≤ m) (__2 : n ≤ p) : ex Nat (λ a => ex Nat (λ b => a * n - b * m = gcd_aux p m n ∨ b * m - a * n = gcd_aux p m n))", "predict": "axiom eq_minus_gcd_aux (p m n : N) (Hc : 0 < n) (Hd : n <= m) (He : n <= p) : (ex : Nat) => (a : Nat) => (b : Nat) => disj : Eq (skillnaden (produkten av a och n) (produkten av b och m)) (gcd_aux p m n)) => (Eq (skillnaden (produkten av b och m) (produkten av a och n)) (gcd_aux p m n)) : ex a b : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1033. Låt $n$ vara ett naturligt tal. Anta att $1 < n$ och $2 \\times n$ är primt. Anta att $1 < 2 n$. Då för alla funktioner $H1$ från naturliga tal $m$ och element av $divisible$ av $m$ och $2 \\times n$ och element $__1$ av $Lt$ av $1$ och $m$ till element av $Eq$ av $m$ och $2 \\times n$, för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "axiom let_clause_1033 (n : Nat) (ltn : 1 < n) (_clearme : prime (2 * n)) (H : 1 < 2 * n) (H1 : (m : Nat) -> (x__ : divisible m (2 * n)) -> (__1 : 1 < m) -> m = 2 * n) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_1033 (n : Nat) (H1 : (m : Nat) -> (__1 : Lt 1 m) -> Eq m (2 * n)) (x2515 x2516 : Nat) : Nat := x2515 + x2516 * (x2515 / x2516) + mod x2515 x2516"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Då om $0 < n$ och $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$, så $m d - n c = 1$.\nassistant\n", "label": "axiom let_clause_15692 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : m * d - n * c = 1", "predict": "axiom let_clause_15692 (m n a b : Nat) (c : Nat) (_clearme : ex Nat (λ d => Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1)) (d : Nat) : Eq (m d - n c) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_divides_true. Let $l$ be a list of natural numbers. Let $n \\in N$. Assume that $list_divides$ applied to $l$ and $n$ is equal to $true$. Then $ex$ holds for $Nat$ and the function that maps $p$ to the conjunction of $mem$ applied to $Nat$ and $p$ and $l$ and $divisible$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom list_divides_true : forall l : list nat, forall n : nat, forall x__ : (list_divides l n = true), ex nat (fun p => mem nat p l /\\ divisible p n) .", "predict": "Axiom list_divides_true : forall l : list nat, forall n : N, list_divides l n -> ex Nat (fun p => mem Nat p l) (divisible p n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i$ and $j$ be natural numbers. Assume that $i$ is less than or equal to $n$. Then if $j$ is less than or equal to $n$, then for all natural numbers $a$, if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : ((i : N) -> N), forall n : N, forall permf : permut f n, forall i : N, forall j : N, forall a : N, forall b : N, forall __ : ((i0 : N) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Hc : a = b, f a = i -> forall Hb : b = n -> forall Hc : f b = j -> forall Hb : b = n -> forall Hc : f b = j -> forall __ : ((i0 : N) -> (Leq i0 n) -> Leq (f i0) n), forall Hc : injf a b -> f a = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBigop_commute. Let $n$ and $m$ be natural numbers. Let $p11$ be a function from natural numbers to booleans. Let $p12$ be a function from natural numbers and natural numbers $__1$ to booleans. Let $p21$ be a function from natural numbers to booleans. Let $p22$ be a function from natural numbers and natural numbers $__1$ to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f$ be a function from natural numbers and natural numbers $__1$ to elements of $B$. Assume that $0$ is less than $n$. Then if $0$ is less than $m$, then for all functions $__2$ from natural numbers $i$ and natural numbers $j$ and elements $__2$ of $Lt$ of $i$ and $n$ and elements $__3$ of $Lt$ of $j$ and $m$ to elements of $Eq$ of $andb$ applied to $p11$ applied to $i$ and $p12$ applied to $i$ and $j$ and $andb$ applied to $p21$ applied to $j$ and $p22$ applied to $i$ and $j$, $bigop$ applied to $n$ and the function that maps $i$ to $p11$ applied to $i$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $bigop$ applied to $m$ and the function that maps $j$ to $p12$ applied to $i$ and $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $f$ applied to $i$ and $j$ is equal to $bigop$ applied to $m$ and the function that maps $j$ to $p21$ applied to $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $bigop$ applied to $n$ and the function that maps $i$ to $p22$ applied to $i$ and $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $j$.\nassistant\n", "label": "axiom bigop_commute (n m : Nat) (p11 : (x__ : Nat) -> bool) (p12 : (x__ : Nat) -> (__1 : Nat) -> bool) (p21 : (x__ : Nat) -> bool) (p22 : (x__ : Nat) -> (__1 : Nat) -> bool) (B : Set) (nil : B) (op : ACop B nil) (f : (x__ : Nat) -> (__1 : Nat) -> B) (x__ : 0 < n) (__1 : 0 < m) (__2 : (i : Nat) -> (j : Nat) -> (__2 : i < n) -> (__3 : j < m) -> andb (p11 i) (p12 i j) = andb (p21 j) (p22 i j)) : bigop n (λ i => p11 i) B nil (aop__o__op B nil op) (λ i => bigop m (λ j => p12 i j) B nil (aop__o__op B nil op) (λ j => f i j)) = bigop m (λ j => p21 j) B nil (aop__o__op B nil op) (λ j => bigop n (λ i => p22 i j) B nil (aop__o__op B nil op) (λ i => f i j))", "predict": "axiom bigop_commute (n m : Nat) (p11 : (i : Nat) -> Bool) (p12 : (i : Nat) -> (__1 : Nat) -> Bool) (p21 : (i : Nat) -> Bool) (p22 : (i : Nat) -> (__1 : Nat) -> Bool) (B : Set) (nil : B) (op : ACop B nil) (f : (i : Nat) -> (__1 : Nat) -> B) (Hc : 0 < n) (Hm : 0 < m) (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) : bigop n (λ i => p11 i) B nil (aop__o__op B nil op) (λ i => bigop m (λ j => p12 i j) B nil (aop__o__op B nil op) (λ j => f i j))) = bigop m (λ j => p21 j) B nil (aop__o__op B nil op) (λ j => bigop n (λ i => p22 i j) B nil (aop__o__op B nil op) (λ i => f i j)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTech_log. Let $p , n \\in N$. Assume that $1 < p$. Assume that $0 < n$. Then $max$ applied to the sum of $n$ and $1$ and the function that maps $x$ to $leb$ applied to the exponentiation of $p$ and $x$ and $n$ is equal to $\\log_ p {n}$.\nassistant\n", "label": "tech_log : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Eq (log p n) (max (plus n (nd 1)) (x : Nat => leb (pow p x) n)) .", "predict": "tech_log : p : N -> n : N -> 1 < p -> 0 < n -> max (n + 1) (x : N => leb (p^x) n) = log_p n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNat_inv_rect_Type4. Soit $Hterm \\in N$. Soit $P$ une fonction des nombres naturels $_z659$ à des éléments de $Type4$. Soit $_H1$ une fonction des éléments $_z660$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$. Alors pour toutes les fonctions $_H2$ des nombres naturels $x_370$ et des fonctions $_x_372$ des éléments $_z660$ de $Eq$ de $Hterm$ et de $x_370$ à des éléments de $P$ de $x_370$ et des éléments $_z660$ de $Eq$ de $Hterm$ et de la somme de $x_370$ et de $1$ à des éléments de $P$ de la somme de $x_370$ et de $1$, $P$ tient pour $Hterm$.\nassistant\n", "label": "Axiom nat_inv_rect_Type4 : forall Hterm : nat, forall P : ((_z659 : nat) -> Type4), forall _H1 : ((_z660 : Hterm = 0) -> P 0), forall _H2 : ((x_370 : nat) -> (_x_372 : (_z660 : Hterm = x_370) -> P x_370) -> (_z660 : Hterm = x_370 + 1) -> P (x_370 + 1)), P Hterm .", "predict": "Axiom nat_inv_rect_Type4 : forall Hterm : N, forall P : ((_z659 : N) -> Type4), forall _H1 : ((_z660 : Eq Hterm 0) -> P 0), forall _H2 : ((x_370 : N) -> (_x_372 : (_z660 : Eq Hterm x_370) -> P x_370) -> (_z660 : Eq Hterm (x_370 + 1)) -> P (x_370 + 1)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNot_not_bertrand_to_bertrand1. Soit $n \\in N$. Supposons qu'il n'est pas le cas que $not_bertrand$ tienne pour $n$. Soit $x \\in N$. Supposons que $n \\leq x$. Supposons que $x \\leq 2 n$. Soit $__3$ une fonction des nombres naturels $p$ et des éléments $__3$ de $Lt$ de $x$ et de $p$ et des éléments $__4$ de $Leq$ de $p$ et de $2 \\times n$ à des éléments de $not$ de $prime (p)$. Alors $ex$ tient pour $Nat$ et la fonction qui envoie $p$ à la conjonction de la conjonction de $Lt$ appliqué à $n$ et $p$ et de $Leq$ appliqué à $p$ et $x$ et de $prime$ appliqué à $p$.\nassistant\n", "label": "not_not_bertrand_to_bertrand1 : n : Nat -> __ : not (not_bertrand n) -> x : Nat -> __1 : Leq n x -> __2 : Leq x (times (nd 2) n) -> __3 : (p : Nat -> __3 : Lt x p -> __4 : Leq p (times (nd 2) n) -> not (prime p)) -> ex Nat (p : Nat => and (and (Lt n p) (Leq p x)) (prime p)) .", "predict": "not_not_bertrand_to_bertrand1 : n : N -> x : N -> n <= x -> x <= 2 n -> __3 : (p : N -> __3 : Lt x p -> __4 : Leq p (2 n) -> not prime p) -> ex : Nat -> (p : N -> Lt n p -> Leq p x -> prime p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_SO_to_le_B_exp. Let $n$ be a natural number. Assume that $1 < n$. Then $B (2 n)\\leq 2 ^ pred (2 n)$.\nassistant\n", "label": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))", "predict": "postulate lt_SO_to_le_B_exp : (n : Set) -> (1 < n) -> B (2 n) <= 2 ^ pred (2 n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nSquare_double. Låt $n$ vara ett naturligt tal. Anta att $2$ är mindre än $n$. Då är produkten av summan av $n$ och $1$ och summan av $n$ och $1$ mindre än eller lika med produkten av produkten av $2$ och $n$ och $n$.\nassistant\n", "label": "postulate square_double : (n : Nat) -> (_ : Lt 2 n) -> Leq (times (plus n 1) (plus n 1)) (times (times 2 n) n)", "predict": "postulate square_double : (n : Nat) -> 2 < n -> (n + 1) * (n + 1) <= (2 * n) * n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_15692. Soit $m , n , a , b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$ est égale à $1$.\nassistant\n", "label": "Axiom let_clause_15692 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), m * d - n * c = 1 .", "predict": "Axiom let_clause_15692 : forall m : N, forall n : N, forall a : N, forall b : N, forall c : Nat, forall _clearme : (d : Nat) -> Eq (Nat) (difference (product c n) (product d m)) 1) (Eq (Nat) (difference (product d m) (product c n)) 1), forall d : Nat, ((difference (product c n) (product d m)) = 1) -> ((difference (product d m) (product c n)) = 1) -> (difference (product d m) (product c n)) = 1) -> (difference (product m d) (product n c)) = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPermut_n_to_le. Låt $h$ vara en funktion från naturliga tal till naturliga tal. Låt $k$ och $n$ vara naturliga tal. Anta att $k$ är mindre än eller lika med $n$. Låt $__1$ vara ett element av $permut$ av $h$ och $n$. Låt $__2$ vara en funktion från naturliga tal $m$ och element $__2$ av $Lt$ av $m$ och $k$ till element av $Eq$ av $h$ applicerat på $m$ och $m$. Låt $j \\in N$. Anta att $k$ är mindre än eller lika med $j$. Anta att $j$ är mindre än eller lika med $n$. Då är $k$ mindre än eller lika med $h$ applicerat på $j$.\nassistant\n", "label": "postulate permut_n_to_le : (h : (_ : Nat) -> Nat) -> (k : Nat) -> (n : Nat) -> (_ : Leq k n) -> (__1 : permut h n) -> (__2 : (m : Nat) -> (__2 : Lt m k) -> Eq (h m) m) -> (j : Nat) -> (__3 : Leq k j) -> (__4 : Leq j n) -> Leq k (h j)", "predict": "postulate permut_n_to_le : (h : nat -> nat) -> (k : nat) -> (n : nat) -> (__1 : permut h n) -> (__2 : (m : nat) -> (__2 : Lt m k) -> Eq (h m) m)) -> (j : N) -> (k : nat) -> (j : nat) -> (n : nat) -> (k : minderEllenligOchEllerLik n) -> (j : minderEllenligOchEllerLik n) -> (k : minderEllenligOchEllerLik j) -> (h j : nat) -> postulate permut_n_to_le : (h : nat -> nat) -> (k : nat) -> (n : nat) -> (__1 : permut h n) -> (__2 : (m : nat) -> (__2 : Lt m k) -> Eq (h m) m)) -> (j : N) -> (k : nat) -> (j : nat) -> (n : nat) -> (k : minderEllenligOchEllerLik n) -> (j : minderEllenligOchEllerLik n) -> (k : minderEllenligOchEllerLik j) -> (h j : nat) -> permut_n_to_le h k n __1 __2 j k j n k (h j)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1545. Låt $m , n \\in N$. Anta att det största gemensama delaret av $m$ och $n$ är lika med $0$. Anta att $0$ är delbart med $n$. Låt $q1$ vara ett naturligt tal. Anta att $n$ är lika med produkten av $0$ och $q1$. Anta att $0$ är delbart med $m$. Låt $q2 \\in N$. Anta att $m$ är lika med produkten av $0$ och $q2$. Då är $m$ lika med $0$.\nassistant\n", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : N) -> (n : N) -> (q1 : N) -> (q2 : N) -> m == 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nRange_discr. Låt $a1$ vara en mängd. Låt $x$ och $y$ vara element av $range$ av $a1$. Då om $x = y$, så håller $match_range$ för $a1$ och $Type2 + 1$ och funktionen som avbildar $__$ som $univ (Type2)$ och funktionen som avbildar $t0$ och $t1$ och $t2$ som $match_range$ applicerat på $a1$ och summan av $Type2$ och $1$ och funktionen som avbildar $__$ som $univ$ applicerat på $Type2$ och funktionen som avbildar $u0$ och $u1$ och $u2$ som $prod$ applicerat på summan av $Type1$ och $1$ och $Type1$ och $univ$ applicerat på $Type1$ och funktionen som avbildar $P$ som $prod$ applicerat på $Type1$ och $Type1$ och $prod$ applicerat på $Prop$ och $Type1$ och $Eq$ applicerat på $R0$ applicerat på $prod$ applicerat på $Set$ och $Set$ och $Nat$ och funktionen som avbildar $__$ som $a1$ och $t0$ och $u0$ och funktionen som avbildar $e0$ som $prod$ applicerat på $Prop$ och $Type1$ och $Eq$ applicerat på $R1$ applicerat på $prod$ applicerat på $Set$ och $Set$ och $Nat$ och funktionen som avbildar $__$ som $a1$ och $t0$ och funktionen som avbildar $x0$ och $p0$ som $Nat", "label": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ t0 : ((_ : Nat) -> a1) -> \\ t1 : Nat -> \\ t2 : ((_ : Nat) -> bool) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ u0 : ((_ : Nat) -> a1) -> \\ u1 : Nat -> \\ u2 : ((_ : Nat) -> bool) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) (\\ e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) (\\ _e2 : Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\", "predict": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (x == y) -> (match_range : a1 -> Type2 + 1) -> (__ : univ Type2) -> (t0 : a1) -> (t1 : a1) -> (t2 : a1) -> match_range a1 (sum Type2 1) (\\ __ : univ Type2 -> univ Type2) (\\ u0 : a1 -> u1 : a1 -> u2 : a1 -> prod (Type1 + 1) Type1 (univ Type1) (\\ P : prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat)) (\\ __ : a1 -> t0)) (\\ e0 : prod Prop Type1 (Eq (R1 (prod Set Set Nat)) (\\ __ : a1 -> t0) (\\ x0 : a1 -> p0 : Nat) -> t1) -> u0) (\\ e1 : prod Prop Type1 (Eq (R1 (prod Set Set Nat)) (\\ __ : a1 -> t0) (\\ x0 : a1 -> p0 : Nat) -> t1) -> u1) (\\ e2 : prod Prop Type1 (Eq (R2 (prod Set Set Nat)) (\\ __ : a1 -> t0) (\\ x0 : a1 -> p0 : Nat) -> t1) -> u2) (\\ _e2 : prod Prop Type1 (Eq (R2 (prod Set Set Nat)) (\\ __ : a1 -> t0) (\\ x0 : a1 -> p0 : Nat) -> t1) -> postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (x == y) -> (match_range : a1 -> Type2 + 1) -> (__ : univ Type2) -> (t0 : a1) -> (t1 : a1) -> (t2 : a1) -> match_range a1 (sum Type2 1) (\\ __ : univ Type2 -> univ Type2) (\\ u0 : a1 -> u1 : a1 -> u2 : a1 -> prod (Type1 + 1) Type1 (univ Type1) (\\ P : prod Type1 Type1 ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDpi1__o__aop__o__op. Soit $x0$ un ensemble. Soit $x1$ un élément de $x0$. Soit $x2$ une fonction des éléments de $ACop$ de $x0$ et de $x1$ à des ensembles. Soit $x3$ un élément de $DPair$ de $ACop$ appliqué à $x0$ et $x1$ et de $x2$. Alors pour tous les éléments $_x_887$ et $_x_888$ de $x0$, $x0$.\nassistant\n", "label": "dpi1__o__aop__o__op : x0 : Set -> x1 : x0 -> x2 : (__ : ACop x0 x1 -> Set) -> x3 : DPair (ACop x0 x1) x2 -> _x_887 : x0 -> _x_888 : x0 -> x0 .", "predict": "dpi1__o__aop__o__op : x0 : Set -> x1 : x0 -> x2 : (ACop x0 x1 -> Set) -> x3 : DPair (ACop x0 x1) x2 -> _x_887 : x0 -> _x_888 : x0 -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1561. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$. Then the difference of the product of $p$ and $a$ and the product of $m$ and $b$ is equal to $1$.\nassistant\n", "label": "axiom let_clause_1561 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : a * p - b * m = gcd p m) (H0 : a * p - b * m = 1) : p * a - m * b = 1", "predict": "axiom let_clause_1561 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : (b : Nat) -> Eq (diff (mul a p) (mul b m)) (gcd p m) -> Eq (diff (mul b m) (mul a p)) (gcd p m)) (b : Nat) : Eq (diff (mul a p) (mul b m)) (gcd p m) -> Eq (diff (mul b m) (mul a p)) (gcd p m) -> Eq (diff (mul a p) (mul b m)) 1) : Eq (diff (mul p a) (mul m b)) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBigop_distr. Soit $n$ un nombre naturel. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Alors pour tous les éléments $R$ de $Dop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, pour tous les éléments $a$ de $B$, $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $let_aop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et la fonction qui envoie $i$ à $let_mop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et $a$ et $f$ appliqué à $i$ est égal à $let_mop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et $a$ et $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $let_aop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "postulate bigop_distr : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> Eq (let_mop n p B nil R f a a (bigop n (\\ i : Nat -> p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (\\ i : Nat -> f i))) (bigop n (\\ i : Nat -> p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (\\ i : Nat -> let_mop n p B nil R f a a (f i)))", "predict": "postulate bigop_distr : (n : Nat) -> (p : (i : Nat) -> Bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (i : Nat) -> B) -> (a : B) -> (i : Nat) -> let_aop : (n : Nat) -> (p : (i : Nat) -> Bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (i : Nat) -> B) -> (a : B) -> (i : Nat) -> let_mop : (n : Nat) -> (p : (i : Nat) -> Bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (i : Nat) -> B) -> (a : B) -> (a' : B) -> (i : Nat) -> f : (i : Nat) -> B -> bigop_distr : (n : Nat) -> (p : (i : Nat) -> Bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (i : Nat) -> B) -> (a : B) -> bigop : (i : Nat) -> let_aop n p B nil R f a -> bigop_distr n p B nil R f a = let_mop n p B nil R f a"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nEq_length_to_mem_all. Soit $n \\in N$. Soit $l$ une liste de nombres naturels. Supposons que $length$ appliqué à $Nat$ et $l$ est égal à $n$. Alors pour tous les éléments $__1$ de $unique$ de $Nat$ et de $l$, pour toutes les fonctions $__2$ des nombres naturels $x$ et des éléments $__2$ de $mem$ de $Nat$ et de $x$ et de $l$ à des éléments de $Lt$ de $x$ et de $n$, pour tous les nombres naturels $i$, si $i$ est inférieur à $n$, alors $mem$ tient pour $Nat$ et $i$ et $l$.\nassistant\n", "label": "axiom eq_length_to_mem_all (n : Nat) (l : list Nat) (x__ : length Nat l = n) (__1 : unique Nat l) (__2 : (x : Nat) -> (__2 : mem Nat x l) -> x < n) (i : Nat) (__3 : i < n) : mem Nat i l", "predict": "axiom eq_length_to_mem_all (n : N) (l : List Nat) (__1 : unique Nat l) (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) (i : Nat) : i < n -> mem Nat i l"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_ind. Let $_n , _m , _q , _r \\in N$. Let $Q_$ be a function from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions. Then for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_809$.\nassistant\n", "label": "div_mod_spec_ind : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 .", "predict": "div_mod_spec_ind : _n : N -> _m : N -> _q : N -> _r : N -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (product _q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLstar_ind_r_aux. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $b1$ vara ett element av $B$. Låt $P$ vara ett element av $relation2$ av $Nat$ och $B$. Låt $__$ vara ett element av $P$ av $0$ och $b1$. Låt $__1$ vara en funktion från naturliga tal $l$ och element $b$ av $B$ och element $b2$ av $B$ och element $__1$ av $lstar$ av $B$ och $R$ och $l$ och $b1$ och $b$ och element $__2$ av $R$ av $b$ och $b2$ och element $__3$ av $P$ av $l$ och $b$ till element av $P$ av summan av $l$ och $1$ och $b2$. Låt $l \\in N$. Låt $b$ och $b2$ vara element av $B$. Låt $__2$ vara ett element av $lstar$ av $B$ och $R$ och $l$ och $b$ och $b2$. Anta att $b$ är lika med $b1$. Då håller $P$ för $l$ och $b2$.\nassistant\n", "label": "axiom lstar_ind_r_aux (B : Set) (R : relation B) (b1 : B) (P : relation2 Nat B) (x__ : P 0 b1) (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2) (l : Nat) (b b2 : B) (__2 : lstar B R l b b2) (__3 : b = b1) : P l b2", "predict": "axiom lstar_ind_r_aux (B : Set) (R : relation B) (b1 : B) (P : relation2 Nat B) (__ : P 0 b1) (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (sum l 1 b2)) (l : Nat) (b b2 : B) (__2 : lstar B R l b b2) (b1 : B) : P l b2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDecidable_mem_nat. Let $n \\in N$. Let $l$ be a list of natural numbers. Then $decidable$ holds for $mem$ applied to $Nat$ and $n$ and $l$.\nassistant\n", "label": "decidable_mem_nat : n : Nat -> l : list Nat -> decidable (mem Nat n l) .", "predict": "decidable_mem_nat : n : N -> l : List Nat -> decidable (mem Nat n l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1617. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Då om produkten av $m$ och $n$ är lika med produkten av $p$ och $c$, så för alla naturliga tal $a$, för alla element $_clearme0$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$, för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$.\nassistant\n", "label": "Axiom let_clause_1617 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (a * p - b * m = gcd p m), forall H0 : (a * p - b * m = 1), gcd p m = p * a - m * b .", "predict": "Axiom let_clause_1617 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : ex Nat (fun b => Eq (skillnaden (produkt av a och p) (produkt av b och m)) (största gemensama delare av p och m)), forall b : Nat, ((skillnaden (produkt av a och p) (produkt av b och m)) = (största gemensama delare av p och m)) -> ((skillnaden (produkt av b och m) (produkt av a och p)) = (största gemensama delare av p och m)) -> ((skillnaden (produkt av a och p) (produkt av b och m)) = (största gemensama delare av p och m)) -> ((skillnaden (produkt av a och p) (produkt av b och m)) = 1) -> (största gemensama delare av p och m) = (produkt av p och a) - (produkt av m et b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDop_rect_Type0. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_955$ av $Dop$ av $A$ och $_nil$ till mängder. Låt $_H_mk_Dop$ vara en funktion från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod (a , _nil)$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod (a , aop__o__op (A , _nil , sum , b , c))$ och $aop__o__op (A , _nil , sum , prod (a , b), prod (a , c))$ till element av $Q_$ av $mk_Dop (A , _nil , sum , prod , _null , _distr)$. Då för alla element $x_955$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_955$.\nassistant\n", "label": "axiom Dop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955", "predict": "axiom Dop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLstar_r_inv_ind. Låt $x1$ vara en mängd. Låt $x2$ vara ett element av $relation$ av $x1$. Låt $x3 \\in N$. Låt $x4$ och $x5$ vara element av $x1$. Låt $_Hterm$ vara ett element av $lstar_r$ av $x1$ och $x2$ och $x3$ och $x4$ och $x5$. Då för alla funktioner $P$ från naturliga tal $_z2386$ och element $_z2385$ av $x1$ och element $_z2384$ av $x1$ till påståenden, för alla funktioner $_H1$ från element $b$ av $x1$ och element $_z2389$ av $Eq$ av $x3$ och $0$ och element $_z2388$ av $Eq$ av $x4$ och $b$ och element $_z2387$ av $Eq$ av $x5$ och $b$ till element av $P$ av $0$ och $b$ och $b$, för alla funktioner $_H2$ från naturliga tal $l$ och element $b1$ av $x1$ och element $b$ av $x1$ och element $_x_1340$ av $lstar_r$ av $x1$ och $x2$ och $l$ och $b1$ och $b$ och element $b2$ av $x1$ och element $_x_1339$ av $x2$ av $b$ och $b2$ och funktioner $_x_1342$ från element $_z2389$ av $Eq$ av $x3$ och $l$ och element $_z2388$ av $Eq$ av $x4$ och $b1$ och element $_z2387$ av $Eq$ av $x5$ och $b$ till element av $P$ av $l$ och $b1$ och $b$ och element $_z2389$ av $Eq$ av $x3$ och $l + 1$ och element $_z2388$ av $Eq$ av $x4$ och $b1$ och element $_z2387$ av $Eq$ av $x5$ och $b2$ till element av $P$ av $l + 1$ och $b1$ och $b2$, håller $P$ för $x3$ och $x4$ och $x5$.\nassistant\n", "label": "Axiom lstar_r_inv_ind : forall x1 : Set, forall x2 : relation x1, forall x3 : nat, forall x4 : x1, forall x5 : x1, forall _Hterm : lstar_r x1 x2 x3 x4 x5, forall P : ((_z2386 : nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop), forall _H1 : ((b : x1) -> (_z2389 : x3 = 0) -> (_z2388 : x4 = b) -> (_z2387 : x5 = b) -> P 0 b b), forall _H2 : ((l : nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : x3 = l) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b) -> P l b1 b) -> (_z2389 : x3 = l + 1) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b2) -> P (l + 1) b1 b2), P x3 x4 x5 .", "predict": "Axiom lstar_r_inv_ind : forall x1 : set, forall x2 : relation x1, forall x3 : N, forall x4 : x1, forall x5 : x1, forall _Hterm : lstar_r x1 x2 x3 x4 x5, forall P : ((_z2386 : N) -> (_z2385 : x1) -> (_z2384 : x1) -> nat), forall _H1 : ((b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b), forall _H2 : ((l : N) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (l + 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (l + 1) b1 b2)), P x3 x4 x5 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nGcd_times_SO_to_gcd_SO. Let $m$ and $n$ and $p$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $p$. Then if the greatest common divisor of $m$ and the product of $n$ and $p$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to $1$.\nassistant\n", "label": "gcd_times_SO_to_gcd_SO : m : Nat -> n : Nat -> p : Nat -> __ : Lt 0 n -> __1 : Lt 0 p -> __2 : Eq (gcd m (times n p)) (nd 1) -> Eq (gcd m n) (nd 1) .", "predict": "gcd_times_SO_to_gcd_SO : m : Nat -> n : Nat -> p : Nat -> 0 < n -> 0 < p -> gcd(m, n * p) = 1 -> gcd(m, n) = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nACop_rect_Type0. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_901$ av $ACop$ av $A$ och $_nil$ till mängder, för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $Q_$ av $mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_901$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_901$.\nassistant\n", "label": "axiom ACop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_901 : ACop A _nil) -> Set) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)) (x_901 : ACop A _nil) : Q_ x_901", "predict": "axiom ACop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_901 : ACop A _nil) -> Set) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop) a b (op A _nil aop) b a)) -> Q_ (mk_ACop A _nil aop _comm)) (x_901 : ACop A _nil) : Q_ x_901"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nEq_length_to_mem_all. Soit $n$ un nombre naturel. Soit $l$ une liste de nombres naturels. Supposons que $length$ appliqué à $Nat$ et $l$ est égal à $n$. Soit $__1$ un élément de $unique$ de $Nat$ et de $l$. Soit $__2$ une fonction des nombres naturels $x$ et des éléments $__2$ de $mem$ de $Nat$ et de $x$ et de $l$ à des éléments de $Lt$ de $x$ et de $n$. Soit $i \\in N$. Alors si $i$ est inférieur à $n$, alors $mem$ tient pour $Nat$ et $i$ et $l$.\nassistant\n", "label": "postulate eq_length_to_mem_all : (n : Nat) -> (l : list Nat) -> (_ : Eq (length Nat l) n) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) -> (i : Nat) -> (__3 : Lt i n) -> mem Nat i l", "predict": "postulate eq_length_to_mem_all : (n : Nat) -> (l : List Nat) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) -> (i : N) -> (i < n) -> mem Nat i l"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_16003. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Then if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "let_clause_16003 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .", "predict": "let_clause_16003 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> 1 = gcd n m -> c : N -> _clearme : (d : Nat -> Eq (c n - d m) 1) -> (d : Nat -> Eq (d m - c n) 1) -> d : Nat -> c n - d m = 1 -> d m - c n = 1 -> m d - n c = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_exp_priml. Soit $n \\in N$. Supposons que $0 < n$. Alors $2 ^ (2 n)\\leq 2 n ^ (prim (2 n)+ 1)$.\nassistant\n", "label": "postulate le_exp_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (pow (times 2 n) (plus (prim (times 2 n)) 1))", "predict": "postulate le_exp_priml : (n : N) -> (0 < n) -> 2 ^ (2 n) <= 2 n ^ (prim (2 n) + 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_73. Låt $n , m , p \\in N$. Anta att $0$ är mindre än $p$. Låt $x134$ och $x135$ och $x136$ vara naturliga tal. Då är summan av $x134$ och summan av $x135$ och $x136$ lika med summan av $x135$ och summan av $x134$ och $x136$.\nassistant\n", "label": "Axiom let_clause_73 : forall n : nat, forall m : nat, forall p : nat, forall posp : (0 < p), forall x134 : nat, forall x135 : nat, forall x136 : nat, x134 + (x135 + x136) = x135 + (x134 + x136) .", "predict": "Axiom let_clause_73 : forall n : N, forall m : N, forall p : N, forall x134 : N, forall x135 : N, forall x136 : N, x134 + (x135 + x136) = x135 + (x134 + x136) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDop_rect_Type5. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_947$ de $Dop$ de $A$ et de $_nil$ à des éléments de $Type5$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_947$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_947$.\nassistant\n", "label": "postulate Dop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_947 : Dop A _nil) -> Type5) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_947 : Dop A _nil) -> Q_ x_947", "predict": "postulate Dop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_947 : Dop A _nil) -> Type5) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_947 : Dop A _nil) -> Q_ x_947"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $g1$ och $g2$ vara funktioner från naturliga tal till naturliga tal. Låt $n1$ vara ett naturligt tal. Låt $Hind$ vara en funktion från funktioner från naturliga tal $i$ och element av $Lt$ av $i$ och $n1$ och element $__1$ av $Eq$ av $p$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$ till element av $Leq$ av $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$. Då för alla funktioner $Hle$ från naturliga tal $i$ och element av $Lt$ av $i$ och summan av $n1$ och $1$ och element $__1$ av $Eq$ av $p$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$, om $p$ applicerat på $n1$ är lika med $true$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nassistant\n", "label": "postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : N) -> (p : (i : N) -> Bool) -> (g1 : (i : N) -> Nat) -> (g2 : (i : N) -> Nat) -> (n1 : Nat) -> (Hind : (i : N) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (bigop : (n1 : Nat) -> (i : N) -> p i) -> Nat -> 1 -> times -> (i : N) -> g1 i) -> (bigop : (n1 : Nat) -> (i : N) -> p i) -> Nat -> 1 -> times -> (i : N) -> g2 i)) -> (Hle : (i : N) -> (__1 : Lt i (sum n1 1)) -> Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 == (product x2516 (quotient x2515 x2516)) + (mod x2515 x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nMin_exists. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $t , m \\in N$. Supposons que $m$ est inférieur à $t$. Supposons que $f$ appliqué à $m$ est égal à $true$. Soit $k , b \\in N$. Supposons que $b$ est inférieur ou ágal à $m$. Alors pour toutes les fonctions $__3$ des nombres naturels $i$ et des éléments $__3$ de $Leq$ de $b$ et de $i$ et des éléments $__4$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $f$ appliqué à $i$ et de contradiction, si $t$ est égal à la somme de $k$ et de $b$, alors $min$ appliqué à $k$ et $b$ et $f$ est égal à $m$.\nassistant\n", "label": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m", "predict": "postulate min_exists : (f : (N -> Bool)) -> (t : N) -> (m : N) -> (k : N) -> (b : N) -> (__3 : (i : N) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) contradiction) -> (t : N) -> (min : k -> b -> f) -> m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_ind. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $Q_$ vara en funktion från naturliga tal $x_1233$ och element $x_1232$ av $B$ och element $x_1231$ av $B$ och element $_x_1234$ av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$ till påståenden. Låt $_H_lstar_O$ vara en funktion från element $b$ av $B$ till element av $Q_$ av $0$ och $b$ och $b$ och $lstar_O (B , _R , b)$. Då för alla funktioner $_H_lstar_S$ från element $b1$ av $B$ och element $b$ av $B$ och element $x_1236$ av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $x_1235$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ och element $_x_1238$ av $Q_$ av $l$ och $b$ och $b2$ och $x_1235$ till element av $Q_$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B , _R , b1 , b , x_1236 , l , b2 , x_1235)$, för alla naturliga tal $x_1233$, för alla element $x_1232$ och $x_1231$ av $B$, för alla element $x_1234$ av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$, håller $Q_$ för $x_1233$ och $x_1232$ och $x_1231$ och $x_1234$.\nassistant\n", "label": "lstar_ind : B : Set -> _R : relation B -> Q_ : (x_1233 : Nat -> x_1232 : B -> x_1231 : B -> _x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Prop) -> _H_lstar_O : (b : B -> Q_ 0 b b (lstar_O B _R b)) -> _H_lstar_S : (b1 : B -> b : B -> x_1236 : _R b1 b -> l : Nat -> b2 : B -> x_1235 : lstar B _R l b b2 -> _x_1238 : Q_ l b b2 x_1235 -> Q_ (plus l (nd 1)) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> x_1233 : Nat -> x_1232 : B -> x_1231 : B -> x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Q_ x_1233 x_1232 x_1231 x_1234 .", "predict": "lstar_ind : B : set -> _R : relation B -> Q_ : (x_1233 : nat -> x_1232 : B -> x_1231 : B -> _x_1234 : lstar B _R x_1233 x_1232 x_1231 -> bool) -> _H_lstar_O : (b : B -> Q_ 0 b b (lstar_O B _R b)) -> _H_lstar_S : (b1 : B -> b : B -> x_1236 : _R b1 b -> l : nat -> b2 : B -> x_1235 : lstar B _R l b b2 -> _x_1238 : Q_ l b b2 x_1235 -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> x_1233 : nat -> x_1232 : B -> x_1231 : B -> x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Q_ x_1233 x_1232 x_1231 x_1234 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_div_mod. Let $n , m \\in N$. Assume that $0 < m$. Then $div_mod_spec$ holds for $n$ and $m$ and $n \\div m$ and $mod (n , m)$.\nassistant\n", "label": "div_mod_spec_div_mod : n : Nat -> m : Nat -> __ : Lt 0 m -> div_mod_spec n m (div n m) (mod n m) .", "predict": "div_mod_spec_div_mod : n : N -> m : N -> 0 < m -> div_mod_spec n m (n div m) (mod n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDiscr_plus_xy_minus_xz. Soit $x , z , y \\in N$. Supposons que $x + y = x - z$. Alors $y = 0$.\nassistant\n", "label": "postulate discr_plus_xy_minus_xz : (x : Nat) -> (z : Nat) -> (y : Nat) -> (_ : Eq (plus x y) (minus x z)) -> Eq y 0", "predict": "postulate discr_plus_xy_minus_xz : (x : N) -> (z : N) -> (y : N) -> x + y == x - z -> y == 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1033. Let $n \\in N$. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Assume that $p2 (n1)= true$. Then if $p1 (n1)= true$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "axiom let_clause_1033 (n : Nat) (p1 p2 : (x__ : Nat) -> bool) (g1 g2 : (x__ : Nat) -> Nat) (n1 : Nat) (Hind : (x__ : (i : Nat) -> (x__ : i < n1) -> (__1 : p1 i = true) -> p2 i = true) -> (__1 : (i : Nat) -> (__1 : i < n1) -> (__2 : p1 i = true) -> g1 i ≤ g2 i) -> bigop n1 (λ i => p1 i) Nat 0 plus (λ i => g1 i) ≤ bigop n1 (λ i => p2 i) Nat 0 plus (λ i => g2 i)) (H1 : (i : Nat) -> (x__ : i < n1 + 1) -> (__1 : p1 i = true) -> p2 i = true) (H2 : (i : Nat) -> (x__ : i < n1 + 1) -> (__1 : p1 i = true) -> g1 i ≤ g2 i) (Hp2 : p2 n1 = true) (Hp1 : p1 n1 = true) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_1033 (n : N) (p1 p2 : (i : N) -> Bool) (g1 g2 : (i : N) -> N) (n1 : N) (Hind : (i : N) -> (__1 : Eq p1 i true) -> (__1 : (i : N) -> (__1 : Lt i n1) -> (__2 : Eq p1 i true) -> Leq (g1 i) (g2 i)) -> Eq p2 i true) : (__1 : (i : N) -> (__1 : Lt i n1) -> (__2 : Eq p1 i true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (λ i => p1 i) Nat 0 plus (λ i => g1 i)) (bigop n1 (λ i => p2 i) Nat 0 plus (λ i => g2 i))) (H1 : (i : N) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq p1 i true) -> Eq p2 i true) (H2 : (i : N) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq p1 i true) -> Leq (g1 i) (g2 i)) (p2_n1 : Eq p2 n1 true) (p1_n1 : Eq p1 n1 true) (x2515 x2516 : N) : x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFalse_to_lt_max. Let $f$ be a function from natural numbers to booleans. Let $n , m \\in N$. Then if $0 < n$ and absurdity is equal to $f (n)$, then if $max (m , f)\\leq n$, then $max (m , f)< n$.\nassistant\n", "label": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n", "predict": "postulate false_to_lt_max : (f : N -> Bool) -> (n : N) -> (m : N) -> (0 < n) -> (absurdity : f n) -> (max (m , f) <= n) -> max (m , f) < n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_ind_l_aux. Let $B$ be a set. Let $R$ be a function from elements of $B$ and elements $__1$ of $B$ to propositions. Let $b2$ be an element of $B$. Let $P$ be an element of $relation2$ of $Nat$ and $B$. Let $__$ be an element of $P$ of $0$ and $b2$. Let $__1$ be a function from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $__1$ of $R$ of $b1$ and $b$ and elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of $l + 1$ and $b1$. Let $l$ be a natural number. Let $b1$ and $b$ be elements of $B$. Let $__2$ be an element of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b$. Assume that $b = b2$. Then $P$ holds for $l$ and $b1$.\nassistant\n", "label": "postulate lstar_ind_l_aux : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (__3 : Eq b b2) -> P l b1", "predict": "postulate lstar_ind_l_aux : (B : Set) -> (R : (__1 : B) -> Proposition) -> (b2 : B) -> (P : relation2 Nat B) -> (__ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (b2 : B) -> (__ : P l b2) -> P l b1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDiv_mod_spec_inv_rect_CProp1. Låt $x1$ och $x2$ och $x3$ och $x4$ vara naturliga tal. Då för alla element $Hterm$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från element $_z1488$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden, för alla funktioner $_H1$ från element $x_855$ av $Lt$ av $x4$ och $x2$ och element $x_854$ av $Eq$ av $x1$ och summan av produkten av $x3$ och $x2$ och $x4$ och element $_z1489$ av $Eq$ av $Hterm$ och $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_855$ och $x_854$ till element av $P$ av $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_855$ och $x_854$, håller $P$ för $Hterm$.\nassistant\n", "label": "div_mod_spec_inv_rect_CProp1 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1488 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_855 : Lt x4 x2 -> x_854 : Eq x1 (plus (times x3 x2) x4) -> _z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm .", "predict": "div_mod_spec_inv_rect_CProp1 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1488 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_855 : Lt x4 x2 -> x_854 : Eq x1 (sum x3 x2 x4) -> _z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nACop_inv_rect_CProp1. Låt $x1$ vara en mängd. Då för alla element $x2$ av $x1$, för alla element $Hterm$ av $ACop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1620$ av $ACop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från element $aop$ av $Aop$ av $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $x1$ och element $b$ av $x1$ till element av $Eq$ av $op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1621$ av $Eq$ av $Hterm$ och $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $P$ av $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $P$ för $Hterm$.\nassistant\n", "label": "Axiom ACop_inv_rect_CProp1 : forall x1 : Set, forall x2 : x1, forall Hterm : ACop x1 x2, forall P : ((_z1620 : ACop x1 x2) -> Prop), forall _H1 : ((aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> op x1 x2 aop a b = op x1 x2 aop b a) -> (_z1621 : Hterm = mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)), P Hterm .", "predict": "Axiom ACop_inv_rect_CProp1 : forall x1 : Set, forall x2 : x1, forall Hterm : ACop x1 x2, forall P : ((_z1620 : ACop x1 x2) -> Prop), forall _H1 : ((aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_divides_body. Let $__$ be a list of natural numbers. Then for all natural numbers $__1$, $bool$.\nassistant\n", "label": "postulate list_divides_body : (_ : list Nat) -> (__1 : Nat) -> bool", "predict": "postulate list_divides_body : (__ : List Nat) -> (__1 : Nat) -> (bool : Nat) -> Set"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBertrand_down. Let $n$ be a natural number. Assume that $0 < n$. Assume that $n \\leq 2 ^ 8$. Then $bertrand$ holds for $n$.\nassistant\n", "label": "postulate bertrand_down : (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n (pow 2 8)) -> bertrand n", "predict": "postulate bertrand_down : (n : Nat) -> (0 < n) -> (n <= 2 ^ 8) -> bertrand n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLstar_dx. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $l \\in N$. Låt $b1$ och $b$ vara element av $B$. Låt $__$ vara ett element av $lstar$ av $B$ och $R$ och $l$ och $b1$ och $b$. Låt $b2$ vara ett element av $B$. Då för alla element $__1$ av $R$ av $b$ och $b2$, håller $lstar$ för $B$ och $R$ och $l + 1$ och $b1$ och $b2$.\nassistant\n", "label": "Axiom lstar_dx : forall B : Set, forall R : relation B, forall l : nat, forall b1 : B, forall b : B, forall x__ : lstar B R l b1 b, forall b2 : B, forall __1 : R b b2, lstar B R (l + 1) b1 b2 .", "predict": "Axiom lstar_dx : forall B : set, forall R : relation B, forall l : N, forall b1 : B, forall b : B, forall __ : lstar B R l b1 b, forall b2 : B, forall __1 : R b b2, lstar B R (l + 1) b1 b2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nBigop_iso. Låt $n1$ och $n2$ vara naturliga tal. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla element $op$ av $ACop$ av $B$ och $nil$, för alla funktioner $f1$ och $f2$ från naturliga tal till element av $B$, för alla element $__$ av $iso$ av $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$, är $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f1$ applicerat på $i$ lika med $bigop$ applicerat på $n2$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f2$ applicerat på $i$.\nassistant\n", "label": "bigop_iso : n1 : Nat -> n2 : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f1 : (__ : Nat -> B) -> f2 : (__ : Nat -> B) -> __ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) -> Eq (bigop n1 (i : Nat => p1 i) B nil (aop__o__op B nil op) (i : Nat => f1 i)) (bigop n2 (i : Nat => p2 i) B nil (aop__o__op B nil op) (i : Nat => f2 i)) .", "predict": "bigop_iso : n1 : Nat -> n2 : Nat -> p1 : (Nat -> Sann) -> p2 : (Nat -> Sann) -> B : Set -> nil : B -> op : Aop B nil -> f1 : (Nat -> B) -> f2 : (Nat -> B) -> __ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) -> bigop n1 (i : Nat => p1 i) B nil (aop__o__op B nil op) (i : Nat => f1 i) = bigop n2 (i : Nat => p2 i) B nil (aop__o__op B nil op) (i : Nat => f2 i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15601. Let $n , m \\in N$. Assume that $0 < m$ and $0 = n$. Then if $0$ is divisible by $m$, then for all natural numbers $q$, if $m = 0 q$, then $n = 0$.\nassistant\n", "label": "Axiom let_clause_15601 : forall n : nat, forall m : nat, forall posn : (0 < m), forall eqn0 : (0 = n), forall _clearme : divisible 0 m, forall q : nat, forall eqm : (m = 0 * q), n = 0 .", "predict": "Axiom let_clause_15601 : forall n : N, forall m : N, forall q : N, forall Hc : (m = 0 q), n = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTrue_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $b$ vara ett naturligt tal. Då om $f (b)= true$, så för alla naturliga tal $n$, $min (n , b , f)= b$.\nassistant\n", "label": "axiom true_min (f : (x__ : Nat) -> bool) (b : Nat) (x__ : f b = true) (n : Nat) : min n b f = b", "predict": "axiom true_min (f : nat -> bool) (b : nat) (n : nat) : min (n , b , f) = b"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_p_ord. Let $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$ be natural numbers. Then if $0 < n$ and $0 < m$, then if $p$ is prime and $n$ is divisible by $m$, then if $p_ord (n , p)= mk_Prod (Nat , Nat , a , b)$ and $p_ord (m , p)= mk_Prod (Nat , Nat , c , d)$, then $b$ is divisible by $d$ and $a \\leq c$.\nassistant\n", "label": "axiom divides_to_p_ord (p a b c d n m : Nat) (x__ : 0 < n) (__1 : 0 < m) (__2 : prime p) (__3 : divisible n m) (__4 : p_ord n p = mk_Prod Nat Nat a b) (__5 : p_ord m p = mk_Prod Nat Nat c d) : divisible b d ∧ a ≤ c", "predict": "axiom divides_to_p_ord (p a b c d n m : Nat) : Prop (0 < n) -> (0 < m) -> (p : Prime) -> (p_ord (n , p) : mk_Prod Nat Nat a b) -> (p_ord (m , p) : mk_Prod Nat Nat c d) -> b div d -> a <= c)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLstar_ind_l_aux. Soit $B$ un ensemble. Soit $R$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des propositions. Soit $b2$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b2$. Soit $__1$ une fonction des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $__1$ de $R$ de $b1$ et de $b$ et des éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de la somme de $l$ et de $1$ et de $b1$. Soit $l$ un nombre naturel. Soient $b1$ et $b$ des éléments de $B$. Alors pour tous les éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b$, si $b$ est égal à $b2$, alors $P$ tient pour $l$ et $b1$.\nassistant\n", "label": "Axiom lstar_ind_l_aux : forall B : Set, forall R : ((x__ : B) -> (__1 : B) -> Prop), forall b2 : B, forall P : relation2 nat B, forall x__ : P 0 b2, forall __1 : ((l : nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1), forall l : nat, forall b1 : B, forall b : B, forall __2 : lstar B R l b1 b, forall __3 : (b = b2), P l b1 .", "predict": "Axiom lstar_ind_l_aux : forall B : set, forall R : ((__ : B) -> (__1 : B) -> Prop), forall b2 : B, forall P : (Nat -> B -> Prop), forall __ : (0 -> b2) -> forall __1 : ((l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1), forall l : Nat, forall b1 : B, forall b : B, forall __2 : (lstar B R l b1 b), if b = b2 then P l b1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_intro. Let $n , m , q , r \\in N$. Assume that $r$ is less than $m$. Then if $n$ is equal to the sum of the product of $q$ and $m$ and $r$, then $div_mod_spec$ holds for $n$ and $m$ and $q$ and $r$.\nassistant\n", "label": "postulate div_mod_spec_intro : (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> (__1 : Eq n (plus (times q m) r)) -> div_mod_spec n m q r", "predict": "postulate div_mod_spec_intro : (n : N) -> (m : N) -> (q : N) -> (r : N) -> (r < m) -> (n == (q * m) + r) -> div_mod_spec n m q r"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_O_n_elim. Låt $n \\in N$. Anta att $0$ är mindre än $n$. Låt $P$ vara en funktion från naturliga tal $__1$ till påståenden. Då för alla funktioner $__1$ från naturliga tal $m$ till element av $P$ av summan av $m$ och $1$, håller $P$ för $n$.\nassistant\n", "label": "lt_O_n_elim : n : Nat -> __ : Lt 0 n -> P : (__1 : Nat -> Prop) -> __1 : (m : Nat -> P (plus m (nd 1))) -> P n .", "predict": "lt_O_n_elim : n : N -> P : (__1 : N -> påstående) -> __1 : (m : N -> P (m + 1)) -> P n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nNot_bertrand_to_le_B. Soit $n$ un nombre naturel. Alors si $2 ^ 7 \\leq n$, alors pour tous les éléments $__1$ de $not_bertrand$ de $n$, $B (2 n)\\leq 2 ^ (2 (2 n \\div 3))(2 n ^ pred ((\\sqrt{ 2 n})\\div 2))$.\nassistant\n", "label": "postulate not_bertrand_to_le_B : (n : Nat) -> (_ : Leq (pow 2 7) n) -> (__1 : not_bertrand n) -> Leq (B (times 2 n)) (times (pow 2 (times 2 (div (times 2 n) 3))) (pow (times 2 n) (pred (div (sqrt (times 2 n)) 2))))", "predict": "postulate not_bertrand_to_le_B : (n : Nat) -> (__1 : not_bertrand n) -> B (2 n) <= 2 ^ (2 (2 n \\div 3)) (2 n ^ pred ((\\sqrt{ 2 n})\\div 2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p , m , n \\in N$. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att $b m - a p = 1$. Då $m b - p a = 1$.\nassistant\n", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (a * p - b * m) (gcd p m))) -> (b : N) -> (_gcdp : gcd p m) -> (_eqp : Eq (m * n) (p * c)) -> (_me0 : m * b - p * a) -> (_me1 : b * m - a * p) -> (_me2 : b * m - a * p) -> (_me3 : b * m) -> (_me4 : a * p) -> (_me5 : 1) -> (_me6 : m * b - p * a) -> (_postulate let_clause_15611 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (a * p - b * m) (gcd p m))) -> (b : N) -> (_gcdp : gcd p m) -> (_eqp : Eq (m * n) (p * c)) -> (_me0 : m * b - p * a) -> (_me1 : b * m - a * p) -> (_me2 : b * m - a * p) -> (_me3 : b * m) -> (_me4 : a * p) -> (_me5 : 1) -> (_me6 : m * b - p * a) -> (_me7 : b * n - a * c) -> (_me8 : b * n) -> (_me9 : a * c) -> (_me10 : 1) -> (_me11 : b * n - a * c) -> (_me12 : b * n) -> (_postulate let_clause_15611 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (a * p - b * m) (gcd p m))) -> (b : N) -> (_gcdp : gcd p m) -> (_eqp : Eq ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nACop_rect_Type4_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_891$ de $ACop$ de $A$ et de $_nil$ à des éléments de $Type4$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op (A , _nil , aop , a , b)$ et de $op (A , _nil , aop , b , a)$ à des éléments de $Q_$ de $mk_ACop (A , _nil , aop , _comm)$, pour tous les éléments $x_891$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_891$.\nassistant\n", "label": "ACop_rect_Type4_body : A : Set -> _nil : A -> Q_ : (_x_891 : ACop A _nil -> Type4) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_891 : ACop A _nil -> Q_ x_891 .", "predict": "ACop_rect_Type4_body : A : Set -> _nil : A -> Q_ : (_x_891 : ACop A _nil -> Type4) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_891 : ACop A _nil -> Q_ x_891 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNat_rect_CProp3_body. Soit $Q_$ une fonction des nombres naturels $_x_401$ à des propositions. Soit $_H_O$ un élément de $Q_$ de $0$. Soit $_H_S$ une fonction des nombres naturels $x_402$ et des éléments $_x_404$ de $Q_$ de $x_402$ à des éléments de $Q_$ de la somme de $x_402$ et de $1$. Soit $x_401 \\in N$. Alors $Q_$ tient pour $x_401$.\nassistant\n", "label": "nat_rect_CProp3_body : Q_ : (_x_401 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_402 : Nat -> _x_404 : Q_ x_402 -> Q_ (plus x_402 (nd 1))) -> x_401 : Nat -> Q_ x_401 .", "predict": "nat_rect_CProp3_body : Q_ : (_x_401 : N -> P) -> _H_O : Q_ 0 -> _H_S : (x_402 : N -> _x_404 : Q_ x_402 -> Q_ (x_402 + 1)) -> x_401 : N -> Q_ x_401 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_16001. Soit $m , n , a , b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$. Alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nassistant\n", "label": "let_clause_16001 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (gcd m n) (minus (times n c) (times m d)) .", "predict": "let_clause_16001 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> gcd n m = 1 -> c : N -> _clearme : ex Nat (d : Nat => Eq (diff (prod c n) (prod d m)) 1 => Eq (diff (prod d m) (prod c n)) 1) -> d : N -> (diff (prod c n) (prod d m) = 1 => diff (prod d m) (prod c n) = 1) -> diff (prod c n) (prod d m) = 1 -> gcd m n = diff (n c) (m d) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMax_spec_inv_ind. Let $x1 \\in N$. Let $x2$ be a function from natural numbers to booleans. Let $x3 \\in N$. Let $_Hterm$ be an element of $max_spec$ of $x1$ and $x2$ and $x3$. Let $P$ be a function from natural numbers $_z1769$ to propositions. Let $_H1$ be a function from natural numbers $m$ and elements $_x_975$ of $Lt$ of $m$ and $x1$ and elements $_x_974$ of $Eq$ of $x2 (m)$ and $true$ and functions $_x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $x1$ to elements of $Eq$ of $x2 (i)$ and absurdity and elements $_z1770$ of $Eq$ of $x3$ and $m$ to elements of $P$ of $m$. Let $_H2$ be a function from functions $_x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $x1$ to elements of $Eq$ of $x2 (i)$ and absurdity and elements $_z1770$ of $Eq$ of $x3$ and $0$ to elements of $P$ of $0$. Then $P$ holds for $x3$.\nassistant\n", "label": "postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (_ : Nat) -> bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> (_ : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 0) -> P 0) -> P x3", "predict": "postulate max_spec_inv_ind : (x1 : N) -> (x2 : (i : N) -> Bool) -> (x3 : N) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : N) -> Prop) -> (_H1 : (m : N) -> (_x_975 : Lt m x1) -> (_x_974 : Eq x2 m true) -> (_x_973 : (i : N) -> (__1 : Lt i x1) -> Eq x2 i absurdity) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : N) -> Lt i x1) -> (_z1770 : Eq x3 0) -> P 0) -> P x3"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDiv_plus_times. Låt $m , q , r \\in N$. Då om $r$ är mindre än $m$, så är kvoten av summan av produkten av $q$ och $m$ och $r$ och $m$ lika med $q$.\nassistant\n", "label": "Axiom div_plus_times : forall m : nat, forall q : nat, forall r : nat, forall x__ : (r < m), (q * m + r) / m = q .", "predict": "Axiom div_plus_times : forall m : N, forall q : N, forall r : N, r < m -> (q * m + r) / m = q ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_exp_B. Låt $n \\in N$. Då om $0$ är mindre än $n$, så är potensen av $2$ och produkten av $2$ och $n$ mindre än eller lika med produkten av produkten av $2$ och $n$ och $B$ applicerat på produkten av $2$ och $n$.\nassistant\n", "label": "le_exp_B : n : Nat -> __ : Lt 0 n -> Leq (pow (nd 2) (times (nd 2) n)) (times (times (nd 2) n) (B (times (nd 2) n))) .", "predict": "le_exp_B : n : N -> 0 < n -> 2^(2*n) <= (2*n) * B(2*n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBigop_Sfalse. Let $k$ be a natural number. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be a function from elements of $B$ and elements $__1$ of $B$ to elements of $B$. Let $f$ be a function from natural numbers to elements of $B$. Then if $p$ applied to $k$ is equal to absurdity, then $bigop$ applied to the sum of $k$ and $1$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "Axiom bigop_Sfalse : forall k : nat, forall p : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ((x__ : B) -> (__1 : B) -> B), forall f : ((x__ : nat) -> B), forall x__ : (p k = false), bigop (k + 1) (fun i => p i) B nil op (fun i => f i) = bigop k (fun i => p i) B nil op (fun i => f i) .", "predict": "Axiom bigop_Sfalse : forall k : nat, forall p : nat -> bool, forall B : set, forall nil : B, forall op : (B -> __1 : B -> B), forall f : nat -> B, forall Hc : p k = absurdity, bigop (k + 1) (fun i => p i) B nil op (fun i => f i) = bigop k (fun i => p i) B nil op (fun i => f i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_rect_Type5. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_893$ of $ACop$ of $A$ and $_nil$ to elements of $Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_893$.\nassistant\n", "label": "Axiom ACop_rect_Type5 : forall A : Set, forall _nil : A, forall Q_ : ((_x_893 : ACop A _nil) -> Type5), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)), forall x_893 : ACop A _nil, Q_ x_893 .", "predict": "Axiom ACop_rect_Type5 : forall A : set, forall _nil : A, forall Q_ : ((_x_893 : ACop A _nil) -> Type5), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)), forall x_893 : ACop A _nil, Q_ x_893 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNot_lt_to_le. Låt $n$ och $m$ vara naturliga tal. Då om $n$ inte är mindre än $m$, så $m \\leq n$.\nassistant\n", "label": "axiom not_lt_to_le (n m : Nat) (x__ : ¬ (n < m)) : m ≤ n", "predict": "axiom not_lt_to_le (n m : Nat) : m <= n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_15611. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c \\in N$. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Alors si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$, alors si la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$, alors si la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale à $1$, alors la différence du produit de $m$ et de $b$ et du produit de $p$ et de $a$ est égale à $1$.\nassistant\n", "label": "Axiom let_clause_15611 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (b * m - a * p = gcd p m), forall H0 : (b * m - a * p = 1), m * b - p * a = 1 .", "predict": "Axiom let_clause_15611 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : ex (Nat -> (b : Nat) -> Eq (diff (mul a p) (mul b m)) (gcd p m) -> Eq (diff (mul b m) (mul a p)) (gcd p m)), forall b : Nat, ((diff (mul a p) (mul b m)) = (gcd p m) -> (diff (mul b m) (mul a p)) = (gcd p m) -> (diff (mul b m) (mul a p)) = (gcd p m) -> (diff (mul b m) (mul a p)) = 1 -> (diff (mul m b) (mul p a)) = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEqb_elim. Låt $n$ och $m$ vara naturliga tal. Låt $P$ vara en funktion från sanningsvärden till påståenden. Då för alla funktioner $__$ från element av $Eq$ av $n$ och $m$ till element av $P$ av $true$, för alla funktioner $__1$ från element $__1$ av $not$ av $Eq$ applicerat på $n$ och $m$ till element av $P$ av kontradiktion, håller $P$ för $eqb$ applicerat på $n$ och $m$.\nassistant\n", "label": "axiom eqb_elim (n m : Nat) (P : (x__ : bool) -> Prop) (x__ : (x__ : n = m) -> P true) (__1 : (__1 : ¬ (n = m)) -> P false) : P (eqb n m)", "predict": "axiom eqb_elim (n m : Nat) (P : (Bool -> Set) ) (__ : (Eq n m -> P true)) (__1 : (__1 : not (Eq n m)) -> P contradiction) : P (eqb n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLt_to_le_to_lt_times. Låt $n$ och $m$ och $p$ och $q$ vara naturliga tal. Anta att $n < m$. Då om $p \\leq q$, så om $0 < q$, så $n p < m q$.\nassistant\n", "label": "axiom lt_to_le_to_lt_times (n m p q : Nat) (x__ : n < m) (__1 : p ≤ q) (__2 : 0 < q) : n * p < m * q", "predict": "axiom lt_to_le_to_lt_times (n m p q : Nat) : (n < m) -> (p <= q) -> (0 < q) -> n p < m q"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nCongruent_ab. Soit $m , n , a , b \\in N$. Alors si $0 < n$, alors si $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors $ex$ tient pour $Nat$ et la fonction qui envoie $x$ à la conjonction de $congruent$ appliqué à $x$ et $a$ et $m$ et de $congruent$ appliqué à $x$ et $b$ et $n$.\nassistant\n", "label": "postulate congruent_ab : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\\ x : Nat -> and (congruent x a m) (congruent x b n))", "predict": "postulate congruent_ab : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (ex : Nat) -> (x : N) -> congruent x a m && congruent x b n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFound_max_spec. Let $n$ be a natural number. Then for all functions $f$ from natural numbers to booleans, for all natural numbers $m$, if $m < n$, then if $f (m)= true$, then for all functions $__2$ from natural numbers $i$ and elements $__2$ of $Lt$ of $m$ and $i$ and elements $__3$ of $Lt$ of $i$ and $n$ to elements of $Eq$ of $f (i)$ and absurdity, $max_spec$ holds for $n$ and $f$ and $m$.\nassistant\n", "label": "found_max_spec : n : Nat -> f : (__ : Nat -> bool) -> m : Nat -> __ : Lt m n -> __1 : Eq (f m) true -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i n -> Eq (f i) false) -> max_spec n f m .", "predict": "found_max_spec : n : Nat -> f : (Nat -> Bool) -> m : Nat -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i n -> Eq (f i) absurdity) -> max_spec : n f m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1600. Soit $m , n , a , b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Supposons que $c n - d m = 1$. Alors $n c - m d$ est égal au diviseur commun plus grand de $m$ et de $n$.\nassistant\n", "label": "let_clause_1600 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (gcd m n) (minus (times n c) (times m d)) .", "predict": "let_clause_1600 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : (d : Nat -> Eq (c n - d m) 1) -> d : N -> c n - d m = 1 -> n c - m d = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15611. Let $p , m , n \\in N$. Assume that $0 < p$ and $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Assume that $m n = p c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or equal to $b m - a p$ and the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Assume that $b m - a p = 1$. Then $m b - p a = 1$.\nassistant\n", "label": "let_clause_15611 : p : Nat -> m : Nat -> n : Nat -> posn : Lt 0 p -> gcd1 : Eq (gcd p m) (nd 1) -> _clearme : divisible p (times m n) -> c : Nat -> nm : Eq (times m n) (times p c) -> a : Nat -> _clearme0 : ex Nat (b : Nat => or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> b : Nat -> _clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)) -> H : Eq (minus (times b m) (times a p)) (gcd p m) -> H0 : Eq (minus (times b m) (times a p)) (nd 1) -> Eq (minus (times m b) (times p a)) (nd 1) .", "predict": "let_clause_15611 : p : N -> m : N -> n : N -> c : Nat -> a : Nat -> _clearme0 : (b : Nat -> Eq (difference (product a p) (product b m)) (gcd p m) -> Eq (difference (product b m) (product a p)) (gcd p m)) -> b : N -> gcd p m = a p - b m -> gcd p m = b m - a p -> b m - a p = 1 -> m b - p a = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nCongruent_ab_lt. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Då om $0 < n$, så om $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så håller $ex$ för $Nat$ och funktionen som avbildar $x$ som konjunktionen av konjunktionen av $congruent$ applicerat på $x$ och $a$ och $m$ och $congruent$ applicerat på $x$ och $b$ och $n$ och $Lt$ applicerat på $x$ och produkten av $m$ och $n$.\nassistant\n", "label": "postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\\ x : Nat -> and (and (congruent x a m) (congruent x b n)) (Lt x (times m n)))", "predict": "postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (ex : Nat) -> (f : (x : Nat) -> Nat) -> congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (ex : Nat) -> (f : (x : Nat) -> Nat) -> postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (ex : Nat) -> (f : (x : Nat) -> Nat) -> postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (ex : Nat) -> (f : (x : Nat) -> Nat) -> postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (ex : Nat) -> (f : (x : Nat) -> Nat) -> postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (ex : Nat) -> (f : (x : Nat) -> Nat) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nGcd_n_n. For all natural numbers $n$, the greatest common divisor of $n$ and $n$ is equal to $n$.\nassistant\n", "label": "postulate gcd_n_n : (n : Nat) -> Eq (gcd n n) n", "predict": "postulate gcd_n_n : (n : Nat) -> n == gcd n n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1607. Låt $m , n , a , b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$. Då är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nassistant\n", "label": "let_clause_1607 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .", "predict": "let_clause_1607 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> (c n - d m = 1 -> d m - c n = 1 -> d m - c n = 1) -> m d - n c = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBc1. Låt $n , k \\in N$. Anta att $k < n$. Då $bc (n + 1 , k + 1)= bc (n , k)+ bc (n , k + 1)$.\nassistant\n", "label": "postulate bc1 : (n : Nat) -> (k : Nat) -> (_ : Lt k n) -> Eq (bc (plus n 1) (plus k 1)) (plus (bc n k) (bc n (plus k 1)))", "predict": "postulate bc1 : (n : N) -> (k : N) -> (k < n) -> bc (n + 1 , k + 1) = bc (n , k) + bc (n , k + 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_rect_CProp2_body. Let $Q_$ be a function from natural numbers $_x_405$ to propositions. Let $_H_O$ be an element of $Q_$ of $0$. Then for all functions $_H_S$ from natural numbers $x_406$ and elements $_x_408$ of $Q_$ of $x_406$ to elements of $Q_$ of $x_406 + 1$, for all natural numbers $x_405$, $Q_$ holds for $x_405$.\nassistant\n", "label": "Axiom nat_rect_CProp2_body : forall Q_ : ((_x_405 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_406 : nat) -> (_x_408 : Q_ x_406) -> Q_ (x_406 + 1)), forall x_405 : nat, Q_ x_405 .", "predict": "Axiom nat_rect_CProp2_body : forall Q_ : ((_x_405 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_406 : nat) -> (_x_408 : Q_ x_406) -> Q_ (x_406 + 1)), forall x_405 : nat, Q_ x_405 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1544. Låt $p , q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m$ och $n$ vara naturliga tal. Anta att $0 < n$. Anta att $n \\leq m$. Anta att $n \\leq q + 1$. Anta att $n$ inte är delbart med $m$. Låt $a$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Låt $b \\in N$. Anta att $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ eller $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Anta att $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$. Då $a mod (m , n)- n b = gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "Axiom let_clause_1544 : forall p : nat, forall q : nat, forall Hind : ((m : nat) -> (n : nat) -> (x__ : 0 < n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex nat (fun a => ex nat (fun b => a * n - b * m = gcd_aux q m n \\/ b * m - a * n = gcd_aux q m n))), forall m : nat, forall n : nat, forall posn : (0 < n), forall lenm : Leq n m, forall lenS : Leq n (q + 1), forall ndivnm : (~ divisible n m), forall a : nat, forall _clearme : ex nat (fun b => a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall b : nat, forall _clearme0 : (a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall H : (a * mod m n - b * n = gcd_aux q n (mod m n)), a * mod m n - n * b = gcd_aux q n (mod m n) .", "predict": "Axiom let_clause_1544 : forall p : N, forall q : N, forall Hind : ((m : N) -> (n : N) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (fun a => ex Nat (fun b => disjunktion (Eq (skillnaden (produkten a n) (produkten b m)) (gcd_aux q m n)) (Eq (skillnaden (produkten b m) (produkten a n)) (gcd_aux q m n)))), forall m : N, forall n : N, forall 0 : N, forall nleqm : ((n : N) -> (m : N) -> nat), forall nleqqplusone : ((n : N) -> (q : N) -> nat), forall nnotdivbym : ((n : N) -> (m : N) -> nat), forall a : N, forall _clearme : ex Nat (fun b => disjunktion (Eq (skillnaden (produkten a (mod m n)) (produkten b n)) (gcd_aux q n (mod m n))) (Eq (skillnaden (produkten b n) (produkten a (mod m n))) (gcd_aux q n (mod m n)))), forall b : N, natAxiom let_clause_1544 : forall p : N, forall q : N, forall Hind : ((m : N) -> (n : N) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (fun a => ex Nat (fun b => disjunktion (Eq (skillnaden (produkten a n) (produkten b m)) (gcd_aux q m n)) (Eq (skillnaden (produkten b m) (produkten a n)) (gcd_aux q m n)))), forall m : N, forall n : N, forall 0 : N, forall nleqm : ((n : N) -> (m : N) -> nat), forall nleqqplusone : ((n : N) -> (q : N) -> nat), forall nnotdivbym : ((n : N) -> (m : N) -> nat), forall a : N, forall _clearme : ex Nat (fun b => disjunktion (Eq (skillnaden"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_upper_bound1. Soit $n$ un nombre naturel. Alors $Nat$.\nassistant\n", "label": "Axiom let_upper_bound1 : forall n : nat, nat .", "predict": "Axiom let_upper_bound1 : nat -> Nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_times. Låt $n1 , n2 , m1 , m2 \\in N$. Anta att $n1 \\leq n2$ och $m1 \\leq m2$. Då $n1 m1 \\leq n2 m2$.\nassistant\n", "label": "Axiom le_times : forall n1 : nat, forall n2 : nat, forall m1 : nat, forall m2 : nat, forall x__ : Leq n1 n2, forall __1 : Leq m1 m2, Leq (n1 * m1) (n2 * m2) .", "predict": "Axiom le_times : forall n1 : N, forall n2 : N, forall m1 : N, forall m2 : N, n1 <= n2 -> m1 <= m2 -> n1 m1 <= n2 m2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_div. Let $n , m \\in N$. Then if $n$ is divisible by $m$, then $m \\div n n = m$.\nassistant\n", "label": "axiom divides_to_div (n m : Nat) (x__ : divisible n m) : m / n * n = m", "predict": "axiom divides_to_div (n m : N) : mdiv n n = m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1544. Soient $p$ et $q$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soient $m$ et $n$ des nombres naturels. Supposons que $0 < n$. Supposons que $n \\leq m$. Supposons que $n \\leq q + 1$. Supposons que $n$ n'est pas divisible par $m$. Soit $a$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b$ un nombre naturel. Supposons que $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ ou $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Alors si $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$, alors $a mod (m , n)- n b = gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (ex : Nat) -> (\\ a : Nat -> ex) -> (\\ b : Nat -> Eq (diff (prod a n) (prod b m)) (gcd_aux q m n))) -> (m : Nat) -> (n : Nat) -> (0 < n) -> (n <= m) -> (n <= q + 1) -> (n) /= (m) -> (a : Nat) -> (_clearme : ex) -> (b : Nat) -> Eq (diff (prod a (mod m n)) (prod b n)) (gcd_aux q n (mod m n))) -> (Eq (diff (prod b n) (prod a (mod m n))) (gcd_aux q n (mod m n))) -> (a : Nat) -> (b : Nat) -> (_clearme : ex) -> (Eq (a mod (m , n) - b n) (gcd_aux q n (mod m n))) -> (Eq (b n - a mod (m , n)) (gcd_aux q n (mod m n))) -> (a : Nat) -> (b : Nat) -> (_clearme : ex) -> (Eq (a mod (m , n) - n b) (gcd_aux q n (mod m n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1034. Let $n$ and $m$ and $q$ be natural numbers. Assume that $0 < n$ and $0 < m$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = mod (x2515 , x2516)+ x2516 (x2515 \\div x2516)$.\nassistant\n", "label": "Axiom let_clause_1034 : forall n : nat, forall m : nat, forall q : nat, forall posn : (0 < n), forall posm : (0 < m), forall x2515 : nat, forall x2516 : nat, x2515 = mod x2515 x2516 + x2516 * (x2515 / x2516) .", "predict": "Axiom let_clause_1034 : forall n : nat, forall m : nat, forall q : nat, forall x2515 : nat, forall x2516 : nat, x2515 = mod x2515 x2516 + x2516 (x2515 div x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLt_SO_smallest_factor. Soit $n$ un nombre naturel. Alors si $1 < n$, alors $1 < smallest_factor (n)$.\nassistant\n", "label": "Axiom lt_SO_smallest_factor : forall n : nat, forall x__ : (1 < n), 1 < smallest_factor n .", "predict": "Axiom lt_SO_smallest_factor : forall n : nat, 1 < n -> 1 < smallest_factor n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNat_inv_rect_CProp0. Låt $Hterm$ vara ett naturligt tal. Låt $P$ vara en funktion från naturliga tal $_z713$ till påståenden. Då för alla funktioner $_H1$ från element $_z714$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$, för alla funktioner $_H2$ från naturliga tal $x_414$ och funktioner $_x_416$ från element $_z714$ av $Eq$ av $Hterm$ och $x_414$ till element av $P$ av $x_414$ och element $_z714$ av $Eq$ av $Hterm$ och $x_414 + 1$ till element av $P$ av $x_414 + 1$, håller $P$ för $Hterm$.\nassistant\n", "label": "postulate nat_inv_rect_CProp0 : (Hterm : Nat) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm", "predict": "postulate nat_inv_rect_CProp0 : (Hterm : Set) -> (P : (_z713 : Set) -> Set) -> (_H1 : (_z714 : Eq Hterm 0) -> Set) -> (_H2 : (x_414 : Set) -> (_x_416 : (_z714 : Eq Hterm x_414) -> Set) -> (_z714 : Eq Hterm (x_414 + 1)) -> Set) -> P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_sigma. Låt $n$ vara ett naturligt tal. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Då för alla funktioner $g1$ och $g2$ från naturliga tal till naturliga tal, för alla funktioner $__$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n$ och element $__1$ av $Eq$ av $p1$ applicerat på $i$ och $true$ till element av $Eq$ av $p2$ applicerat på $i$ och $true$, för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n$ och element $__2$ av $Eq$ av $p1$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ mindre än eller lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$.\nassistant\n", "label": "Axiom le_sigma : forall n : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall g1 : ((x__ : nat) -> nat), forall g2 : ((x__ : nat) -> nat), forall x__ : ((i : nat) -> (x__ : i < n) -> (__1 : p1 i = true) -> p2 i = true), forall __1 : ((i : nat) -> (__1 : i < n) -> (__2 : p1 i = true) -> Leq (g1 i) (g2 i)), Leq (bigop n (fun i => p1 i) nat 0 plus (fun i => g1 i)) (bigop n (fun i => p2 i) nat 0 plus (fun i => g2 i)) .", "predict": "Axiom le_sigma : forall n : nat, forall p1 : nat -> bool, forall p2 : nat -> bool, forall g1 : nat -> nat, forall g2 : nat -> nat, forall __ : ((i : nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Eq (p2 i) true), forall __1 : ((i : nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)), forall bigop : ((i : nat) -> p1 i -> Nat) -> 0 -> plus -> (i : nat) -> g1 i), nat -> (i : nat) -> g2 i), nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBijn_fg. Let $f$ and $g$ be functions from natural numbers to natural numbers. Let $n$ be a natural number. Let $__$ be an element of $bijn$ of $f$ and $n$. Then for all elements $__1$ of $bijn$ of $g$ and $n$, $bijn$ holds for the function that maps $p$ to $f (g (p))$ and $n$.\nassistant\n", "label": "bijn_fg : f : (__ : Nat -> Nat) -> g : (__ : Nat -> Nat) -> n : Nat -> __ : bijn f n -> __1 : bijn g n -> bijn (p : Nat => f (g p)) n .", "predict": "bijn_fg : f : (Nat -> Nat) -> g : (Nat -> Nat) -> n : Nat -> __ : bijn f n -> __1 : bijn g n -> p : Nat -> bijn (p -> f (g p)) n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10336. Let $n$ and $m$ be natural numbers. Let $Hind$ be a function from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi (p)$ and $pred (p)\\times (2 ^ (2 p - 3))$. Let $a$ be a natural number. Then if $m = 2 a$ or $m = 2 a + 1$ and $m = 2 a + 1$, then if $1 < 2 a + 1$ and $0 < a$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_10336 : forall n : nat, forall m : nat, forall Hind : ((p : nat) -> (x__ : p < m) -> (__1 : 1 < p) -> Leq (Psi p) (pred p * pow 2 (2 * p - 3))), forall a : nat, forall _clearme : (m = 2 * a \\/ m = 2 * a + 1), forall Hm : (m = 2 * a + 1), forall Hlt : (1 < 2 * a + 1), forall Ha : (0 < a), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_10336 : forall n : Nat, forall m : Nat, forall Hind : ((p : Nat) -> (__1 : Lt p m) -> (__2 : Lt 1 p) -> Leq (Psi p) (pred p) (2 ^ (2 p - 3))), forall a : Nat, if m = 2 a or m = 2 a + 1 and m = 2 a + 1 then if 1 < 2 a + 1 and 0 < a then forall x2515 : Nat, forall x2516 : Nat, x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15311. Låt $n , m \\in N$. Anta att $0$ är mindre än $m$. Anta att $n$ är delbart med $m$. Låt $d , p \\in N$. Anta att $m$ är lika med produkten av $n$ och summan av $p$ och $1$. Då är $m$ lika med summan av $n$ och produkten av $n$ och $p$.\nassistant\n", "label": "axiom let_clause_15311 (n m : Nat) (posm : 0 < m) (_clearme : divisible n m) (d p : Nat) (eqm : m = n * (p + 1)) : m = n + n * p", "predict": "axiom let_clause_15311 (n m : N) (d p : N) : m = n * (p + 1) -> m = n + n * p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMod_S. Let $n , m \\in N$. Then if $0 < m$, then if $mod (n , m)+ 1 < m$, then $mod (n + 1 , m)= mod (n , m)+ 1$.\nassistant\n", "label": "postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (plus (mod n m) 1) m) -> Eq (mod (plus n 1) m) (plus (mod n m) 1)", "predict": "postulate mod_S : (n : N) -> (m : N) -> (0 : N) -> (mod : N) -> (1 : N) -> (mod (n + 1) m) = mod (n m) + 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_16005. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nassistant\n", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : (d : Nat) -> Eq (diff (c * n) (d * m)) 1) -> (d : Nat) -> (eq1 : (diff (c * n) (d * m)) == 1) -> (eq2 : (diff (d * m) (c * n)) == 1) -> (eq3 : (diff (d * m) (c * n)) == 1) -> (div : Nat) -> (div' : Nat) -> (_div : (d : Nat) -> Eq (diff (m * d) (n * c)) div) -> (_div' : (d : Nat) -> Eq (diff (n * d) (m * c)) div') -> (_div__ : (d : Nat) -> Eq (diff (n * d) (m * c)) div__) -> (_div__' : (d : Nat) -> Eq (diff (m * d) (n * c)) div__') -> (_div__div__ : (d : Nat) -> Eq (diff (n * d) (m * c)) div__div__) -> (_div__div__' : (d : Nat) -> Eq (diff (m * d) (n * c)) div__div__) -> (_divdiv : (d : Nat) -> Eq (diff (m * d) (n * c)) divdiv) -> (_divdiv' : (d : Nat) -> Eq (diff (n * d) (m * c)) divdiv) -> (_divdivdiv : (d : Nat) -> Eq (diff (n * d) (m * c)) divdivdiv) -> (_divdivdiv' : (d : Nat) -> Eq (diff (m * d) (n * c)) divdivdiv) -> (_divdivdivdiv : (d : Nat) -> Eq (diff (n * d) (m * c)) divdivdivdiv) -> (_divdivdivdiv' : (d : Nat) -> Eq (diff (m * d) (n * c)) divdivdivdiv) -> (_divdivdivdivdiv : (d : Nat) -> Eq (diff (n *"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1560. Soient $n$ et $m$ des nombres naturels. Alors si $n$ est divisible par $m$, alors si $0 = n$, alors pour tous les nombres naturels $d$, si $m = 0 d$, alors $n = 0$.\nassistant\n", "label": "Axiom let_clause_1560 : forall n : nat, forall m : nat, forall divnm : divisible n m, forall H : (0 = n), forall d : nat, forall auto : (m = 0 * d), n = 0 .", "predict": "Axiom let_clause_1560 : forall n : nat, forall m : nat, forall d : nat, nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNot_divides_ord_rem. Låt $m , p \\in N$. Då om $0$ är mindre än $m$, så om $1$ är mindre än $p$, så är $p$ inte delbart med $ord_rem$ applicerat på $m$ och $p$.\nassistant\n", "label": "axiom not_divides_ord_rem (m p : Nat) (x__ : 0 < m) (__1 : 1 < p) : ¬ divisible p (ord_rem m p)", "predict": "axiom not_divides_ord_rem (m p : N) : (0 < m) -> (1 < p) -> p ≠ ord_rem m p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_ind_l. Let $B$ be a set. Let $R$ be a function from elements of $B$ and elements $__1$ of $B$ to propositions. Let $b2$ be an element of $B$. Let $P$ be an element of $relation2$ of $Nat$ and $B$. Then for all elements $__$ of $P$ of $0$ and $b2$, for all functions $__1$ from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $__1$ of $R$ of $b1$ and $b$ and elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of $l + 1$ and $b1$, for all natural numbers $l$, for all elements $b1$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b1$.\nassistant\n", "label": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1", "predict": "postulate lstar_ind_l : (B : Set) -> (R : (__1 : B) -> Prop) -> (b2 : B) -> (P : Nat -> B -> Prop) -> (__ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Supposons que $f (b)= j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Alors si $a = b$, alors $f (a)= j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (__ : (i0 : Nat) -> (Leq i0 n) -> Nat) (injf : injn f n) : a = b -> f a = j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1560. Soit $n , m \\in N$. Supposons que $n$ est divisible par $m$. Supposons que $0 = n$. Alors pour tous les nombres naturels $d$, si $m = 0 d$, alors $n = 0$.\nassistant\n", "label": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0", "predict": "postulate let_clause_1560 : (n : N) -> (m : N) -> (d : N) -> (n : 0) -> (m : 0 d) -> n : 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMinus_Sn_n. Let $n \\in N$. Then $1 = n + 1 - n$.\nassistant\n", "label": "Axiom minus_Sn_n : forall n : nat, 1 = n + 1 - n .", "predict": "Axiom minus_Sn_n : forall n : N, 1 = n + 1 - n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1575. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$. Soit $x1029$ un nombre naturel. Alors $x1029$ est égal au produit de $x1029$ et de la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nassistant\n", "label": "Axiom let_clause_1575 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), forall x1029 : nat, x1029 = x1029 * (n * c - m * d) .", "predict": "Axiom let_clause_1575 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : (d : Nat) -> Eq (diff (prod c n) (prod d m)) 1 -> Eq (diff (prod d m) (prod c n)) 1 -> forall d : Nat, ((diff (prod c n) (prod d m)) = 1) -> (diff (prod d m) (prod c n)) = 1 -> (diff (prod c n) (prod d m)) = 1 -> forall x1029 : Nat, x1029 = prod x1029 (diff (prod n c) (prod m d)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_min_to_false. Let $f$ be a function from natural numbers to booleans. Let $n$ and $m$ and $b$ be natural numbers. Then if $b \\leq m$, then if $m < min (n , b , f)$, then absurdity is equal to $f (m)$.\nassistant\n", "label": "lt_min_to_false : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> b : Nat -> __ : Leq b m -> __1 : Lt m (min n b f) -> Eq (f m) false .", "predict": "lt_min_to_false : f : (Nat -> Bool) -> n : Nat -> m : Nat -> b : Nat -> b <= m -> m < min (n , b , f) -> absurdity = f (m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_spec_inv_ind. Let $x1 , x2 \\in N$. Let $x3$ be a function from natural numbers to booleans. Then for all natural numbers $x4$, for all elements $_Hterm$ of $min_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from natural numbers $_z1890$ to propositions, for all functions $_H1$ from natural numbers $m$ and elements $_x_1080$ of $Leq$ of $x2$ and $m$ and elements $_x_1079$ of $Lt$ of $m$ and the sum of $x1$ and $x2$ and elements $_x_1078$ of $Eq$ of $x3$ applied to $m$ and $true$ and functions $_x_1077$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $x3$ applied to $i$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and $m$ to elements of $P$ of $m$, for all functions $_H2$ from functions $_x_1081$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $x1$ and $x2$ to elements of $Eq$ of $x3$ applied to $i$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and the sum of $x1$ and $x2$ to elements of $P$ of the sum of $x1$ and $x2$, $P$ holds for $x4$.\nassistant\n", "label": "Axiom min_spec_inv_ind : forall x1 : nat, forall x2 : nat, forall x3 : ((x__ : nat) -> bool), forall x4 : nat, forall _Hterm : min_spec x1 x2 x3 x4, forall P : ((_z1890 : nat) -> Prop), forall _H1 : ((m : nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : m < x1 + x2) -> (_x_1078 : x3 m = true) -> (_x_1077 : (i : nat) -> (x__ : Leq x2 i) -> (__1 : i < m) -> x3 i = false) -> (_z1891 : x4 = m) -> P m), forall _H2 : ((_x_1081 : (i : nat) -> (x__ : Leq x2 i) -> (__1 : i < x1 + x2) -> x3 i = false) -> (_z1891 : x4 = x1 + x2) -> P (x1 + x2)), P x4 .", "predict": "Axiom min_spec_inv_ind : forall x1 : N, forall x2 : N, forall x3 : ((i : N) -> bool), forall x4 : N, forall _Hterm : min_spec x1 x2 x3 x4, forall P : ((_z1890 : N) -> Prop), forall _H1 : ((m : N) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (x1 + x2)) -> (_x_1078 : Eq x3 m true) -> (_x_1077 : (i : N) -> (__1 : Lt i m) -> Eq x3 i absurdity) -> (_z1891 : Eq x4 m) -> P m), forall _H2 : ((_x_1081 : (i : N) -> (__1 : Lt i (x1 + x2)) -> Eq x3 i absurdity) -> (_z1891 : Eq x4 (x1 + x2)) -> P (x1 + x2)), P x4 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFact_pi_p3. Soit $n$ un nombre naturel. Alors le produit de $bigop$ appliqué à la somme du produit de $2$ et de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et du produit de $2$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et du produit de $2$ et du quotient de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$ et de $bigop$ appliqué à la somme du produit de $2$ et de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et du produit de $2$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et de $mod$ appliqué à le quotient du produit de $2$ et de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$ et $2$ est égal à $(2 n)!$.\nassistant\n", "label": "Axiom fact_pi_p3 : forall n : nat, factorial (2 * n) = bigop (2 * n + 1) (fun p => primeb p) nat 1 times (fun p => bigop (log p (2 * n)) (fun i => true) nat 1 times (fun i => pow p (2 * (n / pow p (i + 1))))) * bigop (2 * n + 1) (fun p => primeb p) nat 1 times (fun p => bigop (log p (2 * n)) (fun i => true) nat 1 times (fun i => pow p (mod (2 * n / pow p (i + 1)) 2))) .", "predict": "Axiom fact_pi_p3 : forall n : Nat, (bigop (plus (times 2 n) 1) (fun p => primeb p) Nat 1 times (fun p => bigop (log p (times 2 n)) (fun i => true) Nat 1 times (fun i => (p ** (times 2 (quotient n (p ** (times 2 i))))) * (plus i 1))) (bigop (plus (times 2 n) 1) (fun p => primeb p) Nat 1 times (fun p => bigop (log p (times 2 n)) (fun i => true) Nat 1 times (fun i => (p ** (times 2 (quotient n (p ** (times 2 i)))))))) (mod (times 2 (quotient (times 2 n) (p ** (times 2 i)))) 2)) = (2 n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_O_ord_rem. Let $p , n \\in N$. Assume that $1$ is less than $p$. Assume that $0$ is less than $n$. Then $0$ is less than $ord_rem$ applied to $n$ and $p$.\nassistant\n", "label": "lt_O_ord_rem : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Lt 0 (ord_rem n p) .", "predict": "lt_O_ord_rem : p : N -> n : N -> 1 < p -> 0 < n -> 0 < ord_rem(n, p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_fact_to_le. Pour tous les nombres naturels $p$ et $n$, si $p$ est et premier et divisible par $n !$, alors $p \\leq n$.\nassistant\n", "label": "Axiom divides_fact_to_le : forall p : nat, forall n : nat, forall x__ : prime p, forall __1 : divisible p (factorial n), Leq p n .", "predict": "Axiom divides_fact_to_le : forall p : nat, forall n : nat, if p is prime and divisible by n ! then p <= n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1033. Soit $n \\in N$. Supposons que $0$ est inférieur à $n$. Alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nassistant\n", "label": "postulate let_clause_1033 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (x2515 : N) -> (x2516 : N) -> x2515 == (x2516 * (x2515 / x2516)) + (mod x2515 x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLe_to_not_lt. Låt $n$ och $m$ vara naturliga tal. Då om $n$ är mindre än eller lika med $m$, så är $m$ inte mindre än $n$.\nassistant\n", "label": "axiom le_to_not_lt (n m : Nat) (x__ : n ≤ m) : ¬ (m < n)", "predict": "axiom le_to_not_lt (n m : Nat) : Prop => and (n <= m) (m != n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nOrd_ord_rem. Låt $p$ och $q$ och $m$ vara naturliga tal. Anta att $0 < m$. Anta att $p$ är primt. Då om $q$ är primt, så om $q < p$, så $ord (ord_rem (m , p), q)= ord (m , q)$.\nassistant\n", "label": "ord_ord_rem : p : Nat -> q : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : prime q -> __3 : Lt q p -> Eq (ord (ord_rem m p) q) (ord m q) .", "predict": "ord_ord_rem : p : nat -> q : nat -> m : nat -> 0 < m -> p : primt -> q : primt -> q < p -> ord (ord_rem (m , p), q) = ord (m , q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i , j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Då om $f (a)= i$, så för alla naturliga tal $b$, om $b \\leq n$ och $f (b)= j$ och $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : nat -> nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : (f a = b -> a = b) -> b : Nat -> f b = j -> __ b : Leq b n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : (a = b -> f a = j) -> b : Nat -> f b = j -> __ b : Leq b n -> f b = j -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nEqb_elim. Pour tous les nombres naturels $n$ et $m$, pour toutes les fonctions $P$ des valeurs booléennes à des propositions, pour toutes les fonctions $__$ des éléments de $Eq$ de $n$ et de $m$ à des éléments de $P$ de $true$, pour toutes les fonctions $__1$ des éléments $__1$ de $not$ de $Eq (n , m)$ à des éléments de $P$ de contradiction, $P$ tient pour $eqb (n , m)$.\nassistant\n", "label": "postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)", "predict": "postulate eqb_elim : (n : Set) -> (m : Set) -> (P : (b : Set) -> Set) -> (__ : (__1 : Set) -> Set) -> (__1 : (__1 : Set) -> Set) -> P (eqb n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDiv_mod_spec_div_mod. Soient $n$ et $m$ des nombres naturels. Alors si $0 < m$, alors $div_mod_spec$ tient pour $n$ et $m$ et $n \\div m$ et $mod (n , m)$.\nassistant\n", "label": "axiom div_mod_spec_div_mod (n m : Nat) (x__ : 0 < m) : div_mod_spec n m (n / m) (mod n m)", "predict": "axiom div_mod_spec_div_mod (n m : Nat) : (0 < m) -> div_mod_spec n m (n div m) (mod n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExp_ord. Let $p$ and $n$ be natural numbers. Then if $1 < p$ and $0 < n$, then $n = p ^ ord (n , p)ord_rem (n , p)$.\nassistant\n", "label": "Axiom exp_ord : forall p : nat, forall n : nat, forall x__ : (1 < p), forall __1 : (0 < n), n = pow p (ord n p) * ord_rem n p .", "predict": "Axiom exp_ord : forall p : nat, forall n : nat, 1 < p -> 0 < n -> n = p ^ ord (n , p)ord_rem (n , p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDiv_mod_spec_rect_Type2. Låt $_n$ och $_m$ och $_q$ och $_r$ vara naturliga tal. Låt $Q_$ vara en funktion från element $_x_825$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till element av $Type2$. Då för alla funktioner $_H_div_mod_spec_intro$ från element $x_827$ av $Lt$ av $_r$ och $_m$ och element $x_826$ av $Eq$ av $_n$ och $_q _m + _r$ till element av $Q_$ av $div_mod_spec_intro (_n , _m , _q , _r , x_827 , x_826)$, för alla element $x_825$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_825$.\nassistant\n", "label": "div_mod_spec_rect_Type2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_825 : div_mod_spec _n _m _q _r -> Type2) -> _H_div_mod_spec_intro : (x_827 : Lt _r _m -> x_826 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> x_825 : div_mod_spec _n _m _q _r -> Q_ x_825 .", "predict": "div_mod_spec_rect_Type2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_825 : div_mod_spec -> Type2) -> _H_div_mod_spec_intro : (x_827 : Lt -> x_826 : Eq -> Q_ : div_mod_spec_intro (_n , _m , _q , _r , x_827 , x_826)) -> x_825 : div_mod_spec -> Q_ : x_825 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1573. Låt $n$ och $m$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $m$ är delbart med $n$. Låt $d \\in N$. Anta att $0$ är lika med $m$. Anta att $n$ är lika med produkten av $m$ och $d$. Då är $n$ lika med $m$.\nassistant\n", "label": "let_clause_1573 : n : Nat -> m : Nat -> posn : Lt 0 n -> _clearme : divisible m n -> d : Nat -> auto : Eq 0 m -> auto' : Eq n (times m d) -> Eq n m .", "predict": "let_clause_1573 : n : Nat -> m : Nat -> 0 < n -> m = n * d -> 0 = m -> n = m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_n_8_to_le_Psi_exp. Soit $n \\in N$. Supposons que $n$ est inférieur ou ágal à $8$. Alors $Psi$ appliqué à $n$ est inférieur ou ágal à la puissance de $2$ et de la différence du produit de $2$ et de $n$ et de $3$.\nassistant\n", "label": "le_n_8_to_le_Psi_exp : n : Nat -> __ : Leq n (nd 8) -> Leq (Psi n) (pow (nd 2) (minus (times (nd 2) n) (nd 3))) .", "predict": "le_n_8_to_le_Psi_exp : n : N -> n <= 8 -> Psi n <= 2^(2*n-3) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nGcd_1_to_lt_n. Soient $i$ et $n$ des nombres naturels. Supposons que $1 < n$ et $i \\leq n$. Supposons que $1$ est égal au diviseur commun plus grand de $i$ et de $n$. Alors $i < n$.\nassistant\n", "label": "axiom gcd_1_to_lt_n (i n : Nat) (x__ : 1 < n) (__1 : i ≤ n) (__2 : gcd i n = 1) : i < n", "predict": "axiom gcd_1_to_lt_n (i n : Nat) : (1 < n) -> (i <= n) -> (1 = gcd i n) -> i < n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15591. Let $n$ and $m$ be natural numbers. Assume that $0 < m$ and $0 = n$. Assume that $0$ is divisible by $m$. Let $q$ be a natural number. Then if $m = 0 q$, then $m = n$.\nassistant\n", "label": "Axiom let_clause_15591 : forall n : nat, forall m : nat, forall posn : (0 < m), forall eqn0 : (0 = n), forall _clearme : divisible 0 m, forall q : nat, forall eqm : (m = 0 * q), m = n .", "predict": "Axiom let_clause_15591 : forall n : nat, forall m : nat, forall q : nat, (0 < m) -> (0 = n) -> (0) = m -> m = 0 q -> m = n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nCommutative_gcd. Låt $n , m \\in N$. Då är det största gemensama delaret av $m$ och $n$ lika med det största gemensama delaret av $n$ och $m$.\nassistant\n", "label": "postulate commutative_gcd : (n : Nat) -> (m : Nat) -> Eq (gcd n m) (gcd m n)", "predict": "postulate commutative_gcd : (n : N) -> (m : N) -> gcd n m == gcd m n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_Type4. Let $x1$ be a set. Then for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1506$ of $Aop$ of $x1$ and $x2$ to elements of $Type4$, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1507$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.\nassistant\n", "label": "Aop_inv_rect_Type4 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1506 : Aop x1 x2 -> Type4) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .", "predict": "Aop_inv_rect_Type4 : x1 : Set -> x2 : Set -> Hterm : Aop x1 x2 -> P : (_z1506 : Aop x1 x2 -> Type4) -> _H1 : (op : (__1 : Set -> x1) -> _nill : (a : Set -> Eq (op x2 a) a) -> _nilr : (a : Set -> Eq (op a x2) a) -> _assoc : (a : Set -> b : Set -> c : Set -> Eq (op a (op b c)) (op (op a b) c)) -> _z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFound_min_spec. Soit $n , b \\in N$. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $m \\in N$. Supposons que $b \\leq m$. Supposons que $m < n + b$. Alors si $f (m)= true$, alors pour toutes les fonctions $__3$ des nombres naturels $i$ et des éléments $__3$ de $Leq$ de $b$ et de $i$ et des éléments $__4$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $f (i)$ et de contradiction, $min_spec$ tient pour $n$ et $b$ et $f$ et $m$.\nassistant\n", "label": "Axiom found_min_spec : forall n : nat, forall b : nat, forall f : ((x__ : nat) -> bool), forall m : nat, forall x__ : Leq b m, forall __1 : (m < n + b), forall __2 : (f m = true), forall __3 : ((i : nat) -> (__3 : Leq b i) -> (__4 : i < m) -> f i = false), min_spec n b f m .", "predict": "Axiom found_min_spec : forall n : N, forall b : N, forall f : ((i : N) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) contradiction), forall m : N, b <= m -> m < n + b -> f m = true -> forall __3 : ((i : N) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) contradiction), min_spec n b f m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15441. Let $p , q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$ and $n \\leq m$. Assume that $n \\leq q + 1$ and $n$ is not divisible by $m$. Let $a$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b \\in N$. Then if $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ or $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$ and $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, then $n b - a mod (m , n)= gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "Axiom let_clause_15441 : forall p : nat, forall q : nat, forall Hind : ((m : nat) -> (n : nat) -> (x__ : 0 < n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex nat (fun a => ex nat (fun b => a * n - b * m = gcd_aux q m n \\/ b * m - a * n = gcd_aux q m n))), forall m : nat, forall n : nat, forall posn : (0 < n), forall lenm : Leq n m, forall lenS : Leq n (q + 1), forall ndivnm : (~ divisible n m), forall a : nat, forall _clearme : ex nat (fun b => a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall b : nat, forall _clearme0 : (a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall H : (b * n - a * mod m n = gcd_aux q n (mod m n)), n * b - a * mod m n = gcd_aux q n (mod m n) .", "predict": "Axiom let_clause_15441 : forall p : N, forall q : N, forall Hind : ((m : N) -> (n : N) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n q) -> ex : Nat -> (a : Nat) -> ex Nat (b : Nat) -> Eq (difference (product a n) (product b m)) (gcd_aux q m n) -> Eq (difference (product b m) (product a n)) (gcd_aux q m n) -> Eq (difference (product b n) (product a (mod m n))) (gcd_aux q n (mod m n)) -> Eq (difference (product b (mod m n)) (product a n)) (gcd_aux q n (mod m n)) -> Eq (difference (product b n) (product a (mod m n))) (gcd_aux q n (mod m n))), forall m : N, forall n : N, forall Axiom let_clause_15441 : forall p : N, forall q : N, forall Hind : ((m : N) -> (n : N) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n q) -> ex : Nat -> (a : Nat) -> ex Nat (b : Nat) -> Eq (difference (product a n) (product b m)) (gcd_aux q m n) -> Eq (difference (product b m) (product a n)) (gcd_aux q m n) -> Eq (difference (product b n) (product a (mod m n))) (gcd_aux q n (mod m n)) -> Eq (difference (product b (mod m n)) (product a n)) (gcd_aux q n (mod m n)) -> Eq (difference (product b n) (product a (mod m n))) (gcd_aux q n (mod m n))), forall m : N, forall n : N, forall Axiom let_clause_15441 : forall p : N, forall q : N, forall Hind : ((m : N) -> (n : N) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n q) -> ex : Nat -> (a : Nat) -> ex Nat (b : Nat) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAop_rect_CProp4_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_875$ de $Aop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $_nil$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $_nil$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $Q_$ de $mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_875$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_875$.\nassistant\n", "label": "postulate Aop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875", "predict": "postulate Aop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_exp_to_divides. Soient $p$ et $n$ et $m$ des nombres naturels. Supposons que $p$ est et premier et divisible par $n ^ m$. Alors $p$ est divisible par $n$.\nassistant\n", "label": "Axiom divides_exp_to_divides : forall p : nat, forall n : nat, forall m : nat, forall x__ : prime p, forall __1 : divisible p (pow n m), divisible p n .", "predict": "Axiom divides_exp_to_divides : forall p : nat, forall n : nat, forall m : nat, p : n ^ m -> p : n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a$ be a natural number. Assume that $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$. Assume that $a$ is less than or equal to $n$. Assume that $f$ applied to $a$ is equal to $i$. Let $b \\in N$. Assume that $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$. Assume that $b$ is less than or equal to $n$. Assume that $f$ applied to $b$ is equal to $j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$. Let $injf$ be an element of $injn$ of $f$ and $n$. Then if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : (N -> N) -> n : N -> permf : permut f n -> i : N -> j : N -> a : N -> a <= n -> f a = i -> a <= n -> f a = i -> b : N -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : N -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_minus_comm. Let $a$ and $b$ and $c$ be natural numbers. Then the difference of the difference of $a$ and $b$ and $c$ is equal to the difference of the difference of $a$ and $c$ and $b$.\nassistant\n", "label": "minus_minus_comm : a : Nat -> b : Nat -> c : Nat -> Eq (minus (minus a b) c) (minus (minus a c) b) .", "predict": "minus_minus_comm : a : Nat -> b : Nat -> c : Nat -> (a - b) - c = (a - c) - b ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_10331. Soit $n$ un nombre naturel. Supposons que $5 < n$. Alors pour tous les nombres naturels $m$, si $6 \\leq m$, alors si $(m + 1)^ 2 \\leq 2 ^ m$, alors pour tous les nombres naturels $a$, si $6 \\leq a$, alors si $2 (a + 1)+ 1 \\leq 2 ^ a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> (n : Nat) -> (m : Nat) -> (a : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> postulate let_clause_10331 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> (n : Nat) -> (m : Nat) -> (a : Nat) -> (postulate let_clause_10331 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> (n : Nat) -> (m : Nat) -> (a : Nat) -> (postulate let_clause_10331 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> (n : Nat) -> (m : Nat) -> (a : Nat) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nMonotonic_lt_plus_l. Soit $n$ un nombre naturel. Alors $monotonic$ tient pour $Nat$ et $Lt$ et la fonction qui envoie $m$ à la somme de $m$ et de $n$.\nassistant\n", "label": "monotonic_lt_plus_l : n : Nat -> monotonic Nat Lt (m : Nat => plus m n) .", "predict": "monotonic_lt_plus_l : n : Nat -> m : Nat -> monotonic Nat Lt (m : Nat => m + n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1575. Låt $m , n , a , b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Då för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så för alla naturliga tal $x1029$, $x1029 = x1029 (n c - m d)$.\nassistant\n", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : ex Nat (\\ d : Nat -> Eq (c n - d m) 1)) -> (d : Nat) -> (x1029 : Nat) -> x1029 = x1029 (n c - m d)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_16005. Let $m , n , a , b \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.\nassistant\n", "label": "let_clause_16005 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .", "predict": "let_clause_16005 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> gcd(n, m) = 1 -> c : N -> _clearme : (d : Nat -> Eq (c * n - d * m) 1) -> Eq (d * m - c * n) 1) -> d : Nat -> (Eq (c * n - d * m) 1 -> Eq (d * m - c * n) 1 -> Eq (d * m - c * n) 1 -> gcd(m, n) = (m * d - n * c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLstar_inv_ind. Soit $x1$ un ensemble. Soit $x2$ un élément de $relation$ de $x1$. Soit $x3$ un nombre naturel. Soient $x4$ et $x5$ des éléments de $x1$. Soit $_Hterm$ un élément de $lstar$ de $x1$ et de $x2$ et de $x3$ et de $x4$ et de $x5$. Soit $P$ une fonction des nombres naturels $_z2089$ et des éléments $_z2088$ de $x1$ et des éléments $_z2087$ de $x1$ à des propositions. Soit $_H1$ une fonction des éléments $b$ de $x1$ et des éléments $_z2092$ de $Eq$ de $x3$ et de $0$ et des éléments $_z2091$ de $Eq$ de $x4$ et de $b$ et des éléments $_z2090$ de $Eq$ de $x5$ et de $b$ à des éléments de $P$ de $0$ et de $b$ et de $b$. Alors pour toutes les fonctions $_H2$ des éléments $b1$ de $x1$ et des éléments $b$ de $x1$ et des éléments $_x_1236$ de $x2$ de $b1$ et de $b$ et des nombres naturels $l$ et des éléments $b2$ de $x1$ et des éléments $_x_1235$ de $lstar$ de $x1$ et de $x2$ et de $l$ et de $b$ et de $b2$ et des fonctions $_x_1238$ des éléments $_z2092$ de $Eq$ de $x3$ et de $l$ et des éléments $_z2091$ de $Eq$ de $x4$ et de $b$ et des éléments $_z2090$ de $Eq$ de $x5$ et de $b2$ à des éléments de $P$ de $l$ et de $b$ et de $b2$ et des éléments $_z2092$ de $Eq$ de $x3$ et de la somme de $l$ et de $1$ et des éléments $_z2091$ de $Eq$ de $x4$ et de $b1$ et des éléments $_z2090$ de $Eq$ de $x5$ et de $b2$ à des éléments de $P$ de la somme de $l$ et de $1$ et de $b1$ et de $b2$, $P$ tient pour $x3$ et $x4$ et $x5$.\nassistant\n", "label": "axiom lstar_inv_ind (x1 : Set) (x2 : relation x1) (x3 : Nat) (x4 x5 : x1) (_Hterm : lstar x1 x2 x3 x4 x5) (P : (_z2089 : Nat) -> (_z2088 : x1) -> (_z2087 : x1) -> Prop) (_H1 : (b : x1) -> (_z2092 : x3 = 0) -> (_z2091 : x4 = b) -> (_z2090 : x5 = b) -> P 0 b b) (_H2 : (b1 : x1) -> (b : x1) -> (_x_1236 : x2 b1 b) -> (l : Nat) -> (b2 : x1) -> (_x_1235 : lstar x1 x2 l b b2) -> (_x_1238 : (_z2092 : x3 = l) -> (_z2091 : x4 = b) -> (_z2090 : x5 = b2) -> P l b b2) -> (_z2092 : x3 = l + 1) -> (_z2091 : x4 = b1) -> (_z2090 : x5 = b2) -> P (l + 1) b1 b2) : P x3 x4 x5", "predict": "axiom lstar_inv_ind (x1 : Set) (x2 : relation x1) (x3 : Nat) (x4 x5 : Set) (_Hterm : lstar x1 x2 x3 x4 x5) (P : (_z2089 : Nat) -> (_z2088 : Set) -> (_z2087 : Set) -> Prop) (_H1 : (b : Set) -> (_z2092 : Eq x3 0) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b) -> P 0 b b) (_H2 : (b1 : Set) -> (b : Set) -> (_x_1236 : x2 b1 b) -> (l : Nat) -> (b2 : Set) -> (_x_1235 : lstar x1 x2 l b b2) -> (_x_1238 : (_z2092 : Eq x3 l) -> (_z2091 : Eq x4 b) -> (_z2090 : Eq x5 b2) -> P l b b2) -> (_z2092 : Eq x3 (l + 1)) -> (_z2091 : Eq x4 b1) -> (_z2090 : Eq x5 b2) -> P (l + 1) b1 b2)) : P x3 x4 x5"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_Psi_BPsi1. Let $n$ be a natural number. Then if $0 < n$, then $Psi (2 n)\\leq B (2 n)Psi (n)$.\nassistant\n", "label": "le_Psi_BPsi1 : n : Nat -> __ : Lt 0 n -> Leq (Psi (times (nd 2) n)) (times (B (times (nd 2) n)) (Psi n)) .", "predict": "le_Psi_BPsi1 : n : Nat -> 0 < n -> Psi (2 n) <= B (2 n) Psi (n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_10471. Soient $n1$ et $n2$ des nombres naturels. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $ACop$ de $B$ et de $nil$. Alors pour toutes les fonctions $f1$ et $f2$ des nombres naturels à des éléments de $B$, pour tous les éléments $_clearme$ de $iso$ de $B$ et de $mk_range (B , f1 , n1 , p1)$ et de $mk_range (B , f2 , n2 , p2)$, pour toutes les fonctions $h$ des nombres naturels à des nombres naturels, pour tous les éléments $_clearme0$ de $ex$ de $prod$ appliqué à $Set$ et $Set$ et $Nat$ et la fonction qui envoie $__$ à $Nat$ et de la fonction qui envoie $k$ à la conjonction de la conjonction de $prod$ appliqué à $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Prop$ et $Prop$ et $Eq$ appliqué à $p1$ appliqué à $i$ et $true$ et la fonction qui envoie $__1$ à $Eq$ appliqué à $f1$ appliqué à $i$ et $f2$ appliqué à $h$ appliqué à $i$ et de $sub_hk$ appliqué à $h$ et $k$ et $B$ et $mk_range$ appliqué à $B$ et $f1$ et $n1$ et $p1$ et $mk_range$ appliqué à $B$ et $f2$ et $n2$ et $p2$ et de $sub_hk$ appliqué à $k$ et $h$ et $B$ et $mk_range$ appliqué à $B$ et $f2$ et $n2$ et $p2$ et $mk_range$ appliqué à $B$ et $f1$ et $n1$ et $p1$, pour toutes les fonctions $k$ des nombres naturels à des nombres naturels, si $prod$ tient pour $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Prop$ et $Prop$ et $Eq$ appliqué", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true ->", "predict": "postulate let_clause_10471 : (n1 : Naturals) -> (n2 : Naturals) -> (p1 : (i : Naturals) -> Bool) -> (p2 : (i : Naturals) -> Bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (i : Naturals) -> B) -> (f2 : (i : Naturals) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (i : Naturals) -> Naturals) -> (_clearme0 : ex (prod Set Set Nat (\\ __ : Naturals -> Nat)) (\\ k : Naturals -> conj (conj (prod Set Prop Nat (\\ i : Naturals -> prod Prop Prop (Lt i n1) (\\ __ : Prop -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Prop -> Eq (f1 i) (f2 (h i))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (i : Naturals) -> Naturals) -> (_clearme1 : ex (prod Set Set Nat (\\ __ : Naturals -> Nat)) (\\ i : Naturals -> conj (prod Prop Prop (Lt i n1) (\\ __ : Prop -> Eq (p1 i) true)) (Eq (f1 i) (f2 (k i))))) -> (_clearme2 : ex (prod Set Set Nat (\\ __ : Naturals -> Nat)) (\\ i : Naturals -> conj (prod Prop Prop (Lt i n1) (\\ __ : Prop -> Eq (p1 i) false)) (Eq (f1 i) nil))) -> (_clearme3 : ex (prod Set Set Nat (\\ __ : Naturals -> Nat)) (\\ i : Naturals -> conj (prod Prop Prop (Lt i n2) (\\ __ : Prop -> Eq (p2 i) true)) (Eq (f2 i) (f1 (k i))))) -> (_clearme4 : ex (prod Set Set Nat (\\ __ : Naturals -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBc. Let $_n$ and $_k$ be natural numbers. Then $Nat$.\nassistant\n", "label": "Axiom bc : forall _n : nat, forall _k : nat, nat .", "predict": "Axiom bc : forall _n : Nat, forall _k : Nat, Nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAxiom. Let $__$ and $__1$ be natural numbers. Then the quotient of $__$ and $__1$ is a natural number.\nassistant\n", "label": "Axiom div : forall x__ : nat, forall __1 : nat, nat .", "predict": "Axiom div : forall __ : nat, forall __1 : nat, nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_CProp4. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions. Let $_H_mk_Aop$ be a function from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil , a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a , _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a , op (b , c))$ and $op (op (a , b), c)$ to elements of $Q_$ of $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$. Let $x_875$ be an element of $Aop$ of $A$ and $_nil$. Then $Q_$ holds for $x_875$.\nassistant\n", "label": "Aop_rect_CProp4 : A : Set -> _nil : A -> Q_ : (_x_875 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_875 : Aop A _nil -> Q_ x_875 .", "predict": "Aop_rect_CProp4 : A : Set -> _nil : A -> Q_ : (_x_875 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (a : A -> __1 : A -> A) -> _nill : (a : A -> Eq op (_nil , a) a) -> _nilr : (a : A -> Eq op (a , _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq op (a , op (b , c)) (op (op (a , b) , c))) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_875 : Aop A _nil -> Q_ x_875 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMinus_pred_pred. Låt $n$ och $m$ vara naturliga tal. Då om $0$ är mindre än $n$, så om $0$ är mindre än $m$, så är skillnaden mellan $pred$ applicerat på $n$ och $pred$ applicerat på $m$ lika med skillnaden mellan $n$ och $m$.\nassistant\n", "label": "axiom minus_pred_pred (n m : Nat) (x__ : 0 < n) (__1 : 0 < m) : pred n - pred m = n - m", "predict": "axiom minus_pred_pred (n m : Nat) : Nat => if 0 < n => if 0 < m => pred n - pred m => n - m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_times_to_le. För alla naturliga tal $a$ och $n$ och $m$, om $0 < a$ och $a n \\leq a m$, så $n \\leq m$.\nassistant\n", "label": "le_times_to_le : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 a -> __1 : Leq (times a n) (times a m) -> Leq n m .", "predict": "le_times_to_le : a : nat -> n : nat -> m : nat -> 0 < a -> a n <= a m -> n <= m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_to_divides_times. Låt $p , q , n \\in N$. Anta att $p$ är primt. Anta att $p$ inte är delbart med $q$. Anta att $p$ är delbart med $n$. Då om $q$ är delbart med $n$, så är $p \\times q$ delbart med $n$.\nassistant\n", "label": "postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n", "predict": "postulate divides_to_divides_times : (p : N) -> (q : N) -> (n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N) -> n : N) -> (p : N) -> (q : N"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_r_S. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l$ be a natural number. Let $b1$ and $b$ be elements of $B$. Let $__$ be an element of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$. Let $b2$ be an element of $B$. Let $__1$ be an element of $R$ of $b$ and $b2$. Then $lstar_r$ holds for $B$ and $R$ and $l + 1$ and $b1$ and $b2$.\nassistant\n", "label": "lstar_r_S : B : Set -> R : relation B -> l : Nat -> b1 : B -> b : B -> __ : lstar_r B R l b1 b -> b2 : B -> __1 : R b b2 -> lstar_r B R (plus l (nd 1)) b1 b2 .", "predict": "lstar_r_S : B : set -> R : relation B -> l : natural -> b1 : B -> b : B -> __ : lstar_r B R l b1 b -> b2 : B -> __1 : R b b2 -> lstar_r B R (l + 1) b1 b2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNilr_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ is equal to $a$.\nassistant\n", "label": "postulate nilr_body : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx a nil) a", "predict": "postulate nilr_body : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> op A nil xxx a nil == a"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15311. Låt $n , m \\in N$. Anta att $0 < m$. Anta att $n$ är delbart med $m$. Då för alla naturliga tal $d$ och $p$, om $m = n (p + 1)$, så $m = n + n p$.\nassistant\n", "label": "axiom let_clause_15311 (n m : Nat) (posm : 0 < m) (_clearme : divisible n m) (d p : Nat) (eqm : m = n * (p + 1)) : m = n + n * p", "predict": "axiom let_clause_15311 (n m : N) (d p : Nat) : m = n + n p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nAop_rect_CProp0_body. För alla mängder $A$, för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_885$ av $Aop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil , a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a , _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a , op (b , c))$ och $op (op (a , b), c)$ till element av $Q_$ av $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$, för alla element $x_885$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_885$.\nassistant\n", "label": "Axiom Aop_rect_CProp0_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_885 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_885 : Aop A _nil, Q_ x_885 .", "predict": "Axiom Aop_rect_CProp0_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_885 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (a : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_885 : Aop A _nil, Q_ x_885 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15591. Soit $n , m \\in N$. Supposons que $0 < m$ et $0 = n$. Alors si $0$ est divisible par $m$, alors pour tous les nombres naturels $q$, si $m = 0 q$, alors $m = n$.\nassistant\n", "label": "let_clause_15591 : n : Nat -> m : Nat -> posn : Lt 0 m -> eqn0 : Eq 0 n -> _clearme : divisible 0 m -> q : Nat -> eqm : Eq m (times 0 q) -> Eq m n .", "predict": "let_clause_15591 : n : N -> m : N -> 0 < m -> 0 = n -> 0 : m -> q : N -> m = 0 q -> m = n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1075. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $bijf$ be an element of $bijn$ of $f$ and $n + 1$. Then if $f (n + 1)= n + 1$, then for all natural numbers $i$, if $i \\leq n$, then for all natural numbers $a$, if $a \\leq n + 1$ and $f (a)= i$ and $a \\leq n + 1$, then if $f (a)= i$ and $a = n + 1$, then $i = a$.\nassistant\n", "label": "axiom let_clause_1075 (f : (x__ : Nat) -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (fS : f (n + 1) = n + 1) (i : Nat) (lein : i ≤ n) (a : Nat) (_clearme : a ≤ n + 1 ∧ f a = i) (lean : a ≤ n + 1) (fa : f a = i) (Hc : a = n + 1) : i = a", "predict": "axiom let_clause_1075 (f : Nat -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (i : Nat) (a : Nat) : (a <= n + 1) -> (f a = i) -> (a <= n + 1) -> (f a = i) -> (a = n + 1) -> i = a"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1047. Soient $k$ et $n$ des nombres naturels. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$. Soit $f$ une fonction des nombres naturels à des éléments de $B$. Supposons que $n \\leq k$. Soit $j$ un nombre naturel. Supposons que $n \\leq j$. Alors pour toutes les fonctions $Hind$ des fonctions des nombres naturels $i$ et des éléments de $Leq$ de $n$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $j$ à des éléments de $Eq$ de $p (i)$ et de contradiction à des éléments de $Eq$ de $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et de $bigop$ appliqué à $j$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$, pour toutes les fonctions $Hfalse$ des nombres naturels $i$ et des éléments de $Leq$ de $n$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $j + 1$ à des éléments de $Eq$ de $p (i)$ et de contradiction, pour tous les nombres naturels $x2571$ et $x2572$, $x2571 = x2572 (x2571 \\div x2572)+ mod (x2571 , x2572)$.\nassistant\n", "label": "axiom let_clause_1047 (k n : Nat) (p : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : (x__ : B) -> (__1 : B) -> B) (f : (x__ : Nat) -> B) (lenk : n ≤ k) (j : Nat) (leup : n ≤ j) (Hind : (x__ : (i : Nat) -> (x__ : n ≤ i) -> (__1 : i < j) -> p i = false) -> bigop n (λ i => p i) B nil op (λ i => f i) = bigop j (λ i => p i) B nil op (λ i => f i)) (Hfalse : (i : Nat) -> (x__ : n ≤ i) -> (__1 : i < j + 1) -> p i = false) (x2571 x2572 : Nat) : x2571 = x2572 * (x2571 / x2572) + mod x2571 x2572", "predict": "axiom let_clause_1047 (k n : Nat) (p : (Nat -> Bool)) (B : Set) (nil : B) (op : (B -> __1 : B) -> B) (f : (Nat -> B)) (nleqk : n <= k) (j : Nat) (nlejq : n <= j) (Hind : (i : Nat) -> (__1 : Leq n i) -> (__1 : Lt i j) -> Eq (p i) contradiction) -> (bigop n (λ i => p i) B nil op (λ i => f i)) -> (bigop j (λ i => p i) B nil op (λ i => f i))) (Hfalse : (i : Nat) -> (__1 : Leq n i) -> (__1 : Lt i (j + 1)) -> Eq (p i) contradiction) -> (x2571 x2572 : Nat) -> (x2571 = x2572 (x2571 \\div x2572) + mod (x2571 , x2572)) :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBijn_fg. Let $f$ and $g$ be functions from natural numbers to natural numbers. Let $n \\in N$. Then for all elements $__$ of $bijn$ of $f$ and $n$, for all elements $__1$ of $bijn$ of $g$ and $n$, $bijn$ holds for the function that maps $p$ to $f$ applied to $g$ applied to $p$ and $n$.\nassistant\n", "label": "postulate bijn_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : bijn g n) -> bijn (\\ p : Nat -> f (g p)) n", "predict": "postulate bijn_fg : (f : (x : N) -> N) -> (g : (x : N) -> N) -> (n : N) -> (__ : bijn f n) -> (__1 : bijn g n) -> bijn (\\ p : N -> f (g p)) n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLt_exp_to_lt. Soit $a , n , m \\in N$. Supposons que $0 < a$. Supposons que $a ^ n < a ^ m$. Alors $n < m$.\nassistant\n", "label": "Axiom lt_exp_to_lt : forall a : nat, forall n : nat, forall m : nat, forall x__ : (0 < a), forall __1 : (pow a n < pow a m), n < m .", "predict": "Axiom lt_exp_to_lt : forall a : N, forall n : N, forall m : N, 0 < a -> a ^ n < a ^ m -> n < m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nACop_inv_rect_CProp1. För alla mängder $x1$, för alla element $x2$ av $x1$, för alla element $Hterm$ av $ACop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1620$ av $ACop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från element $aop$ av $Aop$ av $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $x1$ och element $b$ av $x1$ till element av $Eq$ av $op (x1 , x2 , aop , a , b)$ och $op (x1 , x2 , aop , b , a)$ och element $_z1621$ av $Eq$ av $Hterm$ och $mk_ACop (x1 , x2 , aop , _comm)$ till element av $P$ av $mk_ACop (x1 , x2 , aop , _comm)$, håller $P$ för $Hterm$.\nassistant\n", "label": "ACop_inv_rect_CProp1 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1620 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .", "predict": "ACop_inv_rect_CProp1 : x1 : Set -> x2 : Set -> Hterm : ACop x1 x2 -> P : (_z1620 : ACop x1 x2 -> Set) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLstar_Conf3. För alla mängder $A$ och $B$, för alla element $succ$ av $relation2$ av $A$ och $B$, för alla element $R$ av $relation$ av $A$, för alla element $__$ av $Conf3$ av $A$ och $B$ och $succ$ och $R$, för alla naturliga tal $l$, håller $Conf3$ för $A$ och $B$ och $succ$ och $lstar$ applicerat på $A$ och $R$ och $l$.\nassistant\n", "label": "Axiom lstar_Conf3 : forall A : Set, forall B : Set, forall succ : relation2 A B, forall R : relation A, forall x__ : Conf3 A B succ R, forall l : nat, Conf3 A B succ (lstar A R l) .", "predict": "Axiom lstar_Conf3 : forall A : Set, forall B : Set, forall succ : relation2 A B, forall R : relation A, forall __ : Conf3 A B succ R, forall l : nat, Conf3 A B succ (lstar A R l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nF2_ind_aux. Let $A1$ and $A2$ be sets. Let $f$ be a function from elements of $A1$ and elements $__1$ of $A2$ to natural numbers. Let $P$ be an element of $relation2$ of $A1$ and $A2$. Let $__$ be a function from natural numbers $n$ and functions from elements $a1$ of $A1$ and elements $a2$ of $A2$ and elements of $Lt$ of $f$ applied to $a1$ and $a2$ and $n$ to elements of $P$ of $a1$ and $a2$ and elements $a1$ of $A1$ and elements $a2$ of $A2$ and elements $__1$ of $Eq$ of $f$ applied to $a1$ and $a2$ and $n$ to elements of $P$ of $a1$ and $a2$. Let $n \\in N$. Let $a1$ be an element of $A1$. Then for all elements $a2$ of $A2$, if $f$ applied to $a1$ and $a2$ is equal to $n$, then $P$ holds for $a1$ and $a2$.\nassistant\n", "label": "Axiom f2_ind_aux : forall A1 : Set, forall A2 : Set, forall f : ((x__ : A1) -> (__1 : A2) -> nat), forall P : relation2 A1 A2, forall x__ : ((n : nat) -> (x__ : (a1 : A1) -> (a2 : A2) -> (x__ : f a1 a2 < n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> (__1 : f a1 a2 = n) -> P a1 a2), forall n : nat, forall a1 : A1, forall a2 : A2, forall __1 : (f a1 a2 = n), P a1 a2 .", "predict": "Axiom f2_ind_aux : forall A1 : set, forall A2 : set, forall f : ((__1 : A2) -> nat), forall P : relation2 A1 A2, forall __ : ((n : Nat) -> (a1 : A1) -> (a2 : A2) -> (Lt : f a1 a2 n) -> P a1 a2) -> (a1 : A1) -> (a2 : A2) -> (__1 : Eq (f a1 a2) n) -> P a1 a2), forall n : Nat, forall a1 : A1, forall a2 : A2, if f a1 a2 = n then P a1 a2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp3_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_879$ of $Aop$ of $A$ and $_nil$ to propositions. Let $_H_mk_Aop$ be a function from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil , a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a , _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a , op (b , c))$ and $op (op (a , b), c)$ to elements of $Q_$ of $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$. Let $x_879$ be an element of $Aop$ of $A$ and $_nil$. Then $Q_$ holds for $x_879$.\nassistant\n", "label": "Axiom Aop_rect_CProp3_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_879 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_879 : Aop A _nil, Q_ x_879 .", "predict": "Axiom Aop_rect_CProp3_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_879 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (a : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op (_nil , a) a)) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_879 : Aop A _nil, Q_ x_879 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1617. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Then for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.\nassistant\n", "label": "Axiom let_clause_1617 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (a * p - b * m = gcd p m), forall H0 : (a * p - b * m = 1), gcd p m = p * a - m * b .", "predict": "Axiom let_clause_1617 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : ((b : Nat) -> Eq (diff (product a p) (product b m)) (gcd p m) -> Eq (diff (product b m) (product a p)) (gcd p m)), forall b : Nat, if (diff (product a p) (product b m) = gcd p m) \\/ (diff (product b m) (product a p) = gcd p m) then if (diff (product a p) (product b m) = gcd p m) then if (diff (product a p) (product b m) = 1) then gcd p m = (product p a) - (product m b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_ind_body. Let $_n \\in N$. Let $Q_$ be a function from natural numbers $x_417$ and elements $_x_418$ of $Leq$ of $_n$ and $x_417$ to propositions. Let $_H_le_n$ be an element of $Q_$ of $_n$ and $le_n$ applied to $_n$. Let $_H_le_S$ be a function from natural numbers $m$ and elements $x_419$ of $Leq$ of $_n$ and $m$ and elements $_x_421$ of $Q_$ of $m$ and $x_419$ to elements of $Q_$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $x_419$. Let $x_417$ be a natural number. Then if $_n$ is less than or equal to $x_417$, then $Q_$ holds for $x_417$ and $x_418$.\nassistant\n", "label": "postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418", "predict": "postulate le_ind_body : (_n : N) -> (Q_ : (x_417 : N) -> (_x_418 : Leq _n x_417) -> P) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : N) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (m + 1) (le_S _n m x_419)) -> (x_417 : N) -> (_n : N) -> (_le_n : x_417) -> Q_ x_417 x_418"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_inv_plus_l. Låt $x , y , z \\in N$. Anta att $x + y \\leq z$. Då $x \\leq z - y$ och $y \\leq z$.\nassistant\n", "label": "le_inv_plus_l : x : Nat -> y : Nat -> z : Nat -> __ : Leq (plus x y) z -> and (Leq x (minus z y)) (Leq y z) .", "predict": "le_inv_plus_l : x : N -> y : N -> z : N -> x + y <= z -> x <= z - y -> y <= z ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPad_bigop. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Then for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $n \\leq k$, then $bigop$ applied to $k$ and the function that maps $i$ to $match_bool$ applied to $Set$ and the function that maps $_0$ to $bool$ and absurdity and $p$ applied to $i$ and $leb$ applied to $n$ and $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "axiom pad_bigop (k n : Nat) (p : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : (x__ : B) -> (__1 : B) -> B) (f : (x__ : Nat) -> B) (x__ : n ≤ k) : bigop n (λ i => p i) B nil op (λ i => f i) = bigop k (λ i => match_bool Set (λ _0 => bool) false (p i) (leb n i)) B nil op (λ i => f i)", "predict": "axiom pad_bigop (k n : Nat) (p : Nat -> Bool) (B : Set) (nil : B) (op : (x : B) -> (__1 : B) -> B) (f : Nat -> B) (Hc : n <= k) : B = bigop k (λ i => match_bool Set (λ _0 => bool) absurdity (p i) (leb n i)) B nil op (λ i => f i)) = bigop n (λ i => p i) B nil op (λ i => f i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_mop. Låt $n$ vara ett naturligt tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $R$ vara ett element av $Dop$ av $B$ och $nil$. Låt $f$ vara en funktion från naturliga tal till element av $B$. Då för alla element $a$ och $_x_969$ och $_x_970$ av $B$, $B$.\nassistant\n", "label": "let_mop : n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> R : Dop B nil -> f : (__ : Nat -> B) -> a : B -> _x_969 : B -> _x_970 : B -> B .", "predict": "let_mop : n : Nat -> p : (Nat -> Bool) -> B : Set -> nil : B -> R : Dop B nil -> f : (Nat -> B) -> a : B -> _x_969 : B -> _x_970 : B -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPlus_le_0. Soit $x , y \\in N$. Supposons que $x + y \\leq 0$. Alors $x = 0$ et $y = 0$.\nassistant\n", "label": "Axiom plus_le_0 : forall x : nat, forall y : nat, forall x__ : Leq (x + y) 0, x = 0 /\\ y = 0 .", "predict": "Axiom plus_le_0 : forall x : N, forall y : N, forall Hc : x + y <= 0, x = 0 -> y = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_ord_rem. Låt $p$ och $n$ vara naturliga tal. Då om $1 < p$ och $0 < n$, så är $ord_rem (n , p)$ delbart med $n$.\nassistant\n", "label": "postulate divides_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> divisible (ord_rem n p) n", "predict": "postulate divides_ord_rem : (p : Nat) -> (n : Nat) -> (1 < p) -> (0 < n) -> ord_rem (n , p) `div` n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nK1. For all natural numbers $n$ and $p$, if $18$ is less than or equal to $n$, then if $p$ is less than or equal to $n$, then if the quotient of the product of $2$ and $n$ and $3$ is less than $p$, then $k$ applied to the product of $2$ and $n$ and $p$ is equal to $0$.\nassistant\n", "label": "Axiom k1 : forall n : nat, forall p : nat, forall x__ : Leq 18 n, forall __1 : Leq p n, forall __2 : (2 * n / 3 < p), k (2 * n) p = 0 .", "predict": "Axiom k1 : forall n : nat, forall p : nat, if 18 <= n then if p <= n then if (2*n) / 3 < p then k (2*n) p = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (b : Nat) (__ : (i0 : Nat) -> (leq : Leq i0 n) -> Nat) (injf : injn f n) : a = b -> f (f a) = j -> f b = j -> __ (f a) = i -> __ (f b) = j -> f a = j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_16171. Låt $p , m , n \\in N$. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om $b m - a p = 1$, så är $m b - p a$ lika med det största gemensama delaret av $p$ och $m$.\nassistant\n", "label": "axiom let_clause_16171 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : b * m - a * p = gcd p m) (H0 : b * m - a * p = 1) : gcd p m = m * b - p * a", "predict": "axiom let_clause_16171 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : ex Nat (λ b => Eq (product a p) (product b m) (gcd p m))) (b : Nat) : Eq (gcd p m) (if b m - a p = 1 then m b - p a else b m - a p)) : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nP_ord_exp1. Soient $p$ et $n$ et $q$ et $r$ des nombres naturels. Supposons que $0 < p$ et $p$ n'est pas divisible par $r$. Supposons que $n = p ^ q r$. Alors $p_ord (n , p)= mk_Prod (Nat , Nat , q , r)$.\nassistant\n", "label": "p_ord_exp1 : p : Nat -> n : Nat -> q : Nat -> r : Nat -> __ : Lt 0 p -> __1 : not (divisible p r) -> __2 : Eq n (times (pow p q) r) -> Eq (p_ord n p) (mk_Prod Nat Nat q r) .", "predict": "p_ord_exp1 : p : Nat -> n : Nat -> q : Nat -> r : Nat -> 0 < p -> p != r -> n = p ^ q r -> p_ord (n , p) = mk_Prod (Nat , Nat , q , r) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAxiom. Låt $_n \\in N$. Då är kvadratroten av $_n$ ett naturligt tal.\nassistant\n", "label": "postulate sqrt : (_n : Nat) -> Nat", "predict": "postulate sqrt : (_n : N) -> N"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMax'_body. Let $__ \\in N$. Let $__1$ be a function from natural numbers $__1$ to booleans. Let $__2$ be a natural number. Then $Nat$.\nassistant\n", "label": "Axiom max'_body : forall x__ : nat, forall __1 : ((__1 : nat) -> bool), forall __2 : nat, nat .", "predict": "Axiom max'_body : forall __ : N, forall __1 : ((__1 : N) -> Bool), forall __2 : Nat, Nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_rect_Type3. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_949$ of $Dop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod (a , _nil)$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod (a , aop__o__op (A , _nil , sum , b , c))$ and $aop__o__op (A , _nil , sum , prod (a , b), prod (a , c))$ to elements of $Q_$ of $mk_Dop (A , _nil , sum , prod , _null , _distr)$, for all elements $x_949$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_949$.\nassistant\n", "label": "postulate Dop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_949 : Dop A _nil) -> Type3) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_949 : Dop A _nil) -> Q_ x_949", "predict": "postulate Dop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_949 : Dop A _nil) -> Type3) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_949 : Dop A _nil) -> Q_ x_949"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nSigma_const. Låt $n \\in N$. Då är $n$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $true$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $1$.\nassistant\n", "label": "Axiom sigma_const : forall n : nat, bigop n (fun i => true) nat 0 plus (fun i => 1) = n .", "predict": "Axiom sigma_const : forall n : N, nat n = bigop n (fun i => true) Nat 0 plus (fun i => 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLprim. Let $__ , __1 \\in N$. Let $__2$ be a list of natural numbers. Then $list$ holds for $Nat$.\nassistant\n", "label": "axiom lprim (x__ __1 : Nat) (__2 : list Nat) : list Nat", "predict": "axiom lprim (__ __1 : N) (__2 : List N) : List Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Anta att $d m - c n = 1$. Då $m d - n c = 1$.\nassistant\n", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (c n - d m) 1)) -> (d : Nat) -> (m d - n c) -> 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPrime_to_lt_O. Pour tous les nombres naturels $p$, si $p$ est premier, alors $0 < p$.\nassistant\n", "label": "postulate prime_to_lt_O : (p : Nat) -> (_ : prime p) -> Lt 0 p", "predict": "postulate prime_to_lt_O : (p : Nat) -> p > 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBigop_commute. Låt $n$ och $m$ vara naturliga tal. Låt $p11$ vara en funktion från naturliga tal till sanningsvärden. Låt $p12$ vara en funktion från naturliga tal och naturliga tal $__1$ till sanningsvärden. Låt $p21$ vara en funktion från naturliga tal till sanningsvärden. Låt $p22$ vara en funktion från naturliga tal och naturliga tal $__1$ till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Då för alla element $op$ av $ACop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal och naturliga tal $__1$ till element av $B$, om $0 < n$, så om $0 < m$, så för alla funktioner $__2$ från naturliga tal $i$ och naturliga tal $j$ och element $__2$ av $Lt$ av $i$ och $n$ och element $__3$ av $Lt$ av $j$ och $m$ till element av $Eq$ av $andb (p11 (i), p12 (i , j))$ och $andb (p21 (j), p22 (i , j))$, är $bigop$ applicerat på $m$ och funktionen som avbildar $j$ som $p21$ applicerat på $j$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $j$ som $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p22$ applicerat på $i$ och $j$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $j$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p11$ applicerat på $i$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $bigop$ applicerat på $m$ och funktionen som avbildar $j$ som $p12$ applicerat på $i$ och $j$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $j$ som $f$ applic", "label": "postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (_ : Nat) -> bool) -> (p12 : (_ : Nat) -> (__1 : Nat) -> bool) -> (p21 : (_ : Nat) -> bool) -> (p22 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (\\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\\ i : Nat -> bigop m (\\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\\ j : Nat -> f i j))) (bigop m (\\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\\ j : Nat -> bigop n (\\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\\ i : Nat -> f i j)))", "predict": "postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (i : Nat) -> Bool) -> (p12 : (i : Nat) -> (__1 : Nat) -> Bool) -> (p21 : (j : Nat) -> Bool) -> (p22 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (i : Nat) -> (__1 : Nat) -> B) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 (i), p12 (i , j))) (andb (p21 (j), p22 (i , j)))) -> bigop m (\\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\\ j : Nat -> bigop n (\\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\\ i : Nat -> f i j))) == bigop n (\\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\\ i : Nat -> bigop m (\\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\\ j : Nat -> f i j)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1617. Låt $p , m , n \\in N$. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$. Anta att $a p - b m = 1$. Då är $p a - m b$ lika med det största gemensama delaret av $p$ och $m$.\nassistant\n", "label": "Axiom let_clause_1617 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (a * p - b * m = gcd p m), forall H0 : (a * p - b * m = 1), gcd p m = p * a - m * b .", "predict": "Axiom let_clause_1617 : forall p : N, forall m : N, forall n : N, forall c : N, forall a : Nat, forall _clearme0 : ex Nat (fun b => Eq (prod a p) (prod b m) (gcd p m)) (Eq (prod b m) (prod a p) (gcd p m)), forall b : Nat, ((gcd p m) = (a p - b m) -> (gcd p m) = (b m - a p) -> (gcd p m) = (a p - b m) -> (a p - b m) = 1) -> (p a - m b) = (gcd p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_inv_rect_Type3. Let $x1 , x2 , x3 , x4 \\in N$. Let $Hterm$ be an element of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$. Let $P$ be a function from elements $_z1446$ of $div_mod_spec$ of $x1$ and $x2$ and $x3$ and $x4$ to elements of $Type3$. Let $_H1$ be a function from elements $x_823$ of $Lt$ of $x4$ and $x2$ and elements $x_822$ of $Eq$ of $x1$ and the sum of the product of $x3$ and $x2$ and $x4$ and elements $_z1447$ of $Eq$ of $Hterm$ and $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$ to elements of $P$ of $div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$. Then $P$ holds for $Hterm$.\nassistant\n", "label": "div_mod_spec_inv_rect_Type3 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1446 : div_mod_spec x1 x2 x3 x4 -> Type3) -> _H1 : (x_823 : Lt x4 x2 -> x_822 : Eq x1 (plus (times x3 x2) x4) -> _z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm .", "predict": "div_mod_spec_inv_rect_Type3 : x1 : N -> x2 : N -> x3 : N -> x4 : N -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1446 : div_mod_spec x1 x2 x3 x4 -> Type3) -> _H1 : (x_823 : Lt x4 x2 -> x_822 : Eq x1 (product x3 x2) x4 -> _z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Then if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "Axiom let_clause_16002 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c .", "predict": "Axiom let_clause_16002 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ((d : Nat) -> Eq (c n - d m) 1) -> (d : Nat) -> Eq (d m - c n) 1), forall d : Nat, ((c n - d m) = 1 -> (d m - c n) = 1 -> (d m - c n) = 1 -> m d - n c = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Alors si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (n : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (leq : Leq i0 n) -> (Leq (f i0) n)) -> (injf : injn f n) -> (a == b) -> (f a == i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_max_spec. Let $_n$ be a natural number. Let $_f$ be a function from natural numbers to booleans. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $max_spec$ of $_n$ and $_f$ and $__$ to elements of $return_sort$. Let $case_found_max_spec$ be a function from natural numbers $m$ and elements of $Lt$ of $m$ and $_n$ and elements $__1$ of $Eq$ of $_f (m)$ and $true$ and functions $__2$ from natural numbers $i$ and elements $__2$ of $Lt$ of $m$ and $i$ and elements $__3$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f (i)$ and absurdity to elements of $return_type$ of $m$ and $found_max_spec (_n , _f , m , __ , __1 , __2)$. Let $case_not_found_max_spec$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f (i)$ and absurdity to elements of $return_type$ of $0$ and $not_found_max_spec (_n , _f , __)$. Then for all natural numbers $__$, for all elements $z$ of $max_spec$ of $_n$ and $_f$ and $__$, $return_type$ holds for $__$ and $z$.\nassistant\n", "label": "match_max_spec : _n : Nat -> _f : (__ : Nat -> bool) -> return_sort : Sort -> return_type : (__ : Nat -> z : max_spec _n _f __ -> return_sort) -> case_found_max_spec : (m : Nat -> __ : Lt m _n -> __1 : Eq (_f m) true -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i _n -> Eq (_f i) false) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> case_not_found_max_spec : (__ : (i : Nat -> __ : Lt i _n -> Eq (_f i) false) -> return_type 0 (not_found_max_spec _n _f __)) -> __ : Nat -> z : max_spec _n _f __ -> return_type __ z .", "predict": "match_max_spec : _n : Nat -> _f : (Nat -> Bool) -> return_sort : Sort -> return_type : (Nat -> z : max_spec _n _f -> __ : (m : Nat -> Lt m _n -> __1 : Eq _f m true -> __2 : (i : Nat -> Lt m i -> __3 : Lt i _n -> Eq _f i absurdity) -> return_sort) -> m : Nat -> found_max_spec (_n _f m __ __1 __2) -> __ : (m : Nat -> Lt m _n -> __1 : Eq _f m true -> __2 : (i : Nat -> Lt m i -> __3 : Lt i _n -> Eq _f i absurdity) -> return_sort) -> __ : (i : Nat -> Lt i _n -> Eq _f i absurdity) -> return_sort) -> __ : Nat -> z : max_spec _n _f __ -> return_type __ z ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1562. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Then if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then $n c - m d = 1$.\nassistant\n", "label": "Axiom let_clause_1562 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), n * c - m * d = 1 .", "predict": "Axiom let_clause_1562 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ((d : Nat) -> Eq (c n - d m) 1 \\/ Eq (d m - c n) 1), forall d : Nat, if c n - d m = 1 \\/ d m - c n = 1 then n c - m d = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1572. Soient $m$ et $n$ des nombres naturels. Alors si $0 < n$, alors si $0$ est égal au diviseur commun plus grand de $m$ et de $n$, alors si $m = 0$, alors si $n = 0$, alors $m = 0$.\nassistant\n", "label": "axiom let_clause_1572 (m n : Nat) (posn : 0 < n) (H : gcd m n = 0) (auto : m = 0) (auto' : n = 0) : m = 0", "predict": "axiom let_clause_1572 (m n : Nat) : (0 < n) -> (0 = gcd m n) -> (m = 0) -> (n = 0) -> m = 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_15621. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $c n - d m = 1$, then $n c - m d = 1$.\nassistant\n", "label": "axiom let_clause_15621 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : n * c - m * d = 1", "predict": "axiom let_clause_15621 (m n a b : Nat) (_clearme : Nat (λ d => Eq (c n - d m) 1 ∨ Eq (d m - c n) 1)) (d : Nat) : Nat (λ c => Eq (n c - m d) 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNot_not_bertrand_to_bertrand1. Soit $n$ un nombre naturel. Alors s'il n'est pas le cas que $not_bertrand$ tienne pour $n$, alors pour tous les nombres naturels $x$, si $n$ est inférieur ou ágal à $x$, alors si $x$ est inférieur ou ágal au produit de $2$ et de $n$, alors pour toutes les fonctions $__3$ des nombres naturels $p$ et des éléments $__3$ de $Lt$ de $x$ et de $p$ et des éléments $__4$ de $Leq$ de $p$ et du produit de $2$ et de $n$ à des éléments de $not$ de $prime$ appliqué à $p$, $ex$ tient pour $Nat$ et la fonction qui envoie $p$ à la conjonction de la conjonction de $Lt$ appliqué à $n$ et $p$ et de $Leq$ appliqué à $p$ et $x$ et de $prime$ appliqué à $p$.\nassistant\n", "label": "axiom not_not_bertrand_to_bertrand1 (n : Nat) (x__ : ¬ not_bertrand n) (x : Nat) (__1 : n ≤ x) (__2 : x ≤ 2 * n) (__3 : (p : Nat) -> (__3 : x < p) -> (__4 : p ≤ 2 * n) -> ¬ prime p) : ex Nat (λ p => n < p ∧ p ≤ x ∧ prime p)", "predict": "axiom not_not_bertrand_to_bertrand1 (n : Nat) (x : Nat) (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (2 * n)) -> not (prime p)) : Nat (ex : Nat) (λ p => and (and (Lt n p) (Leq p x)) (prime p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_exp1. Låt $n$ och $m$ och $a$ vara naturliga tal. Anta att $0 < a$ och $n \\leq m$. Då $n ^ a \\leq m ^ a$.\nassistant\n", "label": "le_exp1 : n : Nat -> m : Nat -> a : Nat -> __ : Lt 0 a -> __1 : Leq n m -> Leq (pow n a) (pow m a) .", "predict": "le_exp1 : n : Nat -> m : Nat -> a : Nat -> 0 < a -> n <= m -> n ^ a <= m ^ a ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPermut_to_bijn. Låt $n \\in N$. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $__$ vara ett element av $permut$ av $f$ och $n$. Då håller $bijn$ för $f$ och $n$.\nassistant\n", "label": "postulate permut_to_bijn : (n : Nat) -> (f : (_ : Nat) -> Nat) -> (_ : permut f n) -> bijn f n", "predict": "postulate permut_to_bijn : (n : N) -> (f : nat -> nat) -> (__ : permut f n) -> bijn f n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1033. Let $n$ be a natural number. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1$ be a natural number. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$. Assume that $p2$ applied to $n1$ is equal to $true$. Then if $p1$ applied to $n1$ is equal to $true$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "let_clause_1033 : n : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> n1 : Nat -> Hind : (__ : (i : Nat -> __ : Lt i n1 -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> __1 : (i : Nat -> __1 : Lt i n1 -> __2 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (i : Nat => p1 i) Nat 0 plus (i : Nat => g1 i)) (bigop n1 (i : Nat => p2 i) Nat 0 plus (i : Nat => g2 i))) -> H1 : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> H2 : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Hp2 : Eq (p2 n1) true -> Hp1 : Eq (p1 n1) true -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_1033 : n : Nat -> p1 : (i : Nat -> Bool) -> p2 : (i : Nat -> Bool) -> g1 : (i : Nat -> Nat) -> g2 : (i : Nat -> Nat) -> n1 : Nat -> Hind : (i : Nat -> Lt : i -> n1 -> __1 : Eq(p1 i true) -> __1 : (i : Nat -> __1 : Lt i n1 -> __2 : Eq(p1 i true) -> Leq(g1 i (g2 i)) -> Leq(bigop n1 (i : Nat => p1 i) Nat 0 plus (i : Nat => g1 i)) (bigop n1 (i : Nat => p2 i) Nat 0 plus (i : Nat => g2 i))) -> H1 : (i : Nat -> Lt : i -> (n1 + 1) -> __1 : Eq(p1 i true) -> Eq(p2 i true)) -> H2 : (i : Nat -> Lt : i -> (n1 + 1) -> __1 : Eq(p1 i true) -> Leq(g1 i (g2 i))) -> p2 n1 = true -> p1 n1 = true -> x2515 : Nat -> x2516 : Nat -> x2515 = (x2516 * (x2515 / x2516)) + mod(x2515, x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTo_min. Låt $i$ och $n$ och $m$ vara naturliga tal. Då om $i \\leq n$ och $i \\leq m$, så $i \\leq min (n , m)$.\nassistant\n", "label": "to_min : i : Nat -> n : Nat -> m : Nat -> __ : Leq i n -> __1 : Leq i m -> Leq i (min n m) .", "predict": "to_min : i : nat -> n : nat -> m : nat -> i <= n -> i <= m -> i <= min (n , m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15691. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $c n - d m = 1$, så $n c - m d = 1$.\nassistant\n", "label": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .", "predict": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> c n - d m = 1 -> n c - m d = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOp_body. For all sets $A$, for all elements $nil$ of $A$, for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.\nassistant\n", "label": "postulate op_body : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A", "predict": "postulate op_body : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nEq_fact_pi_p. Låt $n \\in N$. Då är fakulteten av $n$ lika med $bigop$ applicerat på skillnaden mellan summan av $n$ och $1$ och $1$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $true$ applicerat på summan av $i$ och $1$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $i0$ applicerat på summan av $i$ och $1$.\nassistant\n", "label": "postulate eq_fact_pi_p : (n : Nat) -> Eq (factorial n) (bigop (minus (plus n 1) 1) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i 1)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> i0) (plus i 1)))", "predict": "postulate eq_fact_pi_p : (n : N) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nS_mod. Låt $_n , _m \\in N$. Då $Nat$.\nassistant\n", "label": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat", "predict": "postulate S_mod : (_n : N) -> (_m : N) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_min_r. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $b$ vara naturliga tal. Då är $min$ applicerat på $n$ och $b$ och $f$ mindre än eller lika med summan av $n$ och $b$.\nassistant\n", "label": "le_min_r : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> Leq (min n b f) (plus n b) .", "predict": "le_min_r : f : nat -> sann -> n : nat -> b : nat -> min(n, b, f) <= n + b ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDop_rect_Type0. För alla mängder $A$, för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_955$ av $Dop$ av $A$ och $_nil$ till mängder, för alla funktioner $_H_mk_Dop$ från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $Q_$ av $mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_955$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_955$.\nassistant\n", "label": "axiom Dop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955", "predict": "axiom Dop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : Aop A _nil) -> (prod : (x : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15691. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $c n - d m = 1$, then $n c - m d = 1$.\nassistant\n", "label": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .", "predict": "let_clause_15691 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> c n - d m = 1 -> n c - m d = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNth_prime. Soit $__ \\in N$. Alors $Nat$.\nassistant\n", "label": "axiom nth_prime (x__ : Nat) : Nat", "predict": "axiom nth_prime (__ : N) : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTranspose_i_j_j. Pour tous les nombres naturels $i$ et $j$, $transpose (i , j , j)= i$.\nassistant\n", "label": "axiom transpose_i_j_j (i j : Nat) : transpose i j j = i", "predict": "axiom transpose_i_j_j (i j : Nat) : Nat := i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_plus_a. För alla naturliga tal $a$ och $n$ och $m$, om $n \\leq m$, så $n \\leq a + m$.\nassistant\n", "label": "Axiom le_plus_a : forall a : nat, forall n : nat, forall m : nat, forall x__ : Leq n m, Leq n (a + m) .", "predict": "Axiom le_plus_a : forall a : nat, forall n : nat, forall m : nat, n <= m -> n <= a + m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLstar_dx. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $l \\in N$. Soient $b1$ et $b$ des éléments de $B$. Soit $__$ un élément de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b$. Soit $b2$ un élément de $B$. Soit $__1$ un élément de $R$ de $b$ et de $b2$. Alors $lstar$ tient pour $B$ et $R$ et la somme de $l$ et de $1$ et $b1$ et $b2$.\nassistant\n", "label": "axiom lstar_dx (B : Set) (R : relation B) (l : Nat) (b1 b : B) (x__ : lstar B R l b1 b) (b2 : B) (__1 : R b b2) : lstar B R (l + 1) b1 b2", "predict": "axiom lstar_dx (B : Set) (R : Set) (l : Nat) (b1 b : Set) (__ : lstar B R l b1 b) (b2 : Set) (__1 : R b b2) : Set (B R (l + 1) b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_17041. Soit $m \\in N$. Supposons que $0 < m$. Alors pour tous les nombres naturels $a$ et $x1029$, $x1029 = aop__o__op (Nat , 0 , plusAC , x1029 , 0)$.\nassistant\n", "label": "let_clause_17041 : m : Nat -> posm : Lt 0 m -> a : Nat -> x1029 : Nat -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0) .", "predict": "let_clause_17041 : m : N -> 0 < m -> a : Nat -> x1029 : Nat -> x1029 = aop__o__op (Nat , 0 , plusAC , x1029 , 0) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLog_times_l. Låt $p , n , m \\in N$. Anta att $0 < n$ och $0 < m$. Då om $1 < p$, så $\\log_ p {n}+ \\log_ p {m}\\leq \\log_ p {(n m)}$.\nassistant\n", "label": "axiom log_times_l (p n m : Nat) (x__ : 0 < n) (__1 : 0 < m) (__2 : 1 < p) : log p n + log p m ≤ log p (n * m)", "predict": "axiom log_times_l (p n m : N) (Hc : 0 < n) (Hd : 0 < m) (Hp : 1 < p) : log_ p {n} + log_ p {m} ≤ log_ p {(n m)}"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTo_min. Låt $i$ och $n$ och $m$ vara naturliga tal. Anta att $i \\leq n$ och $i \\leq m$. Då $i \\leq min (n , m)$.\nassistant\n", "label": "to_min : i : Nat -> n : Nat -> m : Nat -> __ : Leq i n -> __1 : Leq i m -> Leq i (min n m) .", "predict": "to_min : i : nat -> n : nat -> m : nat -> i <= n -> i <= m -> i <= min (n , m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_to_dividesb_true1. Soient $n$ et $m$ des nombres naturels. Alors si $0 < m$ et $n$ est divisible par $m$, alors $dividesb (n , m)= true$.\nassistant\n", "label": "Axiom divides_to_dividesb_true1 : forall n : nat, forall m : nat, forall x__ : (0 < m), forall __1 : divisible n m, dividesb n m = true .", "predict": "Axiom divides_to_dividesb_true1 : forall n : nat, forall m : nat, 0 < m -> n = m -> dividesb (n , m)= true ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPad_bigop_nil. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $Aop$ of $B$ and $nil$. Let $f$ be a function from natural numbers to elements of $B$. Assume that $n \\leq k$. Let $__1$ be a function from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $or$ of $Eq$ applied to $p$ applied to $i$ and absurdity and $Eq (f (i), nil)$. Then $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (i : Nat) -> Bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (i : Nat) -> B) -> (n <= k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) absurdity) (Eq (f i) nil)) -> bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) == bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1075. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Then for all elements $bijf$ of $bijn$ of $f$ and $n + 1$, if $f (n + 1)= n + 1$, then for all natural numbers $i$, if $i \\leq n$, then for all natural numbers $a$, if $a \\leq n + 1$ and $f (a)= i$, then if $a \\leq n + 1$, then if $f (a)= i$, then if $a = n + 1$, then $i = a$.\nassistant\n", "label": "axiom let_clause_1075 (f : (x__ : Nat) -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (fS : f (n + 1) = n + 1) (i : Nat) (lein : i ≤ n) (a : Nat) (_clearme : a ≤ n + 1 ∧ f a = i) (lean : a ≤ n + 1) (fa : f a = i) (Hc : a = n + 1) : i = a", "predict": "axiom let_clause_1075 (f : (n : N) -> N) (n : N) (bijf : bijn f (n + 1)) (i : N) (a : N) : ((a : N) <= n + 1) -> (f a) = i) -> (a : N) <= n + 1) -> (f a) = i) -> (a : N) = n + 1) -> i = a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_exp_to_divides. For all natural numbers $p$ and $n$ and $m$, if $p$ is prime, then if $p$ is divisible by $n ^ m$, then $p$ is divisible by $n$.\nassistant\n", "label": "Axiom divides_exp_to_divides : forall p : nat, forall n : nat, forall m : nat, forall x__ : prime p, forall __1 : divisible p (pow n m), divisible p n .", "predict": "Axiom divides_exp_to_divides : forall p : nat, forall n : nat, forall m : nat, p : prime -> p : n ^ m -> p : n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nBigop_a. Soit $a , b \\in N$. Soit $B$ un ensemble. Alors pour tous les éléments $nil$ de $B$, pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $a$ est inférieur ou ágal à $b$, alors $bigop$ appliqué à la différence de la somme de $b$ et de $1$ et de $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $a$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$ est égal à $op$ appliqué à $B$ et $nil$ et $op$ et $bigop$ appliqué à la différence de $b$ et de $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $a$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à le successeur de $i0$ appliqué à la somme de $i$ et de $a$ et $f$ appliqué à $a$.\nassistant\n", "label": "axiom bigop_a (a b : Nat) (B : Set) (nil : B) (op : Aop B nil) (f : (x__ : Nat) -> B) (x__ : a ≤ b) : bigop (b + 1 - a) (λ i => (λ i0 => true) (i + a)) B nil (op B nil op) (λ i => (λ i0 => f i0) (i + a)) = op B nil op (bigop (b - a) (λ i => (λ i0 => true) (i + a)) B nil (op B nil op) (λ i => (λ i0 => f (succ i0)) (i + a))) (f a)", "predict": "axiom bigop_a (a b : N) (B : Set) (nil : B) (op : Aop B nil) (f : (i : N) -> B) (Hc : a <= b) : B = bigop (b + 1 - a) (λ i => (λ i0 => true) (i + a)) B nil (op B nil op) (λ i => (λ i0 => f i0) (i + a))) = op B nil op (bigop (b - a) (λ i => (λ i0 => true) (i + a)) B nil (op B nil op) (λ i => (λ i0 => f (succ i0)) (i + a))) (f a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDiv_mod_spec_intro. Låt $n$ och $m$ och $q$ och $r$ vara naturliga tal. Då om $r < m$ och $n = q m + r$, så håller $div_mod_spec$ för $n$ och $m$ och $q$ och $r$.\nassistant\n", "label": "div_mod_spec_intro : n : Nat -> m : Nat -> q : Nat -> r : Nat -> __ : Lt r m -> __1 : Eq n (plus (times q m) r) -> div_mod_spec n m q r .", "predict": "div_mod_spec_intro : n : Nat -> m : Nat -> q : Nat -> r : Nat -> r < m -> n = q m + r -> div_mod_spec n m q r ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_to_le_to_lt. Låt $n$ och $m$ och $p$ vara naturliga tal. Då om $n$ är mindre än $m$, så om $m$ är mindre än eller lika med $p$, så är $n$ mindre än $p$.\nassistant\n", "label": "postulate lt_to_le_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt n m) -> (__1 : Leq m p) -> Lt n p", "predict": "postulate lt_to_le_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> n < m -> m < p -> n < p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1575. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0 < n$, then if $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $c n - d m = 1$, then for all natural numbers $x1029$, $x1029 = x1029 (n c - m d)$.\nassistant\n", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (n * c - m * d) 1)) -> (d : Nat) -> (c n - d m) -> (x1029 : Nat) -> (x1029 = x1029 (n c - m d))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_10471. Soient $n1$ et $n2$ des nombres naturels. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $ACop$ de $B$ et de $nil$. Soient $f1$ et $f2$ des fonctions des nombres naturels à des éléments de $B$. Soit $_clearme$ un élément de $iso$ de $B$ et de $mk_range (B , f1 , n1 , p1)$ et de $mk_range (B , f2 , n2 , p2)$. Soit $h$ une fonction des nombres naturels à des nombres naturels. Soit $_clearme0$ un élément de $ex$ de $prod$ appliqué à $Set$ et $Set$ et $Nat$ et la fonction qui envoie $__$ à $Nat$ et de la fonction qui envoie $k$ à la conjonction de la conjonction de $prod$ appliqué à $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Prop$ et $Prop$ et $Eq$ appliqué à $p1$ appliqué à $i$ et $true$ et la fonction qui envoie $__1$ à $Eq$ appliqué à $f1$ appliqué à $i$ et $f2$ appliqué à $h$ appliqué à $i$ et de $sub_hk$ appliqué à $h$ et $k$ et $B$ et $mk_range$ appliqué à $B$ et $f1$ et $n1$ et $p1$ et $mk_range$ appliqué à $B$ et $f2$ et $n2$ et $p2$ et de $sub_hk$ appliqué à $k$ et $h$ et $B$ et $mk_range$ appliqué à $B$ et $f2$ et $n2$ et $p2$ et $mk_range$ appliqué à $B$ et $f1$ et $n1$ et $p1$. Soit $k$ une fonction des nombres naturels à des nombres naturels. Supposons que $prod$ tient pour $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Prop$ et $Prop$ et $Eq$ appliqué à $p1$ appliqué à $i$ et $true$ et la fonction qui envoie $__1$ à $Eq$ appliqué à $", "label": "axiom let_clause_10471 (n1 n2 : Nat) (p1 p2 : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : ACop B nil) (f1 f2 : (x__ : Nat) -> B) (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (h : (x__ : Nat) -> Nat) (_clearme0 : ex (prod Set Set Nat (λ x__ => Nat)) (λ k => prod Set Prop Nat (λ i => prod Prop Prop (i < n1) (λ x__ => prod Prop Prop (p1 i = true) (λ __1 => f1 i = f2 (h i)))) ∧ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) ∧ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) (k : (x__ : Nat) -> Nat) (_clearme1 : prod Set Prop Nat (λ i => prod Prop Prop (i < n1) (λ x__ => prod Prop Prop (p1 i = true) (λ __1 => f1 i = f2 (h i)))) ∧ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) ∧ sub", "predict": "axiom let_clause_10471 (n1 n2 : Naturals) (p1 p2 : (i : Naturals) -> Bool) (B : Set) (nil : B) (op : ACop B nil) (f1 f2 : (i : Naturals) -> B) (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (h : (i : Naturals) -> Naturals) (_clearme0 : ex (prod Set Set Nat (λ __ => Nat)) (λ k => conj (conj (prod Set Prop Nat (λ i => prod Prop Prop (Lt i n1) (λ __ => prod Prop Prop (Eq (p1 i) true) (λ __1 => Eq (f1 i) (f2 (h i))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))))) (k : (i : Naturals) -> Naturals) : mk_range B f1 n1 p1) : mk_range B f2 n2 p2) (x1 x2 : B) : Bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_rect_CProp3_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_879$ de $Aop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (_nil , a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (a , _nil)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op (a , op (b , c))$ et de $op (op (a , b), c)$ à des éléments de $Q_$ de $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$, pour tous les éléments $x_879$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_879$.\nassistant\n", "label": "Axiom Aop_rect_CProp3_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_879 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_879 : Aop A _nil, Q_ x_879 .", "predict": "Axiom Aop_rect_CProp3_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_879 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_879 : Aop A _nil, Q_ x_879 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_sqrt_to_lt_times_l. Let $m , n \\in N$. Then if $n < \\sqrt{ m}$, then $n n < m$.\nassistant\n", "label": "lt_sqrt_to_lt_times_l : m : Nat -> n : Nat -> __ : Lt n (sqrt m) -> Lt (times n n) m .", "predict": "lt_sqrt_to_lt_times_l : m : N -> n : N -> n < sqrt(m) -> n n < m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1544. Let $p , q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b \\in N$. Then if $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ or $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, then if $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$, then $a mod (m , n)- n b = gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "let_clause_1544 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n)) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n)) .", "predict": "let_clause_1544 : p : N -> q : N -> Hind : (m : N -> n : N -> Lt : 0 -> n -> __1 : Leq n m -> __2 : Leq n q -> ex : Nat -> (a : N -> ex Nat (b : N => Eq (difference (product a n) (product b m)) (gcd_aux q m n) -> Eq (difference (product b m) (product a n)) (gcd_aux q m n))) -> m : N -> n : N -> 0 < n -> n <= m -> n <= q + 1 -> n != (m : N => _clearme : ex Nat (b : N => Eq (difference (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n)) -> Eq (difference (product b n) (product a (mod m n))) (gcd_aux q n (mod m n))) -> b : N -> a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> a mod (m , n) - n b = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_B1_theta. Låt $n$ vara ett naturligt tal. Anta att $18$ är mindre än eller lika med $n$. Låt $__1$ vara ett element av $not_bertrand$ av $n$. Då är $B1$ applicerat på produkten av $2$ och $n$ mindre än eller lika med $theta$ applicerat på kvoten av produkten av $2$ och $n$ och $3$.\nassistant\n", "label": "le_B1_theta : n : Nat -> __ : Leq (nn 1 (nd 8)) n -> __1 : not_bertrand n -> Leq (B1 (times (nd 2) n)) (theta (div (times (nd 2) n) (nd 3))) .", "predict": "le_B1_theta : n : nat -> __1 : not_bertrand n -> B1 (2 * n) <= theta (product (2 * n) / 3) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExp_sigma. For all natural numbers $n$ and $a$, for all functions $p$ from natural numbers to booleans, the exponentiation of $a$ and $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $a$.\nassistant\n", "label": "exp_sigma : n : Nat -> a : Nat -> p : (__ : Nat -> bool) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => a)) (pow a (bigop n (i : Nat => p i) Nat 0 plus (i : Nat => nd 1))) .", "predict": "exp_sigma : n : Nat -> a : Nat -> p : (i : Nat -> Bool) -> bigop n (i : Nat => p i) Nat 0 plus (i : Nat => 1) = bigop n (i : Nat => p i) Nat 1 times (i : Nat => a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_ind_body. Let $_n$ be a natural number. Let $Q_$ be a function from natural numbers $x_417$ and elements $_x_418$ of $Leq$ of $_n$ and $x_417$ to propositions. Let $_H_le_n$ be an element of $Q_$ of $_n$ and $le_n (_n)$. Let $_H_le_S$ be a function from natural numbers $m$ and elements $x_419$ of $Leq$ of $_n$ and $m$ and elements $_x_421$ of $Q_$ of $m$ and $x_419$ to elements of $Q_$ of $m + 1$ and $le_S (_n , m , x_419)$. Let $x_417 \\in N$. Assume that $_n \\leq x_417$. Then $Q_$ holds for $x_417$ and $x_418$.\nassistant\n", "label": "postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418", "predict": "postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (m + 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (_n : Nat) -> (_H_n_le_x_417 : _n <= x_417) -> Q_ x_417 x_418"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_rect_Type1_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_899$ of $ACop$ of $A$ and $_nil$ to elements of $Type1$. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A , _nil , aop , a , b)$ and $op (A , _nil , aop , b , a)$ to elements of $Q_$ of $mk_ACop (A , _nil , aop , _comm)$. Let $x_899$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_899$.\nassistant\n", "label": "Axiom ACop_rect_Type1_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_899 : ACop A _nil) -> Type1), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)), forall x_899 : ACop A _nil, Q_ x_899 .", "predict": "Axiom ACop_rect_Type1_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_899 : ACop A _nil) -> Type1), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)), forall x_899 : ACop A _nil, Q_ x_899 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nBertrand_down. Låt $n \\in N$. Då om $0$ är mindre än $n$, så om $n$ är mindre än eller lika med potensen av $2$ och $8$, så håller $bertrand$ för $n$.\nassistant\n", "label": "bertrand_down : n : Nat -> __ : Lt 0 n -> __1 : Leq n (pow (nd 2) (nd 8)) -> bertrand n .", "predict": "bertrand_down : n : N -> 0 < n -> n < 2^8 -> bertrand n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNot_eq_to_le_to_lt. För alla naturliga tal $n$ och $m$, om $n$ inte är lika med $m$, så om $n$ är mindre än eller lika med $m$, så är $n$ mindre än $m$.\nassistant\n", "label": "not_eq_to_le_to_lt : n : Nat -> m : Nat -> __ : not (Eq n m) -> __1 : Leq n m -> Lt n m .", "predict": "not_eq_to_le_to_lt : n : nat -> m : nat -> n != m -> n <= m -> n < m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1607. Låt $m , n , a , b \\in N$. Då om $0 < n$ och $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nassistant\n", "label": "let_clause_1607 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .", "predict": "let_clause_1607 : m : N -> n : N -> a : N -> b : N -> c : Nat -> _clearme : ex Nat (d : Eq (n - m) 1 -> Eq (m - n) 1) -> d : Nat -> c n - d m = 1 -> d m - c n = 1 -> d m - c n = 1 -> m d - n c = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDividesb. Soient $__$ et $__1$ des nombres naturels. Alors $bool$.\nassistant\n", "label": "dividesb : __ : Nat -> __1 : Nat -> bool .", "predict": "dividesb : __ : N -> __1 : N -> bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Supposons que $a$ est égal à $b$. Alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (n : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a : b) -> f a == j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTimes_times. Pour tous les nombres naturels $x$ et $y$ et $z$, $x (y z)= y (x z)$.\nassistant\n", "label": "axiom times_times (x y z : Nat) : x * (y * z) = y * (x * z)", "predict": "axiom times_times (x y z : Nat) : Nat := y (x z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nS_pred. Pour tous les nombres naturels $n$, si $0 < n$, alors $pred (n)+ 1 = n$.\nassistant\n", "label": "axiom S_pred (n : Nat) (x__ : 0 < n) : pred n + 1 = n", "predict": "axiom S_pred (n : Nat) : Nat := if 0 < n then pred n + 1 else n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_times. Pour tous les nombres naturels $n$ et $m$ et $p$ et $q$, si $n < m$ et $p < q$, alors $n p < m q$.\nassistant\n", "label": "axiom lt_times (n m p q : Nat) (x__ : n < m) (__1 : p < q) : n * p < m * q", "predict": "axiom lt_times (n m p q : Nat) : Bool => and (n < m) (p < q) => n * p < m * q"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDivides_plus. Soient $n$ et $p$ et $q$ des nombres naturels. Alors si $n$ est et divisible par $p$ et divisible par $q$, alors $n$ est divisible par $p + q$.\nassistant\n", "label": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)", "predict": "postulate divides_plus : (n : Set) -> (p : Set) -> (q : Set) -> n % p && n % q -> n % (p + q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_aux_mod_aux. Let $p$ and $n$ and $m$ be natural numbers. Then $n$ is equal to the sum of the product of $div_aux$ applied to $p$ and $n$ and $m$ and the sum of $m$ and $1$ and $mod_aux$ applied to $p$ and $n$ and $m$.\nassistant\n", "label": "div_aux_mod_aux : p : Nat -> n : Nat -> m : Nat -> Eq n (plus (times (div_aux p n m) (plus m (nd 1))) (mod_aux p n m)) .", "predict": "div_aux_mod_aux : p : Nat -> n : Nat -> m : Nat -> n = (div_aux p n m) + (m + 1) + (mod_aux p n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_Type3. Let $_n , _m , _q , _r \\in N$. Let $Q_$ be a function from elements $_x_821$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type3$. Let $_H_div_mod_spec_intro$ be a function from elements $x_823$ of $Lt$ of $_r$ and $_m$ and elements $x_822$ of $Eq$ of $_n$ and $_q _m + _r$ to elements of $Q_$ of $div_mod_spec_intro (_n , _m , _q , _r , x_823 , x_822)$. Then for all elements $x_821$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_821$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type3 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_821 : div_mod_spec _n _m _q _r) -> Type3), forall _H_div_mod_spec_intro : ((x_823 : _r < _m) -> (x_822 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)), forall x_821 : div_mod_spec _n _m _q _r, Q_ x_821 .", "predict": "Axiom div_mod_spec_rect_Type3 : forall _n : N, forall _m : N, forall _q : N, forall _r : N, forall Q_ : ((_x_821 : div_mod_spec _n _m _q _r) -> Type3), forall _H_div_mod_spec_intro : ((x_823 : Lt _r _m) -> (x_822 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)), forall x_821 : div_mod_spec _n _m _q _r, Q_ x_821 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_exp_to_le1. Soient $n$ et $m$ et $p$ des nombres naturels. Alors si $0 < p$ et $n ^ p \\leq m ^ p$, alors $n \\leq m$.\nassistant\n", "label": "Axiom le_exp_to_le1 : forall n : nat, forall m : nat, forall p : nat, forall x__ : (0 < p), forall __1 : Leq (pow n p) (pow m p), Leq n m .", "predict": "Axiom le_exp_to_le1 : forall n : nat, forall m : nat, forall p : nat, 0 < p -> n ^ p <= m ^ p -> n <= m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLtn_to_ltO. Soient $n$ et $m$ des nombres naturels. Alors si $n$ est inférieur à $m$, alors $0$ est inférieur à $m$.\nassistant\n", "label": "Axiom ltn_to_ltO : forall n : nat, forall m : nat, forall x__ : (n < m), 0 < m .", "predict": "Axiom ltn_to_ltO : forall n : nat, forall m : nat, nat -> nat -> nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNth_prime. För alla naturliga tal $__$, $Nat$.\nassistant\n", "label": "nth_prime : __ : Nat -> Nat .", "predict": "nth_prime : __ : Nat -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_to_congruent. Låt $n$ och $m$ och $p$ vara naturliga tal. Anta att $0 < p$. Anta att $m \\leq n$. Då om $p$ är delbart med $n - m$, så håller $congruent$ för $n$ och $m$ och $p$.\nassistant\n", "label": "postulate divides_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq m n) -> (__2 : divisible p (minus n m)) -> congruent n m p", "predict": "postulate divides_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (0 < p) -> (m <= n) -> (p % (n - m) == 0) -> congruent n m p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c \\in N$. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Anta att skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Anta att skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med $1$. Då är skillnaden mellan produkten av $m$ och $b$ och produkten av $p$ och $a$ lika med $1$.\nassistant\n", "label": "axiom let_clause_15611 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : b * m - a * p = gcd p m) (H0 : b * m - a * p = 1) : m * b - p * a = 1", "predict": "axiom let_clause_15611 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : ex Nat (λ b => Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m))) (b : Nat) : Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m)) (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m)) (skillnaden (produkten av b och m) (produkten av a och p)) 1) : Eq (produkten av m och n) (produkten av p und c)) : Eq (skillnaden (produkten av m och n) (produkten av p und c)) 1) : Eq (skillnaden (produkten av m och b) (produkten av p und a)) 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_spec_inv_ind. For all natural numbers $x1$ and $x2$, for all functions $x3$ from natural numbers to booleans, for all natural numbers $x4$, for all elements $_Hterm$ of $min_spec$ of $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from natural numbers $_z1890$ to propositions, for all functions $_H1$ from natural numbers $m$ and elements $_x_1080$ of $Leq$ of $x2$ and $m$ and elements $_x_1079$ of $Lt$ of $m$ and $x1 + x2$ and elements $_x_1078$ of $Eq$ of $x3 (m)$ and $true$ and functions $_x_1077$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $x3 (i)$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and $m$ to elements of $P$ of $m$, for all functions $_H2$ from functions $_x_1081$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and $x1 + x2$ to elements of $Eq$ of $x3 (i)$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and $x1 + x2$ to elements of $P$ of $x1 + x2$, $P$ holds for $x4$.\nassistant\n", "label": "Axiom min_spec_inv_ind : forall x1 : nat, forall x2 : nat, forall x3 : ((x__ : nat) -> bool), forall x4 : nat, forall _Hterm : min_spec x1 x2 x3 x4, forall P : ((_z1890 : nat) -> Prop), forall _H1 : ((m : nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : m < x1 + x2) -> (_x_1078 : x3 m = true) -> (_x_1077 : (i : nat) -> (x__ : Leq x2 i) -> (__1 : i < m) -> x3 i = false) -> (_z1891 : x4 = m) -> P m), forall _H2 : ((_x_1081 : (i : nat) -> (x__ : Leq x2 i) -> (__1 : i < x1 + x2) -> x3 i = false) -> (_z1891 : x4 = x1 + x2) -> P (x1 + x2)), P x4 .", "predict": "Axiom min_spec_inv_ind : forall x1 : Nat, forall x2 : Nat, forall x3 : ((i : Nat) -> Bool), forall x4 : Nat, forall _Hterm : min_spec x1 x2 x3 x4, forall P : ((_z1890 : Nat) -> Prop), forall _H1 : ((m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (x1 + x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (__1 : Lt i m) -> Eq (x3 i) absurdity) -> (_z1891 : Eq x4 m) -> P m), forall _H2 : ((_x_1081 : (i : Nat) -> (__1 : Lt i (x1 + x2)) -> Eq (x3 i) absurdity) -> (_z1891 : Eq x4 (x1 + x2)) -> P (x1 + x2)), P x4 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b \\in N$. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$. Alors pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : Nat -> Nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Anta att skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Då om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $m$ och $b$ och produkten av $p$ och $a$.\nassistant\n", "label": "axiom let_clause_16171 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : b * m - a * p = gcd p m) (H0 : b * m - a * p = 1) : gcd p m = m * b - p * a", "predict": "axiom let_clause_16171 (p m n : Nat) (c : Nat) (a : N) (_clearme0 : ex Nat (λ b => Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m) ∧ Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m))) (b : Nat) : Prod (Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m) ∨ Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m)) (Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m))) : Prod (Eq (produkten av m och n) (produkten av p und c)) (a : N) : Prod (Eq (produkten av m och n) (produkten av p und c)) (b : Nat) : Prod (Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m) ∨ Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m)) (Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m))) (c : Nat) : Prod (Eq (produkten av m och n) (produkten av p und c)) (b : Nat) : Prod (Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m) ∨ Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m)) (Eq (skillnaden (produkten av b"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBigop_0. Let $n \\in N$. Let $B$ be a set. Then for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to the sum of $i$ and $1$ and $f$ applied to $0$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "Axiom bigop_0 : forall n : nat, forall B : Set, forall nil : B, forall op : Aop B nil, forall f : ((x__ : nat) -> B), bigop (n + 1) (fun i => true) B nil (op B nil op) (fun i => f i) = op B nil op (bigop n (fun i => true) B nil (op B nil op) (fun i => f (i + 1))) (f 0) .", "predict": "Axiom bigop_0 : forall n : N, forall B : Set, forall nil : B, forall op : Aop B nil, forall f : ((i : N) -> B), op B nil op (bigop n (fun i => true) B nil (op B nil op) (fun i => f (i + 1)) (f 0)) = bigop (n + 1) (fun i => true) B nil (op B nil op) (fun i => f i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDiv_mod_spec_inv_ind. Låt $x1$ och $x2$ och $x3$ och $x4$ vara naturliga tal. Låt $Hterm$ vara ett element av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1434$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden, för alla funktioner $_H1$ från element $x_811$ av $Lt$ av $x4$ och $x2$ och element $x_810$ av $Eq$ av $x1$ och summan av produkten av $x3$ och $x2$ och $x4$ och element $_z1435$ av $Eq$ av $Hterm$ och $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_811$ och $x_810$ till element av $P$ av $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_811$ och $x_810$, håller $P$ för $Hterm$.\nassistant\n", "label": "div_mod_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1434 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_811 : Lt x4 x2 -> x_810 : Eq x1 (plus (times x3 x2) x4) -> _z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm .", "predict": "div_mod_spec_inv_ind : x1 : nat -> x2 : nat -> x3 : nat -> x4 : nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1434 : div_mod_spec x1 x2 x3 x4 -> påstående) -> _H1 : (x_811 : Lt x4 x2 -> x_810 : Eq x1 (summen av produkten av x3 x2 x4) -> _z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> element av P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_15621. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $c n - d m = 1$, then $n c - m d = 1$.\nassistant\n", "label": "axiom let_clause_15621 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : n * c - m * d = 1", "predict": "axiom let_clause_15621 (m n a b : N) (_clearme : (d : N) -> Eq (c * n - d * m) 1) (d : N) : Eq (n * c - m * d) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLstar_r_S. Låt $B$ vara en mängd. Då för alla element $R$ av $relation$ av $B$, för alla naturliga tal $l$, för alla element $b1$ och $b$ av $B$, för alla element $__$ av $lstar_r$ av $B$ och $R$ och $l$ och $b1$ och $b$, för alla element $b2$ av $B$, för alla element $__1$ av $R$ av $b$ och $b2$, håller $lstar_r$ för $B$ och $R$ och $l + 1$ och $b1$ och $b2$.\nassistant\n", "label": "axiom lstar_r_S (B : Set) (R : relation B) (l : Nat) (b1 b : B) (x__ : lstar_r B R l b1 b) (b2 : B) (__1 : R b b2) : lstar_r B R (l + 1) b1 b2", "predict": "axiom lstar_r_S (B : Set) (R : Set) (l : Nat) (b1 b : B) (__ : lstar_r B R l b1 b) (b2 : B) (__1 : R b b2) : lstar_r B R (l + 1) b1 b2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$. Alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (b : Nat) (__ : (i0 : Nat) -> (Leq i0 n) -> Nat) (injf : injn f n) (a_b : a = b) : f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLe_max_f_max_g. Soient $f$ et $g$ des fonctions des nombres naturels à des valeurs booléennes. Soit $n$ un nombre naturel. Alors pour toutes les fonctions $__$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n$ et des éléments $__1$ de $Eq$ de $f$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $g$ appliqué à $i$ et de $true$, $max$ appliqué à $n$ et $f$ est inférieur ou ágal à $max$ appliqué à $n$ et $g$.\nassistant\n", "label": "axiom le_max_f_max_g (f g : (x__ : Nat) -> bool) (n : Nat) (x__ : (i : Nat) -> (x__ : i < n) -> (__1 : f i = true) -> g i = true) : max n f ≤ max n g", "predict": "axiom le_max_f_max_g (f g : (i : Nat) -> Bool) (n : Nat) (__ : (i : Nat) -> (__1 : Eq (f i) true) -> Eq (g i) true) : Max n f <= Max n g"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1560. Let $n , m \\in N$. Assume that $n$ is divisible by $m$ and $0 = n$. Let $d \\in N$. Assume that $m = 0 d$. Then $n = 0$.\nassistant\n", "label": "axiom let_clause_1560 (n m : Nat) (divnm : divisible n m) (H : 0 = n) (d : Nat) (auto : m = 0 * d) : n = 0", "predict": "axiom let_clause_1560 (n m : N) (d : N) : N := if n = 0 then m else if m = 0 d then 0 else n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_CProp4_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_957$ of $Dop$ of $A$ and $_nil$ to propositions. Let $_H_mk_Dop$ be a function from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$. Let $x_957$ be an element of $Dop$ of $A$ and $_nil$. Then $Q_$ holds for $x_957$.\nassistant\n", "label": "Dop_rect_CProp4_body : A : Set -> _nil : A -> Q_ : (_x_957 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_957 : Dop A _nil -> Q_ x_957 .", "predict": "Dop_rect_CProp4_body : A : Set -> _nil : A -> Q_ : (_x_957 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (a : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_957 : Dop A _nil -> Q_ x_957 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1561. Soit $p , m , n \\in N$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c \\in N$. Supposons que $m n = p c$. Alors pour tous les nombres naturels $a$, pour tous les éléments $_clearme0$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$, pour tous les nombres naturels $b$, si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$, alors si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b = 1$.\nassistant\n", "label": "axiom let_clause_1561 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : a * p - b * m = gcd p m) (H0 : a * p - b * m = 1) : p * a - m * b = 1", "predict": "axiom let_clause_1561 (p m n : N) (c : N) (a : N) (_clearme0 : ex Nat (λ b => Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p) (gcd p m)))) (b : N) : Prop := and (eq (gcd p m) (a p - b m) (b m - a p)) (eq (gcd p m) (a p - b m) 1) => p a - m b = 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_inv_rect_CProp0. Let $x1$ be a set. Let $x2$ be an element of $x1$. Let $Hterm$ be an element of $ACop$ of $x1$ and $x2$. Let $P$ be a function from elements $_z1626$ of $ACop$ of $x1$ and $x2$ to propositions. Let $_H1$ be a function from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1627$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$. Then $P$ holds for $Hterm$.\nassistant\n", "label": "axiom ACop_inv_rect_CProp0 (x1 : Set) (x2 : x1) (Hterm : ACop x1 x2) (P : (_z1626 : ACop x1 x2) -> Prop) (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> op x1 x2 aop a b = op x1 x2 aop b a) -> (_z1627 : Hterm = mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) : P Hterm", "predict": "axiom ACop_inv_rect_CProp0 (x1 : Set) (x2 : Set) (Hterm : ACop x1 x2) (P : (_z1626 : ACop x1 x2) -> Prop) (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop) a b) -> (_z1627 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm))) : P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDop_discr. Pour tous les ensembles $a1$, pour tous les éléments $a2$ de $a1$, pour tous les éléments $x$ et $y$ de $Dop$ de $a1$ et de $a2$, si $x = y$, alors $match_Dop$ tient pour $a1$ et $a2$ et $Type2 + 1$ et la fonction qui envoie $__$ à $univ (Type2)$ et la fonction qui envoie $t0$ et $t1$ et $t2$ et $t3$ à $match_Dop$ appliqué à $a1$ et $a2$ et la somme de $Type2", "label": "Dop_discr : a1 : Set -> a2 : a1 -> x : Dop a1 a2 -> y : Dop a1 a2 -> _e : Eq x y -> match_Dop a1 a2 (plus Type2 (nd 1)) (__ : Dop a1 a2 => univ Type2) (t0 : ACop a1 a2 => t1 : (__ : a1 -> __1 : a1 -> a1) => t2 : (a : a1 -> Eq (t1 a a2) a2) => t3 : (a : a1 -> b : a1 -> c : a1 -> Eq (t1 a (aop__o__op a1 a2 t0 b c)) (aop__o__op a1 a2 t0 (t1 a b) (t1 a c))) => match_Dop a1 a2 (plus Type2 (nd 1)) (__ : Dop a1 a2 => univ Type2) (u0 : ACop a1 a2 => u1 : (__ : a1 -> __1 : a1 -> a1) => u2 : (a : a1 -> Eq (u1 a a2) a2) => u3 : (a : a1 -> b : a1 -> c : a1 -> Eq (u1 a (aop__o__op a1 a2 u0 b c)) (aop__o__op a1 a2 u0 (u1 a b) (u1 a c))) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (ACop a1 a2) t0) u0) (e0 : Eq (R0 (ACop a1 a2) t0) u0 => prod Prop Type1 (Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1) (e1 : Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set", "predict": "Dop_discr : a1 : Set -> a2 : Set -> x : Dop a1 a2 -> y : Dop a1 a2 -> x = y -> match_Dop : a1 -> a2 -> Type2 + 1 -> (__ : Dop a1 a2 -> t0 : Set -> t1 : Set -> t2 : Set -> t3 : Set -> univ Type2) -> (t0 = x -> t1 = y -> t2 = a2 -> t3 = a2) -> (t0 = y -> t1 = x -> t2 = a2 -> t3 = a2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1075. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $bijf$ un élément de $bijn$ de $f$ et de $n + 1$. Supposons que $f (n + 1)= n + 1$. Soit $i$ un nombre naturel. Supposons que $i \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n + 1$ et $f (a)= i$. Supposons que $a \\leq n + 1$. Supposons que $f (a)= i$. Supposons que $a = n + 1$. Alors $i = a$.\nassistant\n", "label": "let_clause_1075 : f : (__ : Nat -> Nat) -> n : Nat -> bijf : bijn f (plus n (nd 1)) -> fS : Eq (f (plus n (nd 1))) (plus n (nd 1)) -> i : Nat -> lein : Leq i n -> a : Nat -> _clearme : and (Leq a (plus n (nd 1))) (Eq (f a) i) -> lean : Leq a (plus n (nd 1)) -> fa : Eq (f a) i -> Hc : Eq a (plus n (nd 1)) -> Eq i a .", "predict": "let_clause_1075 : f : (Nat -> Nat) -> n : Nat -> bijf : bijn f n + 1 -> f (n + 1) = n + 1 -> i : Nat -> i <= n -> a : Nat -> a <= n + 1 -> f (a) = i -> a <= n + 1 -> f (a) = i -> a = n + 1 -> i = a ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_plus_to_minus. Let $n , m , p \\in N$. Assume that $m$ is less than or equal to $n$. Then if $n$ is less than the sum of $p$ and $m$, then the difference of $n$ and $m$ is less than $p$.\nassistant\n", "label": "Axiom lt_plus_to_minus : forall n : nat, forall m : nat, forall p : nat, forall x__ : Leq m n, forall __1 : (n < p + m), n - m < p .", "predict": "Axiom lt_plus_to_minus : forall n : N, forall m : N, forall p : N, forall nlt : (m <= n), forall nsum : (n < (p + m)), forall minus : (n - m), forall plt : (minus < p), ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_upper_bound1. För alla naturliga tal $n$, $Nat$.\nassistant\n", "label": "axiom let_upper_bound1 (n : Nat) : Nat", "predict": "axiom let_upper_bound1 (n : Nat) : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMin_exists. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $t , m \\in N$. Anta att $m < t$. Anta att $f (m)= true$. Låt $k$ och $b$ vara naturliga tal. Anta att $b \\leq m$. Då för alla funktioner $__3$ från naturliga tal $i$ och element $__3$ av $Leq$ av $b$ och $i$ och element $__4$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $f (i)$ och kontradiktion, om $t = k + b$, så $min (k , b , f)= m$.\nassistant\n", "label": "axiom min_exists (f : (x__ : Nat) -> bool) (t m : Nat) (x__ : m < t) (__1 : f m = true) (k b : Nat) (__2 : b ≤ m) (__3 : (i : Nat) -> (__3 : b ≤ i) -> (__4 : i < m) -> f i = false) (__4 : t = k + b) : min k b f = m", "predict": "axiom min_exists (f : nat -> Bool) (t m : Nat) (k b : Nat) (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) contradiction) : (t = k + b) -> min (k b f) = m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_rect_Type3. Let $Q_$ be a function from natural numbers $_x_377$ to elements of $Type3$. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_378$ and elements $_x_380$ of $Q_$ of $x_378$ to elements of $Q_$ of the sum of $x_378$ and $1$. Let $x_377$ be a natural number. Then $Q_$ holds for $x_377$.\nassistant\n", "label": "axiom nat_rect_Type3 (Q_ : (_x_377 : Nat) -> Type3) (_H_O : Q_ 0) (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (x_378 + 1)) (x_377 : Nat) : Q_ x_377", "predict": "axiom nat_rect_Type3 (Q_ : (_x_377 : Nat) -> Type3) (_H_O : Q_ 0) (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (x_378 + 1)) (x_377 : Nat) : Q_ x_377"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_CProp1_body. Let $_A$ be a set. Then for all functions $Q_$ from elements $_x_937$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $range$ of $_A$, $Q_$ holds for $x_937$.\nassistant\n", "label": "Axiom range_rect_CProp1_body : forall _A : Set, forall Q_ : ((_x_937 : range _A) -> Prop), forall _H_mk_range : ((_enum : (x__ : nat) -> _A) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)), forall x_937 : range _A, Q_ x_937 .", "predict": "Axiom range_rect_CProp1_body : forall _A : set, forall Q_ : ((_x_937 : range _A) -> proposition), forall _H_mk_range : ((_enum : (n : set) -> _A) -> (_upto : set) -> (_filter : (n : set) -> bool) -> Q_ (mk_range _A _enum _upto _filter)), forall x_937 : range _A, Q_ x_937 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_exists_to_forall. Let $P$ be a function from natural numbers to propositions. Let $n \\in N$. Assume that it is not the case that $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $P$ applied to $i$. Let $i$ be a natural number. Assume that $i$ is less than $n$. Then it is not the case that $P$ holds for $i$.\nassistant\n", "label": "axiom not_exists_to_forall (P : (x__ : Nat) -> Prop) (n : Nat) (x__ : ¬ ex Nat (λ i => i < n ∧ P i)) (i : Nat) (__1 : i < n) : ¬ P i", "predict": "axiom not_exists_to_forall (P : Nat -> Prop) (n : Nat) (i : Nat) : Prop := and_not_exists_to_forall (λ P => λ n => λ i => not (ex Nat (λ i => Lt i n) (P i))) (λ i => i < n) (λ P => P i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1600. Låt $m , n , a , b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Då om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $n$ och $c$ och produkten av $m$ och $d$.\nassistant\n", "label": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_1600 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1)) -> (d : N) -> (_om skillnaden (produkten av c och n) (produkten av d och m) == 1) -> (_eller skillnaden (produkten av d och m) (produkten av c och n) == 1) -> (_eller skillnaden (produkten av c och n) (produkten av d och m) == 1) -> (det största gemensama delaret av m och n == skillnaden (produkten av n och c) (produkten av m och d))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i , j \\in N$. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a \\in N$. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $a$ är lika med $i$. Låt $b \\in N$. Anta att $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$. Anta att $b$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $b$ är lika med $j$. Låt $__$ vara en funktion från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$. Låt $injf$ vara ett element av $injn$ av $f$ och $n$. Då om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $j$.\nassistant\n", "label": "Axiom let_clause_1063 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = j .", "predict": "Axiom let_clause_1063 : forall f : nat -> nat, forall n : N, forall permf : permut f n, forall i : N, forall j : N, forall a : N, a <= n -> f a = i -> forall b : N, b <= n -> f b = j -> forall __ : (i0 : N) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall a : N, forall b : N, a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLt_plus_to_lt_r. Soient $n$ et $p$ et $q$ des nombres naturels. Alors si $n + p < n + q$, alors $p < q$.\nassistant\n", "label": "lt_plus_to_lt_r : n : Nat -> p : Nat -> q : Nat -> __ : Lt (plus n p) (plus n q) -> Lt p q .", "predict": "lt_plus_to_lt_r : n : Nat -> p : Nat -> q : Nat -> n + p < n + q -> p < q ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15624. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$, alors si $d m - c n = 1$, alors $m d - n c = 1$.\nassistant\n", "label": "let_clause_15624 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .", "predict": "let_clause_15624 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = div_commun_plus_grand n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (diff (c n) (d m)) 1) -> d : Nat -> c n - d m = 1 -> d m - c n = 1 -> d m - c n = 1 -> m d - n c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_fwd_plus_plus_ge. Let $m1 , m2 \\in N$. Assume that $m2 \\leq m1$. Then for all natural numbers $n1$ and $n2$, if $m1 + n1 \\leq m2 + n2$, then $n1 \\leq n2$.\nassistant\n", "label": "Axiom le_fwd_plus_plus_ge : forall m1 : nat, forall m2 : nat, forall x__ : Leq m2 m1, forall n1 : nat, forall n2 : nat, forall __1 : Leq (m1 + n1) (m2 + n2), Leq n1 n2 .", "predict": "Axiom le_fwd_plus_plus_ge : forall m1 : N, forall m2 : N, forall n1 : N, forall n2 : N, m2 <= m1 -> m1 + n1 <= m2 + n2 -> n1 <= n2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nFmax_false. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n , m \\in N$. Supposons que $max (n , f)= m$. Supposons que contradiction est égal à $f (m)$. Alors $m = 0$.\nassistant\n", "label": "fmax_false : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Eq (max n f) m -> __1 : Eq (f m) false -> Eq m 0 .", "predict": "fmax_false : f : (N -> Bool) -> n : N -> m : N -> max (n , f) = m -> contradiction = f (m) -> m = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_10331. Let $n$ be a natural number. Assume that the exponentiation of $2$ and $8$ is less than or equal to $n$. Let $m \\in N$. Assume that $3$ is less than or equal to $m$. Assume that the sum of the logarithm of $2$ and $m$ and $2$ is less than or equal to $m$. Let $x2515$ and $x2516$ be natural numbers. Then $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Set) -> (m : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (2 ^ 8) <= n) -> (_s : (log 2 m) + 2 <= m) -> (x2515 == (x2516 * (x2515 / x2516)) + (mod x2515 x2516))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDivides_gcd_aux_mn. Soit $p , m , n \\in N$. Supposons que $0 < n$. Supposons que $n \\leq m$. Alors si $n \\leq p$, alors $gcd_aux (p , m , n)$ est divisible par $m$ et $gcd_aux (p , m , n)$ est divisible par $n$.\nassistant\n", "label": "divides_gcd_aux_mn : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n p -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n) .", "predict": "divides_gcd_aux_mn : p : N -> m : N -> n : N -> 0 < n -> n <= m -> n <= p -> gcd_aux (p , m , n) : M -> gcd_aux (p , m , n) : N ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Alors si $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$, alors si $b$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $b$ est égal à $j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (Hc : a <= n) (Hd : f a = i) (b : Nat) (He : b <= n) (Hf : f b = j) (Hg : b <= n) (Hh : f b = j) (__ : (i0 : Nat) -> (Leq i0 n) -> Leq (f i0) n) (injf : injn f n) (Hk : a = b) : f a = j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_ind. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and $_q _m + _r$ to elements of $Q_$ of $div_mod_spec_intro (_n , _m , _q , _r , x_811 , x_810)$, for all elements $x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_809$.\nassistant\n", "label": "div_mod_spec_ind : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 .", "predict": "div_mod_spec_ind : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n _q _m + _r -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBc1. Let $n$ and $k$ be natural numbers. Assume that $k < n$. Then $bc (n + 1 , k + 1)= bc (n , k)+ bc (n , k + 1)$.\nassistant\n", "label": "Axiom bc1 : forall n : nat, forall k : nat, forall x__ : (k < n), bc (n + 1) (k + 1) = bc n k + bc n (k + 1) .", "predict": "Axiom bc1 : forall n : nat, forall k : nat, k < n -> bc (n + 1 , k + 1) = bc (n , k) + bc (n , k + 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_10331. Let $n$ be a natural number. Assume that $5$ is less than $n$. Let $m \\in N$. Assume that $6$ is less than or equal to $m$. Assume that the exponentiation of the sum of $m$ and $1$ and $2$ is less than or equal to the exponentiation of $2$ and $m$. Let $a$ be a natural number. Assume that $6$ is less than or equal to $a$. Assume that the sum of the product of $2$ and the sum of $a$ and $1$ and $1$ is less than or equal to the exponentiation of $2$ and $a$. Let $x2515$ and $x2516$ be natural numbers. Then $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Set) -> (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (let_clause_10331 : (n : Set) -> (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x2516 : Set) -> (_e : (m : Set) -> (a : Set) -> (x2515 : Set) -> (x251"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15691. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Då om $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nassistant\n", "label": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .", "predict": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat -> 1 = Eq (skillnaden (produkten av c n) (produkten av d m)) -> 1 = Eq (skillnaden (produkten av d m) (produkten av c n)) -> d : Nat -> c n - d m = 1 -> d m - c n = 1) -> d : Nat -> c n - d m = 1 -> n c - m d = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_minus_O. Let $n , m \\in N$. Then if $n$ is less than or equal to $m$, then the difference of $n$ and $m$ is equal to $0$.\nassistant\n", "label": "eq_minus_O : n : Nat -> m : Nat -> __ : Leq n m -> Eq (minus n m) 0 .", "predict": "eq_minus_O : n : N -> m : N -> n <= m -> n - m = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_O_to_le_theta_exp_theta. Låt $m \\in N$. Då om $0$ är mindre än $m$, så är $theta$ applicerat på summan av produkten av $2$ och $m$ och $1$ mindre än produkten av potensen av $2$ och produkten av $2$ och $m$ och $theta$ applicerat på summan av $m$ och $1$.\nassistant\n", "label": "postulate lt_O_to_le_theta_exp_theta : (m : Nat) -> (_ : Lt 0 m) -> Lt (theta (plus (times 2 m) 1)) (times (pow 2 (times 2 m)) (theta (plus m 1)))", "predict": "postulate lt_O_to_le_theta_exp_theta : (m : N) -> 0 < m -> theta (2 * m + 1) < (2 ^ (2 * m)) * (theta (m + 1))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nProdF. Låt $A$ och $B$ vara mängder. Låt $_f$ vara en funktion från naturliga tal till element av $A$. Låt $_g$ vara en funktion från naturliga tal till element av $B$. Då för alla naturliga tal $_m$ och $_x$, håller $Prod$ för $A$ och $B$.\nassistant\n", "label": "Axiom prodF : forall A : Set, forall B : Set, forall _f : ((x__ : nat) -> A), forall _g : ((x__ : nat) -> B), forall _m : nat, forall _x : nat, Prod A B .", "predict": "Axiom prodF : forall A : set, forall B : set, forall _f : nat -> A, forall _g : nat -> B, forall _m : nat, forall _x : nat, Prod A B ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nGcd_O_l. Soit $m$ un nombre naturel. Alors $m$ est égal au diviseur commun plus grand de $0$ et de $m$.\nassistant\n", "label": "Axiom gcd_O_l : forall m : nat, gcd 0 m = m .", "predict": "Axiom gcd_O_l : forall m : nat, m = gcd 0 m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMod_n_n. Let $n \\in N$. Assume that $0 < n$. Then $mod (n , n)= 0$.\nassistant\n", "label": "Axiom mod_n_n : forall n : nat, forall x__ : (0 < n), mod n n = 0 .", "predict": "Axiom mod_n_n : forall n : N, 0 < n -> mod (n , n) = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nCongruent_ab. For all natural numbers $m$ and $n$ and $a$ and $b$, if $0 < n$, then if $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then $ex$ holds for $Nat$ and the function that maps $x$ to the conjunction of $congruent$ applied to $x$ and $a$ and $m$ and $congruent$ applied to $x$ and $b$ and $n$.\nassistant\n", "label": "Axiom congruent_ab : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall x__ : (0 < n), forall __1 : (0 < m), forall __2 : (gcd n m = 1), ex nat (fun x => congruent x a m /\\ congruent x b n) .", "predict": "Axiom congruent_ab : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall n : Nat, 0 < n -> forall m : Nat, 0 < m -> forall x : Nat, 1 = gcd n m -> ex Nat (fun x => congruent x a m /\\ congruent x b n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_Conf3. Let $A$ and $B$ be sets. Let $succ$ be an element of $relation2$ of $A$ and $B$. Let $R$ be an element of $relation$ of $A$. Let $__$ be an element of $Conf3$ of $A$ and $B$ and $succ$ and $R$. Let $l \\in N$. Then $Conf3$ holds for $A$ and $B$ and $succ$ and $lstar$ applied to $A$ and $R$ and $l$.\nassistant\n", "label": "axiom lstar_Conf3 (A B : Set) (succ : relation2 A B) (R : relation A) (x__ : Conf3 A B succ R) (l : Nat) : Conf3 A B succ (lstar A R l)", "predict": "axiom lstar_Conf3 (A B : Set) (succ : relation2 A B) (R : relation A) (__ : Conf3 A B succ R) (l : N) : Conf3 A B succ (lstar A R l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDiv_times_times. Soient $a$ et $b$ et $c$ des nombres naturels. Alors si $0 < c$ et $0 < b$, alors $a \\div b = a c \\div (b c)$.\nassistant\n", "label": "postulate div_times_times : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 b) -> Eq (div a b) (div (times a c) (times b c))", "predict": "postulate div_times_times : (a : Nat) -> (b : Nat) -> (c : Nat) -> (0 < c) -> (0 < b) -> a div b == a c div (b c)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nF3_ind_aux. Soient $A1$ et $A2$ et $A3$ des ensembles. Soit $f$ une fonction des éléments de $A1$ et des éléments $__1$ de $A2$ et des éléments $__2$ de $A3$ à des nombres naturels. Soit $P$ un élément de $relation3$ de $A1$ et de $A2$ et de $A3$. Soit $__$ une fonction des nombres naturels $n$ et des fonctions des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments de $Lt$ de $f (a1 , a2 , a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$ et des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments $__1$ de $Eq$ de $f (a1 , a2 , a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$. Soit $n$ un nombre naturel. Soit $a1$ un élément de $A1$. Soit $a2$ un élément de $A2$. Soit $a3$ un élément de $A3$. Alors si $f (a1 , a2 , a3)= n$, alors $P$ tient pour $a1$ et $a2$ et $a3$.\nassistant\n", "label": "Axiom f3_ind_aux : forall A1 : Set, forall A2 : Set, forall A3 : Set, forall f : ((x__ : A1) -> (__1 : A2) -> (__2 : A3) -> nat), forall P : relation3 A1 A2 A3, forall x__ : ((n : nat) -> (x__ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (x__ : f a1 a2 a3 < n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : f a1 a2 a3 = n) -> P a1 a2 a3), forall n : nat, forall a1 : A1, forall a2 : A2, forall a3 : A3, forall __1 : (f a1 a2 a3 = n), P a1 a2 a3 .", "predict": "Axiom f3_ind_aux : forall A1 : set, forall A2 : set, forall A3 : set, forall f : ((a1 : A1) -> (__1 : A2) -> (__2 : A3) -> nat), forall P : relation3 A1 A2 A3, forall __ : ((n : nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (Lt : f a1 a2 a3 = n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq f a1 a2 a3 n) -> P a1 a2 a3), forall n : nat, forall a1 : A1, forall a2 : A2, forall a3 : A3, if f a1 a2 a3 = n then P a1 a2 a3 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSquare_double. Let $n$ be a natural number. Then if $2 < n$, then $(n + 1)(n + 1)\\leq 2 n n$.\nassistant\n", "label": "square_double : n : Nat -> __ : Lt (nd 2) n -> Leq (times (plus n (nd 1)) (plus n (nd 1))) (times (times (nd 2) n) n) .", "predict": "square_double : n : Nat -> 2 < n -> (n + 1)(n + 1) <= 2 n n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBigop_sumI. Låt $a , b , c \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Då för alla element $op$ av $Aop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, om $a$ är mindre än eller lika med $b$, så om $b$ är mindre än eller lika med $c$, så är $bigop$ applicerat på skillnaden mellan $c$ och $a$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $p$ applicerat på $i0$ applicerat på summan av $i$ och $a$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $f$ applicerat på $i0$ applicerat på summan av $i$ och $a$ lika med $op$ applicerat på $B$ och $nil$ och $op$ och $bigop$ applicerat på skillnaden mellan $c$ och $b$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $p$ applicerat på $i0$ applicerat på summan av $i$ och $b$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $f$ applicerat på $i0$ applicerat på summan av $i$ och $b$ och $bigop$ applicerat på skillnaden mellan $b$ och $a$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $p$ applicerat på $i0$ applicerat på summan av $i$ och $a$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $f$ applicerat på $i0$ applicerat på summan av $i$ och $a$.\nassistant\n", "label": "postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))))", "predict": "postulate bigop_sumI : (a : N) -> (b : N) -> (c : N) -> (p : (i : N) -> Bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (i : N) -> B) -> (a : N) -> (b : N) -> (c : N) -> bigop (c - a) (\\ i : N -> p i (sum i a)) B nil op (\\ i : N -> f i (sum i a))) == op B nil op (bigop (c - b) (\\ i : N -> p i (sum i b)) B nil op (\\ i : N -> f i (sum i b))) (bigop (b - a) (\\ i : N -> p i (sum i a)) B nil op (\\ i : N -> f i (sum i a))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_fact_10. $(2 \\times 5)! \\leq 2 ^ (2 \\times 5 - 2)5 ! 5 !$.\nassistant\n", "label": "le_fact_10 : Leq (factorial (times (nd 2) (nd 5))) (times (times (pow (nd 2) (minus (times (nd 2) (nd 5)) (nd 2))) (factorial (nd 5))) (factorial (nd 5))) .", "predict": "le_fact_10 : (2 \\times 5)! \\leq 2 ^ (2 \\times 5 - 2)5 ! 5 ! ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Soit $b \\in N$. Supposons que $b \\leq n$ et $f (b)= j$. Alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nassistant\n", "label": "Axiom let_clause_1063 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = j .", "predict": "Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : (nat -> Leq n -> Leq n), forall injf : injn f n, forall a0 : nat, forall Hc : b <= n -> f b = j -> forall Hb : b <= n -> f b = j -> forall __ : (nat -> Leq n -> Leq n), forall injf : injn f n, forall a : nat, forall b : nat, forall a0 : nat, forall Hc : b <= n -> f b = j -> forall Hb : b <= n -> Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : (nat -> Leq n -> Leq n), forall injf : injn f n, forall a0 : nat, forall Hc : b <= n -> f b = j -> forall Hb : b <= n -> f b = j -> forall __ : (nat -> Leq n -> Leq n), forall injf : injn f n, forall a : nat, forall b : nat, forall a0 : nat, forall Hc : b <= n -> f b = j -> forall Hb : b <= n -> f b = j -> forall Hf : a <= n -> f a = i -> forall Hg : b <= n -> f b = j -> forall H : a0 <= n -> forall H1 : Leq a0 i -> forall H2 : Leq i n -> forall H3 : Leq (f a0) n -> forall H4 : a = b -> __ a0 b0 -> forall b0 : Leq a0 n -> forall b1 : Leq i n -> forall b2 : Leq (f a0) n -> forall b3 : b0 = b1 -> forall b4 : b2 = b3 -> forall b5 : b4Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1561. Let $p , m , n \\in N$. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c \\in N$. Assume that $m n = p c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$. Then if $a p - b m = 1$, then $p a - m b = 1$.\nassistant\n", "label": "axiom let_clause_1561 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : a * p - b * m = gcd p m) (H0 : a * p - b * m = 1) : p * a - m * b = 1", "predict": "axiom let_clause_1561 (p m n : N) (c : N) (a : Nat) (_clearme0 : ex (b : Nat) (Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m))) (b : N) : Eq (gcd p m) (a p - b m) (b m - a p)) : Eq (p a - m b) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDiv_mod_spec_rect_CProp1_body. Låt $_n , _m , _q , _r \\in N$. Då för alla funktioner $Q_$ från element $_x_853$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden, för alla funktioner $_H_div_mod_spec_intro$ från element $x_855$ av $Lt$ av $_r$ och $_m$ och element $x_854$ av $Eq$ av $_n$ och $_q _m + _r$ till element av $Q_$ av $div_mod_spec_intro (_n , _m , _q , _r , x_855 , x_854)$, för alla element $x_853$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_853$.\nassistant\n", "label": "Axiom div_mod_spec_rect_CProp1_body : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_853 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_855 : _r < _m) -> (x_854 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)), forall x_853 : div_mod_spec _n _m _q _r, Q_ x_853 .", "predict": "Axiom div_mod_spec_rect_CProp1_body : forall _n : N, forall _m : N, forall _q : N, forall _r : N, forall Q_ : ((_x_853 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_855 : Lt _r _m) -> (x_854 : Eq _n (_q _m + _r)) -> (Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854))), forall x_853 : div_mod_spec _n _m _q _r, Q_ x_853 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBigop_Sfalse. Let $k$ be a natural number. Then for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $p$ applied to $k$ is equal to absurdity, then $bigop$ applied to the sum of $k$ and $1$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "bigop_Sfalse : k : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Eq (p k) false -> Eq (bigop (plus k (nd 1)) (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p i) B nil op (i : Nat => f i)) .", "predict": "bigop_Sfalse : k : Nat -> p : (Nat -> Bool) -> B : Set -> nil : B -> op : (B -> __1 : B -> B) -> f : (Nat -> B) -> p k = absurdity -> bigop (k + 1) (i : Nat => p i) B nil op (i : Nat => f i) = bigop k (i : Nat => p i) B nil op (i : Nat => f i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNat_rect_CProp0_body. Soit $Q_$ une fonction des nombres naturels $_x_413$ à des propositions. Soit $_H_O$ un élément de $Q_$ de $0$. Soit $_H_S$ une fonction des nombres naturels $x_414$ et des éléments $_x_416$ de $Q_$ de $x_414$ à des éléments de $Q_$ de la somme de $x_414$ et de $1$. Alors pour tous les nombres naturels $x_413$, $Q_$ tient pour $x_413$.\nassistant\n", "label": "nat_rect_CProp0_body : Q_ : (_x_413 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_414 : Nat -> _x_416 : Q_ x_414 -> Q_ (plus x_414 (nd 1))) -> x_413 : Nat -> Q_ x_413 .", "predict": "nat_rect_CProp0_body : Q_ : (_x_413 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_414 : Nat -> _x_416 : Q_ x_414 -> Q_ (x_414 + 1)) -> x_413 : Nat -> Q_ x_413 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDop_rect_CProp5. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_959$ av $Dop$ av $A$ och $_nil$ till påståenden. Låt $_H_mk_Dop$ vara en funktion från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod (a , _nil)$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod (a , aop__o__op (A , _nil , sum , b , c))$ och $aop__o__op (A , _nil , sum , prod (a , b), prod (a , c))$ till element av $Q_$ av $mk_Dop (A , _nil , sum , prod , _null , _distr)$. Låt $x_959$ vara ett element av $Dop$ av $A$ och $_nil$. Då håller $Q_$ för $x_959$.\nassistant\n", "label": "postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959", "predict": "postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Set) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om $b m - a p = 1$, så $m b - p a = 1$.\nassistant\n", "label": "Axiom let_clause_15611 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (b * m - a * p = gcd p m), forall H0 : (b * m - a * p = 1), m * b - p * a = 1 .", "predict": "Axiom let_clause_15611 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : (ex : Nat -> (b : Nat) -> Eq (prod a p) (prod b m) (gcd p m)) -> Eq (prod b m) (prod a p) (gcd p m)), forall b : Nat, ((gcd p m) = (a p - b m) -> (gcd p m) = (b m - a p) -> (gcd p m) = (b m - a p) -> b m - a p = 1 -> m b - p a = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEq_div_O. För alla naturliga tal $n$ och $m$, om $n$ är mindre än $m$, så är kvoten av $n$ och $m$ lika med $0$.\nassistant\n", "label": "axiom eq_div_O (n m : Nat) (x__ : n < m) : n / m = 0", "predict": "axiom eq_div_O (n m : Nat) : Nat (if n < m then 0 else div n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1033. Soit $n$ un nombre naturel. Supposons que $1 < n$. Supposons que $2 \\times n$ est premier. Alors si $1 < 2 n$, alors pour toutes les fonctions $H1$ des nombres naturels $m$ et des éléments de $divisible$ de $m$ et de $2 \\times n$ et des éléments $__1$ de $Lt$ de $1$ et de $m$ à des éléments de $Eq$ de $m$ et de $2 \\times n$, pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "axiom let_clause_1033 (n : Nat) (ltn : 1 < n) (_clearme : prime (2 * n)) (H : 1 < 2 * n) (H1 : (m : Nat) -> (x__ : divisible m (2 * n)) -> (__1 : 1 < m) -> m = 2 * n) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_1033 (n : Nat) (H1 : (m : Nat) -> (__1 : Lt 1 m) -> Eq m (2 * n)) (x2515 x2516 : Nat) : Nat := x2515 / x2516 + mod x2515 x2516"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nEq_gcd_times_1. Låt $p$ och $n$ och $m$ vara naturliga tal. Då om $0 < n$ och $0 < m$, så om $1$ är både lika med det största gemensama delaret av $p$ och $n$ och lika med det största gemensama delaret av $p$ och $m$, så är $1$ lika med det största gemensama delaret av $p$ och produkten av $n$ och $m$.\nassistant\n", "label": "Axiom eq_gcd_times_1 : forall p : nat, forall n : nat, forall m : nat, forall x__ : (0 < n), forall __1 : (0 < m), forall __2 : (gcd p n = 1), forall __3 : (gcd p m = 1), gcd p (n * m) = 1 .", "predict": "Axiom eq_gcd_times_1 : forall p : nat, forall n : nat, forall m : nat, 0 < n -> 0 < m -> 1 = gcd p n -> 1 = gcd p m -> 1 = gcd p (n * m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_times_to_divides. Let $p$ and $n$ and $m$ be natural numbers. Then if $p$ is both prime and divisible by $n \\times m$, then $p$ is divisible by $n$ or divisible by $m$.\nassistant\n", "label": "Axiom divides_times_to_divides : forall p : nat, forall n : nat, forall m : nat, forall x__ : prime p, forall __1 : divisible p (n * m), divisible p n \\/ divisible p m .", "predict": "Axiom divides_times_to_divides : forall p : nat, forall n : nat, forall m : nat, ((p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (Axiom divides_times_to_divides : forall p : nat, forall n : nat, forall m : nat, ((p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (Axiom divides_times_to_divides : forall p : nat, forall n : nat, forall m : nat, ((p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) -> (p : nat) -> (n : nat) -> (m : nat) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_inv_rect_CProp0. Let $x1$ be a set. Then for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1626$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1627$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.\nassistant\n", "label": "axiom ACop_inv_rect_CProp0 (x1 : Set) (x2 : x1) (Hterm : ACop x1 x2) (P : (_z1626 : ACop x1 x2) -> Prop) (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> op x1 x2 aop a b = op x1 x2 aop b a) -> (_z1627 : Hterm = mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) : P Hterm", "predict": "axiom ACop_inv_rect_CProp0 (x1 : Set) (x2 : x1) (Hterm : ACop x1 x2) (P : (_z1626 : ACop x1 x2) -> Prop) (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1627 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) : P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_rect_Type0_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_873$ de $Aop$ de $A$ et de $_nil$ à des ensembles, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (_nil , a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (a , _nil)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op (a , op (b , c))$ et de $op (op (a , b), c)$ à des éléments de $Q_$ de $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$, pour tous les éléments $x_873$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_873$.\nassistant\n", "label": "Axiom Aop_rect_Type0_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_873 : Aop A _nil) -> Set), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_873 : Aop A _nil, Q_ x_873 .", "predict": "Axiom Aop_rect_Type0_body : forall A : Ensemble, forall _nil : A, forall Q_ : ((_x_873 : Aop A _nil) -> Ensemble), forall _H_mk_Aop : ((op : (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_873 : Aop A _nil, Q_ x_873 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b \\in N$. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : Nat -> Nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nMinus_to_plus. Pour tous les nombres naturels $n$ et $m$ et $p$, si $m \\leq n$ et $n - m = p$, alors $n = m + p$.\nassistant\n", "label": "Axiom minus_to_plus : forall n : nat, forall m : nat, forall p : nat, forall x__ : Leq m n, forall __1 : (n - m = p), n = m + p .", "predict": "Axiom minus_to_plus : forall n : nat, forall m : nat, forall p : nat, m <= n -> n - m = p -> n = m + p ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNat_rect_CProp4. Soit $Q_$ une fonction des nombres naturels $_x_393$ à des propositions. Soit $_H_O$ un élément de $Q_$ de $0$. Soit $_H_S$ une fonction des nombres naturels $x_394$ et des éléments $_x_396$ de $Q_$ de $x_394$ à des éléments de $Q_$ de la somme de $x_394$ et de $1$. Alors pour tous les nombres naturels $x_393$, $Q_$ tient pour $x_393$.\nassistant\n", "label": "axiom nat_rect_CProp4 (Q_ : (_x_393 : Nat) -> Prop) (_H_O : Q_ 0) (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (x_394 + 1)) (x_393 : Nat) : Q_ x_393", "predict": "axiom nat_rect_CProp4 (Q_ : (_x_393 : Nat) -> Prop) (_H_O : Q_ 0) (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (x_394 + 1)) (x_393 : Nat) : Q_ x_393"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1033. Let $n$ be a natural number. Then if $2 ^ 4 \\leq n$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "postulate let_clause_1033 : (n : Nat) -> (le_n : Leq (pow 2 4) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Set) -> (x2515 : Set) -> (x2516 : Set) -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDiv_mod_spec_div_mod. Soient $n$ et $m$ des nombres naturels. Supposons que $0 < m$. Alors $div_mod_spec$ tient pour $n$ et $m$ et $n \\div m$ et $mod (n , m)$.\nassistant\n", "label": "axiom div_mod_spec_div_mod (n m : Nat) (x__ : 0 < m) : div_mod_spec n m (n / m) (mod n m)", "predict": "axiom div_mod_spec_div_mod (n m : Nat) (Hc : 0 < m) : Nat : div_mod_spec n m (n div m) (mod n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTimes_div_le. For all natural numbers $a$ and $b$ and $c$ and $d$, if $0$ is less than $b$, then if $0$ is less than $d$, then the product of the quotient of $a$ and $b$ and the quotient of $c$ and $d$ is less than or equal to the quotient of the product of $a$ and $c$ and the product of $b$ and $d$.\nassistant\n", "label": "Axiom times_div_le : forall a : nat, forall b : nat, forall c : nat, forall d : nat, forall x__ : (0 < b), forall __1 : (0 < d), Leq (a / b * (c / d)) (a * c / (b * d)) .", "predict": "Axiom times_div_le : forall a : nat, forall b : nat, forall c : nat, forall d : nat, if 0 < b then if 0 < d then (a / b) * (c / d) <= (a * c) / (b * d) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_15611. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Alors si $b m - a p = 1$, alors $m b - p a = 1$.\nassistant\n", "label": "Axiom let_clause_15611 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (b * m - a * p = gcd p m), forall H0 : (b * m - a * p = 1), m * b - p * a = 1 .", "predict": "Axiom let_clause_15611 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : ((b : Nat) -> Eq (Nat) (div (a * p) (b * m)) (gcd p m)) -> (b : Nat) -> Eq (Nat) (div (b * m) (a * p)) (gcd p m)), forall b : Nat, ((gcd p m) = (a * p - b * m) -> (gcd p m) = (b * m - a * p)) -> (gcd p m) = (b * m - a * p)) -> forall b : Nat, b * m - a * p = 1 -> m * b - p * a = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_inv_ind. Let $x1$ be a set. Let $x2$ be an element of $relation$ of $x1$. Let $x3 \\in N$. Let $x4$ and $x5$ be elements of $x1$. Then for all elements $_Hterm$ of $lstar$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from natural numbers $_z2089$ and elements $_z2088$ of $x1$ and elements $_z2087$ of $x1$ to propositions, for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2092$ of $Eq$ of $x3$ and $0$ and elements $_z2091$ of $Eq$ of $x4$ and $b$ and elements $_z2090$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1236$ of $x2$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $x1$ and elements $_x_1235$ of $lstar$ of $x1$ and $x2$ and $l$ and $b$ and $b2$ and functions $_x_1238$ from elements $_z2092$ of $Eq$ of $x3$ and $l$ and elements $_z2091$ of $Eq$ of $x4$ and $b$ and elements $_z2090$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of $l$ and $b$ and $b2$ and elements $_z2092$ of $Eq$ of $x3$ and $l + 1$ and elements $_z2091$ of $Eq$ of $x4$ and $b1$ and elements $_z2090$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of $l + 1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.\nassistant\n", "label": "lstar_inv_ind : x1 : Set -> x2 : relation x1 -> x3 : Nat -> x4 : x1 -> x5 : x1 -> _Hterm : lstar x1 x2 x3 x4 x5 -> P : (_z2089 : Nat -> _z2088 : x1 -> _z2087 : x1 -> Prop) -> _H1 : (b : x1 -> _z2092 : Eq x3 0 -> _z2091 : Eq x4 b -> _z2090 : Eq x5 b -> P 0 b b) -> _H2 : (b1 : x1 -> b : x1 -> _x_1236 : x2 b1 b -> l : Nat -> b2 : x1 -> _x_1235 : lstar x1 x2 l b b2 -> _x_1238 : (_z2092 : Eq x3 l -> _z2091 : Eq x4 b -> _z2090 : Eq x5 b2 -> P l b b2) -> _z2092 : Eq x3 (plus l (nd 1)) -> _z2091 : Eq x4 b1 -> _z2090 : Eq x5 b2 -> P (plus l (nd 1)) b1 b2) -> P x3 x4 x5 .", "predict": "lstar_inv_ind : x1 : Set -> x2 : relation x1 -> x3 : N -> x4 : x1 -> x5 : x1 -> _Hterm : lstar x1 x2 x3 x4 x5 -> P : (_z2089 : N -> _z2088 : x1 -> _z2087 : x1 -> Prop) -> _H1 : (b : x1 -> _z2092 : Eq x3 0 -> _z2091 : Eq x4 b -> _z2090 : Eq x5 b -> P 0 b b) -> _H2 : (b1 : x1 -> b : x1 -> _x_1236 : x2 b1 b -> l : N -> b2 : x1 -> _x_1235 : lstar x1 x2 l b b2 -> _x_1238 : (_z2092 : Eq x3 l -> _z2091 : Eq x4 b -> _z2090 : Eq x5 b2 -> P l b b2) -> _z2092 : Eq x3 (l + 1) -> _z2091 : Eq x4 b1 -> _z2090 : Eq x5 b2 -> P (l + 1) b1 b2) -> P x3 x4 x5 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nMax_exists. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n , m \\in N$. Då om $m < n$ och $f (m)= true$, så för alla funktioner $__2$ från naturliga tal $i$ och element $__2$ av $Lt$ av $m$ och $i$ och element $__3$ av $Lt$ av $i$ och $n$ till element av $Eq$ av $f (i)$ och kontradiktion, $max (n , f)= m$.\nassistant\n", "label": "Axiom max_exists : forall f : ((x__ : nat) -> bool), forall n : nat, forall m : nat, forall x__ : (m < n), forall __1 : (f m = true), forall __2 : ((i : nat) -> (__2 : m < i) -> (__3 : i < n) -> f i = false), max n f = m .", "predict": "Axiom max_exists : forall f : nat -> bool, forall n : Nat, forall m : Nat, forall __2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) (contradiction), forall max : nat -> bool, nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nACop_rect_CProp4. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_903$ av $ACop$ av $A$ och $_nil$ till påståenden. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $Q_$ av $mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$. Då för alla element $x_903$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_903$.\nassistant\n", "label": "Axiom ACop_rect_CProp4 : forall A : Set, forall _nil : A, forall Q_ : ((_x_903 : ACop A _nil) -> Prop), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)), forall x_903 : ACop A _nil, Q_ x_903 .", "predict": "Axiom ACop_rect_CProp4 : forall A : Set, forall _nil : A, forall Q_ : ((_x_903 : ACop A _nil) -> Prop), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop) a b) -> Q_ (mk_ACop A _nil aop _comm)), forall x_903 : ACop A _nil, Q_ x_903 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1600. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then $n c - m d$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "let_clause_1600 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (gcd m n) (minus (times n c) (times m d)) .", "predict": "let_clause_1600 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1 | Eq (d m - c n) 1) -> d : Nat -> c n - d m = 1 -> n c - m d = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_maxr. Låt $i$ och $n$ och $m$ vara naturliga tal. Anta att $max$ applicerat på $n$ och $m$ är mindre än eller lika med $i$. Då är $m$ mindre än eller lika med $i$.\nassistant\n", "label": "le_maxr : i : Nat -> n : Nat -> m : Nat -> __ : Leq (max n m) i -> Leq m i .", "predict": "le_maxr : i : nat -> n : nat -> m : nat -> max n m <= i -> m <= i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_rect_Type4_body. För alla naturliga tal $_n$ och $_m$ och $_q$ och $_r$, för alla funktioner $Q_$ från element $_x_813$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till element av $Type4$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_815$ av $Lt$ av $_r$ och $_m$ och element $x_814$ av $Eq$ av $_n$ och summan av produkten av $_q$ och $_m$ och $_r$ till element av $Q_$ av $div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_815$ och $x_814$, för alla element $x_813$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_813$.\nassistant\n", "label": "axiom div_mod_spec_rect_Type4_body (_n _m _q _r : Nat) (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) (_H_div_mod_spec_intro : (x_815 : _r < _m) -> (x_814 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) (x_813 : div_mod_spec _n _m _q _r) : Q_ x_813", "predict": "axiom div_mod_spec_rect_Type4_body (_n _m _q _r : Nat) (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (sum_of_product _q _m _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) (x_813 : div_mod_spec _n _m _q _r) : Q_ x_813"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15441. Soit $p , q \\in N$. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soient $m$ et $n$ des nombres naturels. Supposons que $0 < n$ et $n \\leq m$. Supposons que $n \\leq q + 1$ et $n$ n'est pas divisible par $m$. Soit $a \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b$ un nombre naturel. Supposons que $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ ou $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$ et $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Alors $n b - a mod (m , n)= gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "let_clause_15441 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n)) .", "predict": "let_clause_15441 : p : N -> q : N -> Hind : (m : N -> n : N -> Lt : 0 -> n -> __1 : Leq n -> m -> __2 : Leq n -> q -> ex : Nat -> (a : N -> ex Nat) -> b : N -> Eq (diff (prod a n) (prod b m)) -> gcd_aux q m n) -> m : N -> n : N -> 0 < n -> n <= m -> n <= q + 1 -> n != (m * k) -> a : N -> _clearme : ex Nat -> (b : N -> Eq (diff (prod a (mod m n)) (prod b n)) -> gcd_aux q n (mod m n)) -> (b : N -> Eq (diff (prod b n) (prod a (mod m n))) -> gcd_aux q n (mod m n)) -> n b - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> b : N -> a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> n b - a mod (m , n) = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAop_rect_Type5_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_865$ av $Aop$ av $A$ och $_nil$ till element av $Type5$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_865$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_865$.\nassistant\n", "label": "Aop_rect_Type5_body : A : Set -> _nil : A -> Q_ : (_x_865 : Aop A _nil -> Type5) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_865 : Aop A _nil -> Q_ x_865 .", "predict": "Aop_rect_Type5_body : A : Set -> _nil : A -> Q_ : (_x_865 : Aop A _nil -> Type5) -> _H_mk_Aop : (op : (a : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_865 : Aop A _nil -> Q_ x_865 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDop_rect_Type0. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_955$ av $Dop$ av $A$ och $_nil$ till mängder, för alla funktioner $_H_mk_Dop$ från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $Q_$ av $mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_955$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_955$.\nassistant\n", "label": "axiom Dop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955", "predict": "axiom Dop_rect_Type0 (A : Set) (_nil : A) (Q_ : (_x_955 : Dop A _nil) -> Set) (_H_mk_Dop : (sum : Aop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) (x_955 : Dop A _nil) : Q_ x_955"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Alors pour tous les nombres naturels $a$, si $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$, alors si $a$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $a$ est égal à $i$, alors pour tous les nombres naturels $b$, si $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$, alors si $b$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $b$ est égal à $j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : Nat -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (b : Nat) -> (__ : (i0 : Nat) -> (x : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a : b) -> f a == j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_16004. Låt $m , n , a , b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Då för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nassistant\n", "label": "Axiom let_clause_16004 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c .", "predict": "Axiom let_clause_16004 : forall m : N, forall n : N, forall a : N, forall b : N, forall c : N, forall _clearme : ex Nat (fun d => Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1) (Eq (skillnaden (produkten av d och m) (produkten av c och n)) 1), forall d : N, if skillnaden (produkten av c och n) (produkten av d och m) = 1 then skillnadelet_clause_16004 : forall m : N, forall n : N, forall a : N, forall b : N, forall c : N, forall _clearme : ex Nat (fun d => Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1) (Eq (skillnaden (produkten av d och m) (produkten av c och n)) 1), forall d : N, if skillnaden (produkten av c och n) (produkten av d och m) = 1 then skillnaden (produkten av d och m) (produkten av c och n) = 1 -> skillnaden (produkten av d och m) (skillnaden (produkten av c och n) (produkten av d och m)) = 1 -> skillnaden (produkten av m och d) (produkten av n et c) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1561. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$. Då om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$ lika med $1$.\nassistant\n", "label": "Axiom let_clause_1561 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (a * p - b * m = gcd p m), forall H0 : (a * p - b * m = 1), p * a - m * b = 1 .", "predict": "Axiom let_clause_1561 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : N, forall _clearme0 : ex Nat (fun b => Eq (skillnaden (produkt av a och p) (produkt av b och m)) (det största gemensama delaret av p och m) . Eq (skillnaden (produkt av b och m) (produkt av a och p)) (det största gemensama delaret av p och m)), forall b : Nat, ((skillnaden (produkt av a och p) (produkt av b och m)) = (det största gemensama delaret av p och m) -> (skillnaden (produkt av b och m) (produkt av a och p)) = (det största gemensama delaret av p och m) -> (skillnaden (produkt av a och p) (produkt av b och m)) = (det största gemensama delaret av p och m)) -> ((skillnaden (produkt av a och p) (produkt av b och m)) = 1 -> (skillnaden (produkt av p och a) (produkt av m et b)) = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_S_times_2. Let $n$ be a natural number. Then if $0 < n$, then $n + 1 \\leq 2 n$.\nassistant\n", "label": "axiom le_S_times_2 (n : Nat) (x__ : 0 < n) : n + 1 ≤ 2 * n", "predict": "axiom le_S_times_2 (n : Nat) : Bool => if n > 0 then n + 1 <= 2 * n else False"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLt_O_S. Låt $n$ vara ett naturligt tal. Då är $0$ mindre än summan av $n$ och $1$.\nassistant\n", "label": "Axiom lt_O_S : forall n : nat, 0 < n + 1 .", "predict": "Axiom lt_O_S : nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nRange_rect_Type3. Soit $_A$ un ensemble. Soit $Q_$ une fonction des éléments $_x_921$ de $range$ de $_A$ à des éléments de $Type3$. Alors pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range (_A , _enum , _upto , _filter)$, pour tous les éléments $x_921$ de $range$ de $_A$, $Q_$ tient pour $x_921$.\nassistant\n", "label": "range_rect_Type3 : _A : Set -> Q_ : (_x_921 : range _A -> Type3) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_921 : range _A -> Q_ x_921 .", "predict": "range_rect_Type3 : _A : Set -> Q_ : (_x_921 : range _A -> Type3) -> _H_mk_range : (_enum : (n : Nat -> _A) -> _upto : Nat -> _filter : (n : Nat -> Bool) -> mk_range _A _enum _upto _filter) -> x_921 : range _A -> Q_ x_921 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDiv_mod_spec_ind. Soient $_n$ et $_m$ et $_q$ et $_r$ des nombres naturels. Soit $Q_$ une fonction des éléments $_x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_811$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_810$ de $Eq$ de $_n$ et de $_q _m + _r$ à des éléments de $Q_$ de $div_mod_spec_intro (_n , _m , _q , _r , x_811 , x_810)$. Alors pour tous les éléments $x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_809$.\nassistant\n", "label": "Axiom div_mod_spec_ind : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_809 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_811 : _r < _m) -> (x_810 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)), forall x_809 : div_mod_spec _n _m _q _r, Q_ x_809 .", "predict": "Axiom div_mod_spec_ind : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_809 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_811 : Lt _r _m) -> (x_810 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)), forall x_809 : div_mod_spec _n _m _q _r, Q_ x_809 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLstar_ind_r_aux. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $b1$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b1$. Soit $__1$ une fonction des nombres naturels $l$ et des éléments $b$ de $B$ et des éléments $b2$ de $B$ et des éléments $__1$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b$ et des éléments $__2$ de $R$ de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de $l + 1$ et de $b2$. Soit $l$ un nombre naturel. Soient $b$ et $b2$ des éléments de $B$. Alors pour tous les éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$, si $b = b1$, alors $P$ tient pour $l$ et $b2$.\nassistant\n", "label": "Axiom lstar_ind_r_aux : forall B : Set, forall R : relation B, forall b1 : B, forall P : relation2 nat B, forall x__ : P 0 b1, forall __1 : ((l : nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2), forall l : nat, forall b : B, forall b2 : B, forall __2 : lstar B R l b b2, forall __3 : (b = b1), P l b2 .", "predict": "Axiom lstar_ind_r_aux : forall B : set, forall R : relation B, forall b1 : B, forall P : relation2 Nat B, forall __ : P 0 b1, forall __1 : ((l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2), forall l : Nat, forall b : B, forall b2 : B, forall __2 : lstar B R l b b2, b = b1 -> P l b2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNot_bertrand_to_le_B. Låt $n$ vara ett naturligt tal. Då om $2 ^ 7 \\leq n$, så för alla element $__1$ av $not_bertrand$ av $n$, $B (2 n)\\leq 2 ^ (2 (2 n \\div 3))(2 n ^ pred (\\sqrt{ (2 n)}\\div 2))$.\nassistant\n", "label": "not_bertrand_to_le_B : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> __1 : not_bertrand n -> Leq (B (times (nd 2) n)) (times (pow (nd 2) (times (nd 2) (div (times (nd 2) n) (nd 3)))) (pow (times (nd 2) n) (pred (div (sqrt (times (nd 2) n)) (nd 2))))) .", "predict": "not_bertrand_to_le_B : n : Nat -> __1 : not_bertrand n -> B (2 n) <= 2^(2 (2 n div 3)) (2 n ^ pred (sqrt (2 n) div 2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nBigop_body. Låt $__ \\in N$. Låt $__1$ vara en funktion från naturliga tal $__1$ till sanningsvärden. Låt $H$ vara en mängd. Låt $__2$ vara ett element av $H$. Låt $__3$ vara en funktion från element $__3$ av $H$ och element $__4$ av $H$ till element av $H$. Låt $__4$ vara en funktion från naturliga tal $__4$ till element av $H$. Då $H$.\nassistant\n", "label": "axiom bigop_body (x__ : Nat) (__1 : (__1 : Nat) -> bool) (H : Set) (__2 : H) (__3 : (__3 : H) -> (__4 : H) -> H) (__4 : (__4 : Nat) -> H) : H", "predict": "axiom bigop_body (__ : N) (__1 : (__ : N) -> Bool) (H : Set) (__2 : H) (__3 : (__3 : H) -> (__4 : H) -> H) (__4 : (__4 : N) -> H) : H"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nPlus_n_Sm. För alla naturliga tal $n$ och $m$, $n + m + 1 = n + (m + 1)$.\nassistant\n", "label": "axiom plus_n_Sm (n m : Nat) : n + m + 1 = n + (m + 1)", "predict": "axiom plus_n_Sm (n m : Nat) : Nat := n + (m + 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_n_n. Let $n$ be a natural number. Then if $0$ is less than $n$, then $mod$ applied to $n$ and $n$ is equal to $0$.\nassistant\n", "label": "mod_n_n : n : Nat -> __ : Lt 0 n -> Eq (mod n n) 0 .", "predict": "mod_n_n : n : Nat -> 0 < n -> mod n n = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nRange_rect_CProp0_body. För alla mängder $_A$, för alla funktioner $Q_$ från element $_x_939$ av $range$ av $_A$ till påståenden, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A , _enum , _upto , _filter)$, för alla element $x_939$ av $range$ av $_A$, håller $Q_$ för $x_939$.\nassistant\n", "label": "range_rect_CProp0_body : _A : Set -> Q_ : (_x_939 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_939 : range _A -> Q_ x_939 .", "predict": "range_rect_CProp0_body : _A : Set -> Q_ : (_x_939 : range _A -> Prop) -> _H_mk_range : (_enum : (x : nat -> _A) -> _upto : nat -> _filter : (x : nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_939 : range _A -> Q_ x_939 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMax_spec_inv_ind. Låt $x1 \\in N$. Låt $x2$ vara en funktion från naturliga tal till sanningsvärden. Låt $x3 \\in N$. Låt $_Hterm$ vara ett element av $max_spec$ av $x1$ och $x2$ och $x3$. Låt $P$ vara en funktion från naturliga tal $_z1769$ till påståenden. Låt $_H1$ vara en funktion från naturliga tal $m$ och element $_x_975$ av $Lt$ av $m$ och $x1$ och element $_x_974$ av $Eq$ av $x2 (m)$ och $true$ och funktioner $_x_973$ från naturliga tal $i$ och element av $Lt$ av $m$ och $i$ och element $__1$ av $Lt$ av $i$ och $x1$ till element av $Eq$ av $x2 (i)$ och kontradiktion och element $_z1770$ av $Eq$ av $x3$ och $m$ till element av $P$ av $m$. Låt $_H2$ vara en funktion från funktioner $_x_976$ från naturliga tal $i$ och element av $Lt$ av $i$ och $x1$ till element av $Eq$ av $x2 (i)$ och kontradiktion och element $_z1770$ av $Eq$ av $x3$ och $0$ till element av $P$ av $0$. Då håller $P$ för $x3$.\nassistant\n", "label": "axiom max_spec_inv_ind (x1 : Nat) (x2 : (x__ : Nat) -> bool) (x3 : Nat) (_Hterm : max_spec x1 x2 x3) (P : (_z1769 : Nat) -> Prop) (_H1 : (m : Nat) -> (_x_975 : m < x1) -> (_x_974 : x2 m = true) -> (_x_973 : (i : Nat) -> (x__ : m < i) -> (__1 : i < x1) -> x2 i = false) -> (_z1770 : x3 = m) -> P m) (_H2 : (_x_976 : (i : Nat) -> (x__ : i < x1) -> x2 i = false) -> (_z1770 : x3 = 0) -> P 0) : P x3", "predict": "axiom max_spec_inv_ind (x1 : N) (x2 : (nat : Set) -> Set) (x3 : N) (_Hterm : max_spec x1 x2 x3) (P : (_z1769 : Nat) -> Set) (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq x2 m true) -> (_x_973 : (i : Nat) -> (Lt m i) -> (__1 : Lt i x1) -> Eq x2 i) -> (_z1770 : Eq x3 m) -> P m) (_H2 : (_x_976 : (i : Nat) -> Lt i x1) -> (_z1770 : Eq x3 0) -> P 0) : P x3"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_10336. Soit $n , m \\in N$. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi$ appliqué à $p$ et du produit de $pred$ appliqué à $p$ et de la puissance de $2$ et de la différence du produit de $2$ et de $p$ et de $3$. Soit $a$ un nombre naturel. Supposons que $m$ est égal au produit de $2$ et de $a$ ou $m$ est égal à la somme du produit de $2$ et de $a$ et de $1$. Supposons que $m$ est égal à la somme du produit de $2$ et de $a$ et de $1$. Supposons que $1$ est inférieur à la somme du produit de $2$ et de $a$ et de $1$. Supposons que $0$ est inférieur à $a$. Soient $x2515$ et $x2516$ des nombres naturels. Alors $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nassistant\n", "label": "Axiom let_clause_10336 : forall n : nat, forall m : nat, forall Hind : ((p : nat) -> (x__ : p < m) -> (__1 : 1 < p) -> Leq (Psi p) (pred p * pow 2 (2 * p - 3))), forall a : nat, forall _clearme : (m = 2 * a \\/ m = 2 * a + 1), forall Hm : (m = 2 * a + 1), forall Hlt : (1 < 2 * a + 1), forall Ha : (0 < a), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_10336 : forall n : N, forall m : N, forall Hind : ((p : N) -> (__1 : Lt p m) -> (__2 : Lt 1 p) -> Leq (Psi p) (pred p * (2 ** (diff (2 * p) 3)))), forall a : N, ((m : N) -> (m = (2 * a) -> m = (2 * a) + 1 -> m = (2 * a) + 1 -> 1 < (2 * a) + 1 -> 0 < a) -> (x2515 : N) -> (x2516 : N) -> x2515 = (x2516 * (x2515 / x2516)) + (mod x2515 x2516)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBigop_sumI. Let $a , b , c \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $Aop$ of $B$ and $nil$. Let $f$ be a function from natural numbers to elements of $B$. Assume that $a \\leq b$ and $b \\leq c$. Then $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to the difference of $c$ and $b$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $b$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $b$ and $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$ is equal to $bigop$ applied to the difference of $c$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$.\nassistant\n", "label": "bigop_sumI : a : Nat -> b : Nat -> c : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq a b -> __1 : Leq b c -> Eq (bigop (minus c a) (i : Nat => (i0 : Nat => p i0) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a))) (op B nil op (bigop (minus c b) (i : Nat => (i0 : Nat => p i0) (plus i b)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i b))) (bigop (minus b a) (i : Nat => (i0 : Nat => p i0) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a)))) .", "predict": "bigop_sumI : a : N -> b : N -> c : N -> p : (N -> Bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (N -> B) -> a <= b -> b <= c -> op B nil (op (bigop (c - b) (i : N => (i0 : N => p i0) (sum i b)) B nil (op B nil (op (i : N => (i0 : N => f i0) (sum i b)) (bigop (b - a) (i : N => (i0 : N => p i0) (sum i a)) B nil (op B nil (op (i : N => (i0 : N => f i0) (sum i a))))) (i : N => (i0 : N => f i0) (sum i a))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1033. Låt $n$ vara ett naturligt tal. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $g1$ och $g2$ vara funktioner från naturliga tal till naturliga tal. Låt $n1$ vara ett naturligt tal. Låt $Hind$ vara en funktion från funktioner från naturliga tal $i$ och element av $Lt$ av $i$ och $n1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$ och funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n1$ och element $__2$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$ till element av $Leq$ av $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$. Låt $H1$ vara en funktion från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$. Låt $H2$ vara en funktion från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$. Anta att $p2 (n1)= true$. Anta att $p1 (n1)= true$. Låt $x2515$ och $x2516$ vara naturliga tal. Då $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_1033 : forall n : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall g1 : ((x__ : nat) -> nat), forall g2 : ((x__ : nat) -> nat), forall n1 : nat, forall Hind : ((x__ : (i : nat) -> (x__ : i < n1) -> (__1 : p1 i = true) -> p2 i = true) -> (__1 : (i : nat) -> (__1 : i < n1) -> (__2 : p1 i = true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (fun i => p1 i) nat 0 plus (fun i => g1 i)) (bigop n1 (fun i => p2 i) nat 0 plus (fun i => g2 i))), forall H1 : ((i : nat) -> (x__ : i < n1 + 1) -> (__1 : p1 i = true) -> p2 i = true), forall H2 : ((i : nat) -> (x__ : i < n1 + 1) -> (__1 : p1 i = true) -> Leq (g1 i) (g2 i)), forall Hp2 : (p2 n1 = true), forall Hp1 : (p1 n1 = true), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_1033 : forall n : nat, forall p1 : ((i : nat) -> bool), forall p2 : ((i : nat) -> bool), forall g1 : ((i : nat) -> nat), forall g2 : ((i : nat) -> nat), forall n1 : nat, forall Hind : ((f : (i : nat) -> Lt i n1) -> (__1 : Eq (p1 i) true) -> (__1 : (i : nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Eq (p2 i) true), forall H1 : ((i : nat) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true), forall H2 : ((i : nat) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)), forall p2_n1 : Eq (p2 n1) true, forall p1_n1 : Eq (p1 n1) true, forall x2515 : nat, forall x2516 : nat, x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBigop_a. Soit $a , b \\in N$. Alors pour tous les ensembles $B$, pour tous les éléments $nil$ de $B$, pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $a$ est inférieur ou ágal à $b$, alors $bigop$ appliqué à la différence de la somme de $b$ et de $1$ et de $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $a$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$ est égal à $op$ appliqué à $B$ et $nil$ et $op$ et $bigop$ appliqué à la différence de $b$ et de $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $a$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à le successeur de $i0$ appliqué à la somme de $i$ et de $a$ et $f$ appliqué à $a$.\nassistant\n", "label": "postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus (plus b 1) a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f (succ i0)) (plus i a))) (f a))", "predict": "postulate bigop_a : (a : N) -> (b : N) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (i : N) -> B) -> (a <= b) -> bigop (b - a) (\\ i : N -> (\\ i0 : N -> true) (\\ i : N -> a + i)) B nil op (\\ i : N -> (\\ i0 : N -> f i0) (\\ i : N -> a + i)) == op B nil op (bigop b (\\ i : N -> (\\ i0 : N -> true) (\\ i : N -> a + i)) B nil op (\\ i : N -> (\\ i0 : N -> f (succ i0)) (\\ i : N -> a + i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDiv_mod_spec_inv_rect_CProp1. Låt $x1 , x2 , x3 , x4 \\in N$. Låt $Hterm$ vara ett element av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Låt $P$ vara en funktion från element $_z1488$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden. Låt $_H1$ vara en funktion från element $x_855$ av $Lt$ av $x4$ och $x2$ och element $x_854$ av $Eq$ av $x1$ och $x3 x2 + x4$ och element $_z1489$ av $Eq$ av $Hterm$ och $div_mod_spec_intro (x1 , x2 , x3 , x4 , x_855 , x_854)$ till element av $P$ av $div_mod_spec_intro (x1 , x2 , x3 , x4 , x_855 , x_854)$. Då håller $P$ för $Hterm$.\nassistant\n", "label": "Axiom div_mod_spec_inv_rect_CProp1 : forall x1 : nat, forall x2 : nat, forall x3 : nat, forall x4 : nat, forall Hterm : div_mod_spec x1 x2 x3 x4, forall P : ((_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop), forall _H1 : ((x_855 : x4 < x2) -> (x_854 : x1 = x3 * x2 + x4) -> (_z1489 : Hterm = div_mod_spec_intro x1 x2 x3 x4 x_855 x_854) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)), P Hterm .", "predict": "Axiom div_mod_spec_inv_rect_CProp1 : forall x1 : N, forall x2 : N, forall x3 : N, forall x4 : N, forall Hterm : div_mod_spec x1 x2 x3 x4, forall P : ((_z1488 : div_mod_spec x1 x2 x3 x4) -> bool), forall _H1 : ((x_855 : Lt x4 x2) -> (x_854 : Eq x1 (x3 x2 + x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1571. Soient $m$ et $n$ des nombres naturels. Supposons que $0 < n$. Supposons que $0$ est égal au diviseur commun plus grand de $m$ et de $n$. Alors si $m = 0$, alors si $n = 0$, alors $m = n$.\nassistant\n", "label": "axiom let_clause_1571 (m n : Nat) (posn : 0 < n) (H : gcd m n = 0) (auto : m = 0) (auto' : n = 0) : m = n", "predict": "axiom let_clause_1571 (m n : Nat) (Hc : 0 < n) (Hd : 0 = gcd m n) (Hm : m = 0) (Hn : n = 0) : m = n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nRange_inv_rect_CProp2. Soit $x1$ un ensemble. Soit $Hterm$ un élément de $range$ de $x1$. Soit $P$ une fonction des éléments $_z1680$ de $range$ de $x1$ à des propositions. Soit $_H1$ une fonction des fonctions $_enum$ des nombres naturels à des éléments de $x1$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes et des éléments $_z1681$ de $Eq$ de $Hterm$ et de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $P$ de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$. Alors $P$ tient pour $Hterm$.\nassistant\n", "label": "Axiom range_inv_rect_CProp2 : forall x1 : Set, forall Hterm : range x1, forall P : ((_z1680 : range x1) -> Prop), forall _H1 : ((_enum : (x__ : nat) -> x1) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> (_z1681 : Hterm = mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)), P Hterm .", "predict": "Axiom range_inv_rect_CProp2 : forall x1 : ensemble, forall Hterm : range x1, forall P : ((_z1680 : range x1) -> proposition), forall _H1 : ((_enum : (n : nat) -> x1) -> (_upto : nat) -> (_filter : (n : nat) -> bool) -> (_z1681 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1544. Soient $p$ et $q$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soit $m , n \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $n$ est inférieur ou ágal à $m$. Supposons que $n$ est inférieur ou ágal à la somme de $q$ et de $1$. Supposons que $n$ n'est pas divisible par $m$. Soit $a \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b$ un nombre naturel. Supposons que la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ est égale à $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ ou la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n q) -> (ex : Nat) -> (a : Nat) -> (_clearme : ex) -> (b : Nat) -> Eq (difference (product a n) (product b m)) (gcd_aux q m n)) -> (m : Nat) -> (n : Nat) -> (0 : Lt n) -> (n : Lt m) -> (n : Lt (q + 1)) -> (n : Not (divisible m n)) -> (a : Nat) -> (_clearme : ex) -> (b : Nat) -> Eq (difference (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n))) -> (b : Nat) -> Eq (difference (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n))) -> Eq (difference (product b n) (product a (mod m n))) (gcd_aux q n (mod m n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1075. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $bijf$ vara ett element av $bijn$ av $f$ och summan av $n$ och $1$. Anta att $f$ applicerat på summan av $n$ och $1$ är lika med summan av $n$ och $1$. Låt $i \\in N$. Anta att $i$ är mindre än eller lika med $n$. Låt $a \\in N$. Anta att $a$ är mindre än eller lika med summan av $n$ och $1$ och $f$ applicerat på $a$ är lika med $i$. Då om $a$ är mindre än eller lika med summan av $n$ och $1$, så om $f$ applicerat på $a$ är lika med $i$, så om $a$ är lika med summan av $n$ och $1$, så är $i$ lika med $a$.\nassistant\n", "label": "axiom let_clause_1075 (f : (x__ : Nat) -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (fS : f (n + 1) = n + 1) (i : Nat) (lein : i ≤ n) (a : Nat) (_clearme : a ≤ n + 1 ∧ f a = i) (lean : a ≤ n + 1) (fa : f a = i) (Hc : a = n + 1) : i = a", "predict": "axiom let_clause_1075 (f : nat -> nat) (n : N) (bijf : bijn f (n + 1)) (i : N) (a : N) : (a <= (n + 1)) -> (f a = i) -> (a <= sum n (1 : N)) -> (f a = i) -> (a = sum n (1 : N)) -> (i = a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15441. Låt $p , q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m$ och $n$ vara naturliga tal. Anta att $0 < n$. Anta att $n \\leq m$. Då om $n \\leq q + 1$, så om $n$ inte är delbart med $m$, så för alla naturliga tal $a$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$, för alla naturliga tal $b$, om $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ eller $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, så om $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, så $n b - a mod (m , n)= gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "let_clause_15441 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n)) .", "predict": "let_clause_15441 : p : N -> q : N -> Hind : (m : N -> n : N -> __1 : Leq n m -> __2 : Leq n q -> ex : Nat -> (a : ex Nat -> b : disjunktion (Eq (skillnaden (produkten a n) (produkten b m)) (gcd_aux q m n)) -> Eq (skillnaden (produkten b m) (produkten a n)) (gcd_aux q m n))) -> m : N -> n : N -> 0 < n -> n <= m -> n <= q + 1 -> n ~m -> a : Nat -> _clearme : ex Nat -> (b : disjunktion (Eq (skillnaden (produkten a (mod m n)) (produkten b n)) (gcd_aux q n (mod m n))) -> Eq (skillnaden (produkten b n) (produkten a (mod m n))) (gcd_aux q n (mod m n))) -> b : Nat -> a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> n b - a mod (m , n) = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_ind_body. For all sets $_A$, for all functions $Q_$ from elements $_x_915$ of $range$ of $_A$ to propositions, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_915$ of $range$ of $_A$, $Q_$ holds for $x_915$.\nassistant\n", "label": "postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_915 : range _A) -> Q_ x_915", "predict": "postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A) -> Set) -> (_H_mk_range : (_enum : (x : Set) -> (_upto : Set) -> (_filter : (x : Set) -> Set) -> Set) -> (x_915 : range _A) -> Set) -> (x_915 : range _A) -> Q_ x_915"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_exp_to_le. Let $b$ and $n$ and $m$ be natural numbers. Assume that $1 < b$. Assume that $b ^ n \\leq b ^ m$. Then $n \\leq m$.\nassistant\n", "label": "le_exp_to_le : b : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) b -> __1 : Leq (pow b n) (pow b m) -> Leq n m .", "predict": "le_exp_to_le : b : Nat -> n : Nat -> m : Nat -> 1 < b -> b ^ n <= b ^ m -> n <= m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPi_p_primeb4. Låt $n$ vara ett naturligt tal. Då om $1 < n$, så är $bigop$ applicerat på summan av $n$ och $1$ och funktionen som avbildar $p$ som $primeb$ applicerat på $p$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $p$ som $bigop$ applicerat på logaritmen av $p$ och produkten av $2$ och $n$ och funktionen som avbildar $i$ som $true$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som potensen av $p$ och produkten av $2$ och kvoten av $n$ och potensen av $p$ och summan av $i$ och $1$ lika med $bigop$ applicerat på summan av produkten av $2$ och $n$ och $1$ och funktionen som avbildar $p$ som $primeb$ applicerat på $p$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $p$ som $bigop$ applicerat på logaritmen av $p$ och produkten av $2$ och $n$ och funktionen som avbildar $i$ som $true$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som potensen av $p$ och produkten av $2$ och kvoten av $n$ och potensen av $p$ och summan av $i$ och $1$.\nassistant\n", "label": "pi_p_primeb4 : n : Nat -> __ : Lt (nd 1) n -> Eq (bigop (plus (times (nd 2) n) (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) .", "predict": "pi_p_primeb4 : n : Nat -> 1 < n -> bigop (n + 1) (p : Nat => primeb p) Nat 1 times (p : Nat => bigop (log p (2 * n)) (i : Nat => true) Nat 1 times (i : Nat => poten p (2 * (n / poten p i)))) -> bigop (produkten av 2 och n) (p : Nat => primeb p) Nat 1 times (p : Nat => bigop (log p (2 * n)) (i : Nat => true) Nat 1 times (i : Nat => poten p (2 * (n / poten p i)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPermut_transpose_r. Soit $f$ une fonction des nombres naturels à des nombres naturels. Alors pour tous les nombres naturels $m$ et $i$ et $j$, si $i \\leq m$ et $j \\leq m$, alors pour tous les éléments $__2$ de $permut$ de $f$ et de $m$, $permut$ tient pour la fonction qui envoie $n$ à $f (transpose (i , j , n))$ et $m$.\nassistant\n", "label": "axiom permut_transpose_r (f : (x__ : Nat) -> Nat) (m i j : Nat) (x__ : i ≤ m) (__1 : j ≤ m) (__2 : permut f m) : permut (λ n => f (transpose i j n)) m", "predict": "axiom permut_transpose_r (f : Nat -> Nat) (m i j : Nat) (__2 : permut f m) : Nat => f (transpose i j)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_16002. Låt $m , n , a , b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nassistant\n", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (c n - d m) 1)) -> (d : Nat) -> (if c n - d m == 1 then m d - n c else d m - c n) -> (if d m - c n == 1 then m d - n c else d m - c n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_16171. Låt $p , m , n \\in N$. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller lika med $b m - a p$ och det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om $b m - a p = 1$, så är $m b - p a$ lika med det största gemensama delaret av $p$ och $m$.\nassistant\n", "label": "Axiom let_clause_16171 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (b * m - a * p = gcd p m), forall H0 : (b * m - a * p = 1), gcd p m = m * b - p * a .", "predict": "Axiom let_clause_16171 : forall p : N, forall m : N, forall n : N, forall c : Nat, forall a : Nat, forall _clearme0 : ex Nat (fun b => Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m) (Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m))), forall b : Nat, ((a p - b m) = (b m - a p)) -> (det största gemensama delaret av p och m) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> (b m - a p) -> ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_to_le_ord. Soit $p , n , m \\in N$. Alors si $0 < n$ et $0 < m$, alors si $p$ est premier et $n$ est divisible par $m$, alors $ord (n , p)\\leq ord (m , p)$.\nassistant\n", "label": "Axiom divides_to_le_ord : forall p : nat, forall n : nat, forall m : nat, forall x__ : (0 < n), forall __1 : (0 < m), forall __2 : prime p, forall __3 : divisible n m, Leq (ord n p) (ord m p) .", "predict": "Axiom divides_to_le_ord : forall p : N, forall n : N, forall m : N, 0 < n -> 0 < m -> p : premier -> n : divisible par m -> ord n p <= ord m p ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDiv_mod_spec_rect_Type0. Pour tous les nombres naturels $_n$ et $_m$ et $_q$ et $_r$, pour toutes les fonctions $Q_$ des éléments $_x_833$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des ensembles, pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_835$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_834$ de $Eq$ de $_n$ et de $_q _m + _r$ à des éléments de $Q_$ de $div_mod_spec_intro (_n , _m , _q , _r , x_835 , x_834)$, pour tous les éléments $x_833$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_833$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type0 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_833 : div_mod_spec _n _m _q _r) -> Set), forall _H_div_mod_spec_intro : ((x_835 : _r < _m) -> (x_834 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_835 x_834)), forall x_833 : div_mod_spec _n _m _q _r, Q_ x_833 .", "predict": "Axiom div_mod_spec_rect_Type0 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_833 : div_mod_spec _n _m _q _r) -> set), forall _H_div_mod_spec_intro : ((x_835 : Lt _r _m) -> (x_834 : Eq _n (_q _m + _r)) -> (Q_ (div_mod_spec_intro _n _m _q _r x_835 x_834))), forall x_833 : div_mod_spec _n _m _q _r, Q_ x_833 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nRange_inv_rect_Type2. Soit $x1$ un ensemble. Alors pour tous les éléments $Hterm$ de $range$ de $x1$, pour toutes les fonctions $P$ des éléments $_z1650$ de $range$ de $x1$ à des éléments de $Type2$, pour toutes les fonctions $_H1$ des fonctions $_enum$ des nombres naturels à des éléments de $x1$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes et des éléments $_z1651$ de $Eq$ de $Hterm$ et de $mk_range (x1 , _enum , _upto , _filter)$ à des éléments de $P$ de $mk_range (x1 , _enum , _upto , _filter)$, $P$ tient pour $Hterm$.\nassistant\n", "label": "axiom range_inv_rect_Type2 (x1 : Set) (Hterm : range x1) (P : (_z1650 : range x1) -> Type2) (_H1 : (_enum : (x__ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (x__ : Nat) -> bool) -> (_z1651 : Hterm = mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) : P Hterm", "predict": "axiom range_inv_rect_Type2 (x1 : Set) (Hterm : range x1) (P : (_z1650 : range x1) -> Type2) (_H1 : (_enum : (n : Nat) -> x1) -> (_upto : Nat) -> (_filter : (n : Nat) -> Bool) -> (_z1651 : Eq Hterm (mk_range (x1 , _enum , _upto , _filter))) -> P (mk_range (x1 , _enum , _upto , _filter))) : P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiv_mod_spec_inv_ind. Soient $x1$ et $x2$ et $x3$ et $x4$ des nombres naturels. Soit $Hterm$ un élément de $div_mod_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$. Soit $P$ une fonction des éléments $_z1434$ de $div_mod_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$ à des propositions. Soit $_H1$ une fonction des éléments $x_811$ de $Lt$ de $x4$ et de $x2$ et des éléments $x_810$ de $Eq$ de $x1$ et de $x3 x2 + x4$ et des éléments $_z1435$ de $Eq$ de $Hterm$ et de $div_mod_spec_intro (x1 , x2 , x3 , x4 , x_811 , x_810)$ à des éléments de $P$ de $div_mod_spec_intro (x1 , x2 , x3 , x4 , x_811 , x_810)$. Alors $P$ tient pour $Hterm$.\nassistant\n", "label": "div_mod_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1434 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_811 : Lt x4 x2 -> x_810 : Eq x1 (plus (times x3 x2) x4) -> _z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm .", "predict": "div_mod_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1434 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_811 : Lt x4 x2 -> x_810 : Eq x1 (x3 x2 + x4) -> _z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDivides_to_p_ord. Soient $p$ et $a$ et $b$ et $c$ et $d$ et $n$ et $m$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $p$ est premier. Supposons que $n$ est divisible par $m$. Alors si $p_ord (n , p)= mk_Prod (Nat , Nat , a , b)$, alors si $p_ord (m , p)= mk_Prod (Nat , Nat , c , d)$, alors $b$ est divisible par $d$ et $a \\leq c$.\nassistant\n", "label": "postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : Eq (p_ord n p) (mk_Prod Nat Nat a b)) -> (__5 : Eq (p_ord m p) (mk_Prod Nat Nat c d)) -> and (divisible b d) (Leq a c)", "predict": "postulate divides_to_p_ord : (p : Set Nat) -> (a : Set Nat) -> (b : Set Nat) -> (c : Set Nat) -> (d : Set Nat) -> (n : Set Nat) -> (m : Set Nat) -> (0 : Set Nat) -> (mk_Prod : (x : Set Nat) -> (y : Set Nat) -> (a : Set Nat) -> (b : Set Nat) -> Set Nat) -> (p_ord : (x : Set Nat) -> (p : Set Nat) -> Set Nat) -> (b : Set Nat) -> (d : Set Nat) -> (a : Set Nat) -> (c : Set Nat) -> Set Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLog_times_l. Låt $p , n , m \\in N$. Anta att $0 < n$. Anta att $0 < m$. Då om $1 < p$, så $\\log_ p {n}+ \\log_ p {m}\\leq \\log_ p {(n m)}$.\nassistant\n", "label": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))", "predict": "postulate log_times_l : (p : N) -> (n : N) -> (m : N) -> (0 : N) -> (0 : N) -> (1 : N) -> (p : N) -> (n : N) -> (m : N) -> log_ p {n} + log_ p {m} <= log_ p {(n * m)}"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nExp_n_O. Låt $n \\in N$. Anta att $0 < n$. Då $0 ^ n = 0$.\nassistant\n", "label": "axiom exp_n_O (n : Nat) (x__ : 0 < n) : pow 0 n = 0", "predict": "axiom exp_n_O (n : N) : 0 ^ n = 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDiv_mod_spec_inv_rect_CProp1. Soit $x1 , x2 , x3 , x4 \\in N$. Soit $Hterm$ un élément de $div_mod_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$. Soit $P$ une fonction des éléments $_z1488$ de $div_mod_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$ à des propositions. Soit $_H1$ une fonction des éléments $x_855$ de $Lt$ de $x4$ et de $x2$ et des éléments $x_854$ de $Eq$ de $x1$ et de $x3 x2 + x4$ et des éléments $_z1489$ de $Eq$ de $Hterm$ et de $div_mod_spec_intro (x1 , x2 , x3 , x4 , x_855 , x_854)$ à des éléments de $P$ de $div_mod_spec_intro (x1 , x2 , x3 , x4 , x_855 , x_854)$. Alors $P$ tient pour $Hterm$.\nassistant\n", "label": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (plus (times x3 x2) x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : N) -> (x2 : N) -> (x3 : N) -> (x4 : N) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (x3 x2 + x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Alors pour tous les nombres naturels $a$, si $a \\leq n$ et $f (a)= i$, alors si $a \\leq n$, alors si $f (a)= i$, alors pour tous les nombres naturels $b$, si $b \\leq n$ et $f (b)= j$, alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : Nat -> Nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPermut_transpose_r. Pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, pour tous les nombres naturels $m$ et $i$ et $j$, si $i$ est inférieur ou ágal à $m$, alors si $j$ est inférieur ou ágal à $m$, alors pour tous les éléments $__2$ de $permut$ de $f$ et de $m$, $permut$ tient pour la fonction qui envoie $n$ à $f$ appliqué à $transpose$ appliqué à $i$ et $j$ et $n$ et $m$.\nassistant\n", "label": "Axiom permut_transpose_r : forall f : ((x__ : nat) -> nat), forall m : nat, forall i : nat, forall j : nat, forall x__ : Leq i m, forall __1 : Leq j m, forall __2 : permut f m, permut (fun n => f (transpose i j n)) m .", "predict": "Axiom permut_transpose_r : forall f : nat -> nat, forall m : nat, forall i : nat, forall j : nat, forall __2 : permut f m, nat -> nat, forall n : nat, nat -> nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nPi_p_primeb5. Låt $n \\in N$. Då om $1 < n$, så är $bigop$ applicerat på summan av $n$ och $1$ och funktionen som avbildar $p$ som $primeb$ applicerat på $p$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $p$ som $bigop$ applicerat på logaritmen av $p$ och $n$ och funktionen som avbildar $i$ som $true$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som potensen av $p$ och produkten av $2$ och kvoten av $n$ och potensen av $p$ och summan av $i$ och $1$ lika med $bigop$ applicerat på summan av produkten av $2$ och $n$ och $1$ och funktionen som avbildar $p$ som $primeb$ applicerat på $p$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $p$ som $bigop$ applicerat på logaritmen av $p$ och produkten av $2$ och $n$ och funktionen som avbildar $i$ som $true$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som potensen av $p$ och produkten av $2$ och kvoten av $n$ och potensen av $p$ och summan av $i$ och $1$.\nassistant\n", "label": "axiom pi_p_primeb5 (n : Nat) (x__ : 1 < n) : bigop (2 * n + 1) (λ p => primeb p) Nat 1 times (λ p => bigop (log p (2 * n)) (λ i => true) Nat 1 times (λ i => pow p (2 * (n / pow p (i + 1))))) = bigop (n + 1) (λ p => primeb p) Nat 1 times (λ p => bigop (log p n) (λ i => true) Nat 1 times (λ i => pow p (2 * (n / pow p (i + 1)))))", "predict": "axiom pi_p_primeb5 (n : N) : Nat :=\nif 1 < n then\nbigop (n + 1) (λ p => primeb p) Nat 1 times (λ p => bigop (log p n) (λ i => true) Nat 1 times (λ i => potencia p (2 * (n / potencia p i)))) (λ i => sum (λ j => potencia p (j + 1)) (i))) else n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_15692. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$. Alors $m d - n c = 1$.\nassistant\n", "label": "axiom let_clause_15692 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : m * d - n * c = 1", "predict": "axiom let_clause_15692 (m n a b : Nat) (c : Nat) (_clearme : (d : Nat) -> Eq (c n - d m) 1) (d : Nat) : Eq (m d - n c) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1648. Soient $n$ et $q$ des nombres naturels. Supposons que $0$ est inférieur à $q$. Soit $n1$ un nombre naturel. Supposons que $n1$ est égal à la somme du produit de $bigop$ appliqué à la somme de $n1$ et de $1$ et la fonction qui envoie $m$ à $andb$ appliqué à $leb$ appliqué à $1$ et $m$ et $dividesb$ appliqué à $q$ et $m$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $m$ à $1$ et de $q$ et de $mod$ appliqué à $n1$ et $q$. Supposons que $q$ est divisible par la somme de $n1$ et de $1$ et la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$. Supposons que $q$ est divisible par la somme de $n1$ et de $1$. Supposons que la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$. Alors la somme de $n1$ et de $1$ est égale à la somme de $q$ et du produit de $q$ et du quotient de $n1$ et de $q$.\nassistant\n", "label": "axiom let_clause_1648 (n q : Nat) (posq : 0 < q) (n1 : Nat) (Hind : n1 = bigop (n1 + 1) (λ m => andb (leb 1 m) (dividesb q m)) Nat 0 plus (λ m => 1) * q + mod n1 q) (_clearme : divisible q (n1 + 1) ∧ n1 + 1 = (n1 / q + 1) * q) (divq : divisible q (n1 + 1)) (eqn1 : n1 + 1 = (n1 / q + 1) * q) : n1 + 1 = q + q * (n1 / q)", "predict": "axiom let_clause_1648 (n q : Nat) (n1 : Nat) : Bool :=\nandb (leb 1 n1) (dividesb q n1) ∧\n(q % n1 = 0) ∧\n(q / n1 = 1) ∧\n(q % (n1 + 1) = 0) ∧\n(q / (n1 + 1) = 1) ∧\n(n1 + 1 = q) ∧\n(q % (n1 + 1) = 0) ∧\n(q / (n1 + 1) = 1) →\n(n1 + 1 = q + (q * (n1 / q)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLstar_r_sn. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $l$ un nombre naturel. Soient $b$ et $b2$ des éléments de $B$. Soit $__$ un élément de $lstar_r$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$. Alors pour tous les éléments $b1$ de $B$, pour tous les éléments $__1$ de $R$ de $b1$ et de $b$, $lstar_r$ tient pour $B$ et $R$ et la somme de $l$ et de $1$ et $b1$ et $b2$.\nassistant\n", "label": "postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (plus l 1) b1 b2", "predict": "postulate lstar_r_sn : (B : Set) -> (R : Set) -> (l : Nat) -> (b : B) -> (b2 : B) -> (__ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (l + 1) b1 b2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_ord_log. Soit $n , p \\in N$. Supposons que $0 < n$ et $1 < p$. Alors $ord (n , p)\\leq \\log_ p {n}$.\nassistant\n", "label": "Axiom le_ord_log : forall n : nat, forall p : nat, forall x__ : (0 < n), forall __1 : (1 < p), Leq (ord n p) (log p n) .", "predict": "Axiom le_ord_log : forall n : N, forall p : N, 0 < n -> 1 < p -> ord (n , p) <= log_ p {n} ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_B2_exp. Let $n$ be a natural number. Assume that $2 ^ 7 \\leq n$. Then $B2 (2 n)\\leq 2 n ^ pred (\\sqrt{ (2 n)}\\div 2)$.\nassistant\n", "label": "Axiom le_B2_exp : forall n : nat, forall x__ : Leq (pow 2 7) n, Leq (B2 (2 * n)) (pow (2 * n) (pred (sqrt (2 * n) / 2))) .", "predict": "Axiom le_B2_exp : forall n : nat, 2 ^ 7 <= n -> B2 (2 n) <= 2 n ^ pred (sqrt (2 n) / 2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_16001. Soit $m , n , a , b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Supposons que $c n - d m = 1$. Alors $n c - m d$ est égal au diviseur commun plus grand de $m$ et de $n$.\nassistant\n", "label": "Axiom let_clause_16001 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), gcd m n = n * c - m * d .", "predict": "Axiom let_clause_16001 : forall m : N, forall n : N, forall a : N, forall b : N, forall c : Nat, forall _clearme : (d : Nat) -> Eq (Nat) (div (c * n) (d * m)) 1) (Eq (Nat) (div (d * m) (c * n)) 1), forall d : N, (c n - d m = 1) -> (n c - m d) = div (m) n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPlus_le_0. For all natural numbers $x$ and $y$, if the sum of $x$ and $y$ is less than or equal to $0$, then $x$ is equal to $0$ and $y$ is equal to $0$.\nassistant\n", "label": "plus_le_0 : x : Nat -> y : Nat -> __ : Leq (plus x y) 0 -> and (Eq x 0) (Eq y 0) .", "predict": "plus_le_0 : x : Nat -> y : Nat -> x + y <= 0 -> x = 0 -> y = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_plus_div. Let $m , n , q \\in N$. Assume that $0 < q$. Then $m \\div q + n \\div q \\leq (m + n)\\div q$.\nassistant\n", "label": "le_plus_div : m : Nat -> n : Nat -> q : Nat -> __ : Lt 0 q -> Leq (plus (div m q) (div n q)) (div (plus m n) q) .", "predict": "le_plus_div : m : N -> n : N -> q : N -> 0 < q -> m \\div q + n \\div q <= (m + n) \\div q ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nGcd_n_n. För alla naturliga tal $n$, är det största gemensama delaret av $n$ och $n$ lika med $n$.\nassistant\n", "label": "postulate gcd_n_n : (n : Nat) -> Eq (gcd n n) n", "predict": "postulate gcd_n_n : (n : Nat) -> n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_O_n_elim. Låt $n \\in N$. Anta att $0$ är mindre än $n$. Låt $P$ vara en funktion från naturliga tal $__1$ till påståenden. Låt $__1$ vara en funktion från naturliga tal $m$ till element av $P$ av summan av $m$ och $1$. Då håller $P$ för $n$.\nassistant\n", "label": "lt_O_n_elim : n : Nat -> __ : Lt 0 n -> P : (__1 : Nat -> Prop) -> __1 : (m : Nat -> P (plus m (nd 1))) -> P n .", "predict": "lt_O_n_elim : n : N -> P : (__1 : N -> påståenden) -> __1 : (m : N -> element av P av summan av m och 1) -> P(n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nRange_rect_CProp4. Soit $_A$ un ensemble. Alors pour toutes les fonctions $Q_$ des éléments $_x_929$ de $range$ de $_A$ à des propositions, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_929$ de $range$ de $_A$, $Q_$ tient pour $x_929$.\nassistant\n", "label": "postulate range_rect_CProp4 : (_A : Set) -> (Q_ : (_x_929 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_929 : range _A) -> Q_ x_929", "predict": "postulate range_rect_CProp4 : (_A : Set) -> (Q_ : (_x_929 : range _A) -> Set) -> (_H_mk_range : (_enum : (n : Set) -> (_a : Set) -> (_upto : Set) -> (_filter : (n : Set) -> Set) -> mk_range _A _enum _upto _filter) -> (x_929 : range _A) -> Set) -> (x_929 : range _A) -> Q_ x_929"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i$ and $j$ be natural numbers. Assume that $i \\leq n$ and $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b$ be a natural number. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Assume that $f (b)= j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$. Let $injf$ be an element of $injn$ of $f$ and $n$. Assume that $a = b$. Then $f (a)= i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (x : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a == b) -> f a"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nNat_rect_CProp1_body. För alla funktioner $Q_$ från naturliga tal $_x_409$ till påståenden, för alla element $_H_O$ av $Q_$ av $0$, för alla funktioner $_H_S$ från naturliga tal $x_410$ och element $_x_412$ av $Q_$ av $x_410$ till element av $Q_$ av $x_410 + 1$, för alla naturliga tal $x_409$, håller $Q_$ för $x_409$.\nassistant\n", "label": "Axiom nat_rect_CProp1_body : forall Q_ : ((_x_409 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_410 : nat) -> (_x_412 : Q_ x_410) -> Q_ (x_410 + 1)), forall x_409 : nat, Q_ x_409 .", "predict": "Axiom nat_rect_CProp1_body : forall Q_ : ((_x_409 : nat) -> Prop), forall _H_O : (Q_ 0), forall _H_S : ((x_410 : nat) -> (_x_412 : Q_ x_410) -> Q_ (x_410 + 1)), forall x_409 : nat, Q_ x_409 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_4_to_le_B_exp. Låt $n$ vara ett naturligt tal. Då om $4 < n$, så $B (2 n)\\leq 2 ^ (2 n - 2)$.\nassistant\n", "label": "postulate lt_4_to_le_B_exp : (n : Nat) -> (_ : Lt 4 n) -> Leq (B (times 2 n)) (pow 2 (minus (times 2 n) 2))", "predict": "postulate lt_4_to_le_B_exp : (n : Nat) -> (4 < n) -> B (2 n) <= 2 ^ (2 n - 2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_10471. Låt $n1 , n2 \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara ett element av $ACop$ av $B$ och $nil$. Låt $f1$ och $f2$ vara funktioner från naturliga tal till element av $B$. Låt $_clearme$ vara ett element av $iso$ av $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$. Låt $h$ vara en funktion från naturliga tal till naturliga tal. Låt $_clearme0$ vara ett element av $ex$ av $prod$ applicerat på $Set$ och $Set$ och $Nat$ och funktionen som avbildar $__$ som $Nat$ och funktionen som avbildar $k$ som konjunktionen av konjunktionen av $prod$ applicerat på $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applicerat på $Prop$ och $Prop$ och $Eq$ applicerat på $p1$ applicerat på $i$ och $true$ och funktionen som avbildar $__1$ som $Eq$ applicerat på $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $sub_hk$ applicerat på $h$ och $k$ och $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $sub_hk$ applicerat på $k$ och $h$ och $B$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$. Låt $k$ vara en funktion från naturliga tal till naturliga tal. Anta att $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applicerat på $Prop$ och $Prop$ och", "label": "Axiom let_clause_10471 : forall n1 : nat, forall n2 : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ACop B nil, forall f1 : ((x__ : nat) -> B), forall f2 : ((x__ : nat) -> B), forall _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2), forall h : ((x__ : nat) -> nat), forall _clearme0 : ex (prod Set Set nat (fun x__ => nat)) (fun k => prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop Prop (p1 i = true) (fun __1 => f1 i = f2 (h i)))) /\\ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) /\\ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)), forall k : ((x__ : nat) -> nat), forall _clearme1 : (prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop", "predict": "Axiom let_clause_10471 : forall n1 : N, forall n2 : N, forall p1 : nat -> bool, forall p2 : nat -> bool, forall B : Set, forall nil : B, forall op : Aop B nil, forall f1 : nat -> B, forall f2 : nat -> B, forall _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2), forall h : nat -> nat, forall _clearme0 : ex (prod Set Set Nat (fun __ => Nat)) (fun k => konjunktion (konjunktion (prod Set Prop Nat (fun i => prod Prop Prop (Lt i n1) (fun __ => prod Prop Prop (Eq (p1 i) true) (fun __1 => Eq (f1 i) (f2 (h i))))) (fun __1 => Eq (sub_hk h k) B) (mk_range B f1 n1 p1)) (mk_range B f2 n2 p2) (fun __1 => sub_hk k h B) (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))), forall k : nat -> nat, prod Set Set Nat (fun i => nat) (fun __ => nat) (fun i => sub_hk k i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_n_fact_n. Let $n$ be a natural number. Then $n \\leq n !$.\nassistant\n", "label": "postulate le_n_fact_n : (n : Nat) -> Leq n (factorial n)", "predict": "postulate le_n_fact_n : (n : Nat) -> n <= n !"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1648. Soit $n , q \\in N$. Supposons que $0 < q$. Soit $n1$ un nombre naturel. Alors si la somme du produit de $bigop$ appliqué à la somme de $n1$ et de $1$ et la fonction qui envoie $m$ à $andb$ appliqué à $leb$ appliqué à $1$ et $m$ et $dividesb$ appliqué à $q$ et $m$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $m$ à $1$ et de $q$ et de $mod (n1 , q)$ est égale à $n1$, alors si $q$ est divisible par $n1 + 1$ et $n1 + 1 = (n1 \\div q + 1)q$, alors si $q$ est divisible par $n1 + 1$, alors si $n1 + 1 = (n1 \\div q + 1)q$, alors $n1 + 1 = q + q (n1 \\div q)$.\nassistant\n", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : (n : N) -> (q : N) -> (n1 : N) -> (andb : (m : N) -> Nat) -> (dividesb : (q : N) -> (m : N) -> Nat) -> (plus : (m : N) -> Nat) -> (1 : N) -> (n1 : N) -> (q : N) -> (mod : (n1 : N) -> (q : N) -> Nat) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (postulate let_clause_1648 : (n : N) -> (q : N) -> (n1 : N) -> (andb : (m : N) -> Nat) -> (dividesb : (q : N) -> (m : N) -> Nat) -> (plus : (m : N) -> Nat) -> (1 : N) -> (n1 : N) -> (q : N) -> (mod : (n1 : N) -> (q : N) -> Nat) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (postulate let_clause_1648 : (n : N) -> (q : N) -> (n1 : N) -> (andb : (m : N) -> Nat) -> (dividesb : (q : N) -> (m : N) -> Nat) -> (plus : (m : N) -> Nat) -> (1 : N) -> (n1 : N) -> (q : N) -> (mod : (n1 : N) -> (q : N) -> Nat) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N) -> (n1 : N) -> (q : N"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_16005. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nassistant\n", "label": "let_clause_16005 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .", "predict": "let_clause_16005 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> c n - d m = 1 -> m d - n c = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_exp_to_lt. Låt $a , n , m \\in N$. Anta att $0 < a$. Då om $a ^ n < a ^ m$, så $n < m$.\nassistant\n", "label": "lt_exp_to_lt : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 a -> __1 : Lt (pow a n) (pow a m) -> Lt n m .", "predict": "lt_exp_to_lt : a : N -> n : N -> m : N -> 0 < a -> a ^ n < a ^ m -> n < m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPlus_minus_plus_plus_l. For all natural numbers $z$ and $x$ and $y$ and $h$, the difference of the sum of $z$ and the sum of $x$ and $h$ and the sum of $y$ and $h$ is equal to the difference of the sum of $z$ and $x$ and $y$.\nassistant\n", "label": "axiom plus_minus_plus_plus_l (z x y h : Nat) : z + (x + h) - (y + h) = z + x - y", "predict": "axiom plus_minus_plus_plus_l (z x y h : Nat) : Nat := (z + (x + h)) - (y + h) - (z + x) + y"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBigop_commute. Soit $n , m \\in N$. Soit $p11$ une fonction des nombres naturels à des valeurs booléennes. Soit $p12$ une fonction des nombres naturels et des nombres naturels $__1$ à des valeurs booléennes. Soit $p21$ une fonction des nombres naturels à des valeurs booléennes. Soit $p22$ une fonction des nombres naturels et des nombres naturels $__1$ à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $ACop$ de $B$ et de $nil$. Soit $f$ une fonction des nombres naturels et des nombres naturels $__1$ à des éléments de $B$. Supposons que $0 < n$ et $0 < m$. Soit $__2$ une fonction des nombres naturels $i$ et des nombres naturels $j$ et des éléments $__2$ de $Lt$ de $i$ et de $n$ et des éléments $__3$ de $Lt$ de $j$ et de $m$ à des éléments de $Eq$ de $andb (p11 (i), p12 (i , j))$ et de $andb (p21 (j), p22 (i , j))$. Alors $bigop$ appliqué à $m$ et la fonction qui envoie $j$ à $p21$ appliqué à $j$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $j$ à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p22$ appliqué à $i$ et $j$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $j$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p11$ appliqué à $i$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $bigop$ appliqué à $m$ et la fonction qui envoie $j$ à $p12$ appliqué à $i$ et $j$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $j$ à $f$ appliqué à $i$ et $j$.\nassistant\n", "label": "postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (_ : Nat) -> bool) -> (p12 : (_ : Nat) -> (__1 : Nat) -> bool) -> (p21 : (_ : Nat) -> bool) -> (p22 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (\\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\\ i : Nat -> bigop m (\\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\\ j : Nat -> f i j))) (bigop m (\\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\\ j : Nat -> bigop n (\\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\\ i : Nat -> f i j)))", "predict": "postulate bigop_commute : (n : N) -> (m : N) -> (p11 : (i : N) -> Bool) -> (p12 : (i : N) -> (__1 : N) -> Bool) -> (p21 : (j : N) -> Bool) -> (p22 : (i : N) -> (__1 : N) -> Bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (__1 : N) -> B) -> (__2 : (i : N) -> (j : N) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> bigop m (\\ j : N -> p21 j) B nil (aop__o__op B nil op) (\\ j : N -> bigop n (\\ i : N -> p22 i j) B nil (aop__o__op B nil op) (\\ i : N -> f i j))) == bigop n (\\ i : N -> p11 i) B nil (aop__o__op B nil op) (\\ i : N -> bigop m (\\ j : N -> p12 i j) B nil (aop__o__op B nil op) (\\ j : N -> f i j)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15611. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c \\in N$. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Alors si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$, alors si $b m - a p = 1$, alors $m b - p a = 1$.\nassistant\n", "label": "let_clause_15611 : p : Nat -> m : Nat -> n : Nat -> posn : Lt 0 p -> gcd1 : Eq (gcd p m) (nd 1) -> _clearme : divisible p (times m n) -> c : Nat -> nm : Eq (times m n) (times p c) -> a : Nat -> _clearme0 : ex Nat (b : Nat => or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> b : Nat -> _clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)) -> H : Eq (minus (times b m) (times a p)) (gcd p m) -> H0 : Eq (minus (times b m) (times a p)) (nd 1) -> Eq (minus (times m b) (times p a)) (nd 1) .", "predict": "let_clause_15611 : p : Nat -> m : Nat -> n : Nat -> 0 < p -> 1 = gcd p m -> p = m * n -> c : Nat -> m * n = p * c -> a : Nat -> _clearme0 : ex Nat (b : Nat => Eq (a * p - b * m) (gcd p m) -> Eq (b * m - a * p) (gcd p m)) -> b : Nat -> gcd p m = a * p - b * m -> gcd p m = b * m - a * p -> b * m - a * p = 1 -> m * b - p * a = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nPermut_fg. För alla funktioner $f$ och $g$ från naturliga tal till naturliga tal, för alla naturliga tal $n$, för alla element $__$ av $permut$ av $f$ och $n$, för alla element $__1$ av $permut$ av $g$ och $n$, håller $permut$ för funktionen som avbildar $m$ som $f$ applicerat på $g$ applicerat på $m$ och $n$.\nassistant\n", "label": "Axiom permut_fg : forall f : ((x__ : nat) -> nat), forall g : ((x__ : nat) -> nat), forall n : nat, forall x__ : permut f n, forall __1 : permut g n, permut (fun m => f (g m)) n .", "predict": "Axiom permut_fg : forall f : nat -> nat, forall g : nat -> nat, forall n : nat, forall __ : permut f n, forall __1 : permut g n, permut (fun m => f (g m)) n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i \\leq n$. Assume that $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$. Assume that $a \\leq n$. Then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$, then if $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nassistant\n", "label": "let_clause_1068 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) i .", "predict": "let_clause_1068 : f : (N -> N) -> n : N -> permf : permut f n -> i : N -> j : N -> a : N -> a <= n -> f (a) = i -> a <= n -> f (a) = i -> b : N -> b <= n -> f (b) = j -> b <= n -> f (b) = j -> __ : (i0 : N -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f (a) = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTimes_div. Let $a$ and $b$ and $c$ be natural numbers. Assume that $0 < b$ and $c$ is divisible by $b$. Then $a (b \\div c)= a b \\div c$.\nassistant\n", "label": "Axiom times_div : forall a : nat, forall b : nat, forall c : nat, forall x__ : (0 < b), forall __1 : divisible c b, a * (b / c) = a * b / c .", "predict": "Axiom times_div : forall a : nat, forall b : nat, forall c : nat, 0 < b -> c = b * nat -> a (b \\div c) = a b \\div c ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBigop_commute. Let $n$ and $m$ be natural numbers. Then for all functions $p11$ from natural numbers to booleans, for all functions $p12$ from natural numbers and natural numbers $__1$ to booleans, for all functions $p21$ from natural numbers to booleans, for all functions $p22$ from natural numbers and natural numbers $__1$ to booleans, for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers and natural numbers $__1$ to elements of $B$, if $0 < n$ and $0 < m$, then for all functions $__2$ from natural numbers $i$ and natural numbers $j$ and elements $__2$ of $Lt$ of $i$ and $n$ and elements $__3$ of $Lt$ of $j$ and $m$ to elements of $Eq$ of $andb (p11 (i), p12 (i , j))$ and $andb (p21 (j), p22 (i , j))$, $bigop$ applied to $m$ and the function that maps $j$ to $p21$ applied to $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $bigop$ applied to $n$ and the function that maps $i$ to $p22$ applied to $i$ and $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $j$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p11$ applied to $i$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $bigop$ applied to $m$ and the function that maps $j$ to $p12$ applied to $i$ and $j$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $j$ to $f$ applied to $i$ and $j$.\nassistant\n", "label": "bigop_commute : n : Nat -> m : Nat -> p11 : (__ : Nat -> bool) -> p12 : (__ : Nat -> __1 : Nat -> bool) -> p21 : (__ : Nat -> bool) -> p22 : (__ : Nat -> __1 : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (__ : Nat -> __1 : Nat -> B) -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : (i : Nat -> j : Nat -> __2 : Lt i n -> __3 : Lt j m -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (i : Nat => p11 i) B nil (aop__o__op B nil op) (i : Nat => bigop m (j : Nat => p12 i j) B nil (aop__o__op B nil op) (j : Nat => f i j))) (bigop m (j : Nat => p21 j) B nil (aop__o__op B nil op) (j : Nat => bigop n (i : Nat => p22 i j) B nil (aop__o__op B nil op) (i : Nat => f i j))) .", "predict": "bigop_commute : n : Nat -> m : Nat -> p11 : (i : Nat -> Bool) -> p12 : (i : Nat -> __1 : Nat -> Bool) -> p21 : (i : Nat -> Bool) -> p22 : (i : Nat -> __1 : Nat -> Bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (i : Nat -> __1 : Nat -> B) -> 0 < n -> 0 < m -> __2 : (i : Nat -> j : Nat -> __2 : Lt i n -> __3 : Lt j m -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> bigop m (j : Nat => p21 j) B nil (aop__o__op B nil op) (j : Nat => bigop n (i : Nat => p22 i j) B nil (aop__o__op B nil op) (i : Nat => f i j)) = bigop n (i : Nat => p11 i) B nil (aop__o__op B nil op) (i : Nat => bigop m (j : Nat => p12 i j) B nil (aop__o__op B nil op) (j : Nat => f i j)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Anta att $f (b)= j$. Låt $__$ vara en funktion från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$. Låt $injf$ vara ett element av $injn$ av $f$ och $n$. Anta att $a = b$. Då $f (a)= j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : nat -> nat) (n : nat) (permf : permut f n) (i j : nat) (a : nat) (b : N) (__ : (i0 : nat) -> (Leq i0 n) -> Leq (f i0) n) (injf : injn f n) (Hc : a = b) : f a = j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInvert_permut_f. For all functions $f$ from natural numbers to natural numbers, for all natural numbers $n$ and $m$, if $m \\leq n$, then for all elements $__1$ of $injn$ of $f$ and $n$, $invert_permut (n , f , f (m))= m$.\nassistant\n", "label": "axiom invert_permut_f (f : (x__ : Nat) -> Nat) (n m : Nat) (x__ : m ≤ n) (__1 : injn f n) : invert_permut n f (f m) = m", "predict": "axiom invert_permut_f (f : Nat -> Nat) (n m : Nat) (__1 : injn f n) : Nat := m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Anta att $f (b)= j$. Låt $__$ vara en funktion från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$. Låt $injf$ vara ett element av $injn$ av $f$ och $n$. Anta att $a = b$. Då $f (a)= j$.\nassistant\n", "label": "Axiom let_clause_1063 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = j .", "predict": "Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : N, forall b : N, forall __ : (i0 : nat -> Leq i0 n) -> Leq (f i0) n), forall injf : (f a = j), forall __ : (a = b), f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nF_max_true. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ vara ett naturligt tal. Låt $__$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och $Eq$ applicerat på $f$ applicerat på $i$ och $true$. Då är $f$ applicerat på $max$ applicerat på $n$ och $f$ lika med $true$.\nassistant\n", "label": "axiom f_max_true (f : (x__ : Nat) -> bool) (n : Nat) (x__ : ex Nat (λ i => i < n ∧ f i = true)) : f (max n f) = true", "predict": "axiom f_max_true (f : Nat -> Bool) (n : Nat) (__ : ex Nat (λ i => Lt i n && Eq (f i) true)) : f (max n (f n)) = true"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_15621. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$. Then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.\nassistant\n", "label": "axiom let_clause_15621 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : n * c - m * d = 1", "predict": "axiom let_clause_15621 (m n a b : Nat) (c : N) (_clearme : (d : Nat) -> Eq (diff (c * n) (d * m)) 1) (d : Nat) : Eq (diff (c * n) (d * m)) 1) : Eq (diff (n * c) (m * d)) 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_15441. Låt $p , q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m , n \\in N$. Anta att $0 < n$ och $n \\leq m$. Anta att $n \\leq q + 1$ och $n$ inte är delbart med $m$. Låt $a$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Låt $b \\in N$. Då om $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ eller $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$ och $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, så $n b - a mod (m , n)= gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "Axiom let_clause_15441 : forall p : nat, forall q : nat, forall Hind : ((m : nat) -> (n : nat) -> (x__ : 0 < n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex nat (fun a => ex nat (fun b => a * n - b * m = gcd_aux q m n \\/ b * m - a * n = gcd_aux q m n))), forall m : nat, forall n : nat, forall posn : (0 < n), forall lenm : Leq n m, forall lenS : Leq n (q + 1), forall ndivnm : (~ divisible n m), forall a : nat, forall _clearme : ex nat (fun b => a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall b : nat, forall _clearme0 : (a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall H : (b * n - a * mod m n = gcd_aux q n (mod m n)), n * b - a * mod m n = gcd_aux q n (mod m n) .", "predict": "Axiom let_clause_15441 : forall p : N, forall q : N, forall Hind : ((m : N) -> (n : N) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (fun a => ex Nat (fun b => disjunktion (Eq (skillnaden (produkten a n) (produkten b m)) (gcd_aux q m n)) (Eq (skillnaden (produkten b m) (produkten a n)) (gcd_aux q m n)))), forall m : N, forall n : N, forall 0 : N, forall nleq : (n <= m), forall nleqq : (n <= q + 1), forall nnotdiv : (n != delbart med m), forall a : Nat, forall _clearme : ex Nat (fun b => disjunktion (Eq (skillnaden (a (mod m n)) (b n)) (gcd_aux q n (mod m n))) (Eq (skillnaden (b n) (a (mod m n))) (gcd_aux q n (mod m n))), forall b : N, forall ambmod : ((a mod (m , n) - b n) = gcd_aux (q , n , mod (m , n))), forall bnotambmod : ((b n - a mod (m , n)) = gcd_aux (q , n , mod (m , n))), forall bnbmod : ((b n - a mod (m , n)) = gcd_aux (q , n , mod (m , n))), forall namb : (n b - a mod (m , n)) = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nFilter_divides. Låt $_n$ och $_m$ vara naturliga tal. Då för alla element $return_sort$ av $Sort$, för alla funktioner $return_type$ från element $z$ av $divisible$ av $_n$ och $_m$ till element av $return_sort$, för alla funktioner $return$ från element $z$ av $divisible$ av $_n$ och $_m$ till element av $return_type$ av $z$, om $_n$ är delbart med $_m$, så håller $return_type$ för $z$.\nassistant\n", "label": "axiom filter_divides (_n _m : Nat) (return_sort : Sort) (return_type : (z : divisible _n _m) -> return_sort) (return : (z : divisible _n _m) -> return_type z) (z : divisible _n _m) : return_type z", "predict": "axiom filter_divides (_n _m : Nat) (return_sort : Sort) (return_type : (z : divisible _n _m) -> return_sort) (return : (z : divisible _n _m) -> return_type z) (_n_divides_m : _n % _m == 0) : return_type z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBigop_commute. Låt $n , m \\in N$. Låt $p11$ vara en funktion från naturliga tal till sanningsvärden. Låt $p12$ vara en funktion från naturliga tal och naturliga tal $__1$ till sanningsvärden. Låt $p21$ vara en funktion från naturliga tal till sanningsvärden. Låt $p22$ vara en funktion från naturliga tal och naturliga tal $__1$ till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Då för alla element $op$ av $ACop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal och naturliga tal $__1$ till element av $B$, om $0$ är mindre än $n$, så om $0$ är mindre än $m$, så för alla funktioner $__2$ från naturliga tal $i$ och naturliga tal $j$ och element $__2$ av $Lt$ av $i$ och $n$ och element $__3$ av $Lt$ av $j$ och $m$ till element av $Eq$ av $andb$ applicerat på $p11$ applicerat på $i$ och $p12$ applicerat på $i$ och $j$ och $andb$ applicerat på $p21$ applicerat på $j$ och $p22$ applicerat på $i$ och $j$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p11$ applicerat på $i$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $bigop$ applicerat på $m$ och funktionen som avbildar $j$ som $p12$ applicerat på $i$ och $j$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $j$ som $f$ applicerat på $i$ och $j$ lika med $bigop$ applicerat på $m$ och funktionen som avbildar $j$ som $p21$ applicerat på $j$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $j$ som $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p22$ applicerat på $i$ och $j$ och $B$ och $", "label": "postulate bigop_commute : (n : Nat) -> (m : Nat) -> (p11 : (_ : Nat) -> bool) -> (p12 : (_ : Nat) -> (__1 : Nat) -> bool) -> (p21 : (_ : Nat) -> bool) -> (p22 : (_ : Nat) -> (__1 : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> (__1 : Nat) -> B) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : (i : Nat) -> (j : Nat) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (\\ i : Nat -> p11 i) B nil (aop__o__op B nil op) (\\ i : Nat -> bigop m (\\ j : Nat -> p12 i j) B nil (aop__o__op B nil op) (\\ j : Nat -> f i j))) (bigop m (\\ j : Nat -> p21 j) B nil (aop__o__op B nil op) (\\ j : Nat -> bigop n (\\ i : Nat -> p22 i j) B nil (aop__o__op B nil op) (\\ i : Nat -> f i j)))", "predict": "postulate bigop_commute : (n : N) -> (m : N) -> (p11 : (i : N) -> Bool) -> (p12 : (i : N) -> (__1 : N) -> Bool) -> (p21 : (j : N) -> Bool) -> (p22 : (j : N) -> (__1 : N) -> Bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (__1 : N) -> (__2 : N) -> B) -> (__2 : (i : N) -> (j : N) -> (__2 : Lt i n) -> (__3 : Lt j m) -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> bigop n (\\ i : N -> p11 i) B nil (aop__o__op B nil op) (\\ i : N -> bigop m (\\ j : N -> p12 i j) B nil (aop__o__op B nil op) (\\ j : N -> f i j))) == bigop m (\\ j : N -> p21 j) B nil (aop__o__op B nil op) (\\ j : N -> bigop n (\\ i : N -> p22 i j) B nil (aop__o__op B nil op) (\\ i : N -> f i j)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLt_div_S_div. Pour tous les nombres naturels $n$ et $m$, si $0 < m$, alors si $m ^ 2 \\leq n$, alors $n \\div (m + 1)< n \\div m$.\nassistant\n", "label": "lt_div_S_div : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Leq (pow m (nd 2)) n -> Lt (div n (plus m (nd 1))) (div n m) .", "predict": "lt_div_S_div : n : Nat -> m : Nat -> 0 < m -> m ^ 2 <= n -> n div (m + 1) < n div m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10331. Let $n$ be a natural number. Assume that $2 ^ 8 \\leq n$. Let $m$ be a natural number. Assume that $3 \\leq m$. Assume that $\\log_ 2 {m}+ 2 \\leq m$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_10331 : forall n : nat, forall len : Leq (pow 2 8) n, forall m : nat, forall lt2m : Leq 3 m, forall Hind : Leq (log 2 m + 2) m, forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_10331 : forall n : nat, forall m : nat, forall x2515 : nat, forall x2516 : nat, 2 ^ 8 <= n -> 3 <= m -> log_2 {m} + 2 <= m -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_exp1. Låt $n , m , p \\in N$. Anta att $0$ är mindre än $p$. Anta att $n$ är mindre än $m$. Då är potensen av $n$ och $p$ mindre än potensen av $m$ och $p$.\nassistant\n", "label": "postulate lt_exp1 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt n m) -> Lt (pow n p) (pow m p)", "predict": "postulate lt_exp1 : (n : N) -> (m : N) -> (p : N) -> (0 : N) < p -> n < m -> pot(n : N) ^ p < pot(m : N) ^ p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1062. Låt $a$ och $b$ och $q$ och $r$ och $q1$ och $r1$ vara naturliga tal. Då för alla element $_clearme$ av $div_mod_spec$ av $a$ och $b$ och $q$ och $r$, om $r < b$ och $a = q b + r$, så för alla element $_clearme0$ av $div_mod_spec$ av $a$ och $b$ och $q1$ och $r1$, om $r1 < b$ och $a = q1 b + r1$, så om $q$ inte är mindre än eller lika med $q1$, så $a = r1 + b q1$.\nassistant\n", "label": "Axiom let_clause_1062 : forall a : nat, forall b : nat, forall q : nat, forall r : nat, forall q1 : nat, forall r1 : nat, forall _clearme : div_mod_spec a b q r, forall ltrb : (r < b), forall spec : (a = q * b + r), forall _clearme0 : div_mod_spec a b q1 r1, forall ltr1b : (r1 < b), forall spec1 : (a = q1 * b + r1), forall leqq1 : (~ Leq q q1), a = r1 + b * q1 .", "predict": "Axiom let_clause_1062 : forall a : nat, forall b : nat, forall q : nat, forall r : nat, forall q1 : nat, forall r1 : nat, forall _clearme : div_mod_spec a b q r, forall _clearme0 : div_mod_spec a b q1 r1, forall q2 : nat, nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1562. Låt $m , n , a , b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så $n c - m d = 1$.\nassistant\n", "label": "axiom let_clause_1562 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : n * c - m * d = 1", "predict": "axiom let_clause_1562 (m n a b : Nat) (_clearme : ex Nat (λ d => Eq (c n - d m) 1)) (d : Nat) : Nat := if c n - d m = 1 || d m - c n = 1 || c n - d m = 1 then n c - m d else 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15624. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Då om $0$ är mindre än $n$, så om $0$ är mindre än $m$, så om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$ lika med $1$.\nassistant\n", "label": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skillnaden mellan produkten av c och n) (produkt av d och m)) 1) -> (d : Nat) -> (_0 : < n) -> (_1 : < m) -> (gcd : nat -> nat -> nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skillnaden mellan produkten av c och n) (produkt av d och m)) 1) -> (d : Nat) -> (_0 : < n) -> (_1 : < m) -> (gcd : nat -> nat -> nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skillnaden mellan produkten av c och n) (produkt av d och m)) 1) -> (d : Nat) -> (_0 : < n) -> (_1 : < m) -> (gcd : nat -> nat -> nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skillnaden mellan produkten av c och n) (produkt av d och m)) 1) -> (d : Nat) -> (_0 : < n) -> (_1 : < m) -> (gcd : nat -> nat -> nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skillnaden mellan produkten av c och n) (produkt av d och m)) 1) -> (d : Nat) -> (_0 : < n) -> (_postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skillnaden mellan produkten av c och n) (produkt av d och m)) 1) -> (d : Nat) -> (_0 : < n) -> (_1 : < m) -> (gcd : nat -> nat -> nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (skill"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDistr. Soit $A$ un ensemble. Alors pour tous les éléments $nil$ de $A$, pour tous les éléments $xxx$ de $Dop$ de $A$ et de $nil$, pour tous les éléments $a$ et $b$ et $c$ de $A$, $prod (A , nil , xxx , a , aop__o__op (A , nil , sum (A , nil , xxx), b , c))= aop__o__op (A , nil , sum (A , nil , xxx), prod (A , nil , xxx , a , b), prod (A , nil , xxx , a , c))$.\nassistant\n", "label": "axiom distr (A : Set) (nil : A) (xxx : Dop A nil) (a b c : A) : prod A nil xxx a (aop__o__op A nil (sum A nil xxx) b c) = aop__o__op A nil (sum A nil xxx) (prod A nil xxx a b) (prod A nil xxx a c)", "predict": "axiom distr (A : Set) (nil : A) (xxx : Dop A nil) (a b c : A) : Prod A nil xxx a (aop__o__op A nil (sum A nil xxx) b c)) = aop__o__op A nil (sum A nil xxx) (Prod A nil xxx a b) (Prod A nil xxx a c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp5_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_877$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil , a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a , _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a , op (b , c))$ and $op (op (a , b), c)$ to elements of $Q_$ of $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$, for all elements $x_877$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_877$.\nassistant\n", "label": "Axiom Aop_rect_CProp5_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_877 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_877 : Aop A _nil, Q_ x_877 .", "predict": "Axiom Aop_rect_CProp5_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_877 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op (_nil , a) a)) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_877 : Aop A _nil, Q_ x_877 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_ind. Soit $_n \\in N$. Soit $Q_$ une fonction des nombres naturels $x_417$ et des éléments $_x_418$ de $Leq$ de $_n$ et de $x_417$ à des propositions. Soit $_H_le_n$ un élément de $Q_$ de $_n$ et de $le_n$ appliqué à $_n$. Soit $_H_le_S$ une fonction des nombres naturels $m$ et des éléments $x_419$ de $Leq$ de $_n$ et de $m$ et des éléments $_x_421$ de $Q_$ de $m$ et de $x_419$ à des éléments de $Q_$ de la somme de $m$ et de $1$ et de $le_S$ appliqué à $_n$ et $m$ et $x_419$. Soit $x_417$ un nombre naturel. Supposons que $_n$ est inférieur ou ágal à $x_417$. Alors $Q_$ tient pour $x_417$ et $x_418$.\nassistant\n", "label": "postulate le_ind : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418", "predict": "postulate le_ind : (_n : N) -> (Q_ : (x_417 : N) -> (_x_418 : Leq _n x_417) -> P) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : N) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (m + 1) (le_S _n m x_419)) -> (x_417 : N) -> (_n : N) -> (_H_le : _n <= x_417) -> Q_ x_417 x_418"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nChecker_spec. Låt $tl$ vara en lista av naturliga tal. Låt $a \\in N$. Då för alla listor $l$ av naturliga tal, om $checker (l)= true$, så om $l = cons (Nat , a , tl)$, så för alla naturliga tal $p$, för alla element $__2$ av $mem$ av $Nat$ och $p$ och $tl$, håller $ex$ för $Nat$ och funktionen som avbildar $pp$ som konjunktionen av konjunktionen av $mem$ applicerat på $Nat$ och $pp$ och $l$ och $Lt$ applicerat på $pp$ och $p$ och $Leq$ applicerat på $p$ och produkten av $2$ och $pp$.\nassistant\n", "label": "checker_spec : tl : list Nat -> a : Nat -> l : list Nat -> __ : Eq (checker l) true -> __1 : Eq l (cons Nat a tl) -> p : Nat -> __2 : mem Nat p tl -> ex Nat (pp : Nat => and (and (mem Nat pp l) (Lt pp p)) (Leq p (times (nd 2) pp))) .", "predict": "checker_spec : tl : List Nat -> a : Nat -> l : List Nat -> p : Nat -> __2 : mem Nat p tl -> ex : Nat -> (pp : mem Nat p l -> Lt pp p -> Leq p (2 * pp)) -> true ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_to_le_min. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n , m \\in N$. Supposons que $n \\leq m$. Alors pour tous les nombres naturels $b$, $min (n , b , f)\\leq min (m , b , f)$.\nassistant\n", "label": "Axiom le_to_le_min : forall f : ((x__ : nat) -> bool), forall n : nat, forall m : nat, forall x__ : Leq n m, forall b : nat, Leq (min n b f) (min m b f) .", "predict": "Axiom le_to_le_min : forall f : nat -> bool, forall n : nat, forall m : nat, forall b : nat, min (n , b , f) <= min (m , b , f) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15691. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$. Then $n c - m d = 1$.\nassistant\n", "label": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .", "predict": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : (d : Nat -> Eq (c n - d m) 1) -> d : N -> c n - d m = 1 -> n c - m d = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15624. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Då om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så $m d - n c = 1$.\nassistant\n", "label": "axiom let_clause_15624 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : m * d - n * c = 1", "predict": "axiom let_clause_15624 (m n a b : Nat) (_clearme : ex Nat (λ d => Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1 (Eq (skillnaden (produkten av d och m) (produkten av c och n)) 1))) (d : Nat) : Nat => if (c n - d m) = 1 || (d m - c n) = 1 => if (d m - c n) = 1 => m d - n c = 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nPermut_invert_permut. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $__$ vara ett element av $permut$ av $f$ och $n$. Då håller $permut$ för $invert_permut (n , f)$ och $n$.\nassistant\n", "label": "axiom permut_invert_permut (f : (x__ : Nat) -> Nat) (n : Nat) (x__ : permut f n) : permut (invert_permut n f) n", "predict": "axiom permut_invert_permut (f : nat -> nat) (n : N) (__ : permut f n) : permut (invert_permut (n , f)) n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_16004. Låt $m , n , a , b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nassistant\n", "label": "axiom let_clause_16004 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c", "predict": "axiom let_clause_16004 (m n a b : N) (_clearme : ex Nat (λ d => Eq (c n - d m) 1)) (d : N) : Nat => if c n - d m = 1 then m d - n c else if d m - c n = 1 then m d - n c else m d - n c"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15611. Låt $p , m , n \\in N$. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$, så om $b m - a p = 1$, så $m b - p a = 1$.\nassistant\n", "label": "axiom let_clause_15611 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : b * m - a * p = gcd p m) (H0 : b * m - a * p = 1) : m * b - p * a = 1", "predict": "axiom let_clause_15611 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : ex Nat (λ b => Eq (product a p) (product b m) (gcd p m))) (b : Nat) : (gcd p m) = (if (gcd p m) = (a p - b m) then b m - a p else if (gcd p m) = (b m - a p) then 1 else 0) => m b - p a = 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_10471. Låt $n1$ och $n2$ vara naturliga tal. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara ett element av $ACop$ av $B$ och $nil$. Då för alla funktioner $f1$ och $f2$ från naturliga tal till element av $B$, för alla element $_clearme$ av $iso$ av $B$ och $mk_range (B , f1 , n1 , p1)$ och $mk_range (B , f2 , n2 , p2)$, för alla funktioner $h$ från naturliga tal till naturliga tal, för alla element $_clearme0$ av $ex$ av $prod$ applicerat på $Set$ och $Set$ och $Nat$ och funktionen som avbildar $__$ som $Nat$ och funktionen som avbildar $k$ som konjunktionen av konjunktionen av $prod$ applicerat på $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applicerat på $Prop$ och $Prop$ och $Eq$ applicerat på $p1$ applicerat på $i$ och $true$ och funktionen som avbildar $__1$ som $Eq$ applicerat på $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $sub_hk$ applicerat på $h$ och $k$ och $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $sub_hk$ applicerat på $k$ och $h$ och $B$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$, för alla funktioner $k$ från naturliga tal till naturliga tal, om $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applicerat på $Prop$ och $Prop$", "label": "Axiom let_clause_10471 : forall n1 : nat, forall n2 : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ACop B nil, forall f1 : ((x__ : nat) -> B), forall f2 : ((x__ : nat) -> B), forall _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2), forall h : ((x__ : nat) -> nat), forall _clearme0 : ex (prod Set Set nat (fun x__ => nat)) (fun k => prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop Prop (p1 i = true) (fun __1 => f1 i = f2 (h i)))) /\\ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) /\\ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)), forall k : ((x__ : nat) -> nat), forall _clearme1 : (prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop Prop (p1 i = true) (fun __1 => f1 i = f2 (h i)))) /\\ sub_hk h k", "predict": "Axiom let_clause_10471 : forall n1 : nat, forall n2 : nat, forall p1 : ((i : nat) -> Prop), forall p2 : ((i : nat) -> Prop), forall B : Set, forall nil : B, forall op : Aop B nil, forall f1 : ((i : nat) -> B), forall f2 : ((i : nat) -> B), forall _clearme : iso B (mk_range (B , f1 , n1 , p1) (mk_range (B , f2 , n2 , p2)), forall h : ((i : nat) -> nat), forall _clearme0 : ex (prod Set Set Nat (fun __ => Nat)) (fun k => konjunktion (konjunktion (prod Set Prop Nat (fun i => prod Prop Prop (Lt i n1) (fun __ => prod Prop Prop (Eq (p1 i) true) (fun __1 => Eq (f1 i) (f2 (h i))))) (fun _clearme0 => mk_range B f1 n1 p1)) (mk_range B f2 n2 p2) (fun _clearme1 => sub_hk (h k) B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) (fun i => sub_hk i (fun _clearme2 => Eq (f1 i) (f2 (h i))) B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)))), forall k : ((i : nat) -> nat), prod Set Prop Nat (fun i => Prod Prop Prop (Lt i n1) (fun __ => Eq (p1 i) true)) (fun _clearme3 => Eq (f1 n1) (f2 (k n1))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBijn_transpose. Soit $n , i , j \\in N$. Supposons que $i \\leq n$ et $j \\leq n$. Alors $bijn$ tient pour $transpose (i , j)$ et $n$.\nassistant\n", "label": "postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n", "predict": "postulate bijn_transpose : (n : N) -> (i : N) -> (j : N) -> bijn (transpose i j) n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFound_min_spec. Låt $n , b \\in N$. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $m \\in N$. Anta att $b \\leq m$. Anta att $m < n + b$. Anta att $f (m)= true$. Då för alla funktioner $__3$ från naturliga tal $i$ och element $__3$ av $Leq$ av $b$ och $i$ och element $__4$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $f (i)$ och kontradiktion, håller $min_spec$ för $n$ och $b$ och $f$ och $m$.\nassistant\n", "label": "postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m", "predict": "postulate found_min_spec : (n : N) -> (b : N) -> (f : (i : N) -> Bool) -> (m : N) -> (__3 : (i : N) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) kontradiktion) -> min_spec n b f m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLprim_invariant. Låt $n$ och $i$ vara naturliga tal. Låt $acc$ vara en lista av naturliga tal. Då om $1$ är mindre än $i$, så för alla element $__1$ av $primes_below$ av $acc$ och $i$, håller $primes_below$ för $lprim$ applicerat på $n$ och $i$ och $acc$ och summan av $n$ och $i$.\nassistant\n", "label": "Axiom lprim_invariant : forall n : nat, forall i : nat, forall acc : list nat, forall x__ : (1 < i), forall __1 : primes_below acc i, primes_below (lprim n i acc) (n + i) .", "predict": "Axiom lprim_invariant : forall n : nat, forall i : nat, forall acc : list nat, forall __1 : primes_below acc i, primes_below (lprim n i acc) (n + i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15622. Låt $m , n , a , b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Anta att $d m - c n = 1$. Då $m d - n c = 1$.\nassistant\n", "label": "let_clause_15622 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .", "predict": "let_clause_15622 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> 1 = gcd n m -> c : N -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> c n - d m = 1 -> m d - n c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1062. Soit $a , b , q , r , q1 , r1 \\in N$. Soit $_clearme$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q$ et de $r$. Supposons que $r < b$ et $a = q b + r$. Soit $_clearme0$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q1$ et de $r1$. Alors si $r1 < b$ et $a = q1 b + r1$, alors si $q$ n'est pas inférieur ou ágal à $q1$, alors $a = r1 + b q1$.\nassistant\n", "label": "let_clause_1062 : a : Nat -> b : Nat -> q : Nat -> r : Nat -> q1 : Nat -> r1 : Nat -> _clearme : div_mod_spec a b q r -> ltrb : Lt r b -> spec : Eq a (plus (times q b) r) -> _clearme0 : div_mod_spec a b q1 r1 -> ltr1b : Lt r1 b -> spec1 : Eq a (plus (times q1 b) r1) -> leqq1 : not (Leq q q1) -> Eq a (plus r1 (times b q1)) .", "predict": "let_clause_1062 : a : N -> b : N -> q : N -> r : N -> q1 : N -> r1 : N -> _clearme : div_mod_spec a b q r -> r < b -> a = q b + r -> _clearme0 : div_mod_spec a b q1 r1 -> r1 < b -> a = q1 b + r1 -> q < q1 -> a = r1 + b q1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10471. Let $n1$ and $n2$ be natural numbers. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f1$ and $f2$ be functions from natural numbers to elements of $B$. Let $_clearme$ be an element of $iso$ of $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Let $h$ be a function from natural numbers to natural numbers. Let $_clearme0$ be an element of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $k$ be a function from natural numbers to natural numbers. Assume that $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $sub_hk$ holds for $h$ and $k$ and $B$", "label": "Axiom let_clause_10471 : forall n1 : nat, forall n2 : nat, forall p1 : ((x__ : nat) -> bool), forall p2 : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ACop B nil, forall f1 : ((x__ : nat) -> B), forall f2 : ((x__ : nat) -> B), forall _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2), forall h : ((x__ : nat) -> nat), forall _clearme0 : ex (prod Set Set nat (fun x__ => nat)) (fun k => prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop Prop (p1 i = true) (fun __1 => f1 i = f2 (h i)))) /\\ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) /\\ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)), forall k : ((x__ : nat) -> nat), forall _clearme1 : (prod Set Prop nat (fun i => prod Prop Prop (i < n1) (fun x__ => prod Prop Prop (p1 i = true) (fun __1 => f1 i = f2 (h i)))) /\\ sub_hk h k", "predict": "Axiom let_clause_10471 : forall n1 : Nat, forall n2 : Nat, forall p1 : ((i : Nat) -> Bool), forall p2 : ((i : Nat) -> Bool), forall B : Set, forall nil : B, forall op : ACop B nil, forall f1 : ((i : Nat) -> B), forall f2 : ((i : Nat) -> B), forall _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2), forall h : ((i : Nat) -> Nat), forall _clearme0 : ex (prod Set Set Nat (fun __ => Nat)) (fun k => conjunction (conjunction (prod Set Prop Nat (fun i => prod Prop Prop (Lt i n1) (fun __ => prod Prop Prop (Eq (p1 i) true) (fun __1 => Eq (f1 i) (f2 (h i))))) (sub_hk h k)) B (mk_range B f1 n1 p1)) (sub_hk k h B (mk_range B f2 n2 p2)) (sub_hk (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))), forall k : ((i : Nat) -> Nat), prod Set Prop Nat (fun i => prod Prop Prop (Lt i n1) (fun __ => prod Prop Prop (Eq (p1 i) true) (fun __1 => Eq (f1 i) (f2 (h i))))) (sub_hk h k) B (mk_range B f1 n1 p1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nACop_rect_CProp0_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_913$ de $ACop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et de $op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $Q_$ de $mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_913$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_913$.\nassistant\n", "label": "Axiom ACop_rect_CProp0_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_913 : ACop A _nil) -> Prop), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)), forall x_913 : ACop A _nil, Q_ x_913 .", "predict": "Axiom ACop_rect_CProp0_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_913 : ACop A _nil) -> Prop), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)), forall x_913 : ACop A _nil, Q_ x_913 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMatch_divides. Låt $_n$ och $_m$ vara naturliga tal. Låt $return_sort$ vara ett element av $Sort$. Då för alla funktioner $return_type$ från element $z$ av $divisible$ av $_n$ och $_m$ till element av $return_sort$, för alla funktioner $case_quotient$ från naturliga tal $q$ och element av $Eq$ av $_m$ och produkten av $_n$ och $q$ till element av $return_type$ av $quotient$ applicerat på $_n$ och $_m$ och $q$ och $__$, om $_n$ är delbart med $_m$, så håller $return_type$ för $z$.\nassistant\n", "label": "axiom match_divides (_n _m : Nat) (return_sort : Sort) (return_type : (z : divisible _n _m) -> return_sort) (case_quotient : (q : Nat) -> (x__ : _m = _n * q) -> return_type (quotient _n _m q __)) (z : divisible _n _m) : return_type z", "predict": "axiom match_divides (_n _m : Nat) (return_sort : Sort) (return_type : (z : divisible _n _m) -> return_sort) (case_quotient : (q : Nat) -> (x : Eq _m (_n * q)) -> return_type (quotient _n _m q __)) (_n_divides_m : _n % _m = 0) : return_type z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nF3_ind_aux. Soient $A1$ et $A2$ et $A3$ des ensembles. Soit $f$ une fonction des éléments de $A1$ et des éléments $__1$ de $A2$ et des éléments $__2$ de $A3$ à des nombres naturels. Soit $P$ un élément de $relation3$ de $A1$ et de $A2$ et de $A3$. Soit $__$ une fonction des nombres naturels $n$ et des fonctions des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments de $Lt$ de $f (a1 , a2 , a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$ et des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments $__1$ de $Eq$ de $f (a1 , a2 , a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$. Soit $n$ un nombre naturel. Soit $a1$ un élément de $A1$. Soit $a2$ un élément de $A2$. Soit $a3$ un élément de $A3$. Supposons que $f (a1 , a2 , a3)= n$. Alors $P$ tient pour $a1$ et $a2$ et $a3$.\nassistant\n", "label": "f3_ind_aux : A1 : Set -> A2 : Set -> A3 : Set -> f : (__ : A1 -> __1 : A2 -> __2 : A3 -> Nat) -> P : relation3 A1 A2 A3 -> __ : (n : Nat -> __ : (a1 : A1 -> a2 : A2 -> a3 : A3 -> __ : Lt (f a1 a2 a3) n -> P a1 a2 a3) -> a1 : A1 -> a2 : A2 -> a3 : A3 -> __1 : Eq (f a1 a2 a3) n -> P a1 a2 a3) -> n : Nat -> a1 : A1 -> a2 : A2 -> a3 : A3 -> __1 : Eq (f a1 a2 a3) n -> P a1 a2 a3 .", "predict": "f3_ind_aux : A1 : Set -> A2 : Set -> A3 : Set -> f : (a1 : Set -> __1 : Set -> __2 : Set -> Nat) -> P : (a1 : Set -> a2 : Set -> a3 : Set -> Eq : (f a1 a2 a3) n -> P a1 a2 a3) -> __ : (n : Nat -> a1 : Set -> a2 : Set -> a3 : Set -> Lt : (f a1 a2 a3) n -> P a1 a2 a3) -> n : Nat -> a1 : Set -> a2 : Set -> a3 : Set -> __1 : Eq (f a1 a2 a3) n -> P a1 a2 a3) -> A1 : Set -> A2 : Set -> A3 : Set -> f (a1 : Set -> a2 : Set -> a3 : Set) = n -> P a1 a2 a3 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_inv_ind. Soient $x1$ et $x2$ des nombres naturels. Alors si $x1$ est inférieur ou ágal à $x2$, alors pour toutes les fonctions $P$ des nombres naturels $_z724$ à des propositions, pour toutes les fonctions $_H1$ des éléments $_z725$ de $Eq$ de $x2$ et de $x1$ à des éléments de $P$ de $x1$, pour toutes les fonctions $_H2$ des nombres naturels $m$ et des éléments $_x_419$ de $Leq$ de $x1$ et de $m$ et des fonctions $_x_421$ des éléments $_z725$ de $Eq$ de $x2$ et de $m$ à des éléments de $P$ de $m$ et des éléments $_z725$ de $Eq$ de $x2$ et de la somme de $m$ et de $1$ à des éléments de $P$ de la somme de $m$ et de $1$, $P$ tient pour $x2$.\nassistant\n", "label": "Axiom le_inv_ind : forall x1 : nat, forall x2 : nat, forall _Hterm : Leq x1 x2, forall P : ((_z724 : nat) -> Prop), forall _H1 : ((_z725 : x2 = x1) -> P x1), forall _H2 : ((m : nat) -> (_x_419 : Leq x1 m) -> (_x_421 : (_z725 : x2 = m) -> P m) -> (_z725 : x2 = m + 1) -> P (m + 1)), P x2 .", "predict": "Axiom le_inv_ind : forall x1 : nat, forall x2 : nat, forall P : ((_z724 : nat) -> Prop), forall _H1 : ((_z725 : Eq x2 x1) -> P x1), forall _H2 : ((m : nat) -> (_x_419 : Leq x1 m) -> (_x_421 : (_z725 : Eq x2 m) -> P m) -> (_z725 : Eq x2 (m + 1)) -> P (m + 1)), P x2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nTrue_to_le_min. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $n$ et $m$ et $b$ des nombres naturels. Alors si $b \\leq m$ et $f (m)= true$, alors $min (n , b , f)\\leq m$.\nassistant\n", "label": "true_to_le_min : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> b : Nat -> __ : Leq b m -> __1 : Eq (f m) true -> Leq (min n b f) m .", "predict": "true_to_le_min : f : (n : Set -> b : Set -> true) -> n : Set -> m : Set -> b : Set -> min (n , b , f) <= m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_15625. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$ est égale à $1$.\nassistant\n", "label": "Axiom let_clause_15625 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), m * d - n * c = 1 .", "predict": "Axiom let_clause_15625 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : (d : Nat) -> Eq (diff (prod c n) (prod d m)) 1 -> Eq (diff (prod d m) (prod c n)) 1), forall d : Nat, ((diff (prod c n) (prod d m)) = 1 -> (diff (prod d m) (prod c n)) = 1 -> (diff (prod d m) (prod c n)) = 1 -> (prod m d) = (prod n c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Supposons que $f (b)= j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$. Alors pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : N -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (__ : (i0 : N) -> (Leq i0 n) -> Leq (f i0) n) (injf : injn f n) : a = b -> f (a) = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nRange_rect_Type0. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_927$ av $range$ av $_A$ till mängder. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A , _enum , _upto , _filter)$. Då för alla element $x_927$ av $range$ av $_A$, håller $Q_$ för $x_927$.\nassistant\n", "label": "postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927", "predict": "postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : nat -> _A) -> (_upto : nat) -> (_filter : nat -> Bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15621. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $c n - d m = 1$, then $n c - m d = 1$.\nassistant\n", "label": "let_clause_15621 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .", "predict": "let_clause_15621 : m : N -> n : N -> a : N -> b : N -> 0 < n -> 0 < m -> 1 = gcd n m -> c : N -> _clearme : (d : Nat -> Eq (c n - d m) 1) -> d : N -> c n - d m = 1 -> n c - m d = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExp_to_log_r. Let $b$ and $n$ and $m$ be natural numbers. Assume that $1 < b$ and $n < m$. Assume that $b ^ n \\leq m$. Then $n \\leq \\log_ b {m}$.\nassistant\n", "label": "axiom exp_to_log_r (b n m : Nat) (x__ : 1 < b) (__1 : n < m) (__2 : pow b n ≤ m) : n ≤ log b m", "predict": "axiom exp_to_log_r (b n m : Nat) : Nat => assume 1 < b => assume n < m => assume b ^ n <= m => n <= log_b m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMatch_lstar_r. Soit $B$ un ensemble. Soit $_R$ un élément de $relation$ de $B$. Soit $return_sort$ un élément de $Sort$. Alors pour toutes les fonctions $return_type$ des nombres naturels et des éléments $__1$ de $B$ et des éléments $__2$ de $B$ et des éléments $z$ de $lstar_r$ de $B$ et de $_R$ et de $__$ et de $__1$ et de $__2$ à des éléments de $return_sort$, pour toutes les fonctions $case_lstar_r_O$ des éléments $b$ de $B$ à des éléments de $return_type$ de $0$ et de $b$ et de $b$ et de $lstar_r_O$ appliqué à $B$ et $_R$ et $b$, pour toutes les fonctions $case_lstar_r_S$ des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments de $lstar_r$ de $B$ et de $_R$ et de $l$ et de $b1$ et de $b$ et des éléments $b2$ de $B$ et des éléments $__1$ de $_R$ de $b$ et de $b2$ à des éléments de $return_type$ de la somme de $l$ et de $1$ et de $b1$ et de $b2$ et de $lstar_r_S$ appliqué à $B$ et $_R$ et $l$ et $b1$ et $b$ et $__$ et $b2$ et $__1$, pour tous les nombres naturels $__$, pour tous les éléments $__1$ et $__2$ de $B$, pour tous les éléments $z$ de $lstar_r$ de $B$ et de $_R$ et de $__$ et de $__1$ et de $__2$, $return_type$ tient pour $__$ et $__1$ et $__2$ et $z$.\nassistant\n", "label": "axiom match_lstar_r (B : Set) (_R : relation B) (return_sort : Sort) (return_type : (x__ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x__ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (l + 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) (x__ : Nat) (__1 __2 : B) (z : lstar_r B _R __ __1 __2) : return_type __ __1 __2 z", "predict": "axiom match_lstar_r (B : Set) (_R : relation B) (return_sort : Sort) (return_type : (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (z : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (l + 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) (__ : Nat) (__1 __2 : B) (z : lstar_r B _R __ __1 __2) : return_type __ __1 __2 z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1047. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Then for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all natural numbers $j$, if $n$ is less than or equal to $j$, then for all functions $Hind$ from functions from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and $j$ to elements of $Eq$ of $p$ applied to $i$ and absurdity to elements of $Eq$ of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $j$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$, for all functions $Hfalse$ from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $j$ and $1$ to elements of $Eq$ of $p$ applied to $i$ and absurdity, for all natural numbers $x2571$ and $x2572$, $x2571$ is equal to the sum of the product of $x2572$ and the quotient of $x2571$ and $x2572$ and $mod$ applied to $x2571$ and $x2572$.\nassistant\n", "label": "Axiom let_clause_1047 : forall k : nat, forall n : nat, forall p : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ((x__ : B) -> (__1 : B) -> B), forall f : ((x__ : nat) -> B), forall lenk : Leq n k, forall j : nat, forall leup : Leq n j, forall Hind : ((x__ : (i : nat) -> (x__ : Leq n i) -> (__1 : i < j) -> p i = false) -> bigop n (fun i => p i) B nil op (fun i => f i) = bigop j (fun i => p i) B nil op (fun i => f i)), forall Hfalse : ((i : nat) -> (x__ : Leq n i) -> (__1 : i < j + 1) -> p i = false), forall x2571 : nat, forall x2572 : nat, x2571 = x2572 * (x2571 / x2572) + mod x2571 x2572 .", "predict": "Axiom let_clause_1047 : forall k : nat, forall n : nat, forall p : ((i : nat) -> bool), forall B : set, forall nil : B, forall op : ((i : B) -> (__1 : B) -> B), forall f : ((i : nat) -> B), forall n : nat, forall j : nat, forall Hind : ((i : nat) -> (__1 : Lt i j) -> Eq (p i) absurdity) -> Eq (bigop n (fun i => p i) B nil op (fun i => f i)) (bigop j (fun i => p i) B nil op (fun i => f i))), forall Hfalse : ((i : nat) -> (__1 : Leq n i) -> (__2 : Lt i (j + 1)) -> Eq (p i) absurdity), forall x2571 : nat, forall x2572 : nat, x2571 = (x2572 * (x2571 / x2572)) + mod x2571 x2572 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPsi'. Låt $__$ vara ett naturligt tal. Då $Nat$.\nassistant\n", "label": "postulate Psi' : (_ : Nat) -> Nat", "predict": "postulate Psi' : (__ : Nat) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDivides_ord_rem. Låt $p$ och $n$ vara naturliga tal. Anta att $1 < p$. Anta att $0 < n$. Då är $ord_rem (n , p)$ delbart med $n$.\nassistant\n", "label": "axiom divides_ord_rem (p n : Nat) (x__ : 1 < p) (__1 : 0 < n) : divisible (ord_rem n p) n", "predict": "axiom divides_ord_rem (p n : Nat) : (1 < p) -> (0 < n) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_gcd_aux. Let $p , m , n , d \\in N$. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq p$. Assume that $d$ is divisible by $m$. Assume that $d$ is divisible by $n$. Then $d$ is divisible by $gcd_aux (p , m , n)$.\nassistant\n", "label": "axiom divides_gcd_aux (p m n d : Nat) (x__ : 0 < n) (__1 : n ≤ m) (__2 : n ≤ p) (__3 : divisible d m) (__4 : divisible d n) : divisible d (gcd_aux p m n)", "predict": "axiom divides_gcd_aux (p m n d : N) (Hc : 0 < n) (Hl : n ≤ m) (Hl2 : n ≤ p) (Hd : d % m = 0) (Hd2 : d % n = 0) : d % gcd_aux (p , m , n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nChecker_spec. Let $tl$ be a list of natural numbers. Then for all natural numbers $a$, for all lists $l$ of natural numbers, if $checker (l)= true$, then if $l = cons (Nat , a , tl)$, then for all natural numbers $p$, for all elements $__2$ of $mem$ of $Nat$ and $p$ and $tl$, $ex$ holds for $Nat$ and the function that maps $pp$ to the conjunction of the conjunction of $mem$ applied to $Nat$ and $pp$ and $l$ and $Lt$ applied to $pp$ and $p$ and $Leq$ applied to $p$ and the product of $2$ and $pp$.\nassistant\n", "label": "Axiom checker_spec : forall tl : list nat, forall a : nat, forall l : list nat, forall x__ : (checker l = true), forall __1 : (l = cons nat a tl), forall p : nat, forall __2 : mem nat p tl, ex nat (fun pp => mem nat pp l /\\ pp < p /\\ Leq p (2 * pp)) .", "predict": "Axiom checker_spec : forall tl : list nat, forall a : nat, forall l : list nat, if checker l = true then if l = cons Nat a tl then forall p : nat, forall __2 : mem Nat p tl, ex Nat (fun pp => conjunction (conjunction (mem Nat pp l) (Lt pp p)) (Leq p (product 2 pp))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNot_not_bertrand_to_bertrand1. Låt $n \\in N$. Då om det inte är fallet att $not_bertrand$ håller för $n$, så för alla naturliga tal $x$, om $n$ är mindre än eller lika med $x$, så om $x$ är mindre än eller lika med produkten av $2$ och $n$, så för alla funktioner $__3$ från naturliga tal $p$ och element $__3$ av $Lt$ av $x$ och $p$ och element $__4$ av $Leq$ av $p$ och produkten av $2$ och $n$ till element av $not$ av $prime$ applicerat på $p$, håller $ex$ för $Nat$ och funktionen som avbildar $p$ som konjunktionen av konjunktionen av $Lt$ applicerat på $n$ och $p$ och $Leq$ applicerat på $p$ och $x$ och $prime$ applicerat på $p$.\nassistant\n", "label": "postulate not_not_bertrand_to_bertrand1 : (n : Nat) -> (_ : not (not_bertrand n)) -> (x : Nat) -> (__1 : Leq n x) -> (__2 : Leq x (times 2 n)) -> (__3 : (p : Nat) -> (__3 : Lt x p) -> (__4 : Leq p (times 2 n)) -> not (prime p)) -> ex Nat (\\ p : Nat -> and (and (Lt n p) (Leq p x)) (prime p))", "predict": "postulate not_not_bertrand_to_bertrand1 : (n : N) -> (x : N) -> (__3 : (p : N) -> (__3 : Lt x p) -> (__4 : Leq p (2 * n)) -> not (prime p)) -> (ex : Nat) -> (\\ p : N -> conj (conj (Lt n p) (Leq p x)) (prime p)) -> not (prime n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDop_rect_Type3. Soit $A$ un ensemble. Alors pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_949$ de $Dop$ de $A$ et de $_nil$ à des éléments de $Type3$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_949$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_949$.\nassistant\n", "label": "Axiom Dop_rect_Type3 : forall A : Set, forall _nil : A, forall Q_ : ((_x_949 : Dop A _nil) -> Type3), forall _H_mk_Dop : ((sum : ACop A _nil) -> (prod : (x__ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> prod a _nil = _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> prod a (aop__o__op A _nil sum b c) = aop__o__op A _nil sum (prod a b) (prod a c)) -> Q_ (mk_Dop A _nil sum prod _null _distr)), forall x_949 : Dop A _nil, Q_ x_949 .", "predict": "Axiom Dop_rect_Type3 : forall A : Set, forall _nil : A, forall Q_ : ((_x_949 : Dop A _nil) -> Type3), forall _H_mk_Dop : ((sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)), forall x_949 : Dop A _nil, Q_ x_949 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1600. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Alors pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nassistant\n", "label": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : (d : Nat) -> Eq (difference (product c n) (product d m)) 1) -> Eq (difference (product d m) (product c n)) 1) -> (d : Nat) -> (_difference_1 : Eq (difference (product c n) (product d m)) 1) -> (_difference_2 : Eq (difference (product d m) (product c n)) 1) -> (_difference_3 : Eq (difference (product c n) (product d m)) 1) -> (div_commun_plus_grand : (m : Nat) -> (n : Nat) -> Nat) -> div_commun_plus_grand m n) -> postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : (d : Nat) -> Eq (difference (product c n) (product d m)) 1) -> Eq (difference (product d m) (product c n)) 1) -> (d : Nat) -> (_difference_1 : Eq (difference (product c n) (product d m)) 1) -> (_difference_2 : Eq (difference (product d m) (product c n)) 1) -> (_difference_3 : Eq (difference (product c n) (product d m)) 1) -> (div_commun_plus_grand : (m : Nat) -> (n : Nat) -> Nat) -> div_commun_plus_grand m n) -> (_div_commun_plus_grand : (m : Nat) -> (n : Nat) -> c : Nat) -> Eq (difference (product c n) (product m d)) 1) -> (_div_commun_plus_grand_2 : (m : Nat) -> (n : Nat) -> a : Nat) -> Eq (difference (product a n) (product m d)) 1) -> (_div_commun_plus_grand_3 : (m : Nat) -> (n : Nat) -> b : Nat) -> Eq (difference (product b n) (product m d)) 1) -> (_div_commun"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nMax_spec_inv_ind. Soit $x1$ un nombre naturel. Soit $x2$ une fonction des nombres naturels à des valeurs booléennes. Soit $x3 \\in N$. Soit $_Hterm$ un élément de $max_spec$ de $x1$ et de $x2$ et de $x3$. Soit $P$ une fonction des nombres naturels $_z1769$ à des propositions. Soit $_H1$ une fonction des nombres naturels $m$ et des éléments $_x_975$ de $Lt$ de $m$ et de $x1$ et des éléments $_x_974$ de $Eq$ de $x2 (m)$ et de $true$ et des fonctions $_x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $x1$ à des éléments de $Eq$ de $x2 (i)$ et de contradiction et des éléments $_z1770$ de $Eq$ de $x3$ et de $m$ à des éléments de $P$ de $m$. Soit $_H2$ une fonction des fonctions $_x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $x1$ à des éléments de $Eq$ de $x2 (i)$ et de contradiction et des éléments $_z1770$ de $Eq$ de $x3$ et de $0$ à des éléments de $P$ de $0$. Alors $P$ tient pour $x3$.\nassistant\n", "label": "Axiom max_spec_inv_ind : forall x1 : nat, forall x2 : ((x__ : nat) -> bool), forall x3 : nat, forall _Hterm : max_spec x1 x2 x3, forall P : ((_z1769 : nat) -> Prop), forall _H1 : ((m : nat) -> (_x_975 : m < x1) -> (_x_974 : x2 m = true) -> (_x_973 : (i : nat) -> (x__ : m < i) -> (__1 : i < x1) -> x2 i = false) -> (_z1770 : x3 = m) -> P m), forall _H2 : ((_x_976 : (i : nat) -> (x__ : i < x1) -> x2 i = false) -> (_z1770 : x3 = 0) -> P 0), P x3 .", "predict": "Axiom max_spec_inv_ind : forall x1 : nat, forall x2 : (nat -> bool), forall x3 : N, forall _Hterm : max_spec x1 x2 x3, forall P : ((_z1769 : nat) -> Prop), forall _H1 : ((m : nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq x2 m true) -> (_x_973 : (i : nat) -> (Lt m i) -> (__1 : Lt i x1) -> Eq x2 i contradiction) -> (_z1770 : Eq x3 m) -> P m), forall _H2 : ((_x_976 : (i : nat) -> Lt i x1) -> Eq x2 i contradiction) -> (_z1770 : Eq x3 0) -> P 0), P x3 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_to_gcd. För alla naturliga tal $m$ och $n$, om $0 < n$ och $n$ är delbart med $m$, så är $n$ lika med det största gemensama delaret av $n$ och $m$.\nassistant\n", "label": "postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (gcd n m) n", "predict": "postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> (0 < n) -> n % m == 0) -> n == gcd n m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nGcd_O_to_eq_O. Let $m , n \\in N$. Then if the greatest common divisor of $m$ and $n$ is equal to $0$, then $m$ is equal to $0$ and $n$ is equal to $0$.\nassistant\n", "label": "postulate gcd_O_to_eq_O : (m : Nat) -> (n : Nat) -> (_ : Eq (gcd m n) 0) -> and (Eq m 0) (Eq n 0)", "predict": "postulate gcd_O_to_eq_O : (m : N) -> (n : N) -> (gcd : N) -> (m == 0 && n == 0)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1545. Låt $m , n \\in N$. Anta att det största gemensama delaret av $m$ och $n$ är lika med $0$. Anta att $0$ är delbart med $n$. Låt $q1$ vara ett naturligt tal. Då om $n$ är lika med produkten av $0$ och $q1$, så om $0$ är delbart med $m$, så för alla naturliga tal $q2$, om $m$ är lika med produkten av $0$ och $q2$, så är $m$ lika med $0$.\nassistant\n", "label": "let_clause_1545 : m : Nat -> n : Nat -> H : Eq (gcd m n) 0 -> _clearme : divisible 0 n -> q1 : Nat -> H1 : Eq n (times 0 q1) -> _clearme0 : divisible 0 m -> q2 : Nat -> H2 : Eq m (times 0 q2) -> Eq m 0 .", "predict": "let_clause_1545 : m : N -> n : N -> q1 : Nat -> n : 0 -> q2 : Nat -> m : 0 -> m : 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat_inv_rect_CProp3. Let $Hterm$ be a natural number. Let $P$ be a function from natural numbers $_z695$ to propositions. Let $_H1$ be a function from elements $_z696$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Let $_H2$ be a function from natural numbers $x_402$ and functions $_x_404$ from elements $_z696$ of $Eq$ of $Hterm$ and $x_402$ to elements of $P$ of $x_402$ and elements $_z696$ of $Eq$ of $Hterm$ and the sum of $x_402$ and $1$ to elements of $P$ of the sum of $x_402$ and $1$. Then $P$ holds for $Hterm$.\nassistant\n", "label": "postulate nat_inv_rect_CProp3 : (Hterm : Nat) -> (P : (_z695 : Nat) -> Prop) -> (_H1 : (_z696 : Eq Hterm 0) -> P 0) -> (_H2 : (x_402 : Nat) -> (_x_404 : (_z696 : Eq Hterm x_402) -> P x_402) -> (_z696 : Eq Hterm (plus x_402 1)) -> P (plus x_402 1)) -> P Hterm", "predict": "postulate nat_inv_rect_CProp3 : (Hterm : Set) -> (P : (_z695 : Set) -> Set) -> (_H1 : (_z696 : Eq Hterm 0) -> Set) -> (_H2 : (x_402 : Set) -> (_x_404 : (_z696 : Eq Hterm x_402) -> Set) -> (_z696 : Eq Hterm (x_402 + 1)) -> Set) -> P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nFound_min_spec. Låt $n , b \\in N$. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $m \\in N$. Då om $b$ är mindre än eller lika med $m$, så om $m$ är mindre än summan av $n$ och $b$, så om $f$ applicerat på $m$ är lika med $true$, så för alla funktioner $__3$ från naturliga tal $i$ och element $__3$ av $Leq$ av $b$ och $i$ och element $__4$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $f$ applicerat på $i$ och kontradiktion, håller $min_spec$ för $n$ och $b$ och $f$ och $m$.\nassistant\n", "label": "axiom found_min_spec (n b : Nat) (f : (x__ : Nat) -> bool) (m : Nat) (x__ : b ≤ m) (__1 : m < n + b) (__2 : f m = true) (__3 : (i : Nat) -> (__3 : b ≤ i) -> (__4 : i < m) -> f i = false) : min_spec n b f m", "predict": "axiom found_min_spec (n b : N) (f : nat -> Bool) (m : N) : (__3 : (i : N) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) contradiction) -> min_spec n b f m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a$ be a natural number. Assume that $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$. Assume that $a$ is less than or equal to $n$. Assume that $f$ applied to $a$ is equal to $i$. Let $b$ be a natural number. Assume that $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$. Assume that $b$ is less than or equal to $n$. Assume that $f$ applied to $b$ is equal to $j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : (N -> N) -> n : N -> permf : permut f n -> i : N -> j : N -> a : N -> a <= n -> f a = i -> b : N -> b <= n -> f b = j -> __ : (i0 : N -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nEqb_body. Låt $__ , __1 \\in N$. Då $bool$.\nassistant\n", "label": "eqb_body : __ : Nat -> __1 : Nat -> bool .", "predict": "eqb_body : __ : N -> __1 : N -> bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMax_spec_ind_body. Let $_n \\in N$. Let $_f$ be a function from natural numbers to booleans. Then for all functions $Q_$ from natural numbers $x_971$ and elements $_x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$ to propositions, for all functions $_H_found_max_spec$ from natural numbers $m$ and elements $x_975$ of $Lt$ of $m$ and $_n$ and elements $x_974$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$, for all functions $_H_not_found_max_spec$ from functions $x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$, for all natural numbers $x_971$, for all elements $x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$, $Q_$ holds for $x_971$ and $x_972$.\nassistant\n", "label": "postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind_body : (_n : N) -> (_f : (x : N) -> Bool) -> (Q_ : (x_971 : N) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : N) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : N) -> (__1 : Lt i _n) -> Eq (_f i) absurdity) -> (Q_ (m) (found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (x_976 : (i : N) -> Eq (_f i) absurdity) -> (Q_ 0 (not_found_max_spec _n _f x_976))) -> (x_971 : N) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nF3_ind. Låt $A1$ och $A2$ och $A3$ vara mängder. Låt $f$ vara en funktion från element av $A1$ och element $__1$ av $A2$ och element $__2$ av $A3$ till naturliga tal. Låt $P$ vara ett element av $relation3$ av $A1$ och $A2$ och $A3$. Låt $__$ vara en funktion från naturliga tal $n$ och funktioner från element $a1$ av $A1$ och element $a2$ av $A2$ och element $a3$ av $A3$ och element av $Lt$ av $f (a1 , a2 , a3)$ och $n$ till element av $P$ av $a1$ och $a2$ och $a3$ och element $a1$ av $A1$ och element $a2$ av $A2$ och element $a3$ av $A3$ och element $__1$ av $Eq$ av $f (a1 , a2 , a3)$ och $n$ till element av $P$ av $a1$ och $a2$ och $a3$. Låt $a1$ vara ett element av $A1$. Låt $a2$ vara ett element av $A2$. Då för alla element $a3$ av $A3$, håller $P$ för $a1$ och $a2$ och $a3$.\nassistant\n", "label": "axiom f3_ind (A1 A2 A3 : Set) (f : (x__ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) (P : relation3 A1 A2 A3) (x__ : (n : Nat) -> (x__ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (x__ : f a1 a2 a3 < n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : f a1 a2 a3 = n) -> P a1 a2 a3) (a1 : A1) (a2 : A2) (a3 : A3) : P a1 a2 a3", "predict": "axiom f3_ind (A1 A2 A3 : Set) (f : (a1 : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) (P : relation3 A1 A2 A3) (__ : (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (Lt : f a1 a2 a3) -> n) -> (P a1 a2 a3)) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) (a1 : A1) (a2 : A2) (a3 : A3) : P a1 a2 a3) : a3 : A3) : P a1 a2 a3)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLstar_r_ind_body. Soit $B$ un ensemble. Soit $_R$ un élément de $relation$ de $B$. Soit $Q_$ une fonction des nombres naturels $x_1337$ et des éléments $x_1336$ de $B$ et des éléments $x_1335$ de $B$ et des éléments $_x_1338$ de $lstar_r$ de $B$ et de $_R$ et de $x_1337$ et de $x_1336$ et de $x_1335$ à des propositions. Soit $_H_lstar_r_O$ une fonction des éléments $b$ de $B$ à des éléments de $Q_$ de $0$ et de $b$ et de $b$ et de $lstar_r_O$ appliqué à $B$ et $_R$ et $b$. Alors pour toutes les fonctions $_H_lstar_r_S$ des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $x_1340$ de $lstar_r$ de $B$ et de $_R$ et de $l$ et de $b1$ et de $b$ et des éléments $b2$ de $B$ et des éléments $x_1339$ de $_R$ de $b$ et de $b2$ et des éléments $_x_1342$ de $Q_$ de $l$ et de $b1$ et de $b$ et de $x_1340$ à des éléments de $Q_$ de la somme de $l$ et de $1$ et de $b1$ et de $b2$ et de $lstar_r_S$ appliqué à $B$ et $_R$ et $l$ et $b1$ et $b$ et $x_1340$ et $b2$ et $x_1339$, pour tous les nombres naturels $x_1337$, pour tous les éléments $x_1336$ et $x_1335$ de $B$, pour tous les éléments $x_1338$ de $lstar_r$ de $B$ et de $_R$ et de $x_1337$ et de $x_1336$ et de $x_1335$, $Q_$ tient pour $x_1337$ et $x_1336$ et $x_1335$ et $x_1338$.\nassistant\n", "label": "postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338", "predict": "postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Set) -> (x_1336 : Set) -> (x_1335 : Set) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Set) -> (_H_lstar_r_O : (b : Set) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Set) -> (b1 : Set) -> (b : Set) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : Set) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (l + 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339))) -> (x_1337 : Set) -> (x_1336 : Set) -> (x_1335 : Set) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nList_divides_false. Låt $l$ vara en lista av naturliga tal. Låt $n$ vara ett naturligt tal. Då om $list_divides$ applicerat på $l$ och $n$ är lika med kontradiktion, så för alla naturliga tal $p$, för alla element $__1$ av $mem$ av $Nat$ och $p$ och $l$, är $p$ inte delbart med $n$.\nassistant\n", "label": "axiom list_divides_false (l : list Nat) (n : Nat) (x__ : list_divides l n = false) (p : Nat) (__1 : mem Nat p l) : ¬ divisible p n", "predict": "axiom list_divides_false (l : List Nat) (n : Nat) (p : Nat) (__1 : mem Nat p l) : p % n ≠ 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDiv_mod_spec_rect_CProp4_body. Låt $_n , _m , _q , _r \\in N$. Låt $Q_$ vara en funktion från element $_x_837$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden. Låt $_H_div_mod_spec_intro$ vara en funktion från element $x_839$ av $Lt$ av $_r$ och $_m$ och element $x_838$ av $Eq$ av $_n$ och summan av produkten av $_q$ och $_m$ och $_r$ till element av $Q_$ av $div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_839$ och $x_838$. Då för alla element $x_837$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_837$.\nassistant\n", "label": "Axiom div_mod_spec_rect_CProp4_body : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_837 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_839 : _r < _m) -> (x_838 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)), forall x_837 : div_mod_spec _n _m _q _r, Q_ x_837 .", "predict": "Axiom div_mod_spec_rect_CProp4_body : forall _n : N, forall _m : N, forall _q : N, forall _r : N, forall Q_ : ((_x_837 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_839 : Lt _r _m) -> (x_838 : Eq _n (sum _q _m _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)), forall x_837 : div_mod_spec _n _m _q _r, Q_ x_837 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAop_rect_CProp2_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_881$ av $Aop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil , a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a , _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a , op (b , c))$ och $op (op (a , b), c)$ till element av $Q_$ av $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$, för alla element $x_881$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_881$.\nassistant\n", "label": "axiom Aop_rect_CProp2_body (A : Set) (_nil : A) (Q_ : (_x_881 : Aop A _nil) -> Prop) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_881 : Aop A _nil) : Q_ x_881", "predict": "axiom Aop_rect_CProp2_body (A : Set) (_nil : A) (Q_ : (_x_881 : Aop A _nil) -> Set) (_H_mk_Aop : (op : (a : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_881 : Aop A _nil) : Q_ x_881"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMinus_plus_plus_l. För alla naturliga tal $x$ och $y$ och $h$, $x + h - y + h = x - y$.\nassistant\n", "label": "axiom minus_plus_plus_l (x y h : Nat) : x + h - (y + h) = x - y", "predict": "axiom minus_plus_plus_l (x y h : Nat) : Nat => x + h - y + h = x - y"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nGcd_O_to_eq_O. Låt $m$ och $n$ vara naturliga tal. Då om $0$ är lika med det största gemensama delaret av $m$ och $n$, så $m = 0$ och $n = 0$.\nassistant\n", "label": "gcd_O_to_eq_O : m : Nat -> n : Nat -> __ : Eq (gcd m n) 0 -> and (Eq m 0) (Eq n 0) .", "predict": "gcd_O_to_eq_O : m : nat -> n : nat -> 0 = gcd_O -> m = 0 -> n = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nPad_bigop. Pour tous les nombres naturels $k$ et $n$, pour toutes les fonctions $p$ des nombres naturels à des valeurs booléennes, pour tous les ensembles $B$, pour tous les éléments $nil$ de $B$, pour toutes les fonctions $op$ des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $n$ est inférieur ou ágal à $k$, alors $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $match_bool$ appliqué à $Set$ et la fonction qui envoie $_0$ à $bool$ et contradiction et $p$ appliqué à $i$ et $leb$ appliqué à $n$ et $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "pad_bigop : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Leq n k -> Eq (bigop n (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => match_bool Set (_0 : bool => bool) false (p i) (leb n i)) B nil op (i : Nat => f i)) .", "predict": "pad_bigop : k : Nat -> n : Nat -> p : Nat -> Bool -> B : Set -> nil : B -> op : (B -> __1 : B -> B) -> f : Nat -> B -> n <= k -> bigop : (i : Nat -> p : Bool) -> B -> nil -> op -> (i : Nat -> f : B) -> bigop : (i : Nat -> match_bool : Set -> (_0 : Bool -> contradiction : B -> p : Bool -> leb : Nat -> i -> B -> nil -> op -> (i : Nat -> f : B) -> bigop : (i : Nat -> match_bool : Set -> (_0 : Bool -> contradiction : B -> p : Bool -> leb : Nat -> i -> B -> nil -> op -> (i : Nat -> f : B) -> B) -> n : Nat -> B -> nil -> op -> (i : Nat -> f : B) -> B) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10331. Let $n$ be a natural number. Let $p$ be a function from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g2$ applied to $i$. Let $Hle$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Then if $p (n1)= true$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "let_clause_10331 : n : Nat -> p : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> n1 : Nat -> Hind : (__ : (i : Nat -> __ : Lt i n1 -> __1 : Eq (p i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (i : Nat => p i) Nat (nd 1) times (i : Nat => g1 i)) (bigop n1 (i : Nat => p i) Nat (nd 1) times (i : Nat => g2 i))) -> Hle : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p i) true -> Leq (g1 i) (g2 i)) -> Hcase : Eq (p n1) true -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_10331 : n : Nat -> p : (i : Nat -> Bool) -> g1 : (i : Nat -> Nat) -> g2 : (i : Nat -> Nat) -> n1 : Nat -> Hind : (f : (i : Nat -> Lt : i -> n1 -> __1 : Eq (p i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (i : Nat => p i) Nat 1 times (i : Nat => g1 i)) (bigop n1 (i : Nat => p i) Nat 1 times (i : Nat => g2 i))) -> Hle : (i : Nat -> Lt : i -> n1 + 1 -> __1 : Eq (p i) true -> Leq (g1 i) (g2 i)) -> p (n1) = true -> x2515 : Nat -> x2516 : Nat -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15691. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Supposons que $c n - d m = 1$. Alors $n c - m d = 1$.\nassistant\n", "label": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .", "predict": "let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = div_commun_plus_grand n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (diff (prod c n) (prod d m)) 1) -> d : Nat -> c n - d m = 1 -> n c - m d = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1617. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c \\in N$. Assume that $m n = p c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Then if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$, then if $a p - b m = 1$, then $p a - m b$ is equal to the greatest common divisor of $p$ and $m$.\nassistant\n", "label": "axiom let_clause_1617 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : a * p - b * m = gcd p m) (H0 : a * p - b * m = 1) : gcd p m = p * a - m * b", "predict": "axiom let_clause_1617 (p m n : Nat) (c : N) (a : Nat) (_clearme0 : ex Nat (λ b => Eq (a * p - b * m) (gcd p m) ∧ Eq (b * m - a * p) (gcd p m))) (b : Nat) : (gcd p m) = (if a p - b m = 1 then p a - m b else b m - a p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i , j \\in N$. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Då om $a \\leq n$ och $f (a)= i$, så om $a \\leq n$, så om $f (a)= i$, så för alla naturliga tal $b$, om $b \\leq n$ och $f (b)= j$, så om $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nassistant\n", "label": "let_clause_1068 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) i .", "predict": "let_clause_1068 : f : nat -> nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiv_mod_spec_ind_body. Soient $_n$ et $_m$ et $_q$ et $_r$ des nombres naturels. Soit $Q_$ une fonction des éléments $_x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Alors pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_811$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_810$ de $Eq$ de $_n$ et de $_q _m + _r$ à des éléments de $Q_$ de $div_mod_spec_intro (_n , _m , _q , _r , x_811 , x_810)$, pour tous les éléments $x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_809$.\nassistant\n", "label": "div_mod_spec_ind_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 .", "predict": "div_mod_spec_ind_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (_q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAxiom. Let $_n$ and $_m$ and $_q$ and $_r$ be natural numbers. Then $div_mod_spec (_n , _m , _q , _r)$ is a proposition.\nassistant\n", "label": "Axiom div_mod_spec : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, Prop .", "predict": "Axiom div_mod_spec : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, Prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1569. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $c n - d m = 1$, then $n c - m d = 1$.\nassistant\n", "label": "axiom let_clause_1569 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : n * c - m * d = 1", "predict": "axiom let_clause_1569 (m n a b : Nat) (_clearme : ex Nat (λ d => Eq (c n - d m) 1)) (d : Nat) : Nat (if c n - d m = 1 || d m - c n = 1 then n c - m d else 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_exp_Psil. Soit $n$ un nombre naturel. Alors si $0 < n$, alors $2 ^ n \\leq Psi (2 n)$.\nassistant\n", "label": "postulate le_exp_Psil : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 n) (Psi (times 2 n))", "predict": "postulate le_exp_Psil : (n : Nat) -> 0 < n -> 2 ^ n <= Psi (2 n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_ord_O_to_divides. Let $p , m \\in N$. Assume that $0 < m$. Then if $p$ is prime, then if $ord (m , p)$ is not equal to $0$, then $p$ is divisible by $m$.\nassistant\n", "label": "not_ord_O_to_divides : p : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : not (Eq (ord m p) 0) -> divisible p m .", "predict": "not_ord_O_to_divides : p : N -> m : N -> 0 < m -> p : prime -> ord (m , p) != 0 -> p : divisible_by m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$. Då om $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nassistant\n", "label": "Axiom let_clause_1063 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = j .", "predict": "Axiom let_clause_1063 : forall f : nat -> nat, forall n : N, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : (i0 : N -> Leq i0 n) -> Leq (f i0) n), forall injf : (f : nat -> nat) -> (n : N) -> (a : nat) -> (b : nat) -> (a = b -> f a = j), a <= n -> f a = i -> b <= n -> f b = j -> b <= n -> f b = j -> forall __ : (i0 : N -> Leq i0 n) -> Leq (f i0) n), forall injf : (f : nat -> nat) -> (n : N) -> (a : nat) -> (b : nat) -> (a = b -> f a = j), a <= n -> f a = i -> b <= n -> f b = j -> b <= n -> f b = j -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1561. Let $p , m , n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$. Then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the difference of the product of $p$ and $a$ and the product of $m$ and $b$ is equal to $1$.\nassistant\n", "label": "axiom let_clause_1561 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : a * p - b * m = gcd p m) (H0 : a * p - b * m = 1) : p * a - m * b = 1", "predict": "axiom let_clause_1561 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : ex (b : Nat) (Eq (difference (product a p) (product b m)) (gcd p m) ∧ Eq (difference (product b m) (product a p)) (gcd p m))) (b : Nat) : Prop := and (eq (difference (product a p) (product b m)) (gcd p m) ∨ eq (difference (product b m) (product a p)) (gcd p m)) (eq (difference (product a p) (product b m)) (gcd p m)) → eq (difference (product p a) (product m b)) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_r_inv_ind. Let $x1$ be a set. Let $x2$ be an element of $relation$ of $x1$. Let $x3$ be a natural number. Let $x4$ and $x5$ be elements of $x1$. Let $_Hterm$ be an element of $lstar_r$ of $x1$ and $x2$ and $x3$ and $x4$ and $x5$. Let $P$ be a function from natural numbers $_z2386$ and elements $_z2385$ of $x1$ and elements $_z2384$ of $x1$ to propositions. Then for all functions $_H1$ from elements $b$ of $x1$ and elements $_z2389$ of $Eq$ of $x3$ and $0$ and elements $_z2388$ of $Eq$ of $x4$ and $b$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $0$ and $b$ and $b$, for all functions $_H2$ from natural numbers $l$ and elements $b1$ of $x1$ and elements $b$ of $x1$ and elements $_x_1340$ of $lstar_r$ of $x1$ and $x2$ and $l$ and $b1$ and $b$ and elements $b2$ of $x1$ and elements $_x_1339$ of $x2$ of $b$ and $b2$ and functions $_x_1342$ from elements $_z2389$ of $Eq$ of $x3$ and $l$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b$ to elements of $P$ of $l$ and $b1$ and $b$ and elements $_z2389$ of $Eq$ of $x3$ and $l + 1$ and elements $_z2388$ of $Eq$ of $x4$ and $b1$ and elements $_z2387$ of $Eq$ of $x5$ and $b2$ to elements of $P$ of $l + 1$ and $b1$ and $b2$, $P$ holds for $x3$ and $x4$ and $x5$.\nassistant\n", "label": "postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (plus l 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (plus l 1) b1 b2) -> P x3 x4 x5", "predict": "postulate lstar_r_inv_ind : (x1 : Set) -> (x2 : relation x1) -> (x3 : Nat) -> (x4 : x1) -> (x5 : x1) -> (_Hterm : lstar_r x1 x2 x3 x4 x5) -> (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) -> (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) -> (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (l + 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (l + 1) b1 b2)) -> P x3 x4 x5"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDivides_to_not_ord_O. Låt $p$ och $m$ vara naturliga tal. Anta att $0 < m$. Anta att $p$ är primt. Då om $p$ är delbart med $m$, så är $ord (m , p)$ inte lika med $0$.\nassistant\n", "label": "divides_to_not_ord_O : p : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : divisible p m -> not (Eq (ord m p) 0) .", "predict": "divides_to_not_ord_O : p : nat -> m : nat -> 0 < m -> p : primt -> ord (m , p) != 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDecidable_forall. Soit $P$ une fonction des nombres naturels à des propositions. Soit $__$ une fonction des nombres naturels $i$ à des éléments de $decidable$ de $P (i)$. Alors pour tous les nombres naturels $n$, $decidable$ tient pour $prod$ appliqué à $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n$ et la fonction qui envoie $__1$ à $P$ appliqué à $i$.\nassistant\n", "label": "Axiom decidable_forall : forall P : ((x__ : nat) -> Prop), forall x__ : ((i : nat) -> decidable (P i)), forall n : nat, decidable (prod Set Prop nat (fun i => prod Prop Prop (i < n) (fun __1 => P i))) .", "predict": "Axiom decidable_forall : forall P : nat -> Prop, forall __ : (i : nat) -> decidable (P i), forall n : nat, decidable (prod Set Prop Nat (fun i => prod Prop Prop (Lt i n) (fun __1 => P i))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_max_to_false. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $n$ et $m$ des nombres naturels. Supposons que $m$ est inférieur à $n$. Supposons que $max$ appliqué à $n$ et $f$ est inférieur à $m$. Alors $f$ appliqué à $m$ est égal à contradiction.\nassistant\n", "label": "axiom lt_max_to_false (f : (x__ : Nat) -> bool) (n m : Nat) (x__ : m < n) (__1 : max n f < m) : f m = false", "predict": "axiom lt_max_to_false (f : Nat -> Bool) (n m : Nat) : m < n -> max n (f n) < m -> f m = contradiction"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nIter_iter. Soit $A$ un ensemble. Soit $g$ une fonction des éléments de $A$ à des éléments de $A$. Alors pour tous les éléments $a$ de $A$, pour tous les nombres naturels $b$ et $c$, $iter$ appliqué à $A$ et $g$ et $c$ et $iter$ appliqué à $A$ et $g$ et $b$ et $a$ est égal à $iter$ appliqué à $A$ et $g$ et la somme de $b$ et de $c$ et $a$.\nassistant\n", "label": "postulate iter_iter : (A : Set) -> (g : (_ : A) -> A) -> (a : A) -> (b : Nat) -> (c : Nat) -> Eq (iter A g c (iter A g b a)) (iter A g (plus b c) a)", "predict": "postulate iter_iter : (A : Set) -> (g : (a : A) -> A) -> (a : A) -> (b : Nat) -> (c : Nat) -> iter A g c (iter A g b a) == iter A g (b + c) a"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_rect_Type2. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_869$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type2$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $_nil$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $_nil$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $Q_$ de $mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Alors pour tous les éléments $x_869$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_869$.\nassistant\n", "label": "Axiom Aop_rect_Type2 : forall A : Set, forall _nil : A, forall Q_ : ((_x_869 : Aop A _nil) -> Type2), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_869 : Aop A _nil, Q_ x_869 .", "predict": "Axiom Aop_rect_Type2 : forall A : Set, forall _nil : A, forall Q_ : ((_x_869 : Aop A _nil) -> Type2), forall _H_mk_Aop : ((op : (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_869 : Aop A _nil, Q_ x_869 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_upper_bound6. Let $n , m \\in N$. Assume that $nth_prime$ applied to $n$ is less than $m$. Then for all natural numbers $x$, $Nat$.\nassistant\n", "label": "postulate let_upper_bound6 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> (x : Nat) -> Nat", "predict": "postulate let_upper_bound6 : (n : N) -> (m : N) -> (x : Nat) -> nth_prime n < m -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nPermut_n_to_le. Låt $h$ vara en funktion från naturliga tal till naturliga tal. Låt $k$ och $n$ vara naturliga tal. Anta att $k \\leq n$. Låt $__1$ vara ett element av $permut$ av $h$ och $n$. Låt $__2$ vara en funktion från naturliga tal $m$ och element $__2$ av $Lt$ av $m$ och $k$ till element av $Eq$ av $h (m)$ och $m$. Låt $j$ vara ett naturligt tal. Anta att $k \\leq j$. Då om $j \\leq n$, så $k \\leq h (j)$.\nassistant\n", "label": "Axiom permut_n_to_le : forall h : ((x__ : nat) -> nat), forall k : nat, forall n : nat, forall x__ : Leq k n, forall __1 : permut h n, forall __2 : ((m : nat) -> (__2 : m < k) -> h m = m), forall j : nat, forall __3 : Leq k j, forall __4 : Leq j n, Leq k (h j) .", "predict": "Axiom permut_n_to_le : forall h : nat -> nat, forall k : nat, forall n : nat, forall __1 : permut h n, forall __2 : ((m : nat) -> (__2 : Lt m k) -> Eq (h m) m), forall j : nat, k <= j -> j <= n -> k <= h j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLt_minus_to_plus. För alla naturliga tal $a$ och $b$ och $c$, om skillnaden mellan $a$ och $b$ är mindre än $c$, så är $a$ mindre än summan av $c$ och $b$.\nassistant\n", "label": "Axiom lt_minus_to_plus : forall a : nat, forall b : nat, forall c : nat, forall x__ : (a - b < c), a < c + b .", "predict": "Axiom lt_minus_to_plus : forall a : nat, forall b : nat, forall c : nat, if a - b < c then a < c + b ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNat_rect_Type3_body. Pour toutes les fonctions $Q_$ des nombres naturels $_x_377$ à des éléments de $Type3$, pour tous les éléments $_H_O$ de $Q_$ de $0$, pour toutes les fonctions $_H_S$ des nombres naturels $x_378$ et des éléments $_x_380$ de $Q_$ de $x_378$ à des éléments de $Q_$ de $x_378 + 1$, pour tous les nombres naturels $x_377$, $Q_$ tient pour $x_377$.\nassistant\n", "label": "Axiom nat_rect_Type3_body : forall Q_ : ((_x_377 : nat) -> Type3), forall _H_O : Q_ 0, forall _H_S : ((x_378 : nat) -> (_x_380 : Q_ x_378) -> Q_ (x_378 + 1)), forall x_377 : nat, Q_ x_377 .", "predict": "Axiom nat_rect_Type3_body : forall Q_ : ((_x_377 : Type) -> Type3), forall _H_O : Q_ 0, forall _H_S : ((x_378 : Type) -> (_x_380 : Q_ x_378) -> Q_ (x_378 + 1)), forall x_377 : Type, Q_ x_377 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nF_false_to_le_max. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n , p \\in N$. Soit $__$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de $Eq$ appliqué à $f$ appliqué à $i$ et $true$. Soit $__1$ une fonction des nombres naturels $m$ et des éléments $__1$ de $Lt$ de $p$ et de $m$ à des éléments de $Eq$ de $f$ appliqué à $m$ et de contradiction. Alors $max$ appliqué à $n$ et $f$ est inférieur ou ágal à $p$.\nassistant\n", "label": "Axiom f_false_to_le_max : forall f : ((x__ : nat) -> bool), forall n : nat, forall p : nat, forall x__ : ex nat (fun i => i < n /\\ f i = true), forall __1 : ((m : nat) -> (__1 : p < m) -> f m = false), Leq (max n f) p .", "predict": "Axiom f_false_to_le_max : forall f : ((i : N) -> Bool), forall n : N, forall p : N, forall __ : (Nat -> (Lt i n) -> (Eq (f i) true)), forall __1 : ((m : N) -> (__1 : Lt p m) -> Eq (f m) contradiction), forall max : ((i : N) -> (j : N) -> N), max n (f n) <= p ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAop_rect_Type4. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_863$ av $Aop$ av $A$ och $_nil$ till element av $Type4$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$, för alla element $x_863$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_863$.\nassistant\n", "label": "postulate Aop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863", "predict": "postulate Aop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Set4) -> (_H_mk_Aop : (op : (__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_inv_S_dx. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $l$ vara ett naturligt tal. Då för alla element $b1$ och $b2$ av $B$, för alla element $__$ av $lstar$ av $B$ och $R$ och $l + 1$ och $b1$ och $b2$, håller $ex2$ för $B$ och funktionen som avbildar $b$ som $lstar (B , R , l , b1 , b)$ och funktionen som avbildar $b$ som $R (b , b2)$.\nassistant\n", "label": "lstar_inv_S_dx : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar B R (plus l (nd 1)) b1 b2 -> ex2 B (b : B => lstar B R l b1 b) (b : B => R b b2) .", "predict": "lstar_inv_S_dx : B : set -> R : relation B -> l : nat -> b1 : B -> b2 : B -> __ : lstar B R (l + 1) b1 b2 -> ex2 : B -> (b : B -> lstar (B , R , l , b1 , b)) -> (b : B -> R (b , b2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_CProp0. Let $x1$ be a set. Let $x2$ be an element of $x1$. Then for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op (x2 , a)$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op (a , x2)$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op (a , op (b , c))$ and $op (op (a , b), c)$ and elements $_z1561$ of $Eq$ of $Hterm$ and $mk_Aop (x1 , x2 , op , _nill , _nilr , _assoc)$ to elements of $P$ of $mk_Aop (x1 , x2 , op , _nill , _nilr , _assoc)$, $P$ holds for $Hterm$.\nassistant\n", "label": "Aop_inv_rect_CProp0 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1560 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .", "predict": "Aop_inv_rect_CProp0 : x1 : Set -> x2 : Element_of x1 -> Hterm : Aop x1 x2 -> P : (_z1560 : Aop x1 x2 -> Proposition) -> _H1 : (op : (__1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_times_to_le_div. Soit $a , b , c \\in N$. Alors si $0 < b$, alors si $b c \\leq a$, alors $c \\leq a \\div b$.\nassistant\n", "label": "le_times_to_le_div : a : Nat -> b : Nat -> c : Nat -> __ : Lt 0 b -> __1 : Leq (times b c) a -> Leq c (div a b) .", "predict": "le_times_to_le_div : a : N -> b : N -> c : N -> 0 < b -> b c <= a -> c <= a / b ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_to_le_min. For all functions $f$ from natural numbers to booleans, for all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then for all natural numbers $b$, $min$ applied to $n$ and $b$ and $f$ is less than or equal to $min$ applied to $m$ and $b$ and $f$.\nassistant\n", "label": "postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> Leq (min n b f) (min m b f)", "predict": "postulate le_to_le_min : (f : Nat -> Bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> min n b f <= min m b f"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAop_rect_CProp5. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_877$ av $Aop$ av $A$ och $_nil$ till påståenden. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Då för alla element $x_877$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_877$.\nassistant\n", "label": "axiom Aop_rect_CProp5 (A : Set) (_nil : A) (Q_ : (_x_877 : Aop A _nil) -> Prop) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_877 : Aop A _nil) : Q_ x_877", "predict": "axiom Aop_rect_CProp5 (A : Set) (_nil : A) (Q_ : (_x_877 : Aop A _nil) -> Set) (_H_mk_Aop : (op : (a : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_877 : Aop A _nil) : Q_ x_877"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Då om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $m$ och $b$ och produkten av $p$ och $a$.\nassistant\n", "label": "axiom let_clause_16171 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : b * m - a * p = gcd p m) (H0 : b * m - a * p = 1) : gcd p m = m * b - p * a", "predict": "axiom let_clause_16171 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : ex Nat (λ b => Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m))) (b : Nat) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) : Bool) :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nMin_body. Soient $__$ et $__1$ des nombres naturels. Alors pour toutes les fonctions $__2$ des nombres naturels $__2$ à des valeurs booléennes, $Nat$.\nassistant\n", "label": "postulate min_body : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat", "predict": "postulate min_body : (__ : Naturals) -> (__1 : Naturals) -> (__2 : (__2 : Naturals) -> Bool) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPi_p_primeb_dividesb. Soit $n \\in N$. Alors si $0$ est inférieur à $n$, alors $n$ est égal à $bigop$ appliqué à la somme de $n$ et de $1$ et la fonction qui envoie $p$ à $andb$ appliqué à $primeb$ appliqué à $p$ et $dividesb$ appliqué à $p$ et $n$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à la puissance de $p$ et de $ord$ appliqué à $n$ et $p$.\nassistant\n", "label": "postulate pi_p_primeb_dividesb : (n : Nat) -> (_ : Lt 0 n) -> Eq n (bigop (plus n 1) (\\ p : Nat -> andb (primeb p) (dividesb p n)) Nat 1 times (\\ p : Nat -> pow p (ord n p)))", "predict": "postulate pi_p_primeb_dividesb : (n : N) -> 0 < n -> n == bigop (n + 1) (\\ p : N -> andb (primeb p) (dividesb p n)) Nat 1 times (\\ p : N -> power p (ord n p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nP_ord_exp. Låt $n$ och $m$ och $i$ vara naturliga tal. Anta att $0$ är mindre än $m$. Anta att $mod$ applicerat på $n$ och $m$ inte är lika med $0$. Låt $p \\in N$. Då om $i$ är mindre än eller lika med $p$, så är $p_ord_aux$ applicerat på $p$ och produkten av potensen av $m$ och $i$ och $n$ och $m$ lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $i$ och $n$.\nassistant\n", "label": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)", "predict": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (0 : Nat) < m -> (mod n m /= 0) -> (p : Nat) -> (i : Nat) < p -> p_ord_aux p (product (power m i) n) m) == mk_Prod Nat Nat i n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDivides_fact. Pour tous les nombres naturels $n$ et $i$, si $0 < i$, alors si $i \\leq n$, alors $i$ est divisible par $n !$.\nassistant\n", "label": "postulate divides_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 0 i) -> (__1 : Leq i n) -> divisible i (factorial n)", "predict": "postulate divides_fact : (n : Set) -> (i : Set) -> (0 : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (postulate divides_fact : (n : Set) -> (i : Set) -> (0 : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (postulate divides_fact : (n : Set) -> (i : Set) -> (0 : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (i : Set) -> (n : Set) -> (postulate divides_fact : (n : Set) -> (i : Set) -> (0 : Set) -> (i : Set) -> (n :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nCongruent_n_mod_times. Soient $n$ et $m$ et $p$ des nombres naturels. Supposons que $0$ est inférieur à $p$. Alors si $0$ est inférieur à $m$, alors $congruent$ tient pour $n$ et $mod$ appliqué à $n$ et le produit de $m$ et de $p$ et $p$.\nassistant\n", "label": "Axiom congruent_n_mod_times : forall n : nat, forall m : nat, forall p : nat, forall x__ : (0 < p), forall __1 : (0 < m), congruent n (mod n (m * p)) p .", "predict": "Axiom congruent_n_mod_times : forall n : nat, forall m : nat, forall p : nat, forall n0 : nat, forall m0 : nat, forall p0 : nat, nat <= p0 -> nat <= m0 -> congruent n (mod n (m * p)) p ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nEq_ord_sigma_p. Soit $n , m , x \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $x$ est premier. Supposons que la puissance de $x$ et de $m$ est inférieure ou ágale à $n$. Alors si $n$ est inférieur à la puissance de $x$ et de la somme de $m$ et de $1$, alors $ord$ appliqué à $n$ et $x$ est égal à $bigop$ appliqué à $m$ et la fonction qui envoie $i$ à $dividesb$ appliqué à la puissance de $x$ et de la somme de $i$ et de $1$ et $n$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $1$.\nassistant\n", "label": "eq_ord_sigma_p : n : Nat -> m : Nat -> x : Nat -> __ : Lt 0 n -> __1 : prime x -> __2 : Leq (pow x m) n -> __3 : Lt n (pow x (plus m (nd 1))) -> Eq (ord n x) (bigop m (i : Nat => dividesb (pow x (plus i (nd 1))) n) Nat 0 plus (i : Nat => nd 1)) .", "predict": "eq_ord_sigma_p : n : N -> m : N -> x : N -> 0 < n -> x : Prime -> power_x_m : n -> n < power_x (m + 1) -> ord_n_x : Nat -> 0 <= ord_n_x <= plus (m + 1) n -> bigop_m : (i : Nat -> dividesb (power_x (i + 1)) n) -> Nat -> 0 -> plus -> (i : Nat -> 1) -> ord_n_x = bigop_m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_gcd_times. Let $m , n , p \\in N$. Assume that $0$ is less than $p$. Then the greatest common divisor of $m$ and $n$ is less than or equal to the greatest common divisor of $m$ and the product of $n$ and $p$.\nassistant\n", "label": "le_gcd_times : m : Nat -> n : Nat -> p : Nat -> __ : Lt 0 p -> Leq (gcd m n) (gcd m (times n p)) .", "predict": "le_gcd_times : m : N -> n : N -> p : N -> 0 < p -> gcd(m, n) <= gcd(m, n * p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$. Supposons que $b \\leq n$. Supposons que $f (b)= j$. Alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : N -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (b : N) (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) (injf : injn f n) : (a = b) -> f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLd_to_prime. Soit $i \\in N$. Soit $acc$ une liste de nombres naturels. Supposons que $1$ est inférieur à $i$. Alors pour tous les éléments $__1$ de $primes_below$ de $acc$ et de $i$, si $list_divides$ appliqué à $acc$ et $i$ est égal à contradiction, alors $i$ est premier.\nassistant\n", "label": "postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i", "predict": "postulate ld_to_prime : (i : N) -> (acc : List Nat) -> (__1 : primes_below acc i) -> (list_divides acc i) -> contradiction) -> i : Prime"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Then for all natural numbers $a$, if $a \\leq n$ and $f (a)= i$ and $a \\leq n$, then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$ and $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nassistant\n", "label": "let_clause_1068 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) i .", "predict": "let_clause_1068 : f : (N -> N) -> n : N -> permf : permut f n -> i : N -> j : N -> a : N -> b : N -> __ : (i0 : N -> Leq i0 n -> Leq f i0 n) -> injf : injn f n -> a = b -> f (a) = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_exp. Soit $n , m , p \\in N$. Supposons que $0 < p$ et $n \\leq m$. Alors $p ^ n \\leq p ^ m$.\nassistant\n", "label": "postulate le_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq n m) -> Leq (pow p n) (pow p m)", "predict": "postulate le_exp : (n : N) -> (m : N) -> (p : N) -> 0 < p -> n <= m -> p ^ n <= p ^ m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_inv_plus_l. Let $x$ and $y$ and $z$ be natural numbers. Assume that the sum of $x$ and $y$ is less than or equal to $z$. Then $x$ is less than or equal to the difference of $z$ and $y$ and $y$ is less than or equal to $z$.\nassistant\n", "label": "Axiom le_inv_plus_l : forall x : nat, forall y : nat, forall z : nat, forall x__ : Leq (x + y) z, Leq x (z - y) /\\ Leq y z .", "predict": "Axiom le_inv_plus_l : forall x : nat, forall y : nat, forall z : nat, ((x + y) <= z) -> (x <= (z - y)) -> (y <= z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1062. Let $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ be natural numbers. Let $_clearme$ be an element of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$. Assume that $r < b$ and $a = q b + r$. Let $_clearme0$ be an element of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$. Assume that $r1 < b$ and $a = q1 b + r1$. Assume that $q$ is not less than or equal to $q1$. Then $a = r1 + b q1$.\nassistant\n", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (q : q1) -> a = r1 + b q1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPermut_mod. Soit $p , a \\in N$. Supposons que $p$ est premier. Supposons que $p$ n'est pas divisible par $a$. Alors $permut$ tient pour la fonction qui envoie $n$ à $mod (a n , p)$ et $pred (p)$.\nassistant\n", "label": "axiom permut_mod (p a : Nat) (x__ : prime p) (__1 : ¬ divisible p a) : permut (λ n => mod (a * n) p) (pred p)", "predict": "axiom permut_mod (p a : N) : (λ n => mod (a n) p) => pred p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSigma_p_dividesb1. Let $m$ and $n$ and $p$ and $k$ be natural numbers. Assume that $0 < n$. Assume that $p$ is prime. Then if $p$ is not divisible by $n$, then if $m \\leq k$, then $bigop$ applied to $k$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$ is equal to $m$.\nassistant\n", "label": "postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (0 < n) -> (p : Prime) -> (m <= k) -> bigop k (\\ i : Nat -> dividesb (exp p (i + 1)) (exp p m) n) Nat 0 plus (\\ i : Nat -> 1)) = m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1560. Let $n$ and $m$ be natural numbers. Assume that $n$ is divisible by $m$. Assume that $0$ is equal to $n$. Let $d$ be a natural number. Assume that $m$ is equal to the product of $0$ and $d$. Then $n$ is equal to $0$.\nassistant\n", "label": "axiom let_clause_1560 (n m : Nat) (divnm : divisible n m) (H : 0 = n) (d : Nat) (auto : m = 0 * d) : n = 0", "predict": "axiom let_clause_1560 (n m : Nat) (d : Nat) : Nat => if n % m = 0 && 0 = n then d else 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDivides_fact. Låt $n$ och $i$ vara naturliga tal. Anta att $0 < i$. Anta att $i \\leq n$. Då är $i$ delbart med $n !$.\nassistant\n", "label": "Axiom divides_fact : forall n : nat, forall i : nat, forall x__ : (0 < i), forall __1 : Leq i n, divisible i (factorial n) .", "predict": "Axiom divides_fact : forall n : nat, forall i : nat, 0 < i -> i <= n -> natdiv i n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLstar_ind_r_aux. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $b1$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b1$. Soit $__1$ une fonction des nombres naturels $l$ et des éléments $b$ de $B$ et des éléments $b2$ de $B$ et des éléments $__1$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b$ et des éléments $__2$ de $R$ de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de la somme de $l$ et de $1$ et de $b2$. Soit $l \\in N$. Soient $b$ et $b2$ des éléments de $B$. Soit $__2$ un élément de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$. Supposons que $b$ est égal à $b1$. Alors $P$ tient pour $l$ et $b2$.\nassistant\n", "label": "axiom lstar_ind_r_aux (B : Set) (R : relation B) (b1 : B) (P : relation2 Nat B) (x__ : P 0 b1) (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2) (l : Nat) (b b2 : B) (__2 : lstar B R l b b2) (__3 : b = b1) : P l b2", "predict": "axiom lstar_ind_r_aux (B : Set) (R : relation B) (b1 : B) (P : relation2 Nat B) (__ : P 0 b1) (__1 : (l : Nat) -> (b : B) -> (b2 : B) -> (__1 : lstar B R l b1 b) -> (__2 : R b b2) -> (__3 : P l b) -> P (l + 1) b2) (l : Nat) (b b2 : B) (__2 : lstar B R l b b2) (h : b = b1) : P l b2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1607. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nassistant\n", "label": "Axiom let_clause_1607 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c .", "predict": "Axiom let_clause_1607 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : (d : Nat) -> Eq (diff (prod c n) (prod d m)) 1 -> Eq (diff (prod d m) (prod c n)) 1 -> forall d : Nat, ((diff (prod c n) (prod d m)) = 1) \\/ ((diff (prod d m) (prod c n)) = 1) -> (diff (prod d m) (prod c n)) = 1 -> forall div : Nat, (div = (diff (prod m d) (prod n c))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1033. Låt $p , n , q , r \\in N$. Anta att $0 < p$ och $p$ inte är delbart med $r$. Då om $n = p ^ q r$, så för alla naturliga tal $q0$ och $q1$, om $q1 + 1 \\leq p ^ (q1 + 1)$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_1033 : forall p : nat, forall n : nat, forall q : nat, forall r : nat, forall posp : (0 < p), forall ndivpr : (~ divisible p r), forall Hn : (n = pow p q * r), forall q0 : nat, forall q1 : nat, forall Hind : Leq (q1 + 1) (pow p (q1 + 1)), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_1033 : forall p : N, forall n : N, forall q : N, forall r : N, forall q0 : N, forall q1 : N, forall x2515 : N, forall x2516 : N, x2515 = x2516 (x2515 div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDiv_mod_spec_inv_rect_CProp2. Soient $x1$ et $x2$ et $x3$ et $x4$ des nombres naturels. Soit $Hterm$ un élément de $div_mod_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$. Alors pour toutes les fonctions $P$ des éléments $_z1482$ de $div_mod_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$ à des propositions, pour toutes les fonctions $_H1$ des éléments $x_851$ de $Lt$ de $x4$ et de $x2$ et des éléments $x_850$ de $Eq$ de $x1$ et de la somme du produit de $x3$ et de $x2$ et de $x4$ et des éléments $_z1483$ de $Eq$ de $Hterm$ et de $div_mod_spec_intro$ appliqué à $x1$ et $x2$ et $x3$ et $x4$ et $x_851$ et $x_850$ à des éléments de $P$ de $div_mod_spec_intro$ appliqué à $x1$ et $x2$ et $x3$ et $x4$ et $x_851$ et $x_850$, $P$ tient pour $Hterm$.\nassistant\n", "label": "postulate div_mod_spec_inv_rect_CProp2 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1482 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_851 : Lt x4 x2) -> (x_850 : Eq x1 (plus (times x3 x2) x4)) -> (_z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_CProp2 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1482 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_851 : Lt x4 x2) -> (x_850 : Eq x1 (x_851 * x3 + x4)) -> (_z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1573. Let $n$ and $m$ be natural numbers. Assume that $0$ is less than $n$. Assume that $m$ is divisible by $n$. Then for all natural numbers $d$, if $0$ is equal to $m$, then if $n$ is equal to the product of $m$ and $d$, then $n$ is equal to $m$.\nassistant\n", "label": "Axiom let_clause_1573 : forall n : nat, forall m : nat, forall posn : (0 < n), forall _clearme : divisible m n, forall d : nat, forall auto : (0 = m), forall auto' : (n = m * d), n = m .", "predict": "Axiom let_clause_1573 : forall n : nat, forall m : nat, forall d : nat, (0 < n -> m = n * d -> n = m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMax_spec_ind. Låt $_n \\in N$. Låt $_f$ vara en funktion från naturliga tal till sanningsvärden. Låt $Q_$ vara en funktion från naturliga tal $x_971$ och element $_x_972$ av $max_spec$ av $_n$ och $_f$ och $x_971$ till påståenden. Låt $_H_found_max_spec$ vara en funktion från naturliga tal $m$ och element $x_975$ av $Lt$ av $m$ och $_n$ och element $x_974$ av $Eq$ av $_f (m)$ och $true$ och funktioner $x_973$ från naturliga tal $i$ och element av $Lt$ av $m$ och $i$ och element $__1$ av $Lt$ av $i$ och $_n$ till element av $Eq$ av $_f (i)$ och kontradiktion till element av $Q_$ av $m$ och $found_max_spec (_n , _f , m , x_975 , x_974 , x_973)$. Låt $_H_not_found_max_spec$ vara en funktion från funktioner $x_976$ från naturliga tal $i$ och element av $Lt$ av $i$ och $_n$ till element av $Eq$ av $_f (i)$ och kontradiktion till element av $Q_$ av $0$ och $not_found_max_spec (_n , _f , x_976)$. Då för alla naturliga tal $x_971$, för alla element $x_972$ av $max_spec$ av $_n$ och $_f$ och $x_971$, håller $Q_$ för $x_971$ och $x_972$.\nassistant\n", "label": "max_spec_ind : _n : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_971 : Nat -> _x_972 : max_spec _n _f x_971 -> Prop) -> _H_found_max_spec : (m : Nat -> x_975 : Lt m _n -> x_974 : Eq (_f m) true -> x_973 : (i : Nat -> __ : Lt m i -> __1 : Lt i _n -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> _H_not_found_max_spec : (x_976 : (i : Nat -> __ : Lt i _n -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> x_971 : Nat -> x_972 : max_spec _n _f x_971 -> Q_ x_971 x_972 .", "predict": "max_spec_ind : _n : N -> _f : (nat -> sanningsvärden) -> Q_ : (x_971 : nat -> _x_972 : max_spec _n _f x_971 -> påståenden) -> _H_found_max_spec : (m : nat -> x_975 : Lt m _n -> x_974 : Eq _f m true -> x_973 : (i : nat -> _x_972 : Lt m i -> __1 : Lt i _n -> Eq _f i kontradiktion) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> _H_not_found_max_spec : (x_976 : (i : nat -> _x_972 : Lt i _n -> Eq _f i kontradiktion) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> x_971 : nat -> x_972 : max_spec _n _f x_971 -> Q_ x_971 x_972 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nMax'. Soit $__ \\in N$. Soit $__1$ une fonction des nombres naturels $__1$ à des valeurs booléennes. Soit $__2 \\in N$. Alors $Nat$.\nassistant\n", "label": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat", "predict": "postulate max' : (__ : N) -> (__1 : (__ : N) -> Bool) -> (__2 : N) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nPermut_transpose. Soient $i$ et $j$ et $n$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Alors $permut$ tient pour $transpose$ appliqué à $i$ et $j$ et $n$.\nassistant\n", "label": "permut_transpose : i : Nat -> j : Nat -> n : Nat -> __ : Leq i n -> __1 : Leq j n -> permut (transpose i j) n .", "predict": "permut_transpose : i : Nat -> j : Nat -> n : Nat -> i <= n -> j <= n -> permut (transpose i j) n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLstar_step. För alla mängder $B$, för alla funktioner $R$ från element av $B$ och element $__1$ av $B$ till påståenden, för alla element $b1$ och $b2$ av $B$, för alla element $__$ av $R$ av $b1$ och $b2$, håller $lstar$ för $B$ och $R$ och $1$ och $b1$ och $b2$.\nassistant\n", "label": "Axiom lstar_step : forall B : Set, forall R : ((x__ : B) -> (__1 : B) -> Prop), forall b1 : B, forall b2 : B, forall x__ : R b1 b2, lstar B R 1 b1 b2 .", "predict": "Axiom lstar_step : forall B : Set, forall R : ((x : B) -> (__1 : B) -> Prop), forall b1 : B, forall b2 : B, forall __ : R b1 b2, forall lstar : ((B : Set) -> (R : (x : B) -> (__1 : B) -> Prop) -> (m : B) -> (n : B) -> Prop), lstar B R 1 b1 b2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Alors si $a$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $a$ est égal à $i$, alors pour tous les nombres naturels $b$, si $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$, alors si $b$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $b$ est égal à $j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : N -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (Hc : a <= n) (Hd : f a = i) (He : a <= n) (Hf : f a = i) (b : N) (Hg : b <= n) (Hh : f b = j) (Hi : b <= n) (Hj : f b = j) (__ : (i0 : N) -> (Leq i0 n) -> (Leq (f i0) n)) (injf : injn f n) (Hk : a = b) : f a = i) : Lean_proof (λ x => λ y => λ z => λ w => λ v => λ u => axiom let_clause_1068 (f : N -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (Hc : a <= n) (Hd : f a = i) (He : a <= n) (Hf : f a = i) (b : N) (Hg : b <= n) (Hh : f b = j) (Hi : b <= n) (Hj : f b = j) (__ : (i0 : N) -> (Leq i0 n) -> (Leq (f i0) n)) (injf : injn f n) (Hk : a = b) : f a = i) : Lean_proof (λ x => λ y => λ z => λ w => λ v => λ u => axiom let_clause_1068 (f : N -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (Hc : a <= n) (Hd : f a = i) (He : a <= n) (Hf : f a = i) (b : N) (Hg : b <= n) (Hh : f b = j) (Hi : b <= n) (Hj : f b = j) (__ : (i0 : N) -> (Leq i0 n) -> (Leq (f i0) n)) (injf :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_div. Let $n$ and $d$ be natural numbers. Assume that $0 < n$ and $d$ is divisible by $n$. Then $n \\div (n \\div d)= d$.\nassistant\n", "label": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d", "predict": "postulate div_div : (n : Set) -> (d : Set) -> (0 : Set) -> (n : Set) -> (d : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (postulate div_div : (n : Set) -> (d : Set) -> (0 : Set) -> (n : Set) -> (d : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div : Set) -> (n : Set) -> (div :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDivides_exp_to_divides. Soient $p$ et $n$ et $m$ des nombres naturels. Supposons que $p$ est premier. Supposons que $p$ est divisible par $n ^ m$. Alors $p$ est divisible par $n$.\nassistant\n", "label": "divides_exp_to_divides : p : Nat -> n : Nat -> m : Nat -> __ : prime p -> __1 : divisible p (pow n m) -> divisible p n .", "predict": "divides_exp_to_divides : p : Nat -> n : Nat -> m : Nat -> p : n ^ m -> p : n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_15441. Soient $p$ et $q$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soient $m$ et $n$ des nombres naturels. Supposons que $0 < n$. Supposons que $n \\leq m$. Supposons que $n \\leq q + 1$. Supposons que $n$ n'est pas divisible par $m$. Soit $a \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b \\in N$. Supposons que $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ ou $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Supposons que $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Alors $n b - a mod (m , n)= gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "Axiom let_clause_15441 : forall p : nat, forall q : nat, forall Hind : ((m : nat) -> (n : nat) -> (x__ : 0 < n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex nat (fun a => ex nat (fun b => a * n - b * m = gcd_aux q m n \\/ b * m - a * n = gcd_aux q m n))), forall m : nat, forall n : nat, forall posn : (0 < n), forall lenm : Leq n m, forall lenS : Leq n (q + 1), forall ndivnm : (~ divisible n m), forall a : nat, forall _clearme : ex nat (fun b => a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall b : nat, forall _clearme0 : (a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall H : (b * n - a * mod m n = gcd_aux q n (mod m n)), n * b - a * mod m n = gcd_aux q n (mod m n) .", "predict": "Axiom let_clause_15441 : forall p : Nat, forall q : Nat, forall Hind : ((m : Nat) -> (n : Nat) -> (Lt : 0 <= n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> (ex : Nat) -> (a : Nat) -> (b : Nat) -> (Eq : (difference : (a * n) - (b * m)) -> (gcd_aux : q -> m) -> n) -> (let_clause_15441 : forall m : Nat, forall n : Nat, forall 0 : Nat, forall n_leq_m : Nat, forall n_leq_q_plus_1 : Nat, forall n_not_divisible_by_m : Nat, forall a : Nat, forall _clearme : ex Nat (b : Nat) -> (disjonction : Eq (difference (a * mod m n) (b * n)) (gcd_aux q n (mod m n)) -> Eq (difference (b * n) (a * mod m n)) (gcd_aux q n (mod m n))) -> forall b : Nat, forall a_mod_m_n_minus_b_n : gcd_aux (q : Nat) (n : Nat) (mod (m : Nat) n) -> forall b_n_minus_a_mod_m_n : gcd_aux (q : Nat) (n : Nat) (mod (m : Nat) n) -> forall n_b_minus_a_mod_m_n : gcd_aux (q : Nat) (n : Nat) (mod (m : Nat) n), nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a$ un nombre naturel. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Alors si $f$ appliqué à $b$ est égal à $j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : (Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_plus_b. Let $b$ and $n$ and $m$ be natural numbers. Then if $n + b \\leq m$, then $n \\leq m$.\nassistant\n", "label": "postulate le_plus_b : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus n b) m) -> Leq n m", "predict": "postulate le_plus_b : (b : Nat) -> (n : Nat) -> (m : Nat) -> n + b <= m -> n <= m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a \\in N$. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Då om $f$ applicerat på $a$ är lika med $i$, så för alla naturliga tal $b$, om $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$, så om $b$ är mindre än eller lika med $n$, så om $f$ applicerat på $b$ är lika med $j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : nat -> nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : (f : nat -> nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : (f : nat -> nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNat_inv_rect_Type2. Låt $Hterm$ vara ett naturligt tal. Låt $P$ vara en funktion från naturliga tal $_z671$ till element av $Type2$. Låt $_H1$ vara en funktion från element $_z672$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$. Då för alla funktioner $_H2$ från naturliga tal $x_382$ och funktioner $_x_384$ från element $_z672$ av $Eq$ av $Hterm$ och $x_382$ till element av $P$ av $x_382$ och element $_z672$ av $Eq$ av $Hterm$ och $x_382 + 1$ till element av $P$ av $x_382 + 1$, håller $P$ för $Hterm$.\nassistant\n", "label": "nat_inv_rect_Type2 : Hterm : Nat -> P : (_z671 : Nat -> Type2) -> _H1 : (_z672 : Eq Hterm 0 -> P 0) -> _H2 : (x_382 : Nat -> _x_384 : (_z672 : Eq Hterm x_382 -> P x_382) -> _z672 : Eq Hterm (plus x_382 (nd 1)) -> P (plus x_382 (nd 1))) -> P Hterm .", "predict": "nat_inv_rect_Type2 : Hterm : nat -> P : (_z671 : nat -> Type2) -> _H1 : (_z672 : Eq Hterm 0 -> P 0) -> _H2 : (x_382 : nat -> _x_384 : (_z672 : Eq Hterm x_382 -> P x_382) -> _z672 : Eq Hterm (x_382 + 1) -> P (x_382 + 1)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_16001. Soit $m , n , a , b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$, alors si $c n - d m = 1$, alors $n c - m d$ est égal au diviseur commun plus grand de $m$ et de $n$.\nassistant\n", "label": "axiom let_clause_16001 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : gcd m n = n * c - m * d", "predict": "axiom let_clause_16001 (m n a b : Nat) (_clearme : ex Nat (λ d => Eq (n * c - d * m) 1)) (c d : Nat) : Nat => if c n - d m = 1 || d m - c n = 1 then if c n - d m = 1 then m n - n c + m d else m n - n c - m d"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_10331. Låt $n \\in N$. Anta att $5 < n$. Då för alla naturliga tal $m$, om $6 \\leq m$ och $(m + 1)^ 2 \\leq 2 ^ m$, så för alla naturliga tal $a$, om $6 \\leq a$ och $2 (a + 1)+ 1 \\leq 2 ^ a$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_10331 : forall n : nat, forall lt4n : (5 < n), forall m : nat, forall le4m : Leq 6 m, forall Hind : Leq (pow (m + 1) 2) (pow 2 m), forall a : nat, forall lea : Leq 6 a, forall Hinda : Leq (2 * (a + 1) + 1) (pow 2 a), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_10331 : forall n : N, forall m : N, forall a : N, forall x2515 : N, forall x2516 : N, 5 < n -> 6 <= m -> (m + 1)^2 <= 2 ^ m -> 6 <= a -> 2 (a + 1)+ 1 <= 2 ^ a -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nACop_rect_CProp0_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_913$ de $ACop$ de $A$ et de $_nil$ à des propositions. Soit $_H_mk_ACop$ une fonction des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et de $op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $Q_$ de $mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$. Alors pour tous les éléments $x_913$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_913$.\nassistant\n", "label": "postulate ACop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_913 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_913 : ACop A _nil) -> Q_ x_913", "predict": "postulate ACop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_913 : ACop A _nil) -> Set) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_913 : ACop A _nil) -> Q_ x_913"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i$ est inférieur ou ágal à $n$. Alors si $j$ est inférieur ou ágal à $n$, alors pour tous les nombres naturels $a$, si $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$, alors si $a$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $a$ est égal à $i$, alors pour tous les nombres naturels $b$, si $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$, alors si $b$ est inférieur ou ágal à $n$, alors si $f$ appliqué à $b$ est égal à $j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "Axiom let_clause_1063 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = j .", "predict": "Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : ((i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : ((i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : ((i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : ((i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : ((i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : ((i0 : nat) -> (Leq i0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1033. Låt $n$ vara ett naturligt tal. Anta att $2 ^ 7 \\leq n$. Låt $p \\in N$. Anta att $\\sqrt{ (2 n)}+ 1 \\leq p$ och $p < 2 n + 1$. Då om $leb (2 , k (2 n , p))= true$ och $2 n < p ^ 2$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "let_clause_1033 : n : Nat -> len : Leq (pow (nd 2) (nd 7)) n -> p : Nat -> lep : Leq (plus (sqrt (times (nd 2) n)) (nd 1)) p -> ltp : Lt p (plus (times (nd 2) n) (nd 1)) -> Hc : Eq (leb (nd 2) (k (times (nd 2) n) p)) true -> H2n : Lt (times (nd 2) n) (pow p (nd 2)) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_1033 : n : Nat -> p : Nat -> leb (2 , k (2 n , p)) -> 2 n < p^2 -> x2515 : Nat -> x2516 : Nat -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDiv_mod_spec_rect_CProp3_body. Soient $_n$ et $_m$ et $_q$ et $_r$ des nombres naturels. Soit $Q_$ une fonction des éléments $_x_845$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_847$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_846$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_847$ et $x_846$. Alors pour tous les éléments $x_845$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_845$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp3_body (_n _m _q _r : Nat) (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_847 : _r < _m) -> (x_846 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) (x_845 : div_mod_spec _n _m _q _r) : Q_ x_845", "predict": "axiom div_mod_spec_rect_CProp3_body (_n _m _q _r : Nat) (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_847 : Lt _r _m) -> (x_846 : Eq _n (product _q _m _r)) -> (Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846))) (x_845 : div_mod_spec _n _m _q _r) : Q_ x_845"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1033. Soit $n$ un nombre naturel. Alors si $1 < n$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "let_clause_1033 : n : Nat -> lt1n : Lt (nd 1) n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_1033 : n : Nat -> x2515 : Nat -> x2516 : Nat -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$. Alors si $j \\leq n$, alors pour tous les nombres naturels $a$, si $a \\leq n$ et $f (a)= i$, alors si $a \\leq n$, alors si $f (a)= i$, alors pour tous les nombres naturels $b$, si $b \\leq n$ et $f (b)= j$, alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : Nat -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (b : Nat) -> (__ : (i0 : Nat) -> (x : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a : b) -> f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_n_fact_n. Pour tous les nombres naturels $n$, si $2$ est inférieur à $n$, alors $n$ est inférieur à la factorielle de $n$.\nassistant\n", "label": "axiom lt_n_fact_n (n : Nat) (x__ : 2 < n) : n < factorial n", "predict": "axiom lt_n_fact_n (n : Nat) : Bool => if 2 < n then n < fact n else false"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_S_S_to_lt. Soient $n$ et $m$ des nombres naturels. Alors si la somme de $n$ et de $1$ est inférieure à la somme de $m$ et de $1$, alors $n$ est inférieur à $m$.\nassistant\n", "label": "axiom lt_S_S_to_lt (n m : Nat) (x__ : n + 1 < m + 1) : n < m", "predict": "axiom lt_S_S_to_lt (n m : Nat) : Bool => and (lt (n + 1) (m + 1)) (lt n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_S. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $b1$ och $b$ vara element av $B$. Låt $__$ vara ett element av $R$ av $b1$ och $b$. Låt $l$ vara ett naturligt tal. Låt $b2$ vara ett element av $B$. Då för alla element $__1$ av $lstar$ av $B$ och $R$ och $l$ och $b$ och $b2$, håller $lstar$ för $B$ och $R$ och $l + 1$ och $b1$ och $b2$.\nassistant\n", "label": "lstar_S : B : Set -> R : relation B -> b1 : B -> b : B -> __ : R b1 b -> l : Nat -> b2 : B -> __1 : lstar B R l b b2 -> lstar B R (plus l (nd 1)) b1 b2 .", "predict": "lstar_S : B : set -> R : relation B -> b1 : B -> b : B -> __ : R b1 b -> l : nat -> b2 : B -> __1 : lstar B R l b b2 -> lstar B R (l + 1) b1 b2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_10331. Let $n$ be a natural number. Let $p$ be a function from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1$ be a natural number. Then for all functions $Hind$ from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $Nat$ and $1$ and $times$ and the function that maps $i$ to $g2$ applied to $i$, for all functions $Hle$ from natural numbers $i$ and elements of $Lt$ of $i$ and the sum of $n1$ and $1$ and elements $__1$ of $Eq$ of $p$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, if $p$ applied to $n1$ is equal to $true$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (p : (i : Nat) -> Bool) -> (g1 : (i : Nat) -> Nat) -> (g2 : (i : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (i : Nat) -> (__1 : Eq p i true) -> Leq (g1 i) (g2 i)) -> (Hle : (i : Nat) -> (__1 : Lt i (n1 + 1)) -> Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 == (x2516 * (x2515 / x2516)) + (mod x2515 x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_ind_body. Soit $_n$ un nombre naturel. Alors pour toutes les fonctions $Q_$ des nombres naturels $x_417$ et des éléments $_x_418$ de $Leq$ de $_n$ et de $x_417$ à des propositions, pour tous les éléments $_H_le_n$ de $Q_$ de $_n$ et de $le_n (_n)$, pour toutes les fonctions $_H_le_S$ des nombres naturels $m$ et des éléments $x_419$ de $Leq$ de $_n$ et de $m$ et des éléments $_x_421$ de $Q_$ de $m$ et de $x_419$ à des éléments de $Q_$ de $m + 1$ et de $le_S (_n , m , x_419)$, pour tous les nombres naturels $x_417$, si $_n \\leq x_417$, alors $Q_$ tient pour $x_417$ et $x_418$.\nassistant\n", "label": "le_ind_body : _n : Nat -> Q_ : (x_417 : Nat -> _x_418 : Leq _n x_417 -> Prop) -> _H_le_n : Q_ _n (le_n _n) -> _H_le_S : (m : Nat -> x_419 : Leq _n m -> _x_421 : Q_ m x_419 -> Q_ (plus m (nd 1)) (le_S _n m x_419)) -> x_417 : Nat -> x_418 : Leq _n x_417 -> Q_ x_417 x_418 .", "predict": "le_ind_body : _n : Nat -> Q_ : (x_417 : Nat -> _x_418 : Leq _n x_417 -> Prop) -> _H_le_n : Q_ _n (le_n _n) -> _H_le_S : (m : Nat -> x_419 : Leq _n m -> _x_421 : Q_ m x_419 -> Q_ (m + 1) (le_S _n m x_419)) -> x_417 : Nat -> _n <= x_417 -> Q_ x_417 x_418 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nMin_spec_inv_ind. Soient $x1$ et $x2$ des nombres naturels. Soit $x3$ une fonction des nombres naturels à des valeurs booléennes. Soit $x4 \\in N$. Soit $_Hterm$ un élément de $min_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$. Soit $P$ une fonction des nombres naturels $_z1890$ à des propositions. Soit $_H1$ une fonction des nombres naturels $m$ et des éléments $_x_1080$ de $Leq$ de $x2$ et de $m$ et des éléments $_x_1079$ de $Lt$ de $m$ et de $x1 + x2$ et des éléments $_x_1078$ de $Eq$ de $x3 (m)$ et de $true$ et des fonctions $_x_1077$ des nombres naturels $i$ et des éléments de $Leq$ de $x2$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $x3 (i)$ et de contradiction et des éléments $_z1891$ de $Eq$ de $x4$ et de $m$ à des éléments de $P$ de $m$. Alors pour toutes les fonctions $_H2$ des fonctions $_x_1081$ des nombres naturels $i$ et des éléments de $Leq$ de $x2$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $x1 + x2$ à des éléments de $Eq$ de $x3 (i)$ et de contradiction et des éléments $_z1891$ de $Eq$ de $x4$ et de $x1 + x2$ à des éléments de $P$ de $x1 + x2$, $P$ tient pour $x4$.\nassistant\n", "label": "min_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : (__ : Nat -> bool) -> x4 : Nat -> _Hterm : min_spec x1 x2 x3 x4 -> P : (_z1890 : Nat -> Prop) -> _H1 : (m : Nat -> _x_1080 : Leq x2 m -> _x_1079 : Lt m (plus x1 x2) -> _x_1078 : Eq (x3 m) true -> _x_1077 : (i : Nat -> __ : Leq x2 i -> __1 : Lt i m -> Eq (x3 i) false) -> _z1891 : Eq x4 m -> P m) -> _H2 : (_x_1081 : (i : Nat -> __ : Leq x2 i -> __1 : Lt i (plus x1 x2) -> Eq (x3 i) false) -> _z1891 : Eq x4 (plus x1 x2) -> P (plus x1 x2)) -> P x4 .", "predict": "min_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : (Nat -> Bool) -> x4 : Nat -> _Hterm : min_spec x1 x2 x3 x4 -> P : (_z1890 : Nat -> Prop) -> _H1 : (m : Nat -> _x_1080 : Leq x2 m -> _x_1079 : Lt m (x1 + x2) -> _x_1078 : Eq (x3 m) true -> _x_1077 : (i : Nat -> __1 : Lt i m -> Eq (x3 i) contradiction) -> _z1891 : Eq x4 m -> P m) -> _H2 : (_x_1081 : (i : Nat -> __1 : Lt i (x1 + x2) -> Eq (x3 i) contradiction) -> _z1891 : Eq x4 (x1 + x2) -> P (x1 + x2)) -> P x4 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLog_div. Let $p$ and $n$ and $m$ be natural numbers. Then if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.\nassistant\n", "label": "Axiom log_div : forall p : nat, forall n : nat, forall m : nat, forall x__ : (1 < p), forall __1 : (0 < m), forall __2 : Leq m n, Leq (log p (n / m)) (log p n - log p m) .", "predict": "Axiom log_div : forall p : nat, forall n : nat, forall m : nat, forall p1 : nat, forall n1 : nat, forall m1 : nat, 1 < p -> 0 < m -> m <= n -> log p (n / m) <= (log p n - log p m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMatch_min_spec. Soient $_n$ et $_b$ des nombres naturels. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $return_sort$ un élément de $Sort$. Soit $return_type$ une fonction des nombres naturels et des éléments $z$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $__$ à des éléments de $return_sort$. Soit $case_found_min_spec$ une fonction des nombres naturels $m$ et des éléments de $Leq$ de $_b$ et de $m$ et des éléments $__1$ de $Lt$ de $m$ et de la somme de $_n$ et de $_b$ et des éléments $__2$ de $Eq$ de $_f$ appliqué à $m$ et de $true$ et des fonctions $__3$ des nombres naturels $i$ et des éléments $__3$ de $Leq$ de $_b$ et de $i$ et des éléments $__4$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $_f$ appliqué à $i$ et de contradiction à des éléments de $return_type$ de $m$ et de $found_min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $m$ et $__$ et $__1$ et $__2$ et $__3$. Alors pour toutes les fonctions $case_not_found_min_spec$ des fonctions des nombres naturels $i$ et des éléments de $Leq$ de $_b$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de la somme de $_n$ et de $_b$ à des éléments de $Eq$ de $_f$ appliqué à $i$ et de contradiction à des éléments de $return_type$ de la somme de $_n$ et de $_b$ et de $not_found_min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $__$, pour tous les nombres naturels $__$, pour tous les éléments $z$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $__$, $return_type$ tient pour $__$ et $z$.\nassistant\n", "label": "axiom match_min_spec (_n _b : Nat) (_f : (x__ : Nat) -> bool) (return_sort : Sort) (return_type : (x__ : Nat) -> (z : min_spec _n _b _f __) -> return_sort) (case_found_min_spec : (m : Nat) -> (x__ : _b ≤ m) -> (__1 : m < _n + _b) -> (__2 : _f m = true) -> (__3 : (i : Nat) -> (__3 : _b ≤ i) -> (__4 : i < m) -> _f i = false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) (case_not_found_min_spec : (x__ : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < _n + _b) -> _f i = false) -> return_type (_n + _b) (not_found_min_spec _n _b _f __)) (x__ : Nat) (z : min_spec _n _b _f __) : return_type __ z", "predict": "axiom match_min_spec (_n _b : Nat) (_f : Nat -> Bool) (return_sort : Sort) (return_type : Nat -> (z : min_spec _n _b _f __) -> return_sort) (case_found_min_spec : (m : Nat) -> (__1 : Lt m (m + _n + _b)) -> (__2 : Eq (_f m) true) -> (__3 : (i : Nat) -> (__3 : Leq _b i) -> (__4 : Lt i m) -> Eq (_f i) contradiction) -> (return_type m (found_min_spec _n _b _f m __ __1 __2 __3))) (case_not_found_min_spec : (i : Nat) -> (__1 : Lt i (m + _n + _b)) -> (__2 : Eq (_f i) contradiction) -> (return_type (m + _n + _b) (not_found_min_spec _n _b _f i __1 __2))) (__ : Nat) (z : min_spec _n _b _f __) : return_type __ z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15441. Let $p , q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b$ be a natural number. Assume that $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ or $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Assume that $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Then $n b - a mod (m , n)= gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "let_clause_15441 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n)) .", "predict": "let_clause_15441 : p : N -> q : N -> Hind : (m : N -> n : N -> Lt : 0 -> n -> __1 : Leq n m -> __2 : Leq n q -> ex : Nat -> (a : N -> ex Nat -> b : N -> Eq (diff (product a n) (product b m)) (gcd_aux q m n) -> Eq (diff (product b m) (product a n)) (gcd_aux q m n)) -> m : N -> n : N -> 0 < n -> n <= m -> n <= q + 1 -> n notdiv m -> a : N -> _clearme : ex Nat -> (b : N -> Eq (diff (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n)) -> Eq (diff (product b n) (product a (mod m n))) (gcd_aux q n (mod m n))) -> b : N -> a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> n b - a mod (m , n) = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15625. Soit $m , n , a , b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$. Alors $m d - n c = 1$.\nassistant\n", "label": "let_clause_15625 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .", "predict": "let_clause_15625 : m : N -> n : N -> a : N -> b : N -> 1 : diviseur_commun_plus_grand n m -> c : N -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> c n - d m = 1 -> m d - n c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nSameF_upto_le. Soit $A$ un ensemble. Soient $f$ et $g$ des fonctions des nombres naturels à des éléments de $A$. Soient $n$ et $m$ des nombres naturels. Supposons que $n$ est inférieur ou ágal à $m$. Soit $__1$ un élément de $sameF_upto$ de $m$ et de $A$ et de $f$ et de $g$. Alors $sameF_upto$ tient pour $n$ et $A$ et $f$ et $g$.\nassistant\n", "label": "Axiom sameF_upto_le : forall A : Set, forall f : ((x__ : nat) -> A), forall g : ((x__ : nat) -> A), forall n : nat, forall m : nat, forall x__ : Leq n m, forall __1 : sameF_upto m A f g, sameF_upto n A f g .", "predict": "Axiom sameF_upto_le : forall A : set, forall f : (nat -> A), forall g : (nat -> A), forall n : nat, forall m : nat, forall __1 : sameF_upto m A f g, nat <= m -> sameF_upto n A f g ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1545. Let $m , n \\in N$. Assume that $0$ is equal to the greatest common divisor of $m$ and $n$. Assume that $0$ is divisible by $n$. Then for all natural numbers $q1$, if $n = 0 q1$, then if $0$ is divisible by $m$, then for all natural numbers $q2$, if $m = 0 q2$, then $m = 0$.\nassistant\n", "label": "Axiom let_clause_1545 : forall m : nat, forall n : nat, forall H : (gcd m n = 0), forall _clearme : divisible 0 n, forall q1 : nat, forall H1 : (n = 0 * q1), forall _clearme0 : divisible 0 m, forall q2 : nat, forall H2 : (m = 0 * q2), m = 0 .", "predict": "Axiom let_clause_1545 : forall m : N, forall n : N, forall q1 : N, forall q2 : N, (0 = gcd m n -> 0 % n -> q1 = n -> 0 % m -> q2 = m -> m = 0) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1009. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $m$ vara naturliga tal. Anta att $0 < n$ och kontradiktion är lika med $f (n)$. Anta att $max (m , f)\\leq n$ och $max (m , f)= n$. Anta att $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $m$ och funktionen som avbildar $__$ som $Eq$ applicerat på $f$ applicerat på $i$ och kontradiktion och $max (m , f)= 0$. Låt $auto$ vara en funktion från naturliga tal $i$ och element av $Lt$ av $i$ och $m$ till element av $Eq$ av $f (i)$ och kontradiktion. Anta att $max (m , f)= 0$. Då $0 = n$.\nassistant\n", "label": "axiom let_clause_1009 (f : (x__ : Nat) -> bool) (n m : Nat) (posn : 0 < n) (Hfn : f n = false) (Hmax : max m f ≤ n) (Hmax0 : max m f = n) (_clearme : prod Set Prop Nat (λ i => prod Prop Prop (i < m) (λ x__ => f i = false)) ∧ max m f = 0) (auto : (i : Nat) -> (x__ : i < m) -> f i = false) (auto' : max m f = 0) : 0 = n", "predict": "axiom let_clause_1009 (f : nat -> Bool) (n m : nat) : Prop (hyp : 0 < n) (contradiction : f n) (max_m_f : max m f) (max_m_f_eq_n : max m f = n) (prod : Set Prop Nat (λ i => prod Prop Prop (Lt i m) (λ __ => Eq (f i) contradiction))) (auto : (i : nat) -> (lt : Lt i m) -> Eq (f i) contradiction) (max_m_f_eq_0 : max m f = 0) : 0 = n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_4_to_le_Psi_exp. Let $n$ be a natural number. Then if $4$ is less than $n$, then $Psi$ applied to the product of $2$ and $n$ is less than or equal to the product of the exponentiation of $2$ and the difference of the product of $2$ and $n$ and $2$ and $Psi$ applied to $n$.\nassistant\n", "label": "Axiom lt_4_to_le_Psi_exp : forall n : nat, forall x__ : (4 < n), Leq (Psi (2 * n)) (pow 2 (2 * n - 2) * Psi n) .", "predict": "Axiom lt_4_to_le_Psi_exp : forall n : nat, 4 < n -> Psi (2 * n) <= (2 ^ (2 * n - 2)) * Psi n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nEq_length_to_mem_all. Låt $n$ vara ett naturligt tal. Låt $l$ vara en lista av naturliga tal. Anta att $length$ applicerat på $Nat$ och $l$ är lika med $n$. Låt $__1$ vara ett element av $unique$ av $Nat$ och $l$. Låt $__2$ vara en funktion från naturliga tal $x$ och element $__2$ av $mem$ av $Nat$ och $x$ och $l$ till element av $Lt$ av $x$ och $n$. Låt $i \\in N$. Anta att $i$ är mindre än $n$. Då håller $mem$ för $Nat$ och $i$ och $l$.\nassistant\n", "label": "Axiom eq_length_to_mem_all : forall n : nat, forall l : list nat, forall x__ : (length nat l = n), forall __1 : unique nat l, forall __2 : ((x : nat) -> (__2 : mem nat x l) -> x < n), forall i : nat, forall __3 : (i < n), mem nat i l .", "predict": "Axiom eq_length_to_mem_all : forall n : nat, forall l : list nat, forall __1 : unique Nat l, forall __2 : ((x : nat) -> (__2 : mem Nat x l) -> Lt x n), forall i : N, i < n -> mem Nat i l ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1561. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$. Då om $a p - b m = 1$, så $p a - m b = 1$.\nassistant\n", "label": "Axiom let_clause_1561 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (a * p - b * m = gcd p m), forall H0 : (a * p - b * m = 1), p * a - m * b = 1 .", "predict": "Axiom let_clause_1561 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : ex Nat (fun b => Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m) . Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m)), forall b : Nat, ((a p - b m) = (det största gemensama delaret av p och m) -> (b m - a p) = (det största gemensama delaret av p och m)) -> (a p - b m) = (det största gemensama delaret av p och m)) -> (a p - b m) = 1 -> p a - m b = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_15622. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Assume that the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.\nassistant\n", "label": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : (d : Nat) -> Eq (difference (product c n) (product d m)) 1) -> (d : Nat) -> (Eq (difference (product c n) (product d m)) 1) -> (Eq (difference (product d m) (product c n)) 1) -> Eq (difference (product m d) (product n c)) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_mop. För alla naturliga tal $n$, för alla funktioner $p$ från naturliga tal till sanningsvärden, för alla mängder $B$, för alla element $nil$ av $B$, för alla element $R$ av $Dop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, för alla element $a$ och $_x_969$ och $_x_970$ av $B$, $B$.\nassistant\n", "label": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B", "predict": "postulate let_mop : (n : Nat) -> (p : (x : Nat) -> Bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (x : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nTranspose_i_j_j. Pour tous les nombres naturels $i$ et $j$, $transpose (i , j , j)= i$.\nassistant\n", "label": "postulate transpose_i_j_j : (i : Nat) -> (j : Nat) -> Eq (transpose i j j) i", "predict": "postulate transpose_i_j_j : (i : Nat) -> (j : Nat) -> i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1561. Soit $p , m , n \\in N$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c \\in N$. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Alors si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b = 1$.\nassistant\n", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p) (gcd p m)))) -> (b : Nat) -> (gcdp : (p : N) -> (m : N) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p) (gcd p m)))) -> (b : Nat) -> (a : Nat) -> (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p) (gcd p m)))) -> (b : Nat) -> (postulate let_clause_1561 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p) (gcd p m)))) -> (b : Nat) -> (gcdp : (p : N) -> (m : N) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p) (gcd p m)))) -> (b : Nat) -> (a : Nat) -> (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p) (gcd p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_10331. Soit $n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Alors pour toutes les fonctions $g1$ et $g2$ des nombres naturels à des nombres naturels, pour tous les nombres naturels $n1$, pour toutes les fonctions $Hind$ des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$, pour toutes les fonctions $Hle$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$, si $p (n1)= true$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_10331 : forall n : nat, forall p : ((x__ : nat) -> bool), forall g1 : ((x__ : nat) -> nat), forall g2 : ((x__ : nat) -> nat), forall n1 : nat, forall Hind : ((x__ : (i : nat) -> (x__ : i < n1) -> (__1 : p i = true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (fun i => p i) nat 1 times (fun i => g1 i)) (bigop n1 (fun i => p i) nat 1 times (fun i => g2 i))), forall Hle : ((i : nat) -> (x__ : i < n1 + 1) -> (__1 : p i = true) -> Leq (g1 i) (g2 i)), forall Hcase : (p n1 = true), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_10331 : forall n : N, forall p : (nat -> bool), forall g1 : (nat -> nat), forall g2 : (nat -> nat), forall n1 : nat, forall Hind : ((i : nat) -> (__1 : Eq p i true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (fun i => p i) Nat 1 times (fun i => g1 i)) (bigop n1 (fun i => p i) Nat 1 times (fun i => g2 i))), forall Hle : ((i : nat) -> (__1 : Lt i (n1 + 1)) -> Eq p i true) -> Leq (g1 i) (g2 i)), if p (n1) = true, forall x2515 : nat, forall x2516 : nat, x2515 = x2516 (x2515 div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_r_sn. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l \\in N$. Then for all elements $b$ and $b2$ of $B$, for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $b1$ of $B$, for all elements $__1$ of $R$ of $b1$ and $b$, $lstar_r$ holds for $B$ and $R$ and $l + 1$ and $b1$ and $b2$.\nassistant\n", "label": "Axiom lstar_r_sn : forall B : Set, forall R : relation B, forall l : nat, forall b : B, forall b2 : B, forall x__ : lstar_r B R l b b2, forall b1 : B, forall __1 : R b1 b, lstar_r B R (l + 1) b1 b2 .", "predict": "Axiom lstar_r_sn : forall B : set, forall R : relation B, forall l : N, forall b : B, forall b2 : B, forall __ : lstar_r B R l b b2, forall b1 : B, forall __1 : R b1 b, lstar_r B R (l + 1) b1 b2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMin. Låt $__ , __1 \\in N$. Då för alla funktioner $__2$ från naturliga tal $__2$ till sanningsvärden, $Nat$.\nassistant\n", "label": "postulate min : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat", "predict": "postulate min : (__ : N) -> (__1 : N) -> (__2 : (__ : N) -> S) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nEq_sigma_p_div. Låt $n , q \\in N$. Då om $0 < q$, så är $n \\div q$ lika med $bigop$ applicerat på summan av $n$ och $1$ och funktionen som avbildar $m$ som $andb$ applicerat på $leb$ applicerat på $1$ och $m$ och $dividesb$ applicerat på $q$ och $m$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $m$ som $1$.\nassistant\n", "label": "postulate eq_sigma_p_div : (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> Eq (bigop (plus n 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) (div n q)", "predict": "postulate eq_sigma_p_div : (n : N) -> (q : N) -> (0 < q) -> n div q == bigop (sum n 1) (\\ m : N -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : N -> 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c \\in N$. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Då för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $m$ och $b$ och produkten av $p$ och $a$.\nassistant\n", "label": "Axiom let_clause_16171 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (b * m - a * p = gcd p m), forall H0 : (b * m - a * p = 1), gcd p m = m * b - p * a .", "predict": "Axiom let_clause_16171 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : ex Nat (fun b => Eq (skillnaden (produkt av a och p) (produkt av b och m)) (det största gemensama delaret av p och m)) (Eq (skillnaden (produkt av b och m) (produkt av a och p)) (det största gemensama delaret av p och m)), forall b : Nat, if skillnaden (produkt av a och p) (produkt av b och m) = det största gemensama delaret av p och m orelse skillnaden (produkt av b och m) (produkt av a och p) = det största gemensama delaret av p och m then if skillnaden (produkt av b och m) (produkt av a och p) = det största gemensama delaret av p och m then if skillnaden (produkt av b och m) (produkt av a och p) = 1 then det största gemensama delaret av p och m = skillnaden (produkt av m och b) (produkt av p och a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_15624. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that $c n - d m = 1$ or $d m - c n = 1$. Assume that $d m - c n = 1$. Then $m d - n c = 1$.\nassistant\n", "label": "axiom let_clause_15624 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : m * d - n * c = 1", "predict": "axiom let_clause_15624 (m n a b : N) (_clearme : Nat (λ d => Eq (c n - d m) 1 ∨ Eq (d m - c n) 1)) (d : N) : Nat (m d - n c)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDivides_d_gcd. Soit $m , n , d \\in N$. Supposons que $d$ est et divisible par $m$ et divisible par $n$. Alors $d$ est divisible par le diviseur commun plus grand de $n$ et de $m$.\nassistant\n", "label": "postulate divides_d_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : divisible d m) -> (__1 : divisible d n) -> divisible d (gcd n m)", "predict": "postulate divides_d_gcd : (m : N) -> (n : N) -> (d : N) -> d divides m -> d divides n -> d divides gcd n m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i , j \\in N$. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Anta att $f (b)= j$. Då för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : N, forall j : N, forall a : nat, forall b : nat, forall __ : (i0 : nat) -> (Leq : nat) -> nat, forall injf : (f : nat -> nat) -> (n : nat) -> (a : nat) -> (b : nat) -> (f (a) = i) -> (f (b) = j) -> (a = b) -> (f a = i) -> (b = n) -> (f b = j) -> (a <= n) -> (b <= n) -> (Axiom let_clause_1068 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : N, forall j : N, forall a : nat, forall b : nat, forall __ : (i0 : nat) -> (Leq : nat) -> nat, forall injf : (f : nat -> nat) -> (n : nat) -> (a : nat) -> (b : nat) -> (f (a) = i) -> (f (b) = j) -> (a = b) -> (f a = i) -> (b = n) -> (f b = j) -> (a <= n) -> (b <= n) -> (a = b) -> (f a = i) -> (b = n) -> (f b = j) -> (Axiom let_clause_1068 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : N, forall j : N, forall a : nat, forall b : nat, forall __ : (i0 : nat) -> (Leq : nat) -> nat, forall injf : (f : nat -> nat) -> (n : nat) -> (a : nat) -> (b : nat) -> (f (a) = i) -> (f (b) = j) -> (a = b) -> (f a = i) -> (b = n) -> (f b = j) -> (a <= n) -> (b <= n) -> (Axiom let_clause_1068 : forall"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nRange_rect_Type0. Pour tous les ensembles $_A$, pour toutes les fonctions $Q_$ des éléments $_x_927$ de $range$ de $_A$ à des ensembles, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_927$ de $range$ de $_A$, $Q_$ tient pour $x_927$.\nassistant\n", "label": "axiom range_rect_Type0 (_A : Set) (Q_ : (_x_927 : range _A) -> Set) (_H_mk_range : (_enum : (x__ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (x__ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) (x_927 : range _A) : Q_ x_927", "predict": "axiom range_rect_Type0 (_A : Set) (Q_ : (_x_927 : range _A) -> Set) (_H_mk_range : (_enum : (n : Nat) -> _A) -> (_upto : Nat) -> (_filter : (n : Nat) -> Bool) -> mk_range _A _enum _upto _filter) (x_927 : range _A) : Q_ x_927"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nExp_to_log_r. Soit $b , n , m \\in N$. Alors si $1 < b$ et $n < m$, alors si $b ^ n \\leq m$, alors $n \\leq \\log_ b {m}$.\nassistant\n", "label": "Axiom exp_to_log_r : forall b : nat, forall n : nat, forall m : nat, forall x__ : (1 < b), forall __1 : (n < m), forall __2 : Leq (pow b n) m, Leq n (log b m) .", "predict": "Axiom exp_to_log_r : forall b : N, forall n : N, forall m : N, 1 < b -> n < m -> b ^ n <= m -> n <= log_b m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBceq. For all natural numbers $n$ and $k$, $bc$ applied to $n$ and $k$ is equal to the quotient of the factorial of $n$ and the product of the factorial of $k$ and the factorial of the difference of $n$ and $k$.\nassistant\n", "label": "axiom bceq (n k : Nat) : bc n k = factorial n / (factorial k * factorial (n - k))", "predict": "axiom bceq (n k : Nat) : Expr Eq (bc n k) (factorial n) / (factorial k) * (factorial (n - k))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nRange_rect_CProp1. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_937$ av $range$ av $_A$ till påståenden. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A , _enum , _upto , _filter)$. Låt $x_937$ vara ett element av $range$ av $_A$. Då håller $Q_$ för $x_937$.\nassistant\n", "label": "range_rect_CProp1 : _A : Set -> Q_ : (_x_937 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_937 : range _A -> Q_ x_937 .", "predict": "range_rect_CProp1 : _A : set -> Q_ : (_x_937 : range _A -> påståenden) -> _H_mk_range : (_enum : nat -> _A) -> (_upto : nat -> _filter : nat -> sanningsvärden) -> Q_ : mk_range (_A , _enum , _upto , _filter) -> x_937 : range _A -> Q_ : x_937 -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLeb_true_to_le. Låt $n , m \\in N$. Då om $leb$ applicerat på $n$ och $m$ är lika med $true$, så är $n$ mindre än eller lika med $m$.\nassistant\n", "label": "Axiom leb_true_to_le : forall n : nat, forall m : nat, forall x__ : (leb n m = true), Leq n m .", "predict": "Axiom leb_true_to_le : forall n : N, forall m : N, leb n m = true -> n <= m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_15622. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $d m - c n = 1$, så $m d - n c = 1$.\nassistant\n", "label": "Axiom let_clause_15622 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), m * d - n * c = 1 .", "predict": "Axiom let_clause_15622 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ex Nat (fun d => Eq (skillnaden (produkt c n) (produkt d m)) 1) (fun d => Eq (skillnaden (produkt d m) (produkt c n)) 1), forall d : Nat, ((c n - d m = 1) -> (d m - c n = 1)) -> (d m - c n = 1) -> (m d - n c = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nExp_body. För alla naturliga tal $__$ och $__1$, $Nat$.\nassistant\n", "label": "axiom exp_body (x__ __1 : Nat) : Nat", "predict": "axiom exp_body (__ __1 : Nat) : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDiv_n_n. Pour tous les nombres naturels $n$, si $0 < n$, alors $n \\div n = 1$.\nassistant\n", "label": "postulate div_n_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (div n n) 1", "predict": "postulate div_n_n : (n : Nat) -> (if 0 < n then n div n == 1 else undefined)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nACop_rect_CProp0_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_913$ de $ACop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et de $op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $Q_$ de $mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_913$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_913$.\nassistant\n", "label": "postulate ACop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_913 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_913 : ACop A _nil) -> Q_ x_913", "predict": "postulate ACop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_913 : ACop A _nil) -> Set) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_913 : ACop A _nil) -> Q_ x_913"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1034. Soit $n , m , q \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = mod (x2515 , x2516)+ x2516 (x2515 \\div x2516)$.\nassistant\n", "label": "let_clause_1034 : n : Nat -> m : Nat -> q : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516))) .", "predict": "let_clause_1034 : n : N -> m : N -> q : N -> 0 < n -> 0 < m -> x2515 : N -> x2516 : N -> x2515 = mod (x2515 , x2516) + x2516 (x2515 \\div x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPermut_invert_permut. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Alors pour tous les éléments $__$ de $permut$ de $f$ et de $n$, $permut$ tient pour $invert_permut$ appliqué à $n$ et $f$ et $n$.\nassistant\n", "label": "postulate permut_invert_permut : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut f n) -> permut (invert_permut n f) n", "predict": "postulate permut_invert_permut : (f : N -> N) -> (n : N) -> (__ : permut f n) -> permut (invert_permut n f) n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nRange_rect_Type5. För alla mängder $_A$, för alla funktioner $Q_$ från element $_x_919$ av $range$ av $_A$ till element av $Type5$, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A , _enum , _upto , _filter)$, för alla element $x_919$ av $range$ av $_A$, håller $Q_$ för $x_919$.\nassistant\n", "label": "range_rect_Type5 : _A : Set -> Q_ : (_x_919 : range _A -> Type5) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_919 : range _A -> Q_ x_919 .", "predict": "range_rect_Type5 : _A : Set -> Q_ : (_x_919 : range _A -> Type5) -> _H_mk_range : (_enum : (nat -> _A) -> _upto : nat -> _filter : (nat -> bool) -> Q_ : mk_range _A _enum _upto _filter) -> x_919 : range _A -> Q_ x_919 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDivides_fact. Låt $n , i \\in N$. Då om $0$ är mindre än $i$, så om $i$ är mindre än eller lika med $n$, så är $i$ delbart med fakulteten av $n$.\nassistant\n", "label": "Axiom divides_fact : forall n : nat, forall i : nat, forall x__ : (0 < i), forall __1 : Leq i n, divisible i (factorial n) .", "predict": "Axiom divides_fact : forall n : N, forall i : N, 0 < i -> i <= n -> i % (fakulteten n) = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDivides_times. Låt $n$ och $m$ och $p$ och $q$ vara naturliga tal. Då om $n$ är delbart med $p$, så om $m$ är delbart med $q$, så är produkten av $n$ och $m$ delbar med produkten av $p$ och $q$.\nassistant\n", "label": "divides_times : n : Nat -> m : Nat -> p : Nat -> q : Nat -> __ : divisible n p -> __1 : divisible m q -> divisible (times n m) (times p q) .", "predict": "divides_times : n : Nat -> m : Nat -> p : Nat -> q : Nat -> n : p -> m : q -> n * m : p * q ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nFilter_body. Soit $A$ un ensemble. Soit $_xxx$ un élément de $range$ de $A$. Soit $_x_941 \\in N$. Alors $bool$.\nassistant\n", "label": "filter_body : A : Set -> _xxx : range A -> _x_941 : Nat -> bool .", "predict": "filter_body : A : Set -> _xxx : range A -> _x_941 : N -> bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_CProp2_body. Let $Q_$ be a function from natural numbers $_x_405$ to propositions. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_406$ and elements $_x_408$ of $Q_$ of $x_406$ to elements of $Q_$ of the sum of $x_406$ and $1$. Then for all natural numbers $x_405$, $Q_$ holds for $x_405$.\nassistant\n", "label": "nat_rect_CProp2_body : Q_ : (_x_405 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_406 : Nat -> _x_408 : Q_ x_406 -> Q_ (plus x_406 (nd 1))) -> x_405 : Nat -> Q_ x_405 .", "predict": "nat_rect_CProp2_body : Q_ : (_x_405 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_406 : Nat -> _x_408 : Q_ x_406 -> Q_ (x_406 + 1)) -> x_405 : Nat -> Q_ x_405 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_15441. Soient $p$ et $q$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Alors pour tous les nombres naturels $m$ et $n$, si $0 < n$, alors si $n \\leq m$, alors si $n \\leq q + 1$, alors si $n$ n'est pas divisible par $m$, alors pour tous les nombres naturels $a$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$, pour tous les nombres naturels $b$, si $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ ou $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, alors si $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, alors $n b - a mod (m , n)= gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "axiom let_clause_15441 (p q : Nat) (Hind : (m : Nat) -> (n : Nat) -> (x__ : 0 < n) -> (__1 : n ≤ m) -> (__2 : n ≤ q) -> ex Nat (λ a => ex Nat (λ b => a * n - b * m = gcd_aux q m n ∨ b * m - a * n = gcd_aux q m n))) (m n : Nat) (posn : 0 < n) (lenm : n ≤ m) (lenS : n ≤ q + 1) (ndivnm : ¬ divisible n m) (a : Nat) (_clearme : ex Nat (λ b => a * mod m n - b * n = gcd_aux q n (mod m n) ∨ b * n - a * mod m n = gcd_aux q n (mod m n))) (b : Nat) (_clearme0 : a * mod m n - b * n = gcd_aux q n (mod m n) ∨ b * n - a * mod m n = gcd_aux q n (mod m n)) (H : b * n - a * mod m n = gcd_aux q n (mod m n)) : n * b - a * mod m n = gcd_aux q n (mod m n)", "predict": "axiom let_clause_15441 (p q : Nat) (Hind : (m : Nat) -> (n : Nat) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n q) -> (ex : Nat) -> (a : Nat) -> (b : Nat) -> Eq (diff (prod a n) (prod b m)) (gcd_aux q m n)) -> (Eq (diff (prod b m) (prod a n)) (gcd_aux q m n))) (m n : Nat) (Hc : 0 < n) (Hd : n ≤ m) (He : n ≤ q + 1) (Hf : n ≠ div m n) (a : Nat) (_clearme : ex (b : Nat) (Eq (diff (a mod m n) (b n)) (gcd_aux q n (mod m n))) (Eq (diff (b n) (a mod m n)) (gcd_aux q n (mod m n)))) (b : Nat) : (a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) ∨ b n - a mod (m , n) = gcd_aux (q , n , mod (m , n))) -> (b n - a mod (m , n) = gcd_aux (q , n , mod (m , n))) -> n b - a mod (m , n) = gcd_aux (q , n , mod (m , n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMonotonic_le_minus_l. Låt $p$ och $q$ och $n$ vara naturliga tal. Anta att $q \\leq p$. Då $q - n \\leq p - n$.\nassistant\n", "label": "axiom monotonic_le_minus_l (p q n : Nat) (x__ : q ≤ p) : q - n ≤ p - n", "predict": "axiom monotonic_le_minus_l (p q n : Nat) : q <= p -> q - n <= p - n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1062. Let $a , b , q , r , q1 , r1 \\in N$. Let $_clearme$ be an element of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$. Assume that $r < b$. Assume that $a = q b + r$. Then for all elements $_clearme0$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, if $r1 < b$, then if $a = q1 b + r1$, then if $q$ is not less than or equal to $q1$, then $a = r1 + b q1$.\nassistant\n", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : (a : N) -> (b : N) -> (q : N) -> (r : N) -> (q1 : N) -> (r1 : N) -> (_clearme : div_mod_spec a b q r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (r1 < b) -> (a = q1 b + r1) -> (q > q1) -> a = r1 + b q1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nRange_rect_Type3. Soit $_A$ un ensemble. Soit $Q_$ une fonction des éléments $_x_921$ de $range$ de $_A$ à des éléments de $Type3$. Alors pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_921$ de $range$ de $_A$, $Q_$ tient pour $x_921$.\nassistant\n", "label": "postulate range_rect_Type3 : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_921 : range _A) -> Q_ x_921", "predict": "postulate range_rect_Type3 : (_A : Set) -> (Q_ : (_x_921 : range _A) -> Type3) -> (_H_mk_range : (_enum : (n : Set) -> (_x : Set) -> (_x_921 : Set) -> (_upto : Set) -> (_filter : (n : Set) -> (_x_921 : Set) -> (_Q_ : (_x_921 : Set) -> Type3) -> mk_range _A _enum _upto _filter) -> (x_921 : Set) -> (_Q_ x_921)) -> (x_921 : Set) -> Q_ x_921"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAxiom. Låt $__$ vara ett naturligt tal. Då är efterföljaret av $__$ ett naturligt tal.\nassistant\n", "label": "succ : __ : Nat -> Nat .", "predict": "låt __ : nat . då är efterföljaret av __ : nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_div_to_times. Let $n , m , q \\in N$. Assume that $0$ is less than $q$. Assume that the quotient of $n$ and $q$ is less than $m$. Then $n$ is less than the product of $q$ and $m$.\nassistant\n", "label": "postulate lt_div_to_times : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Lt (div n q) m) -> Lt n (times q m)", "predict": "postulate lt_div_to_times : (n : N) -> (m : N) -> (q : N) -> (0 : N) < q -> (n / q) < m -> n < (q * m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nEq_div_div_div_div. Soit $n , m , q \\in N$. Alors si $0$ est inférieur à $n$, alors si $0$ est inférieur à $m$, alors le quotient du quotient de $q$ et de $n$ et de $m$ est égal au quotient du quotient de $q$ et de $m$ et de $n$.\nassistant\n", "label": "Axiom eq_div_div_div_div : forall n : nat, forall m : nat, forall q : nat, forall x__ : (0 < n), forall __1 : (0 < m), q / n / m = q / m / n .", "predict": "Axiom eq_div_div_div_div : forall n : N, forall m : N, forall q : N, 0 < n -> 0 < m -> (q / (n / m)) = (q / m) / n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_times_to_le_div2. Låt $m$ och $n$ och $q$ vara naturliga tal. Anta att $0 < q$. Då om $n \\leq m q$, så $n \\div q \\leq m$.\nassistant\n", "label": "postulate le_times_to_le_div2 : (m : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Lt 0 q) -> (__1 : Leq n (times m q)) -> Leq (div n q) m", "predict": "postulate le_times_to_le_div2 : (m : Nat) -> (n : Nat) -> (q : Nat) -> (0 < q) -> (n <= m * q) -> n div q <= m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFound_min_spec. Let $n , b \\in N$. Let $f$ be a function from natural numbers to booleans. Let $m \\in N$. Assume that $b \\leq m$. Assume that $m < n + b$. Assume that $f (m)= true$. Then for all functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $f (i)$ and absurdity, $min_spec$ holds for $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m", "predict": "postulate found_min_spec : (n : N) -> (b : N) -> (f : (i : N) -> Bool) -> (m : N) -> (__3 : (i : N) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) absurdity) -> min_spec n b f m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_n_fact_n. Låt $n \\in N$. Anta att $2 < n$. Då $n < n !$.\nassistant\n", "label": "lt_n_fact_n : n : Nat -> __ : Lt (nd 2) n -> Lt n (factorial n) .", "predict": "lt_n_fact_n : n : N -> 2 < n -> n < n ! ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTimes_div. Soient $a$ et $b$ et $c$ des nombres naturels. Supposons que $0 < b$. Supposons que $c$ est divisible par $b$. Alors $a (b \\div c)= a b \\div c$.\nassistant\n", "label": "axiom times_div (a b c : Nat) (x__ : 0 < b) (__1 : divisible c b) : a * (b / c) = a * b / c", "predict": "axiom times_div (a b c : Nat) (Hc : b > 0) (Hd : c % b = 0) : a (b \\ div c) = a b \\ div c"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b \\in N$. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : (N -> N), forall n : N, forall permf : permut f n, forall i : N, forall j : N, forall a : N, a <= n -> f a = i -> a <= n -> forall b : N, b <= n -> f b = j -> b <= n -> forall __ : (i0 : N -> Leq i0 n -> Leq (f i0) n), forall injf : injn f n, forall a : N, b : N, a = b -> f a = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_to_le. Soient $x$ et $y$ des nombres naturels. Supposons que $x < y$. Alors $x \\leq y$.\nassistant\n", "label": "axiom lt_to_le (x y : Nat) (x__ : x < y) : x ≤ y", "predict": "axiom lt_to_le (x y : Nat) : x < y -> x <= y"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1600. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $c n - d m = 1$, alors $n c - m d$ est égal au diviseur commun plus grand de $m$ et de $n$.\nassistant\n", "label": "Axiom let_clause_1600 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), gcd m n = n * c - m * d .", "predict": "Axiom let_clause_1600 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : (d : Nat) -> Eq (Nat) (div (Nat) (div (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) (Nat) ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m , n , a , b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Anta att $d m - c n = 1$. Då $m d - n c = 1$.\nassistant\n", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (c n - d m) 1)) -> (d : Nat) -> (_0 : c n - d m) -> (_1 : d m - c n) -> (_2 : d m - c n) -> (_3 : m d - n c) -> (_4 : m d - n c) -> (_5 : m d - n c) -> (_6 : m d - n c) -> (_7 : m d - n c) -> (_8 : m d - n c) -> (_9 : m d - n c) -> (_10 : m d - n c) -> (_11 : m d - n c) -> (_12 : m d - n c) -> (_13 : m d - n c) -> (_14 : m d - n c) -> (_15 : m d - n c) -> (_16 : m d - n c) -> (_17 : m d - n c) -> (_18 : m d - n c) -> (_19 : m d - n c) -> (_20 : m d - n c) -> (_21 : m d - n c) -> (_22 : m d - n c) -> (_23 : m d - n c) -> (_24 : m d - n c) -> (_25 : m d - n c) -> (_26 : m d - n c) -> (_27 : m d - n c) -> (_28 : m d - n c) -> (_29 : m d - n c) -> (_30 : m d - n c) -> (_31 : m d - n c) -> (_32 : m d - n c) -> (_33 : m d - n c) -> (_34 : m d - n c) -> (_35 : m d - n c) -> (_36 : m d - n c) -> (_37 : m d - n c) -> (_38 : m d - n c) -> (_39 : m d - n c) -> (_40 : m d - n c) -> (_"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_rect_Type5_body. Let $_A$ be a set. Let $Q_$ be a function from elements $_x_919$ of $range$ of $_A$ to elements of $Type5$. Let $_H_mk_range$ be a function from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range (_A , _enum , _upto , _filter)$. Let $x_919$ be an element of $range$ of $_A$. Then $Q_$ holds for $x_919$.\nassistant\n", "label": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919", "predict": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (x : Set) -> (_x_920 : Set) -> (_x_921 : Set) -> (_x_922 : Set) -> (_x_923 : Set) -> (_x_924 : Set) -> (_x_925 : Set) -> (_x_926 : Set) -> (_x_927 : Set) -> (_x_928 : Set) -> (_x_929 : Set) -> (_x_930 : Set) -> (_x_931 : Set) -> (_x_932 : Set) -> (_x_933 : Set) -> (_x_934 : Set) -> (_x_935 : Set) -> (_x_936 : Set) -> (_x_937 : Set) -> (_x_938 : Set) -> (_x_939 : Set) -> (_x_940 : Set) -> (_x_941 : Set) -> (_x_942 : Set) -> (_x_943 : Set) -> (_x_944 : Set) -> (_x_945 : Set) -> (_x_946 : Set) -> (_x_947 : Set) -> (_x_948 : Set) -> (_x_949 : Set) -> (_x_950 : Set) -> (_x_951 : Set) -> (_x_952 : Set) -> (_x_953 : Set) -> (_x_954 : Set) -> (_x_955 : Set) -> (_x_956 : Set) -> (_x_957 : Set) -> (_x_958 : Set) -> (_x_959 : Set) -> (_x_960 : Set) -> (_x_961 : Set) -> (_x_962 : Set) -> (_x_963 : Set) -> (_x_964 : Set) -> (_x_965 : Set) -> (_x_9"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nCongruent_exp_pred_SO. Soient $p$ et $a$ des nombres naturels. Supposons que $p$ est premier. Supposons que $p$ n'est pas divisible par $a$. Alors $congruent$ tient pour la puissance de $a$ et de $pred$ appliqué à $p$ et $1$ et $p$.\nassistant\n", "label": "congruent_exp_pred_SO : p : Nat -> a : Nat -> __ : prime p -> __1 : not (divisible p a) -> congruent (pow a (pred p)) (nd 1) p .", "predict": "congruent_exp_pred_SO : p : Nat -> a : Nat -> p : Prime -> p : Not_Divisible a -> congruent (a ** (pred p)) 1 p ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1607. Soit $m , n , a , b \\in N$. Alors si $0 < n$ et $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nassistant\n", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (n * c - m * d) 1)) -> (d : Nat) -> (m * d - n * c) == gcd m n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1532. Låt $n$ och $m$ vara naturliga tal. Anta att $n$ är delbart med $m$ och $0 = n$. Låt $d$ vara ett naturligt tal. Anta att $m = 0 d$. Då $m = 0$.\nassistant\n", "label": "let_clause_1532 : n : Nat -> m : Nat -> divnm : divisible n m -> H : Eq 0 n -> d : Nat -> auto : Eq m (times 0 d) -> Eq m 0 .", "predict": "let_clause_1532 : n : Nat -> m : Nat -> n : m -> 0 = n -> d : Nat -> m : 0 d -> m : 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1575. Let $m , n , a , b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $c n - d m = 1$, then for all natural numbers $x1029$, $x1029 = x1029 (n c - m d)$.\nassistant\n", "label": "axiom let_clause_1575 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) (x1029 : Nat) : x1029 = x1029 * (n * c - m * d)", "predict": "axiom let_clause_1575 (m n a b : N) (_clearme : Nat (λ d => Eq (c n - d m) 1 ∨ Eq (d m - c n) 1)) (d : N) (x1029 : N) : Nat (x1029 (n c - m d))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nACop_rect_CProp3. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_907$ de $ACop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op (A , _nil , aop , a , b)$ et de $op (A , _nil , aop , b , a)$ à des éléments de $Q_$ de $mk_ACop (A , _nil , aop , _comm)$, pour tous les éléments $x_907$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_907$.\nassistant\n", "label": "ACop_rect_CProp3 : A : Set -> _nil : A -> Q_ : (_x_907 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_907 : ACop A _nil -> Q_ x_907 .", "predict": "ACop_rect_CProp3 : A : Set -> _nil : A -> Q_ : (_x_907 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq op A _nil aop a b) -> Eq op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)) -> x_907 : ACop A _nil -> Q_ x_907 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_10336. Låt $n , m \\in N$. Låt $Hind$ vara en funktion från naturliga tal $p$ och element av $Lt$ av $p$ och $m$ och element $__1$ av $Lt$ av $1$ och $p$ till element av $Leq$ av $Psi$ applicerat på $p$ och produkten av $pred$ applicerat på $p$ och potensen av $2$ och skillnaden mellan produkten av $2$ och $p$ och $3$. Då för alla naturliga tal $a$, om $m$ är lika med produkten av $2$ och $a$ eller $m$ är lika med summan av produkten av $2$ och $a$ och $1$, så om $m$ är lika med summan av produkten av $2$ och $a$ och $1$, så om $1$ är mindre än summan av produkten av $2$ och $a$ och $1$, så om $0$ är mindre än $a$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nassistant\n", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : N) -> (m : N) -> (Hind : (p : N) -> (__1 : Lt p m) -> (__2 : Lt 1 p) -> Leq (Psi p) (pred p) (2 ^ (p - 3))) -> (a : N) -> (x2515 : N) -> (x2516 : N) -> (x2515 == (x2516 * (a / x2516)) + mod x2515 x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter. Let $A$ be a set. Let $_xxx$ be an element of $range$ of $A$. Let $_x_941$ be a natural number. Then $bool$.\nassistant\n", "label": "axiom filter (A : Set) (_xxx : range A) (_x_941 : Nat) : bool", "predict": "axiom filter (A : Set) (_xxx : range A) (_x_941 : Nat) : Bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nExp_Sn. För alla naturliga tal $b$ och $n$, $b ^ (n + 1)= b (b ^ n)$.\nassistant\n", "label": "postulate exp_Sn : (b : Nat) -> (n : Nat) -> Eq (pow b (plus n 1)) (times b (pow b n))", "predict": "postulate exp_Sn : (b : Nat) -> (n : Nat) -> b ^ (n + 1) = b * (b ^ n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_10331. Soit $n \\in N$. Supposons que $5 < n$. Soit $m$ un nombre naturel. Supposons que $6 \\leq m$. Alors si $(m + 1)^ 2 \\leq 2 ^ m$, alors pour tous les nombres naturels $a$, si $6 \\leq a$, alors si $2 (a + 1)+ 1 \\leq 2 ^ a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : N) -> (m : N) -> (a : N) -> (x2515 : N) -> (x2516 : N) -> (_e : (m + 1)^ 2 <= 2 ^ m) -> (_e2 : 6 <= a) -> (_e3 : 2 (a + 1)+ 1 <= 2 ^ a) -> (_e4 : x2515 == x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)) -> True"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMax_spec_inv_ind. Låt $x1$ vara ett naturligt tal. Då för alla funktioner $x2$ från naturliga tal till sanningsvärden, för alla naturliga tal $x3$, för alla element $_Hterm$ av $max_spec$ av $x1$ och $x2$ och $x3$, för alla funktioner $P$ från naturliga tal $_z1769$ till påståenden, för alla funktioner $_H1$ från naturliga tal $m$ och element $_x_975$ av $Lt$ av $m$ och $x1$ och element $_x_974$ av $Eq$ av $x2$ applicerat på $m$ och $true$ och funktioner $_x_973$ från naturliga tal $i$ och element av $Lt$ av $m$ och $i$ och element $__1$ av $Lt$ av $i$ och $x1$ till element av $Eq$ av $x2$ applicerat på $i$ och kontradiktion och element $_z1770$ av $Eq$ av $x3$ och $m$ till element av $P$ av $m$, för alla funktioner $_H2$ från funktioner $_x_976$ från naturliga tal $i$ och element av $Lt$ av $i$ och $x1$ till element av $Eq$ av $x2$ applicerat på $i$ och kontradiktion och element $_z1770$ av $Eq$ av $x3$ och $0$ till element av $P$ av $0$, håller $P$ för $x3$.\nassistant\n", "label": "postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (_ : Nat) -> bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> (_ : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 0) -> P 0) -> P x3", "predict": "postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (z : Nat) -> Bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Set) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : Nat) -> (Lt m i) -> (__1 : Lt i x1) -> Eq (x2 i) kontradiktion) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> (Lt i x1) -> Eq (x2 i) kontradiktion) -> (_z1770 : Eq x3 0) -> P 0) -> P x3"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_ind_body. Let $_n$ and $_m$ and $_q$ and $_r$ be natural numbers. Let $Q_$ be a function from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions. Let $_H_div_mod_spec_intro$ be a function from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$. Let $x_809$ be an element of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$. Then $Q_$ holds for $x_809$.\nassistant\n", "label": "axiom div_mod_spec_ind_body (_n _m _q _r : Nat) (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_811 : _r < _m) -> (x_810 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) (x_809 : div_mod_spec _n _m _q _r) : Q_ x_809", "predict": "axiom div_mod_spec_ind_body (_n _m _q _r : Nat) (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (product _q _m _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) (x_809 : div_mod_spec _n _m _q _r) : Q_ x_809"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nOrd_rem_eq. Soit $n , p \\in N$. Alors $ord_rem (n , p)= snd (Nat , Nat , p_ord (n , p))$.\nassistant\n", "label": "ord_rem_eq : n : Nat -> p : Nat -> Eq (ord_rem n p) (snd Nat Nat (p_ord n p)) .", "predict": "ord_rem_eq : n : N -> p : N -> ord_rem (n , p) = snd (Nat , Nat , p_ord (n , p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1544. Soient $p$ et $q$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soient $m$ et $n$ des nombres naturels. Supposons que $0 < n$. Supposons que $n \\leq m$. Supposons que $n \\leq q + 1$. Supposons que $n$ n'est pas divisible par $m$. Alors pour tous les nombres naturels $a$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$, pour tous les nombres naturels $b$, si $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ ou $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$, alors si $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$, alors $a mod (m , n)- n b = gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "Axiom let_clause_1544 : forall p : nat, forall q : nat, forall Hind : ((m : nat) -> (n : nat) -> (x__ : 0 < n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex nat (fun a => ex nat (fun b => a * n - b * m = gcd_aux q m n \\/ b * m - a * n = gcd_aux q m n))), forall m : nat, forall n : nat, forall posn : (0 < n), forall lenm : Leq n m, forall lenS : Leq n (q + 1), forall ndivnm : (~ divisible n m), forall a : nat, forall _clearme : ex nat (fun b => a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall b : nat, forall _clearme0 : (a * mod m n - b * n = gcd_aux q n (mod m n) \\/ b * n - a * mod m n = gcd_aux q n (mod m n)), forall H : (a * mod m n - b * n = gcd_aux q n (mod m n)), a * mod m n - n * b = gcd_aux q n (mod m n) .", "predict": "Axiom let_clause_1544 : forall p : Nat, forall q : Nat, forall Hind : ((m : Nat) -> (n : Nat) -> (Lt : 0 -> n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> (ex : Nat) -> (a : Nat) -> (b : Nat) -> Eq (difference (product a n) (product b m)) (gcd_aux q m n)) -> (Eq (difference (product b m) (product a n)) (gcd_aux q m n))), forall m : Nat, forall n : Nat, forall Hn : ((a : Nat) -> (_clearme : ex a (b : Nat) -> Eq (difference (product a n) (product b m)) (gcd_aux q m n)) -> (b : Nat) -> Eq (difference (product b m) (product a n)) (gcd_aux q m n)), forall a : Nat, forall _clearme : ((b : Nat) -> Eq (difference (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n))) -> (Eq (difference (product b n) (product a (mod m n))) (gcd_aux q n (mod m n))), forall b : Nat, if a mod (m , n)- b n = gcd_aux (q , n , mod (m , n)) or b n - a mod (m , n)= gcd_aux (q , n , mod (m , n)), then if a mod (m , n)- b n = gcd_aux (q , n , mod (m , n)), then a mod (m , n)- n b = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nBigop_I_gen. Soient $a$ et $b$ des nombres naturels. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $Aop$ de $B$ et de $nil$. Soit $f$ une fonction des nombres naturels à des éléments de $B$. Alors si $a$ est inférieur ou ágal à $b$, alors $bigop$ appliqué à la différence de $b$ et de $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $p$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$ est égal à $bigop$ appliqué à $b$ et la fonction qui envoie $i$ à $andb$ appliqué à $leb$ appliqué à $a$ et $i$ et $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "Axiom bigop_I_gen : forall a : nat, forall b : nat, forall p : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : Aop B nil, forall f : ((x__ : nat) -> B), forall x__ : Leq a b, bigop (b - a) (fun i => (fun i0 => p i0) (i + a)) B nil (op B nil op) (fun i => (fun i0 => f i0) (i + a)) = bigop b (fun i => andb (leb a i) (p i)) B nil (op B nil op) (fun i => f i) .", "predict": "Axiom bigop_I_gen : forall a : nat, forall b : nat, forall p : nat -> bool, forall B : set, forall nil : B, forall op : Aop B nil, forall f : nat -> B, forall a : nat <= b, bigop (b - a) (fun i => (fun i0 => p i0) (sum i a)) B nil (op B nil op) (fun i => (fun i0 => f i0) (sum i a))) = bigop b (fun i => andb (leb a i) (p i)) B nil (op B nil op) (fun i => f i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nExp_plus_times. Pour tous les nombres naturels $n$ et $p$ et $q$, $n ^ (p + q)= n ^ p (n ^ q)$.\nassistant\n", "label": "postulate exp_plus_times : (n : Nat) -> (p : Nat) -> (q : Nat) -> Eq (pow n (plus p q)) (times (pow n p) (pow n q))", "predict": "postulate exp_plus_times : (n : Set) -> (p : Set) -> (q : Set) -> n ^ (p + q) = n ^ p (n ^ q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_to_le_max. Let $f$ be a function from natural numbers to booleans. Let $n , m \\in N$. Assume that $n \\leq m$. Then $max (n , f)\\leq max (m , f)$.\nassistant\n", "label": "Axiom le_to_le_max : forall f : ((x__ : nat) -> bool), forall n : nat, forall m : nat, forall x__ : Leq n m, Leq (max n f) (max m f) .", "predict": "Axiom le_to_le_max : forall f : nat -> bool, forall n : N, forall m : N, n <= m -> max (n , f) <= max (m , f) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b \\in N$. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Supposons que $a$ est égal à $b$. Alors $f$ appliqué à $a$ est égal à $i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : N -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (__ : (i0 : N) -> (Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (__ : a == b) -> f a == i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nP_ord_aux_Strue. Låt $n$ och $m$ och $p$ och $q$ och $r$ vara naturliga tal. Då om $mod (n , m)= 0$, så om $p_ord_aux (p , n \\div m , m)= mk_Prod (Nat , Nat , q , r)$, så $p_ord_aux (p + 1 , n , m)= mk_Prod (Nat , Nat , q + 1 , r)$.\nassistant\n", "label": "p_ord_aux_Strue : n : Nat -> m : Nat -> p : Nat -> q : Nat -> r : Nat -> __ : Eq (mod n m) 0 -> __1 : Eq (p_ord_aux p (div n m) m) (mk_Prod Nat Nat q r) -> Eq (p_ord_aux (plus p (nd 1)) n m) (mk_Prod Nat Nat (plus q (nd 1)) r) .", "predict": "p_ord_aux_Strue : n : Nat -> m : Nat -> p : Nat -> q : Nat -> r : Nat -> mod (n , m) = 0 -> p_ord_aux (p , n \\div m , m) = mk_Prod (Nat , Nat , q , r) -> p_ord_aux (p + 1 , n , m) = mk_Prod (Nat , Nat , q + 1 , r) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_exp. Soient $n$ et $m$ et $p$ des nombres naturels. Alors si $0$ est inférieur à $p$, alors si $n$ est inférieur ou ágal à $m$, alors la puissance de $p$ et de $n$ est inférieure ou ágale à la puissance de $p$ et de $m$.\nassistant\n", "label": "postulate le_exp : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq n m) -> Leq (pow p n) (pow p m)", "predict": "postulate le_exp : (n : Set) -> (m : Set) -> (p : Set) -> (0 : Set) -> (n : Set) -> (m : Set) -> p : Set) -> (le : Set) -> (exp : Set) -> (le_exp : n : Set) -> (m : Set) -> (p : Set) -> (0 : Set) -> (n : Set) -> (m : Set) -> p : Set) -> (le : Set) -> (exp : Set) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1648. Soient $n$ et $q$ des nombres naturels. Supposons que $0 < q$. Soit $n1 \\in N$. Alors si la somme du produit de $bigop$ appliqué à la somme de $n1$ et de $1$ et la fonction qui envoie $m$ à $andb$ appliqué à $leb$ appliqué à $1$ et $m$ et $dividesb$ appliqué à $q$ et $m$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $m$ à $1$ et de $q$ et de $mod (n1 , q)$ est égale à $n1$, alors si $q$ est divisible par $n1 + 1$ et $n1 + 1 = (n1 \\div q + 1)q$, alors si $q$ est divisible par $n1 + 1$, alors si $n1 + 1 = (n1 \\div q + 1)q$, alors $n1 + 1 = q + q (n1 \\div q)$.\nassistant\n", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : (n : Naturals) -> (q : Naturals) -> (n1 : Naturals) -> (andb : (m : Naturals) -> andb (leb 1 m) (dividesb q m)) -> (plus : (m : Naturals) -> 1) -> (q : Naturals) -> (mod : (n1 : Naturals) -> q) -> (n1 : Naturals) -> (q : Naturals) -> (n1 + 1 : Naturals) -> (n1divq : Naturals) -> (postulate let_clause_1648 : (n : Naturals) -> (q : Naturals) -> (n1 : Naturals) -> (andb : (m : Naturals) -> andb (leb 1 m) (dividesb q m)) -> (plus : (m : Naturals) -> 1) -> (q : Naturals) -> (mod : (n1 : Naturals) -> q) -> (n1 : Naturals) -> (q : Naturals) -> (n1 + 1 : Naturals) -> (n1divq : Naturals) -> (n1plus1 : Naturals) -> (qdivn1plus1 : Naturals) -> (n1divqplus1 : Naturals) -> (postulate let_clause_1648 : (n : Naturals) -> (q : Naturals) -> (n1 : Naturals) -> (andb : (m : Naturals) -> andb (leb 1 m) (dividesb q m)) -> (plus : (m : Naturals) -> 1) -> (q : Naturals) -> (mod : (n1 : Naturals) -> q) -> (n1 : Naturals) -> (q : Naturals) -> (n1 + 1 : Naturals) -> (n1divq : Naturals) -> (n1plus1 : Naturals) -> (qdivn1plus1 : Naturals) -> (n1divqplus1 : Naturals) -> (n1divqdivn1plus1 : Naturals) -> (n1divqdivn1divqplus1 : Naturals) -> (n1divqdivn1postulate let_clause_1648"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPad_bigop_nil. Let $k , n \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $Aop$ of $B$ and $nil$. Let $f$ be a function from natural numbers to elements of $B$. Assume that $n \\leq k$. Then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $or$ of $Eq$ applied to $p$ applied to $i$ and absurdity and $Eq (f (i), nil)$, $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : N) -> (n : N) -> (p : (i : N) -> Bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (i : N) -> B) -> (__1 : (i : N) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) absurdity) (Eq (f i) nil)) -> bigop k (\\ i : N -> p i) B nil (op B nil op) (\\ i : N -> f i)) -> bigop n (\\ i : N -> p i) B nil (op B nil op) (\\ i : N -> f i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLt_to_log_O. Soit $n , m \\in N$. Alors si $0$ est inférieur à $m$, alors si $m$ est inférieur à $n$, alors le logarithme de $n$ et de $m$ est égal à $0$.\nassistant\n", "label": "Axiom lt_to_log_O : forall n : nat, forall m : nat, forall x__ : (0 < m), forall __1 : (m < n), log n m = 0 .", "predict": "Axiom lt_to_log_O : forall n : N, forall m : N, forall nltm : 0 < m, forall mltn : m < n, log n m = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nChecker_spec. Soit $tl$ une liste de nombres naturels. Soit $a \\in N$. Soit $l$ une liste de nombres naturels. Supposons que $checker$ appliqué à $l$ est égal à $true$. Alors si $l$ est égal à $cons$ appliqué à $Nat$ et $a$ et $tl$, alors pour tous les nombres naturels $p$, pour tous les éléments $__2$ de $mem$ de $Nat$ et de $p$ et de $tl$, $ex$ tient pour $Nat$ et la fonction qui envoie $pp$ à la conjonction de la conjonction de $mem$ appliqué à $Nat$ et $pp$ et $l$ et de $Lt$ appliqué à $pp$ et $p$ et de $Leq$ appliqué à $p$ et le produit de $2$ et de $pp$.\nassistant\n", "label": "checker_spec : tl : list Nat -> a : Nat -> l : list Nat -> __ : Eq (checker l) true -> __1 : Eq l (cons Nat a tl) -> p : Nat -> __2 : mem Nat p tl -> ex Nat (pp : Nat => and (and (mem Nat pp l) (Lt pp p)) (Leq p (times (nd 2) pp))) .", "predict": "checker_spec : tl : List Nat -> a : Nat -> l : List Nat -> checker l = true -> l = cons Nat a tl -> p : Nat -> __2 : mem Nat p tl -> ex : Nat -> pp : Nat -> mem Nat pp l -> Lt pp p -> Leq p (2 * pp) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1544. Soit $p , q \\in N$. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soit $m , n \\in N$. Supposons que $0 < n$ et $n \\leq m$. Supposons que $n \\leq q + 1$ et $n$ n'est pas divisible par $m$. Soit $a \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b \\in N$. Supposons que $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ ou $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$ et $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$. Alors $a mod (m , n)- n b = gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "let_clause_1544 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n)) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n)) .", "predict": "let_clause_1544 : p : N -> q : N -> Hind : (m : N -> n : N -> Lt : 0 -> n -> __1 : Leq n -> m -> __2 : Leq n -> q -> ex : Nat -> (a : N -> ex Nat) -> b : N -> Eq (diff (prod a n) (prod b m)) -> gcd_aux q m n) -> m : N -> n : N -> 0 < n -> n <= m -> n <= q + 1 -> n != div m -> a : N -> _clearme : ex Nat -> (b : N -> Eq (diff (prod a (mod m n)) (prod b n)) -> gcd_aux q n (mod m n)) -> (b : N -> Eq (diff (prod b n) (prod a (mod m n))) -> gcd_aux q n (mod m n)) -> b : N -> a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) -> b n - a mod (m , n) = gcd_aux (q , n , mod (m , n)) -> a mod (m , n) - n b = gcd_aux (q , n , mod (m , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15621. Let $m , n , a , b \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.\nassistant\n", "label": "Axiom let_clause_15621 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), n * c - m * d = 1 .", "predict": "Axiom let_clause_15621 : forall m : N, forall n : N, forall a : N, forall b : N, forall c : N, forall _clearme : ((d : N) -> Eq (diff (prod c n) (prod d m)) 1) -> Eq (diff (prod d m) (prod c n)) 1), forall d : N, ((diff (prod c n) (prod d m)) = 1) -> (diff (prod n c) (prod m d)) = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_max_n. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Alors pour tous les nombres naturels $n$, $max (n , f)\\leq n$.\nassistant\n", "label": "le_max_n : f : (__ : Nat -> bool) -> n : Nat -> Leq (max n f) n .", "predict": "le_max_n : f : nat -> bool -> n : nat -> max (n , f) <= n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAop_rect_Type2. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_869$ av $Aop$ av $A$ och $_nil$ till element av $Type2$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Då för alla element $x_869$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_869$.\nassistant\n", "label": "axiom Aop_rect_Type2 (A : Set) (_nil : A) (Q_ : (_x_869 : Aop A _nil) -> Type2) (_H_mk_Aop : (op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_869 : Aop A _nil) : Q_ x_869", "predict": "axiom Aop_rect_Type2 (A : Set) (_nil : A) (Q_ : (_x_869 : Aop A _nil) -> Type2) (_H_mk_Aop : (op : (__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a)) -> (_nilr : (a : A) -> Eq (op a _nil) a)) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c))) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) (x_869 : Aop A _nil) : Q_ x_869"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_le. Let $_n \\in N$. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$. Let $case_le_n$ be an element of $return_type$ of $_n$ and $le_n$ applied to $_n$. Let $case_le_S$ be a function from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $__$. Let $__$ be a natural number. Assume that $_n$ is less than or equal to $__$. Then $return_type$ holds for $__$ and $z$.\nassistant\n", "label": "match_le : _n : Nat -> return_sort : Sort -> return_type : (__ : Nat -> z : Leq _n __ -> return_sort) -> case_le_n : return_type _n (le_n _n) -> case_le_S : (m : Nat -> __ : Leq _n m -> return_type (plus m (nd 1)) (le_S _n m __)) -> __ : Nat -> z : Leq _n __ -> return_type __ z .", "predict": "match_le : _n : N -> return_sort : Sort -> return_type : (z : Leq _n __ -> return_sort) -> case_le_n : return_type _n (le_n _n) -> case_le_S : (m : N -> z : Leq _n m -> return_type (m + 1) (le_S _n m __)) -> __ : N -> _n <= __ -> return_type __ z ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDiv_mod_spec_rect_CProp0. Låt $_n , _m , _q , _r \\in N$. Låt $Q_$ vara en funktion från element $_x_857$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden. Låt $_H_div_mod_spec_intro$ vara en funktion från element $x_859$ av $Lt$ av $_r$ och $_m$ och element $x_858$ av $Eq$ av $_n$ och $_q _m + _r$ till element av $Q_$ av $div_mod_spec_intro (_n , _m , _q , _r , x_859 , x_858)$. Låt $x_857$ vara ett element av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$. Då håller $Q_$ för $x_857$.\nassistant\n", "label": "postulate div_mod_spec_rect_CProp0 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857", "predict": "postulate div_mod_spec_rect_CProp0 : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Set) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_10471. Soit $n1 , n2 \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $ACop$ de $B$ et de $nil$. Soient $f1$ et $f2$ des fonctions des nombres naturels à des éléments de $B$. Soit $_clearme$ un élément de $iso$ de $B$ et de $mk_range$ appliqué à $B$ et $f1$ et $n1$ et $p1$ et de $mk_range$ appliqué à $B$ et $f2$ et $n2$ et $p2$. Soit $h$ une fonction des nombres naturels à des nombres naturels. Soit $_clearme0$ un élément de $ex$ de $prod$ appliqué à $Set$ et $Set$ et $Nat$ et la fonction qui envoie $__$ à $Nat$ et de la fonction qui envoie $k$ à la conjonction de la conjonction de $prod$ appliqué à $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Prop$ et $Prop$ et $Eq$ appliqué à $p1$ appliqué à $i$ et $true$ et la fonction qui envoie $__1$ à $Eq$ appliqué à $f1$ appliqué à $i$ et $f2$ appliqué à $h$ appliqué à $i$ et de $sub_hk$ appliqué à $h$ et $k$ et $B$ et $mk_range$ appliqué à $B$ et $f1$ et $n1$ et $p1$ et $mk_range$ appliqué à $B$ et $f2$ et $n2$ et $p2$ et de $sub_hk$ appliqué à $k$ et $h$ et $B$ et $mk_range$ appliqué à $B$ et $f2$ et $n2$ et $p2$ et $mk_range$ appliqué à $B$ et $f1$ et $n1$ et $p1$. Soit $k$ une fonction des nombres naturels à des nombres naturels. Supposons que $prod$ tient pour $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Prop$ et $Prop$ et $Eq$ appliqué à $p1$ appliqué à $i$ et $true$ et la fonction qui envoie $__1$ à $Eq$ appliqué à $f1$ appliqué à $i$ et $", "label": "axiom let_clause_10471 (n1 n2 : Nat) (p1 p2 : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : ACop B nil) (f1 f2 : (x__ : Nat) -> B) (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (h : (x__ : Nat) -> Nat) (_clearme0 : ex (prod Set Set Nat (λ x__ => Nat)) (λ k => prod Set Prop Nat (λ i => prod Prop Prop (i < n1) (λ x__ => prod Prop Prop (p1 i = true) (λ __1 => f1 i = f2 (h i)))) ∧ sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) ∧ sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) (k : (x__ : Nat) -> Nat) (_clearme1 : prod Set Prop Nat (λ i => prod Prop Prop (i < n1) (λ x__ => prod Prop Prop (p1 i = true) (λ __1 => f1 i = f2 (h i)))) ∧ sub_hk h", "predict": "axiom let_clause_10471 (n1 n2 : N) (p1 p2 : (i : N) -> Bool) (B : Set) (nil : B) (op : ACop B nil) (f1 f2 : (i : N) -> B) (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (h : (i : N) -> N) (_clearme0 : ex (prod Set Set Nat (λ __ => Nat)) (λ k => conj (conj (prod Set Prop Nat (λ i => prod Prop Prop (Lt i n1) (λ __ => prod Prop Prop (Eq (p1 i) true) (λ __1 => Eq (f1 i) (f2 (h i))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) (k : (i : N) -> N) : Prod Set Set Nat (λ i => Prod Prop Prop (Lt i n1) (λ __ => Prod Prop Prop (Eq (p1 i) true) (λ __1 => Eq (f1 i) (f2 (h i))))) (λ __2 => Prod Prop Prop (Eq (p2 (k i)) true) (λ __3 => Eq (f2 (k i)) (f1 (h i))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1532. Låt $n , m \\in N$. Anta att $n$ är delbart med $m$. Anta att $0 = n$. Låt $d \\in N$. Anta att $m = 0 d$. Då $m = 0$.\nassistant\n", "label": "Axiom let_clause_1532 : forall n : nat, forall m : nat, forall divnm : divisible n m, forall H : (0 = n), forall d : nat, forall auto : (m = 0 * d), m = 0 .", "predict": "Axiom let_clause_1532 : forall n : N, forall m : N, forall ndivm : nat, forall n0 : nat, forall d : N, forall m0d : nat, nat -> nat -> nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMin_exists. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $t$ och $m$ vara naturliga tal. Anta att $m$ är mindre än $t$. Anta att $f$ applicerat på $m$ är lika med $true$. Låt $k , b \\in N$. Då om $b$ är mindre än eller lika med $m$, så för alla funktioner $__3$ från naturliga tal $i$ och element $__3$ av $Leq$ av $b$ och $i$ och element $__4$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $f$ applicerat på $i$ och kontradiktion, om $t$ är lika med summan av $k$ och $b$, så är $min$ applicerat på $k$ och $b$ och $f$ lika med $m$.\nassistant\n", "label": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m", "predict": "postulate min_exists : (f : (nat : Set) -> Set) -> (t : nat) -> (m : nat) -> (k : nat) -> (b : nat) -> (__3 : (i : nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Set) -> (t : k + b) -> (min : k) -> b) -> f) -> m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$. Supposons que $b \\leq n$. Supposons que $f (b)= j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$. Alors pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "let_clause_1068 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) i .", "predict": "let_clause_1068 : f : (Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f (a) = i -> a <= n -> f (a) = i -> b : Nat -> b <= n -> f (b) = j -> b <= n -> f (b) = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f (a) = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_fact_to_le. Let $p$ and $n$ be natural numbers. Then if $p$ is both prime and divisible by $n !$, then $p \\leq n$.\nassistant\n", "label": "axiom divides_fact_to_le (p n : Nat) (x__ : prime p) (__1 : divisible p (factorial n)) : p ≤ n", "predict": "axiom divides_fact_to_le (p n : Nat) : p prime -> n ! -> p ≤ n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1575. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Alors si $0$ est inférieur à $n$, alors si $0$ est inférieur à $m$, alors si le diviseur commun plus grand de $n$ et de $m$ est égal à $1$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors pour tous les nombres naturels $x1029$, $x1029$ est égal au produit de $x1029$ et de la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nassistant\n", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> Eq (diff (c * n) (d * m)) 1)) -> (d : Nat) -> (diff1 : Eq (diff (c * n) (d * m)) 1) -> (diff2 : Eq (diff (d * m) (c * n)) 1) -> (diff3 : Eq (diff (c * n) (d * m)) 1) -> (x1029 : Nat) -> x1029 == (x1029 * (diff (n * c) (m * d)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nSub_hkO. Soient $h$ et $k$ des fonctions des nombres naturels à des nombres naturels. Alors pour tous les ensembles $A$, pour tous les éléments $I$ et $J$ de $range$ de $A$, si $upto$ appliqué à $A$ et $I$ est égal à $0$, alors $sub_hk$ tient pour $h$ et $k$ et $A$ et $I$ et $J$.\nassistant\n", "label": "axiom sub_hkO (h k : (x__ : Nat) -> Nat) (A : Set) (I J : range A) (x__ : upto A I = 0) : sub_hk h k A I J", "predict": "axiom sub_hkO (h k : (Nat -> Nat) -> (A : Set) -> I J : range A) : (upto A I = 0) -> sub_hk h k A I J"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_S_S. Låt $n , m \\in N$. Anta att $n$ är mindre än eller lika med $m$. Då är summan av $n$ och $1$ mindre än eller lika med summan av $m$ och $1$.\nassistant\n", "label": "le_S_S : n : Nat -> m : Nat -> __ : Leq n m -> Leq (plus n (nd 1)) (plus m (nd 1)) .", "predict": "le_S_S : n : N -> m : N -> n <= m -> n + 1 <= m + 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nBijn_n_Sn. Pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, pour tous les nombres naturels $n$, pour tous les éléments $__$ de $bijn$ de $f$ et de $n$, si $f$ appliqué à la somme de $n$ et de $1$ est égal à la somme de $n$ et de $1$, alors $bijn$ tient pour $f$ et la somme de $n$ et de $1$.\nassistant\n", "label": "bijn_n_Sn : f : (__ : Nat -> Nat) -> n : Nat -> __ : bijn f n -> __1 : Eq (f (plus n (nd 1))) (plus n (nd 1)) -> bijn f (plus n (nd 1)) .", "predict": "bijn_n_Sn : f : nat -> nat -> n : nat -> __ : bijn f n -> f (n + 1) = n + 1 -> bijn f (n + 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOr_div_mod1. For all natural numbers $n$ and $q$, if $0$ is less than $q$, then $q$ is divisible by the sum of $n$ and $1$ and the sum of $n$ and $1$ is equal to the product of the sum of the quotient of $n$ and $q$ and $1$ and $q$ or $q$ is not divisible by the sum of $n$ and $1$ and the sum of $n$ and $1$ is equal to the sum of the product of the quotient of $n$ and $q$ and $q$ and the sum of $mod$ applied to $n$ and $q$ and $1$.\nassistant\n", "label": "Axiom or_div_mod1 : forall n : nat, forall q : nat, forall x__ : (0 < q), divisible q (n + 1) /\\ n + 1 = (n / q + 1) * q \\/ (~ divisible q (n + 1) /\\ n + 1 = n / q * q + (mod n q + 1)) .", "predict": "Axiom or_div_mod1 : forall n : nat, forall q : nat, if 0 < q then q = (n + 1) * (n + 1) = (n / q + 1) * q || q =/= (n + 1) * (n + 1) = (n / q * q) + (mod n q + 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Anta att $5 < n$. Låt $m$ vara ett naturligt tal. Anta att $6 \\leq m$. Anta att $(m + 1)^ 2 \\leq 2 ^ m$. Då för alla naturliga tal $a$, om $6 \\leq a$, så om $2 (a + 1)+ 1 \\leq 2 ^ a$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_10331 : forall n : nat, forall lt4n : (5 < n), forall m : nat, forall le4m : Leq 6 m, forall Hind : Leq (pow (m + 1) 2) (pow 2 m), forall a : nat, forall lea : Leq 6 a, forall Hinda : Leq (2 * (a + 1) + 1) (pow 2 a), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_10331 : forall n : nat, forall m : nat, forall a : nat, forall x2515 : nat, forall x2516 : nat, 5 < n -> 6 <= m -> (m + 1)^ 2 <= 2 ^ m -> 6 <= a -> 2 (a + 1)+ 1 <= 2 ^ a -> x2515 = x2516 (x2515 div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1559. Låt $n , m \\in N$. Anta att $n$ är delbart med $m$. Då om $0$ är lika med $n$, så för alla naturliga tal $d$, om $m$ är lika med produkten av $0$ och $d$, så är $m$ lika med $n$.\nassistant\n", "label": "postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n", "predict": "postulate let_clause_1559 : (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (postulate let_clause_1559 : (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N) -> (n : N) -> (m : N) -> (d : N)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nMonotonic_le_minus_r. Låt $p , q , n \\in N$. Anta att $q \\leq p$. Då $n - p \\leq n - q$.\nassistant\n", "label": "Axiom monotonic_le_minus_r : forall p : nat, forall q : nat, forall n : nat, forall x__ : Leq q p, Leq (n - p) (n - q) .", "predict": "Axiom monotonic_le_minus_r : forall p : N, forall q : N, forall n : N, q <= p -> n - p <= n - q ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1553. Låt $n , n0 \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $a$ som disjunktionen av $Eq$ applicerat på $n0$ och produkten av $2$ och $a$ och $Eq$ applicerat på $n0$ och summan av produkten av $2$ och $a$ och $1$. Låt $a$ vara ett naturligt tal. Anta att $n0 = 2 a$ eller $n0 = 2 a + 1$. Då om $n0 = 2 a + 1$, så $n0 = a + (a + 1)$.\nassistant\n", "label": "let_clause_1553 : n : Nat -> n0 : Nat -> _clearme : ex Nat (a : Nat => or (Eq n0 (times (nd 2) a)) (Eq n0 (plus (times (nd 2) a) (nd 1)))) -> a : Nat -> _clearme0 : or (Eq n0 (times (nd 2) a)) (Eq n0 (plus (times (nd 2) a) (nd 1))) -> Hn : Eq n0 (plus (times (nd 2) a) (nd 1)) -> Eq n0 (plus a (plus a (nd 1))) .", "predict": "let_clause_1553 : n : N -> n0 : N -> _clearme : ex Nat -> (a : Nat -> Eq n0 (2 * a)) -> (a : Nat -> Eq n0 (2 * a + 1)) -> a : Nat -> n0 = 2 a -> n0 = 2 a + 1 -> n0 = a + (a + 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPrimes_below_lop. Let $n \\in N$. Then $primes_below$ holds for $list_of_primes$ applied to $n$ and the sum of $n$ and $2$.\nassistant\n", "label": "primes_below_lop : n : Nat -> primes_below (list_of_primes n) (plus n (nd 2)) .", "predict": "primes_below_lop : n : N -> primes_below (list_of_primes n) (n + 2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLt_nth_prime_to_not_prime. Soit $n , m \\in N$. Alors si $nth_prime$ appliqué à $n$ est inférieur à $m$, alors si $m$ est inférieur à $nth_prime$ appliqué à la somme de $n$ et de $1$, alors $m$ n'est pas premier.\nassistant\n", "label": "Axiom lt_nth_prime_to_not_prime : forall n : nat, forall m : nat, forall x__ : (nth_prime n < m), forall __1 : (m < nth_prime (n + 1)), ~ prime m .", "predict": "Axiom lt_nth_prime_to_not_prime : forall n : N, forall m : N, nth_prime n < m -> m < nth_prime (n + 1) -> ~prime m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPad_bigop_nil. Låt $k$ och $n$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Då för alla element $op$ av $Aop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, om $n \\leq k$, så för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Leq$ av $n$ och $i$ och element $__2$ av $Lt$ av $i$ och $k$ till element av $or$ av $Eq$ applicerat på $p$ applicerat på $i$ och kontradiktion och $Eq (f (i), nil)$, är $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nassistant\n", "label": "pad_bigop_nil : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq n k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) (bigop k (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) .", "predict": "pad_bigop_nil : k : Nat -> n : Nat -> p : (Nat -> Bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (Nat -> B) -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> or (Eq (p i) kontradiktion) (Eq (f i) nil)) -> bigop k (i : Nat => p i) B nil op (i : Nat => f i) = bigop n (i : Nat => p i) B nil op (i : Nat => f i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1561. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Assume that $m n = p c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$. Assume that $a p - b m = 1$. Then $p a - m b = 1$.\nassistant\n", "label": "Axiom let_clause_1561 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (a * p - b * m = gcd p m), forall H0 : (a * p - b * m = 1), p * a - m * b = 1 .", "predict": "Axiom let_clause_1561 : forall p : Nat, forall m : Nat, forall n : Nat, forall c : Nat, forall a : Nat, forall _clearme0 : (b : Nat) -> Eq (Nat) (product a p) (product b m) (gcd p m) -> forall b : Nat, ((gcd p m) = (a p - b m) -> (gcd p m) = (b m - a p) -> (gcd p m) = (a p - b m) -> a p - b m = 1 -> p a - m b = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMod_S. Låt $n$ och $m$ vara naturliga tal. Anta att $0$ är mindre än $m$. Då om summan av $mod$ applicerat på $n$ och $m$ och $1$ är mindre än $m$, så är $mod$ applicerat på summan av $n$ och $1$ och $m$ lika med summan av $mod$ applicerat på $n$ och $m$ och $1$.\nassistant\n", "label": "axiom mod_S (n m : Nat) (x__ : 0 < m) (__1 : mod n m + 1 < m) : mod (n + 1) m = mod n m + 1", "predict": "axiom mod_S (n m : Nat) : Bool => and (0 < m) (sum (mod n m) 1 < m) => mod (sum n 1) m = mod n m 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1569. Pour tous les nombres naturels $m$ et $n$ et $a$ et $b$, si $0 < n$ et $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $c n - d m = 1$, alors $n c - m d = 1$.\nassistant\n", "label": "Axiom let_clause_1569 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), n * c - m * d = 1 .", "predict": "Axiom let_clause_1569 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ex Nat (fun d => Eq (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat) (Nat) (div (Nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_rect_Type4. Låt $_n$ och $_m$ och $_q$ och $_r$ vara naturliga tal. Låt $Q_$ vara en funktion från element $_x_813$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till element av $Type4$. Låt $_H_div_mod_spec_intro$ vara en funktion från element $x_815$ av $Lt$ av $_r$ och $_m$ och element $x_814$ av $Eq$ av $_n$ och $_q _m + _r$ till element av $Q_$ av $div_mod_spec_intro (_n , _m , _q , _r , x_815 , x_814)$. Då för alla element $x_813$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_813$.\nassistant\n", "label": "axiom div_mod_spec_rect_Type4 (_n _m _q _r : Nat) (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) (_H_div_mod_spec_intro : (x_815 : _r < _m) -> (x_814 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) (x_813 : div_mod_spec _n _m _q _r) : Q_ x_813", "predict": "axiom div_mod_spec_rect_Type4 (_n _m _q _r : Nat) (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) (x_813 : div_mod_spec _n _m _q _r) : Q_ x_813"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1075. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $bijf$ vara ett element av $bijn$ av $f$ och $n + 1$. Anta att $f (n + 1)= n + 1$. Låt $i \\in N$. Då om $i \\leq n$, så för alla naturliga tal $a$, om $a \\leq n + 1$ och $f (a)= i$ och $a \\leq n + 1$, så om $f (a)= i$ och $a = n + 1$, så $i = a$.\nassistant\n", "label": "Axiom let_clause_1075 : forall f : ((x__ : nat) -> nat), forall n : nat, forall bijf : bijn f (n + 1), forall fS : (f (n + 1) = n + 1), forall i : nat, forall lein : Leq i n, forall a : nat, forall _clearme : (Leq a (n + 1) /\\ f a = i), forall lean : Leq a (n + 1), forall fa : (f a = i), forall Hc : (a = n + 1), i = a .", "predict": "Axiom let_clause_1075 : forall f : nat -> nat, forall n : nat, forall bijf : bijn f n + 1, forall i : N, forall a : nat, a <= n + 1 -> f a = i -> a <= n + 1 -> f a = i -> a = n + 1 -> i = a ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDivides_to_p_ord. Låt $p$ och $a$ och $b$ och $c$ och $d$ och $n$ och $m$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att $p$ är primt. Då om $n$ är delbart med $m$, så om $p_ord$ applicerat på $n$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $a$ och $b$, så om $p_ord$ applicerat på $m$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $c$ och $d$, så är $b$ delbart med $d$ och $a$ är mindre än eller lika med $c$.\nassistant\n", "label": "divides_to_p_ord : p : Nat -> a : Nat -> b : Nat -> c : Nat -> d : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> __4 : Eq (p_ord n p) (mk_Prod Nat Nat a b) -> __5 : Eq (p_ord m p) (mk_Prod Nat Nat c d) -> and (divisible b d) (Leq a c) .", "predict": "divides_to_p_ord : p : Nat -> a : Nat -> b : Nat -> c : Nat -> d : Nat -> n : Nat -> m : Nat -> 0 < n -> 0 < m -> p : Primt -> n : Delbart_med_m -> p_ord(n,p) = mk_Prod(Nat,Nat,a,b) -> p_ord(m,p) = mk_Prod(Nat,Nat,c,d) -> b : Delbart_med_d -> a : mindre_eller_lika_med_c -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1607. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Då om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nassistant\n", "label": "axiom let_clause_1607 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c", "predict": "axiom let_clause_1607 (m n a b : Nat) (c : Nat) (_clearme : ex Nat (λ d => Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1 ∧ Eq (skillnaden (produkten av d och m) (produkten av c och n)) 1)) (d : N) : Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1 → Eq (skillnaden (produkten av d och m) (produkten av c och n)) 1 → Eq (skillnaden (produkten av d och m) (produkten av c och n)) 1 → Eq (mogulteitetsalet (m n) (skillnaden (produkten av m och d) (produkten av n och c))) (skillnaden (produkten av m och d) (produkten av n och c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTranspose_i_j_i. Let $i , j \\in N$. Then $transpose$ applied to $i$ and $j$ and $i$ is equal to $j$.\nassistant\n", "label": "Axiom transpose_i_j_i : forall i : nat, forall j : nat, transpose i j i = j .", "predict": "Axiom transpose_i_j_i : forall i : N, forall j : N, j = transpose i j i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1572. Låt $m$ och $n$ vara naturliga tal. Anta att $0 < n$. Då om $0$ är lika med det största gemensama delaret av $m$ och $n$, så om $m = 0$, så om $n = 0$, så $m = 0$.\nassistant\n", "label": "axiom let_clause_1572 (m n : Nat) (posn : 0 < n) (H : gcd m n = 0) (auto : m = 0) (auto' : n = 0) : m = 0", "predict": "axiom let_clause_1572 (m n : Nat) (Hc : 0 < n) : (Hm : 0 = gcd m n) -> (Hn : m = 0) -> (Hm0 : n = 0) -> m = 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1562. Soit $m , n , a , b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$ est égale à $1$.\nassistant\n", "label": "postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1562 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : Nat) -> (_clearme : ex Nat (\\ d : N -> Eq (diff (prod c n) (prod d m)) 1)) -> (d : N) -> (eq1 : Eq (diff (prod c n) (prod d m)) 1) -> (eq2 : Eq (diff (prod d m) (prod c n)) 1) -> (eq3 : Eq (diff (prod c n) (prod d m)) 1) -> Eq (diff (n c) (m d)) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_lstar. Let $B$ be a set. Let $_R$ be an element of $relation$ of $B$. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $__1$ of $B$ and elements $__2$ of $B$ and elements $z$ of $lstar$ of $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $return_sort$. Let $case_lstar_O$ be a function from elements $b$ of $B$ to elements of $return_type$ of $0$ and $b$ and $b$ and $lstar_O$ applied to $B$ and $_R$ and $b$. Let $case_lstar_S$ be a function from elements $b1$ of $B$ and elements $b$ of $B$ and elements of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $__1$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ to elements of $return_type$ of the sum of $l$ and $1$ and $b1$ and $b2$ and $lstar_S$ applied to $B$ and $_R$ and $b1$ and $b$ and $__$ and $l$ and $b2$ and $__1$. Let $__ \\in N$. Then for all elements $__1$ and $__2$ of $B$, for all elements $z$ of $lstar$ of $B$ and $_R$ and $__$ and $__1$ and $__2$, $return_type$ holds for $__$ and $__1$ and $__2$ and $z$.\nassistant\n", "label": "axiom match_lstar (B : Set) (_R : relation B) (return_sort : Sort) (return_type : (x__ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) (case_lstar_S : (b1 : B) -> (b : B) -> (x__ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (l + 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) (x__ : Nat) (__1 __2 : B) (z : lstar B _R __ __1 __2) : return_type __ __1 __2 z", "predict": "axiom match_lstar (B : Set) (_R : relation B) (return_sort : Sort) (return_type : (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) (case_lstar_S : (b1 : B) -> (b : B) -> (_R : b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (l + 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) (__ : Nat) (__1 __2 : B) (z : lstar B _R __ __1 __2) : return_type __ __1 __2 z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMax_spec_ind. Soit $_n \\in N$. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f$ appliqué à $m$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f$ appliqué à $i$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec$ appliqué à $_n$ et $_f$ et $m$ et $x_975$ et $x_974$ et $x_973$. Alors pour toutes les fonctions $_H_not_found_max_spec$ des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f$ appliqué à $i$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec$ appliqué à $_n$ et $_f$ et $x_976$, pour tous les nombres naturels $x_971$, pour tous les éléments $x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$, $Q_$ tient pour $x_971$ et $x_972$.\nassistant\n", "label": "axiom max_spec_ind (_n : Nat) (_f : (x__ : Nat) -> bool) (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) (_H_found_max_spec : (m : Nat) -> (x_975 : m < _n) -> (x_974 : _f m = true) -> (x_973 : (i : Nat) -> (x__ : m < i) -> (__1 : i < _n) -> _f i = false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) (_H_not_found_max_spec : (x_976 : (i : Nat) -> (x__ : i < _n) -> _f i = false) -> Q_ 0 (not_found_max_spec _n _f x_976)) (x_971 : Nat) (x_972 : max_spec _n _f x_971) : Q_ x_971 x_972", "predict": "axiom max_spec_ind (_n : N) (_f : (x : N) -> Bool) (Q_ : (x_971 : N) -> (_x_972 : max_spec _n _f x_971) -> Prop) (_H_found_max_spec : (m : N) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : N) -> (Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) contradiction) -> (Q_ m (found_max_spec _n _f m x_975 x_974 x_973))) (_H_not_found_max_spec : (x_976 : (i : N) -> Lt i _n) -> Eq (_f i) contradiction) -> (Q_ 0 (not_found_max_spec _n _f x_976))) (x_971 : N) (x_972 : max_spec _n _f x_971) : Q_ x_971 x_972"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a \\in N$. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b \\in N$. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Supposons que $f (b)= j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Supposons que $a = b$. Alors $f (a)= i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : (i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall a : nat, forall b : nat, forall __ : (i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall Hc : a = b, f a = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1075. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $bijf$ vara ett element av $bijn$ av $f$ och $n + 1$. Anta att $f (n + 1)= n + 1$. Låt $i$ vara ett naturligt tal. Anta att $i \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n + 1$ och $f (a)= i$. Anta att $a \\leq n + 1$. Då om $f (a)= i$, så om $a = n + 1$, så $i = a$.\nassistant\n", "label": "axiom let_clause_1075 (f : (x__ : Nat) -> Nat) (n : Nat) (bijf : bijn f (n + 1)) (fS : f (n + 1) = n + 1) (i : Nat) (lein : i ≤ n) (a : Nat) (_clearme : a ≤ n + 1 ∧ f a = i) (lean : a ≤ n + 1) (fa : f a = i) (Hc : a = n + 1) : i = a", "predict": "axiom let_clause_1075 (f : nat -> nat) (n : N) (bijf : bijn f (n + 1)) (i : nat) (a : nat) : (a <= n + 1) -> (f a = i) -> (a <= n + 1) -> (f a = i) -> (a = n + 1) -> (i = a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1600. Låt $m , n , a , b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Då om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $n$ och $c$ och produkten av $m$ och $d$.\nassistant\n", "label": "axiom let_clause_1600 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : gcd m n = n * c - m * d", "predict": "axiom let_clause_1600 (m n a b : N) (_clearme : ex Nat (λ d => Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1)) (d : N) : (skillnaden (produkten av c och n) (produkten av d och m)) = 1 ∨ (skillnaden (produkten av d och m) (produkten av c och n)) = 1) : (skillnaden (produkten av c och n) (produkten av d och m)) = 1 → (största gemensama delaret av m och n) = (produkten av n och c) - (produkten av m och d)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_O_n_elim. Låt $n$ vara ett naturligt tal. Anta att $0$ är mindre än $n$. Då för alla funktioner $P$ från naturliga tal $__1$ till påståenden, för alla funktioner $__1$ från naturliga tal $m$ till element av $P$ av summan av $m$ och $1$, håller $P$ för $n$.\nassistant\n", "label": "postulate lt_O_n_elim : (n : Nat) -> (_ : Lt 0 n) -> (P : (__1 : Nat) -> Prop) -> (__1 : (m : Nat) -> P (plus m 1)) -> P n", "predict": "postulate lt_O_n_elim : (n : Nat) -> (P : (__1 : Nat) -> Set) -> (__1 : (m : Nat) -> Set) -> P (n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiv_mod_spec_ind. Soient $_n$ et $_m$ et $_q$ et $_r$ des nombres naturels. Soit $Q_$ une fonction des éléments $_x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_811$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_810$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_811$ et $x_810$. Alors pour tous les éléments $x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_809$.\nassistant\n", "label": "div_mod_spec_ind : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 .", "predict": "div_mod_spec_ind : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (product _q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1033. Låt $n \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $g1$ och $g2$ vara funktioner från naturliga tal till naturliga tal. Då för alla naturliga tal $n1$, för alla funktioner $Hind$ från funktioner från naturliga tal $i$ och element av $Lt$ av $i$ och $n1$ och element $__1$ av $Eq$ av $p1$ applicerat på $i$ och $true$ till element av $Eq$ av $p2$ applicerat på $i$ och $true$ och funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n1$ och element $__2$ av $Eq$ av $p1$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$ till element av $Leq$ av $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$, för alla funktioner $H1$ från naturliga tal $i$ och element av $Lt$ av $i$ och summan av $n1$ och $1$ och element $__1$ av $Eq$ av $p1$ applicerat på $i$ och $true$ till element av $Eq$ av $p2$ applicerat på $i$ och $true$, för alla funktioner $H2$ från naturliga tal $i$ och element av $Lt$ av $i$ och summan av $n1$ och $1$ och element $__1$ av $Eq$ av $p1$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$, om $p2$ applicerat på $n1$ är lika med $true$, så om $p1$ applicerat på $n1$ är lika med $true$, så för alla naturliga tal $x2515$ och $x2516$,", "label": "let_clause_1033 : n : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> n1 : Nat -> Hind : (__ : (i : Nat -> __ : Lt i n1 -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> __1 : (i : Nat -> __1 : Lt i n1 -> __2 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (i : Nat => p1 i) Nat 0 plus (i : Nat => g1 i)) (bigop n1 (i : Nat => p2 i) Nat 0 plus (i : Nat => g2 i))) -> H1 : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> H2 : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Hp2 : Eq (p2 n1) true -> Hp1 : Eq (p1 n1) true -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_1033 : n : N -> p1 : (i : N -> __1 : Eq p1 i true -> i : Nat -> __1 : Lt i n1 -> i : Nat -> __2 : Eq p1 i true -> Leq (g1 i) (g2 i)) -> p2 : (i : N -> __1 : Eq p1 i true -> i : Nat -> __1 : Lt i n1 -> i : Nat -> __2 : Eq p1 i true -> Leq (g1 i) (g2 i)) -> n1 : Nat -> Hind : (i : N -> __1 : Eq p1 i true -> __1 : (i : Nat -> __1 : Lt i n1 -> __2 : Eq p1 i true -> Leq (g1 i) (g2 i)) -> i : Nat -> __2 : Eq p1 i true -> Eq p2 i true) -> H1 : (i : N -> __1 : Lt i (summan n1 1) -> __1 : Eq p1 i true -> Eq p2 i true) -> H2 : (i : N -> __1 : Lt i (summan n1 1) -> __1 : Eq p1 i true -> Leq (g1 i) (g2 i)) -> x2515 : Nat -> x2516 : Nat -> x2515 <= x2516 -> p2 n1 = true -> p1 n1 = true -> Hind n1 (x2515, x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nFilter_div_mod_spec. Soit $_n , _m , _q , _r \\in N$. Soit $return_sort$ un élément de $Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des éléments de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des éléments de $return_type$ de $z$, pour tous les éléments $z$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $return_type$ tient pour $z$.\nassistant\n", "label": "axiom filter_div_mod_spec (_n _m _q _r : Nat) (return_sort : Sort) (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) (return : (z : div_mod_spec _n _m _q _r) -> return_type z) (z : div_mod_spec _n _m _q _r) : return_type z", "predict": "axiom filter_div_mod_spec (_n _m _q _r : N) (return_sort : Sort) (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) (return : (z : div_mod_spec _n _m _q _r) -> return_type z) (z : div_mod_spec _n _m _q _r) : return_type z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_rect_Type3. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_895$ of $ACop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A , _nil , aop , a , b)$ and $op (A , _nil , aop , b , a)$ to elements of $Q_$ of $mk_ACop (A , _nil , aop , _comm)$, for all elements $x_895$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_895$.\nassistant\n", "label": "Axiom ACop_rect_Type3 : forall A : Set, forall _nil : A, forall Q_ : ((_x_895 : ACop A _nil) -> Type3), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)), forall x_895 : ACop A _nil, Q_ x_895 .", "predict": "Axiom ACop_rect_Type3 : forall A : set, forall _nil : A, forall Q_ : ((_x_895 : ACop A _nil) -> Type3), forall _H_mk_ACop : ((aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)), forall x_895 : ACop A _nil, Q_ x_895 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSquare_S. Let $a \\in N$. Then the exponentiation of the sum of $a$ and $1$ and $2$ is equal to the sum of the sum of the exponentiation of $a$ and $2$ and the product of $2$ and $a$ and $1$.\nassistant\n", "label": "axiom square_S (a : Nat) : pow (a + 1) 2 = pow a 2 + 2 * a + 1", "predict": "axiom square_S (a : N) : N := (a + 1) ^ 2 + (a + 1) * (2 * a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_exp. Låt $n , m , p \\in N$. Då om $0 < p$ och $n \\leq m$, så $p ^ n \\leq p ^ m$.\nassistant\n", "label": "le_exp : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Leq n m -> Leq (pow p n) (pow p m) .", "predict": "le_exp : n : N -> m : N -> p : N -> 0 < p -> n <= m -> p^n <= p^m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_plus. Låt $n , m , p , q \\in N$. Anta att $n < m$. Då om $p < q$, så $n + p < m + q$.\nassistant\n", "label": "lt_plus : n : Nat -> m : Nat -> p : Nat -> q : Nat -> __ : Lt n m -> __1 : Lt p q -> Lt (plus n p) (plus m q) .", "predict": "lt_plus : n : N -> m : N -> p : N -> q : N -> n < m -> p < q -> n + p < m + q ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a$ un nombre naturel. Alors si $a \\leq n$ et $f (a)= i$ et $a \\leq n$, alors si $f (a)= i$, alors pour tous les nombres naturels $b$, si $b \\leq n$ et $f (b)= j$ et $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nassistant\n", "label": "let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .", "predict": "let_clause_1063 : f : Nat -> Nat -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> a : Nat -> a <= n -> f a = i -> a <= n -> f a = i -> b : Nat -> b <= n -> f b = j -> b <= n -> f b = j -> __ : (i0 : Nat -> Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> a = b -> f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1544. Let $p , q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Then if $0$ is less than $n$, then if $n$ is less than or equal to $m$, then if $n$ is less than or equal to the sum of $q$ and $1$, then if $n$ is not divisible by $m$, then for all natural numbers $a$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ or the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $n$ and $b$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to", "label": "axiom let_clause_1544 (p q : Nat) (Hind : (m : Nat) -> (n : Nat) -> (x__ : 0 < n) -> (__1 : n ≤ m) -> (__2 : n ≤ q) -> ex Nat (λ a => ex Nat (λ b => a * n - b * m = gcd_aux q m n ∨ b * m - a * n = gcd_aux q m n))) (m n : Nat) (posn : 0 < n) (lenm : n ≤ m) (lenS : n ≤ q + 1) (ndivnm : ¬ divisible n m) (a : Nat) (_clearme : ex Nat (λ b => a * mod m n - b * n = gcd_aux q n (mod m n) ∨ b * n - a * mod m n = gcd_aux q n (mod m n))) (b : Nat) (_clearme0 : a * mod m n - b * n = gcd_aux q n (mod m n) ∨ b * n - a * mod m n = gcd_aux q n (mod m n)) (H : a * mod m n - b * n = gcd_aux q n (mod m n)) : a * mod m n - n * b = gcd_aux q n (mod m n)", "predict": "axiom let_clause_1544 (p q : N) (Hind : (m : N) -> (n : N) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex : Nat) (m n : N) : (_0 : N) -> (_nleq_m : N) -> (_nleq_q : N) -> (_nleq_sum_q_1 : N) -> (_nnotdiv_m : N) -> (a : N) -> (_clearme : ex b => Eq (diff (prod a n) (prod b m)) (gcd_aux q m n) -> Eq (diff (prod b m) (prod a n)) (gcd_aux q m n)) -> (b : N) -> (_diffeq_gcdqnm : N) -> (_diffeq_gcdqmn : N) -> (_diffeq_gcdqnm2 : N) : Eq (diff (prod a (mod m n)) (prod b n)) (gcd_aux q n (mod m n)) -> Eq (diff (prod b n) (prod a (mod m n))) (gcd_aux q n (mod m n))) : Eq (diff (prod a (mod m n)) (prod n b)) (gcd_aux q n (mod m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNat_inv_rect_CProp1. Soit $Hterm \\in N$. Soit $P$ une fonction des nombres naturels $_z707$ à des propositions. Alors pour toutes les fonctions $_H1$ des éléments $_z708$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$, pour toutes les fonctions $_H2$ des nombres naturels $x_410$ et des fonctions $_x_412$ des éléments $_z708$ de $Eq$ de $Hterm$ et de $x_410$ à des éléments de $P$ de $x_410$ et des éléments $_z708$ de $Eq$ de $Hterm$ et de la somme de $x_410$ et de $1$ à des éléments de $P$ de la somme de $x_410$ et de $1$, $P$ tient pour $Hterm$.\nassistant\n", "label": "nat_inv_rect_CProp1 : Hterm : Nat -> P : (_z707 : Nat -> Prop) -> _H1 : (_z708 : Eq Hterm 0 -> P 0) -> _H2 : (x_410 : Nat -> _x_412 : (_z708 : Eq Hterm x_410 -> P x_410) -> _z708 : Eq Hterm (plus x_410 (nd 1)) -> P (plus x_410 (nd 1))) -> P Hterm .", "predict": "nat_inv_rect_CProp1 : Hterm : N -> P : (_z707 : N -> Prop) -> _H1 : (_z708 : Eq Hterm 0 -> P 0) -> _H2 : (x_410 : N -> _x_412 : (_z708 : Eq Hterm x_410 -> P x_410) -> _z708 : Eq Hterm (x_410 + 1) -> P (x_410 + 1)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_O_bc. Pour tous les nombres naturels $n$ et $m$, si $m \\leq n$, alors $0 < bc (n , m)$.\nassistant\n", "label": "axiom lt_O_bc (n m : Nat) (x__ : m ≤ n) : 0 < bc n m", "predict": "axiom lt_O_bc (n m : Nat) : m <= n -> 0 < bc (n , m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPos_div. Låt $n$ och $m$ vara naturliga tal. Anta att $0 < m$ och $0 < n$. Anta att $mod (n , m)= 0$. Då $0 < n \\div m$.\nassistant\n", "label": "pos_div : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Lt 0 n -> __2 : Eq (mod n m) 0 -> Lt 0 (div n m) .", "predict": "pos_div : n : Nat -> m : Nat -> 0 < m -> 0 < n -> mod (n , m) = 0 -> 0 < n \\div m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMatch_le. Låt $_n \\in N$. Låt $return_sort$ vara ett element av $Sort$. Låt $return_type$ vara en funktion från naturliga tal och element $z$ av $Leq$ av $_n$ och $__$ till element av $return_sort$. Då för alla element $case_le_n$ av $return_type$ av $_n$ och $le_n$ applicerat på $_n$, för alla funktioner $case_le_S$ från naturliga tal $m$ och element av $Leq$ av $_n$ och $m$ till element av $return_type$ av summan av $m$ och $1$ och $le_S$ applicerat på $_n$ och $m$ och $__$, för alla naturliga tal $__$, om $_n$ är mindre än eller lika med $__$, så håller $return_type$ för $__$ och $z$.\nassistant\n", "label": "axiom match_le (_n : Nat) (return_sort : Sort) (return_type : (x__ : Nat) -> (z : _n ≤ __) -> return_sort) (case_le_n : return_type _n (le_n _n)) (case_le_S : (m : Nat) -> (x__ : _n ≤ m) -> return_type (m + 1) (le_S _n m __)) (x__ : Nat) (z : _n ≤ __) : return_type __ z", "predict": "axiom match_le (_n : Sort) (return_sort : Sort) (return_type : (z : Leq _n __) -> return_sort) (case_le_n : return_type _n (le_n _n)) (case_le_S : (m : Nat) -> (z : Leq _n m) -> return_type (sum m 1) (le_S _n m __)) (__ : Nat) : (_n : Nat) -> (_n ≤ __) -> return_type __ (z : Leq _n __)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1033. Låt $p$ och $n$ och $q$ och $r$ vara naturliga tal. Anta att $0 < p$. Anta att $p$ inte är delbart med $r$. Anta att $n = p ^ q r$. Låt $q0 , q1 \\in N$. Då om $q1 + 1 \\leq p ^ (q1 + 1)$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "let_clause_1033 : p : Nat -> n : Nat -> q : Nat -> r : Nat -> posp : Lt 0 p -> ndivpr : not (divisible p r) -> Hn : Eq n (times (pow p q) r) -> q0 : Nat -> q1 : Nat -> Hind : Leq (plus q1 (nd 1)) (pow p (plus q1 (nd 1))) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_1033 : p : Nat -> n : Nat -> q : Nat -> r : Nat -> q0 : Nat -> q1 : Nat -> x2515 : Nat -> x2516 : Nat -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) -> q1 + 1 <= p ^ (q1 + 1) -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_plus_n. Pour tous les nombres naturels $n$ et $m$, $m$ est inférieur ou ágal à la somme de $n$ et de $m$.\nassistant\n", "label": "le_plus_n : n : Nat -> m : Nat -> Leq m (plus n m) .", "predict": "le_plus_n : n : NombreNaturel -> m : NombreNaturel -> m <= n + m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nBc_n_O. Låt $n$ vara ett naturligt tal. Då $bc (n , 0)= 1$.\nassistant\n", "label": "axiom bc_n_O (n : Nat) : bc n 0 = 1", "predict": "axiom bc_n_O (n : Nat) : 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDop_inv_rect_CProp1. Soit $x1$ un ensemble. Soit $x2$ un élément de $x1$. Soit $Hterm$ un élément de $Dop$ de $x1$ et de $x2$. Soit $P$ une fonction des éléments $_z1752$ de $Dop$ de $x1$ et de $x2$ à des propositions. Alors pour toutes les fonctions $_H1$ des éléments $sum$ de $ACop$ de $x1$ et de $x2$ et des fonctions $prod$ des éléments de $x1$ et des éléments $__1$ de $x1$ à des éléments de $x1$ et des fonctions $_null$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $prod (a , x2)$ et de $x2$ et des fonctions $_distr$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ et des éléments $c$ de $x1$ à des éléments de $Eq$ de $prod (a , aop__o__op (x1 , x2 , sum , b , c))$ et de $aop__o__op (x1 , x2 , sum , prod (a , b), prod (a , c))$ et des éléments $_z1753$ de $Eq$ de $Hterm$ et de $mk_Dop (x1 , x2 , sum , prod , _null , _distr)$ à des éléments de $P$ de $mk_Dop (x1 , x2 , sum , prod , _null , _distr)$, $P$ tient pour $Hterm$.\nassistant\n", "label": "Axiom Dop_inv_rect_CProp1 : forall x1 : Set, forall x2 : x1, forall Hterm : Dop x1 x2, forall P : ((_z1752 : Dop x1 x2) -> Prop), forall _H1 : ((sum : ACop x1 x2) -> (prod : (x__ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> prod a x2 = x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> prod a (aop__o__op x1 x2 sum b c) = aop__o__op x1 x2 sum (prod a b) (prod a c)) -> (_z1753 : Hterm = mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)), P Hterm .", "predict": "Axiom Dop_inv_rect_CProp1 : forall x1 : Ensemble, forall x2 : Element x1, forall Hterm : Dop x1 x2, forall P : ((_z1752 : Dop x1 x2) -> Prop), forall _H1 : ((sum : AOp x1 x2) -> (prod : (x1 -> __1 : x1 -> x1) -> (_null : (a : x1) -> Eq (prod (a , x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod (a , aop__o__op (x1 , x2 , sum , b , c)) (aop__o__op (x1 , x2 , sum , prod (a , b), prod (a , c)))) -> (_z1753 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr))), P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat_rect_Type2_body. Let $Q_$ be a function from natural numbers $_x_381$ to elements of $Type2$. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_382$ and elements $_x_384$ of $Q_$ of $x_382$ to elements of $Q_$ of $x_382 + 1$. Let $x_381$ be a natural number. Then $Q_$ holds for $x_381$.\nassistant\n", "label": "postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (plus x_382 1)) -> (x_381 : Nat) -> Q_ x_381", "predict": "postulate nat_rect_Type2_body : (Q_ : (_x_381 : Nat) -> Type2) -> (_H_O : Q_ 0) -> (_H_S : (x_382 : Nat) -> (_x_384 : Q_ x_382) -> Q_ (x_382 + 1)) -> (x_381 : Nat) -> Q_ x_381"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLt_to_le_to_lt. Soit $n , m , p \\in N$. Supposons que $n < m$. Supposons que $m \\leq p$. Alors $n < p$.\nassistant\n", "label": "lt_to_le_to_lt : n : Nat -> m : Nat -> p : Nat -> __ : Lt n m -> __1 : Leq m p -> Lt n p .", "predict": "lt_to_le_to_lt : n : N -> m : N -> p : N -> n < m -> m <= p -> n < p ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_exists. For all functions $f$ from natural numbers to booleans, for all natural numbers $t$ and $m$, if $m < t$, then if $f (m)= true$, then for all natural numbers $k$ and $b$, if $b \\leq m$, then for all functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $f (i)$ and absurdity, if $t = k + b$, then $min (k , b , f)= m$.\nassistant\n", "label": "Axiom min_exists : forall f : ((x__ : nat) -> bool), forall t : nat, forall m : nat, forall x__ : (m < t), forall __1 : (f m = true), forall k : nat, forall b : nat, forall __2 : Leq b m, forall __3 : ((i : nat) -> (__3 : Leq b i) -> (__4 : i < m) -> f i = false), forall __4 : (t = k + b), min k b f = m .", "predict": "Axiom min_exists : forall f : nat -> bool, forall t : nat, forall m : nat, if m < t then if f m = true then forall k : nat, forall b : nat, if b <= m then forall __3 : ((i : nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) absurdity), if t = k + b then min (k , b , f) = m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nEqb_true_to_eq. Soit $n , m \\in N$. Alors si $eqb$ appliqué à $n$ et $m$ est égal à $true$, alors $n$ est égal à $m$.\nassistant\n", "label": "axiom eqb_true_to_eq (n m : Nat) (x__ : eqb n m = true) : n = m", "predict": "axiom eqb_true_to_eq (n m : N) : eqb n m = true -> n = m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_rect_CProp4_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara naturliga tal. Låt $Q_$ vara en funktion från element $_x_837$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden. Låt $_H_div_mod_spec_intro$ vara en funktion från element $x_839$ av $Lt$ av $_r$ och $_m$ och element $x_838$ av $Eq$ av $_n$ och $_q _m + _r$ till element av $Q_$ av $div_mod_spec_intro (_n , _m , _q , _r , x_839 , x_838)$. Då för alla element $x_837$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_837$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp4_body (_n _m _q _r : Nat) (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_839 : _r < _m) -> (x_838 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) (x_837 : div_mod_spec _n _m _q _r) : Q_ x_837", "predict": "axiom div_mod_spec_rect_CProp4_body (_n _m _q _r : Nat) (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_839 : Lt _r _m) -> (x_838 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) (x_837 : div_mod_spec _n _m _q _r) : Q_ x_837"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1569. Soit $m , n , a , b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$, alors si $c n - d m = 1$, alors $n c - m d = 1$.\nassistant\n", "label": "axiom let_clause_1569 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : n * c - m * d = 1", "predict": "axiom let_clause_1569 (m n a b : N) (_clearme : Nat (λ d => Eq (c n - d m) 1)) (d : N) : Eq (n c - m d) 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_15692. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nassistant\n", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : (d : Nat) -> Eq (div (c n) (d m)) 1) -> (d : Nat) -> (_eq1 : (c n - d m) == 1) -> (_eq2 : (d m - c n) == 1) -> (_eq3 : (d m - c n) == 1) -> (m d - n c) == 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNot_divides_to_ord_O. Låt $p , m \\in N$. Anta att $p$ är primt. Anta att $p$ inte är delbart med $m$. Då $ord (m , p)= 0$.\nassistant\n", "label": "not_divides_to_ord_O : p : Nat -> m : Nat -> __ : prime p -> __1 : not (divisible p m) -> Eq (ord m p) 0 .", "predict": "not_divides_to_ord_O : p : N -> m : N -> p : primt -> p : inte delbart med m -> ord (m , p) = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPrimes_below_to_bertrand. Låt $pm \\in N$. Låt $l$ vara en lista av naturliga tal. Anta att $pm$ är primt. Då för alla element $__1$ av $primes_below$ av $l$ och summan av $pm$ och $1$, för alla funktioner $__2$ från naturliga tal $p$ och element $__2$ av $mem$ av $Nat$ och $p$ och $l$ och element $__3$ av $Lt$ av $2$ och $p$ till element av $ex$ av $Nat$ och funktionen som avbildar $pp$ som konjunktionen av konjunktionen av $mem$ applicerat på $Nat$ och $pp$ och $l$ och $Lt$ applicerat på $pp$ och $p$ och $Leq$ applicerat på $p$ och produkten av $2$ och $pp$, för alla naturliga tal $n$, om $0$ är mindre än $n$, så om $n$ är mindre än $pm$, så håller $bertrand$ för $n$.\nassistant\n", "label": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n", "predict": "postulate primes_below_to_bertrand : (pm : N) -> (l : List Nat) -> (__1 : primes_below l) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (2 * pp)))) -> (n : Nat) -> (0 : Nat) -> (n : Nat) -> pm -> (n : Nat) -> bertrand n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFound_max_spec. Soit $n$ un nombre naturel. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $m$ un nombre naturel. Alors si $m < n$, alors si $f (m)= true$, alors pour toutes les fonctions $__2$ des nombres naturels $i$ et des éléments $__2$ de $Lt$ de $m$ et de $i$ et des éléments $__3$ de $Lt$ de $i$ et de $n$ à des éléments de $Eq$ de $f (i)$ et de contradiction, $max_spec$ tient pour $n$ et $f$ et $m$.\nassistant\n", "label": "Axiom found_max_spec : forall n : nat, forall f : ((x__ : nat) -> bool), forall m : nat, forall x__ : (m < n), forall __1 : (f m = true), forall __2 : ((i : nat) -> (__2 : m < i) -> (__3 : i < n) -> f i = false), max_spec n f m .", "predict": "Axiom found_max_spec : forall n : nat, forall f : ((i : nat) -> __2 : (i : nat) -> __3 : nat -> Eq (f i) contradiction) -> nat), forall m : nat, m < n -> f m = true -> forall __2 : ((i : nat) -> __2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) contradiction), max_spec n f m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1033. Låt $p , n , q , r \\in N$. Anta att $0 < p$. Då om $p$ inte är delbart med $r$, så om $n = p ^ q r$, så för alla naturliga tal $q0$ och $q1$, om $q1 + 1 \\leq p ^ (q1 + 1)$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "axiom let_clause_1033 (p n q r : Nat) (posp : 0 < p) (ndivpr : ¬ divisible p r) (Hn : n = pow p q * r) (q0 q1 : Nat) (Hind : q1 + 1 ≤ pow p (q1 + 1)) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_1033 (p n q r : N) (q0 q1 : Nat) (x2515 x2516 : Nat) : Prop := and (not (divisible p r)) (n = p ^ q r) (q1 + 1 <= p ^ (q1 + 1)) (x2515 = x2516 (x2515 \\ div x2516) + mod (x2515 , x2516))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTo_max. Soient $i$ et $n$ et $m$ des nombres naturels. Supposons que $n \\leq i$. Alors si $m \\leq i$, alors $max (n , m)\\leq i$.\nassistant\n", "label": "axiom to_max (i n m : Nat) (x__ : n ≤ i) (__1 : m ≤ i) : max n m ≤ i", "predict": "axiom to_max (i n m : Nat) : nle n i -> mle i m -> le (max n m) i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLog_div. Soit $p , n , m \\in N$. Supposons que $1$ est inférieur à $p$. Supposons que $0$ est inférieur à $m$. Alors si $m$ est inférieur ou ágal à $n$, alors le logarithme de $p$ et du quotient de $n$ et de $m$ est inférieur ou ágal à la différence du logarithme de $p$ et de $n$ et du logarithme de $p$ et de $m$.\nassistant\n", "label": "axiom log_div (p n m : Nat) (x__ : 1 < p) (__1 : 0 < m) (__2 : m ≤ n) : log p (n / m) ≤ log p n - log p m", "predict": "axiom log_div (p n m : N) : (1 < p) -> (0 < m) -> (m <= n) -> (log p (n / m) <= (log p n) - (log p m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_inv_rect_Type4. Let $x1$ be a set. Let $x2$ be an element of $x1$. Let $Hterm$ be an element of $ACop$ of $x1$ and $x2$. Let $P$ be a function from elements $_z1572$ of $ACop$ of $x1$ and $x2$ to elements of $Type4$. Then for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1573$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $P$ holds for $Hterm$.\nassistant\n", "label": "ACop_inv_rect_Type4 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1572 : ACop x1 x2 -> Type4) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1573 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .", "predict": "ACop_inv_rect_Type4 : x1 : Set -> x2 : Element(x1) -> Hterm : Element(ACop(x1, x2) -> Type4) -> P : (_z1572 : ACop(x1, x2) -> Type4) -> _H1 : (aop : Aop(x1, x2) -> _comm : (a : x1 -> b : x1 -> Eq(op(x1, x2, aop) a b) -> op(x1, x2, aop) b a) -> _z1573 : Eq(Hterm, mk_ACop(x1, x2, aop, _comm) -> P(mk_ACop(x1, x2, aop, _comm))) -> P(Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_ind_l_aux. Let $B$ be a set. Let $R$ be a function from elements of $B$ and elements $__1$ of $B$ to propositions. Let $b2$ be an element of $B$. Let $P$ be an element of $relation2$ of $Nat$ and $B$. Let $__$ be an element of $P$ of $0$ and $b2$. Let $__1$ be a function from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $__1$ of $R$ of $b1$ and $b$ and elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of $l + 1$ and $b1$. Let $l \\in N$. Then for all elements $b1$ and $b$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b$, if $b = b2$, then $P$ holds for $l$ and $b1$.\nassistant\n", "label": "postulate lstar_ind_l_aux : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (__3 : Eq b b2) -> P l b1", "predict": "postulate lstar_ind_l_aux : (B : Set) -> (R : (__1 : B) -> Prop) -> (b2 : B) -> (P : (Nat -> B) -> (__ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1)) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (P l b1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a$ est égal à $b$, alors $f$ appliqué à $a$ est égal à $j$.\nassistant\n", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (n : Set) -> Set) -> (n : Set) -> (permf : permut f n) -> (i : Set) -> (j : Set) -> (a : Set) -> (b : Set) -> (__ : (i0 : Set) -> (Leq i0 n) -> Set) -> (injf : injn f n) -> (a : b) -> (f a) == j) -> (__ : (i0 : Set) -> (Leq i0 n) -> Set) -> (inj : injn f n) -> (a : b) -> (f a) == j) -> (__ : (i0 : Set) -> (Leq i0 n) -> Set) -> (inj : injn f n) -> (a : b) -> (f a) == j) -> (__ : (i0 : Set) -> (Leq i0 n) -> Set) -> (inj : injn f n) -> (a : b) -> (f a) == j) -> (__ : (i0 : Set) -> (Leq i0 n) -> Set) -> (inj : injn f n) -> (a : b) -> (f a) == j)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$ och $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$ och $b \\leq n$. Anta att $f (b)= j$. Då för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (x : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (b : Nat) -> (__ : (i0 : Nat) -> (Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a == b) -> f a == i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_upper_bound3. För alla naturliga tal $n$ och $m$ och $x$, $Nat$.\nassistant\n", "label": "let_upper_bound3 : n : Nat -> m : Nat -> x : Nat -> Nat .", "predict": "let_upper_bound3 : n : Nat -> m : Nat -> x : Nat -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_10131. Let $f$ be a function from natural numbers to booleans. Let $n , m , n0 \\in N$. Assume that $max$ applied to the sum of $n0$ and $1$ and $f$ is equal to $m$. Assume that $f$ applied to $m$ is equal to absurdity. Let $i$ and $j$ be natural numbers. Then if the sum of $j$ and $1$ is less than the sum of $n0$ and $1$, then for all natural numbers $x7$, $x7$ is equal to the sum of $m$ and $x7$.\nassistant\n", "label": "postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)", "predict": "postulate let_clause_10131 : (f : (n : N) -> Bool) -> (n : N) -> (m : N) -> (n0 : N) -> (i : N) -> (j : N) -> (x7 : N) -> (max : (a : N) -> (b : N) -> N) -> (let_clause_10131 : (f : (n : N) -> Bool) -> (n : N) -> (m : N) -> (n0 : N) -> (i : N) -> (j : N) -> (x7 : N) -> (max : (a : N) -> (b : N) -> N) -> (postulate let_clause_10131 : (f : (n : N) -> Bool) -> (n : N) -> (m : N) -> (n0 : N) -> (i : N) -> (j : N) -> (x7 : N) -> (max : (a : N) -> (b : N) -> N) -> (postulate let_clause_10131 : (f : (n : N) -> Bool) -> (n : N) -> (m : N) -> (n0 : N) -> (i : N) -> (j : N) -> (x7 : N) -> (max : (a : N) -> (b : N) -> N) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1600. Soit $m , n , a , b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Supposons que $c n - d m = 1$. Alors $n c - m d$ est égal au diviseur commun plus grand de $m$ et de $n$.\nassistant\n", "label": "axiom let_clause_1600 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : gcd m n = n * c - m * d", "predict": "axiom let_clause_1600 (m n a b : Nat) (_clearme : Nat (λ d => Eq (c n - d m) 1)) (d : Nat) : Nat (n c - m d) = 1) : Nat (gcd m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nAop_rect_CProp5_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_877$ av $Aop$ av $A$ och $_nil$ till påståenden. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil , a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a , _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a , op (b , c))$ och $op (op (a , b), c)$ till element av $Q_$ av $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$. Låt $x_877$ vara ett element av $Aop$ av $A$ och $_nil$. Då håller $Q_$ för $x_877$.\nassistant\n", "label": "Axiom Aop_rect_CProp5_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_877 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_877 : Aop A _nil, Q_ x_877 .", "predict": "Axiom Aop_rect_CProp5_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_877 : A) -> Prop), forall _H_mk_Aop : ((op : (a : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op (_nil , a) a)) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_877 : Aop A _nil, Q_ x_877 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nMinus_minus_associative. Låt $x , y , z \\in N$. Då om $z \\leq y$, så om $y \\leq x$, så $x - (y - z)= (x - y)+ z$.\nassistant\n", "label": "Axiom minus_minus_associative : forall x : nat, forall y : nat, forall z : nat, forall x__ : Leq z y, forall __1 : Leq y x, x - (y - z) = x - y + z .", "predict": "Axiom minus_minus_associative : forall x : N, forall y : N, forall z : N, z <= y -> y <= x -> x - (y - z) = (x - y) + z ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_times. Låt $n1$ och $n2$ och $m1$ och $m2$ vara naturliga tal. Anta att $n1$ är mindre än eller lika med $n2$. Då om $m1$ är mindre än eller lika med $m2$, så är produkten av $n1$ och $m1$ mindre än eller lika med produkten av $n2$ och $m2$.\nassistant\n", "label": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)", "predict": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> n1 <= n2 -> m1 <= m2 -> n1 * m1 <= n2 * m2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop__o__op. For all sets $x0$, for all elements $x1$ of $x0$, for all elements $x2$ of $ACop$ of $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $x0$, $x0$.\nassistant\n", "label": "Axiom aop__o__op : forall x0 : Set, forall x1 : x0, forall x2 : ACop x0 x1, forall _x_887 : x0, forall _x_888 : x0, x0 .", "predict": "Axiom aop__o__op : forall x0 : Set, forall x1 : x0, forall x2 : ACop x0 x1, forall _x_887 : x0, forall _x_888 : x0, _x_887 <> _x_888 -> _x_887 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_inv_rect_Type3. Let $x1$ be a set. Let $x2$ be an element of $x1$. Let $Hterm$ be an element of $ACop$ of $x1$ and $x2$. Let $P$ be a function from elements $_z1578$ of $ACop$ of $x1$ and $x2$ to elements of $Type3$. Let $_H1$ be a function from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1579$ of $Eq$ of $Hterm$ and $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $P$ of $mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$. Then $P$ holds for $Hterm$.\nassistant\n", "label": "axiom ACop_inv_rect_Type3 (x1 : Set) (x2 : x1) (Hterm : ACop x1 x2) (P : (_z1578 : ACop x1 x2) -> Type3) (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> op x1 x2 aop a b = op x1 x2 aop b a) -> (_z1579 : Hterm = mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) : P Hterm", "predict": "axiom ACop_inv_rect_Type3 (x1 : Set) (x2 : Element x1) (Hterm : Element ACop x1 x2) (P : (_z1578 : ACop x1 x2) -> Type3) (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a))) -> (_z1579 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) : P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15621. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Då om $0 < n$ och $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så $n c - m d = 1$.\nassistant\n", "label": "axiom let_clause_15621 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : c * n - d * m = 1) : n * c - m * d = 1", "predict": "axiom let_clause_15621 (m n a b : Nat) (c : Nat) (_clearme : ex Nat (λ d => Eq (skillnaden (produkten av c n) (produkten av d m)) 1)) (d : Nat) : Nat (n c - m d)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$ and $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : ((x : N) -> N), forall n : N, forall permf : permut f n, forall i : N, forall j : N, forall a : N, forall b : N, forall __ : ((i0 : N) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Hc : a = b, f a = i -> forall b : N, f b = j -> forall Hb : b = a -> forall __ : ((i0 : N) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, a = b -> f a = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nGcd_1_to_lt_n. Soient $i$ et $n$ des nombres naturels. Supposons que $1 < n$ et $i \\leq n$. Supposons que $1$ est égal au diviseur commun plus grand de $i$ et de $n$. Alors $i < n$.\nassistant\n", "label": "gcd_1_to_lt_n : i : Nat -> n : Nat -> __ : Lt (nd 1) n -> __1 : Leq i n -> __2 : Eq (gcd i n) (nd 1) -> Lt i n .", "predict": "gcd_1_to_lt_n : i : Nat -> n : Nat -> 1 < n -> i <= n -> 1 = gcd i n -> i < n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15625. Låt $m , n , a , b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$, så $m d - n c = 1$.\nassistant\n", "label": "axiom let_clause_15625 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : m * d - n * c = 1", "predict": "axiom let_clause_15625 (m n a b : Nat) (_clearme : ex Nat (λ d => Eq (n - m * d) 1)) (c : Nat) (d : Nat) : Bool => and (c n - d m = 1) (d m - c n = 1) (d m - c n = 1) => m d - n c = 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_inv_S_dx. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l \\in N$. Let $b1$ and $b2$ be elements of $B$. Let $__$ be an element of $lstar$ of $B$ and $R$ and $l + 1$ and $b1$ and $b2$. Then $ex2$ holds for $B$ and the function that maps $b$ to $lstar (B , R , l , b1 , b)$ and the function that maps $b$ to $R (b , b2)$.\nassistant\n", "label": "Axiom lstar_inv_S_dx : forall B : Set, forall R : relation B, forall l : nat, forall b1 : B, forall b2 : B, forall x__ : lstar B R (l + 1) b1 b2, ex2 B (fun b => lstar B R l b1 b) (fun b => R b b2) .", "predict": "Axiom lstar_inv_S_dx : forall B : set, forall R : relation B, forall l : N, forall b1 : B, forall b2 : B, forall __ : lstar B R (l + 1) b1 b2, forall ex2 : ((b : B) -> lstar (B , R , l , b1 , b)) -> (b : B) -> R (b , b2), lstar (B , R , l , b1 , b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_to_p_ord. Soient $p$ et $a$ et $b$ et $c$ et $d$ et $n$ et $m$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $p$ est premier. Supposons que $n$ est divisible par $m$. Supposons que $p_ord (n , p)= mk_Prod (Nat , Nat , a , b)$. Alors si $p_ord (m , p)= mk_Prod (Nat , Nat , c , d)$, alors $b$ est divisible par $d$ et $a \\leq c$.\nassistant\n", "label": "Axiom divides_to_p_ord : forall p : nat, forall a : nat, forall b : nat, forall c : nat, forall d : nat, forall n : nat, forall m : nat, forall x__ : (0 < n), forall __1 : (0 < m), forall __2 : prime p, forall __3 : divisible n m, forall __4 : (p_ord n p = mk_Prod nat nat a b), forall __5 : (p_ord m p = mk_Prod nat nat c d), divisible b d /\\ Leq a c .", "predict": "Axiom divides_to_p_ord : forall p : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall d : Nat, forall n : Nat, forall m : Nat, 0 < n -> 0 < m -> p prime -> n divisible_by m -> p_ord (n , p) = mk_Prod (Nat , Nat , a , b) -> p_ord (m , p) = mk_Prod (Nat , Nat , c , d) -> b divisible_by d -> a <= c ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDivides_gcd_aux. Soit $p , m , n , d \\in N$. Supposons que $0 < n$. Supposons que $n \\leq m$. Alors si $n \\leq p$, alors si $d$ est divisible par $m$, alors si $d$ est divisible par $n$, alors $d$ est divisible par $gcd_aux (p , m , n)$.\nassistant\n", "label": "postulate divides_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> (__3 : divisible d m) -> (__4 : divisible d n) -> divisible d (gcd_aux p m n)", "predict": "postulate divides_gcd_aux : (p : N) -> (m : N) -> (n : N) -> (d : N) -> (0 : N) -> n <= m -> n <= p -> d `div` m -> d `div` n -> d `div` (gcd_aux (p , m , n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNot_lt_to_le. För alla naturliga tal $n$ och $m$, om $n$ inte är mindre än $m$, så är $m$ mindre än eller lika med $n$.\nassistant\n", "label": "not_lt_to_le : n : Nat -> m : Nat -> __ : not (Lt n m) -> Leq m n .", "predict": "not_lt_to_le : n : Nat -> m : Nat -> n >= m -> m <= n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_O_exp. Låt $n , m \\in N$. Anta att $0$ är mindre än $n$. Då är $0$ mindre än potensen av $n$ och $m$.\nassistant\n", "label": "lt_O_exp : n : Nat -> m : Nat -> __ : Lt 0 n -> Lt 0 (pow n m) .", "predict": "lt_O_exp : n : N -> m : N -> 0 < n -> 0 < n^m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nP_ord_degenerate. Låt $p , n \\in N$. Då är $p_ord_aux$ applicerat på $p$ och $n$ och $1$ lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $p$ och $n$.\nassistant\n", "label": "p_ord_degenerate : p : Nat -> n : Nat -> Eq (p_ord_aux p n (nd 1)) (mk_Prod Nat Nat p n) .", "predict": "p_ord_degenerate : p : N -> n : N -> p_ord_aux p n 1 = mk_Prod Nat Nat p n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1033. Let $n$ be a natural number. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Then for all functions $H2$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$, if $p2 (n1)= true$, then if $p1 (n1)= true$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "axiom let_clause_1033 (n : Nat) (p1 p2 : (x__ : Nat) -> bool) (g1 g2 : (x__ : Nat) -> Nat) (n1 : Nat) (Hind : (x__ : (i : Nat) -> (x__ : i < n1) -> (__1 : p1 i = true) -> p2 i = true) -> (__1 : (i : Nat) -> (__1 : i < n1) -> (__2 : p1 i = true) -> g1 i ≤ g2 i) -> bigop n1 (λ i => p1 i) Nat 0 plus (λ i => g1 i) ≤ bigop n1 (λ i => p2 i) Nat 0 plus (λ i => g2 i)) (H1 : (i : Nat) -> (x__ : i < n1 + 1) -> (__1 : p1 i = true) -> p2 i = true) (H2 : (i : Nat) -> (x__ : i < n1 + 1) -> (__1 : p1 i = true) -> g1 i ≤ g2 i) (Hp2 : p2 n1 = true) (Hp1 : p1 n1 = true) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_1033 (n : Nat) (p1 p2 : (i : Nat) -> Bool) (g1 g2 : (i : Nat) -> Nat) (n1 : Nat) (Hind : (i : Nat) -> (__1 : Eq p1 i true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i true) -> Leq (g1 i) (g2 i)) -> Eq p2 i true) : (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (λ i => p1 i) Nat 0 plus (λ i => g1 i)) (bigop n1 (λ i => p2 i) Nat 0 plus (λ i => g2 i))) (H1 : (i : Nat) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq p1 i true) -> Eq p2 i true) : (x2515 x2516 : Nat) -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516)) (H2 : (i : Nat) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq p1 i true) -> Leq (g1 i) (g2 i)) -> p2 n1 = true -> p1 n1 = true -> x2515 x2516 : Nat) -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516)) : x2515 x2516 : Nat) -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nRange_rect_CProp0. Soit $_A$ un ensemble. Soit $Q_$ une fonction des éléments $_x_939$ de $range$ de $_A$ à des propositions. Alors pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_939$ de $range$ de $_A$, $Q_$ tient pour $x_939$.\nassistant\n", "label": "postulate range_rect_CProp0 : (_A : Set) -> (Q_ : (_x_939 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_939 : range _A) -> Q_ x_939", "predict": "postulate range_rect_CProp0 : (_A : Set) -> (Q_ : (_x_939 : range _A) -> Set) -> (_H_mk_range : (_enum : (x : _A) -> n : Set) -> (_upto : Set) -> (_filter : (n : Set) -> Set) -> mk_range _A _enum _upto _filter) -> (x_939 : range _A) -> Q_ x_939"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_exp_prim4l. For all natural numbers $n$, if $0 < n$, then $2 ^ (4 n + 1)\\leq 4 n ^ (prim (4 n)+ 1)$.\nassistant\n", "label": "Axiom le_exp_prim4l : forall n : nat, forall x__ : (0 < n), Leq (pow 2 (4 * n + 1)) (pow (4 * n) (prim (4 * n) + 1)) .", "predict": "Axiom le_exp_prim4l : forall n : nat, 0 < n -> 2 ^ (4 n + 1) <= 4 n ^ (prim (4 n)+ 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMatch_max_spec. Let $_n$ be a natural number. Let $_f$ be a function from natural numbers to booleans. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $max_spec$ of $_n$ and $_f$ and $__$ to elements of $return_sort$. Let $case_found_max_spec$ be a function from natural numbers $m$ and elements of $Lt$ of $m$ and $_n$ and elements $__1$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $__2$ from natural numbers $i$ and elements $__2$ of $Lt$ of $m$ and $i$ and elements $__3$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $return_type$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $__$ and $__1$ and $__2$. Let $case_not_found_max_spec$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $return_type$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $__$. Let $__$ be a natural number. Let $z$ be an element of $max_spec$ of $_n$ and $_f$ and $__$. Then $return_type$ holds for $__$ and $z$.\nassistant\n", "label": "Axiom match_max_spec : forall _n : nat, forall _f : ((x__ : nat) -> bool), forall return_sort : Sort, forall return_type : ((x__ : nat) -> (z : max_spec _n _f x__) -> return_sort), forall case_found_max_spec : ((m : nat) -> (x__ : m < _n) -> (__1 : _f m = true) -> (__2 : (i : nat) -> (__2 : m < i) -> (__3 : i < _n) -> _f i = false) -> return_type m (found_max_spec _n _f m x__ __1 __2)), forall case_not_found_max_spec : ((x__ : (i : nat) -> (x__ : i < _n) -> _f i = false) -> return_type 0 (not_found_max_spec _n _f x__)), forall x__ : nat, forall z : max_spec _n _f x__, return_type x__ z .", "predict": "Axiom match_max_spec : forall _n : nat, forall _f : ((z : nat) -> bool), forall return_sort : Sort, forall return_type : ((m : nat) -> (z : max_spec _n _f) -> (__ : Eq _f m true) -> (__2 : (i : nat) -> (__2 : Lt i m) -> (__3 : Lt i _n) -> Eq _f i absurdity) -> return_sort), forall case_found_max_spec : ((m : nat) -> (Lt : m -> _n) -> (__1 : Eq _f m true) -> (__2 : (i : nat) -> (__2 : Lt i m) -> (__3 : Lt i _n) -> Eq _f i absurdity) -> return_type m (found_max_spec _n _f m __)), forall case_not_found_max_spec : ((__ : (i : nat) -> Lt i _n) -> Eq _f i absurdity) -> return_type 0 (not_found_max_spec _n _f __)), forall __ : nat, forall z : max_spec _n _f __, return_type __ z ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Supposons que $f (b)= j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Alors si $a = b$, alors $f (a)= j$.\nassistant\n", "label": "Axiom let_clause_1063 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = j .", "predict": "Axiom let_clause_1063 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : nat, forall b : nat, forall __ : (i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall a : nat, forall b : nat, if a = b then f a = j ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_16005. Pour tous les nombres naturels $m$ et $n$ et $a$ et $b$, si $0$ est inférieur à $n$, alors si $0$ est inférieur à $m$, alors si le diviseur commun plus grand de $n$ et de $m$ est égal à $1$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nassistant\n", "label": "Axiom let_clause_16005 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c .", "predict": "Axiom let_clause_16005 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ex Nat (fun d => Eq (diff (prod c n) (prod d m)) 1), forall d : Nat, ((diff (prod c n) (prod d m)) = 1) \\/ (diff (prod d m) (prod c n)) = 1) -> (diff (prod d m) (prod c n)) = 1 -> Nat (prod m n) = (prod m (diff d m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nTranspose_transpose. Låt $i , j , n \\in N$. Då $transpose (i , j , transpose (i , j , n))= n$.\nassistant\n", "label": "Axiom transpose_transpose : forall i : nat, forall j : nat, forall n : nat, transpose i j (transpose i j n) = n .", "predict": "Axiom transpose_transpose : forall i : N, forall j : N, forall n : N, n = transpose (i , j , transpose (i , j , n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDivides_smallest_factor_n. Soit $n \\in N$. Alors si $0$ est inférieur à $n$, alors $smallest_factor$ appliqué à $n$ est divisible par $n$.\nassistant\n", "label": "postulate divides_smallest_factor_n : (n : Nat) -> (_ : Lt 0 n) -> divisible (smallest_factor n) n", "predict": "postulate divides_smallest_factor_n : (n : N) -> (if 0 < n then smallest_factor n is divisible by n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nTech_log. Låt $p$ och $n$ vara naturliga tal. Då om $1 < p$ och $0 < n$, så är $max$ applicerat på summan av $n$ och $1$ och funktionen som avbildar $x$ som $leb$ applicerat på potensen av $p$ och $x$ och $n$ lika med $\\log_ p {n}$.\nassistant\n", "label": "Axiom tech_log : forall p : nat, forall n : nat, forall x__ : (1 < p), forall __1 : (0 < n), log p n = max (n + 1) (fun x => leb (pow p x) n) .", "predict": "Axiom tech_log : forall p : nat, forall n : nat, 1 < p -> 0 < n -> max (n + 1) (fun x => leb (p^x) n) = log_p n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1561. Let $p , m , n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$. Then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the difference of the product of $p$ and $a$ and the product of $m$ and $b$ is equal to $1$.\nassistant\n", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (difference (product a p) (product b m)) (gcd p m) . Eq (difference (product b m) (product a p)) (gcd p m))) -> (b : Nat) -> (_difference : Eq (difference (product a p) (product b m)) (gcd p m) . Eq (difference (product b m) (product a p)) (gcd p m)) -> (_gcd : Eq (difference (product a p) (product b m)) (gcd p m)) -> (_condition : Eq (difference (product a p) (product b m)) 1) -> (_result : Eq (difference (product p a) (product m b)) 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNill. Let $A$ be a set. Let $nil$ be an element of $A$. Let $xxx$ be an element of $Aop$ of $A$ and $nil$. Let $a$ be an element of $A$. Then $op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ is equal to $a$.\nassistant\n", "label": "nill : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> Eq (op A nil xxx nil a) a .", "predict": "nill : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> op A nil xxx nil a = a ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_Type3. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_895$ of $ACop$ of $A$ and $_nil$ to elements of $Type3$. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_895$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_895$.\nassistant\n", "label": "axiom ACop_rect_Type3 (A : Set) (_nil : A) (Q_ : (_x_895 : ACop A _nil) -> Type3) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> op A _nil aop a b = op A _nil aop b a) -> Q_ (mk_ACop A _nil aop _comm)) (x_895 : ACop A _nil) : Q_ x_895", "predict": "axiom ACop_rect_Type3 (A : Set) (_nil : A) (Q_ : (_x_895 : ACop A _nil) -> Type3) (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a))) -> Q_ (mk_ACop A _nil aop _comm)) (x_895 : ACop A _nil) : Q_ x_895"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLt_to_not_le. Låt $n , m \\in N$. Anta att $n$ är mindre än $m$. Då är $m$ inte mindre än eller lika med $n$.\nassistant\n", "label": "Axiom lt_to_not_le : forall n : nat, forall m : nat, forall x__ : (n < m), ~ Leq m n .", "predict": "Axiom lt_to_not_le : forall n : N, forall m : N, n < m -> m <> n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTimes_pi. Låt $n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $f$ och $g$ vara funktioner från naturliga tal till naturliga tal. Då är produkten av $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g$ applicerat på $i$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som produkten av $f$ applicerat på $i$ och $g$ applicerat på $i$.\nassistant\n", "label": "times_pi : n : Nat -> p : (__ : Nat -> bool) -> f : (__ : Nat -> Nat) -> g : (__ : Nat -> Nat) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => times (f i) (g i))) (times (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => f i)) (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => g i))) .", "predict": "times_pi : n : N -> p : (nat -> sanningsvärden) -> f : (nat -> nat) -> g : (nat -> nat) -> bigop n (i : nat => p i) Nat 1 times (i : nat => f i) bigop n (i : nat => p i) Nat 1 times (i : nat => g i) -> bigop n (i : nat => p i) Nat 1 times (i : nat => f i * g i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNull_body. Soit $A$ un ensemble. Soit $nil$ un élément de $A$. Soit $xxx$ un élément de $Dop$ de $A$ et de $nil$. Soit $a$ un élément de $A$. Alors $prod (A , nil , xxx , a , nil)= nil$.\nassistant\n", "label": "axiom null_body (A : Set) (nil : A) (xxx : Dop A nil) (a : A) : prod A nil xxx a nil = nil", "predict": "axiom null_body (A : Set) (nil : A) (xxx : Dop A nil) (a : A) : Set nil) : Set nil) : Set nil)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_15601. Let $n$ and $m$ be natural numbers. Assume that $0 < m$ and $0 = n$. Assume that $0$ is divisible by $m$. Let $q \\in N$. Then if $m = 0 q$, then $n = 0$.\nassistant\n", "label": "axiom let_clause_15601 (n m : Nat) (posn : 0 < m) (eqn0 : 0 = n) (_clearme : divisible 0 m) (q : Nat) (eqm : m = 0 * q) : n = 0", "predict": "axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m => assume q : Nat => axiom let_clause_15601 (n m : Nat) (q : Nat) : Prop => assume 0 < m => assume 0 = n => assume 0 : m =>"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_10471. Låt $n1 , n2 \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara ett element av $ACop$ av $B$ och $nil$. Låt $f1$ och $f2$ vara funktioner från naturliga tal till element av $B$. Låt $_clearme$ vara ett element av $iso$ av $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$. Låt $h$ vara en funktion från naturliga tal till naturliga tal. Då för alla element $_clearme0$ av $ex$ av $prod$ applicerat på $Set$ och $Set$ och $Nat$ och funktionen som avbildar $__$ som $Nat$ och funktionen som avbildar $k$ som konjunktionen av konjunktionen av $prod$ applicerat på $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applicerat på $Prop$ och $Prop$ och $Eq$ applicerat på $p1$ applicerat på $i$ och $true$ och funktionen som avbildar $__1$ som $Eq$ applicerat på $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $sub_hk$ applicerat på $h$ och $k$ och $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $sub_hk$ applicerat på $k$ och $h$ och $B$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$, för alla funktioner $k$ från naturliga tal till naturliga tal, om $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1", "predict": "postulate let_clause_10471 : (n1 : N) -> (n2 : N) -> (p1 : (i : N) -> Set) -> (p2 : (i : N) -> Set) -> (B : Set) -> (nil : B) -> (op : AOp B nil) -> (f1 : (i : N) -> B) -> (f2 : (i : N) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (i : N) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ __ : N -> Nat)) (\\ k : Nat -> Nat) (\\ i : N -> Nat) -> (\\ n1 : Set -> Set) -> (\\ n2 : Set -> Set) -> (\\ p1 : (i : N) -> Set) -> (\\ p2 : (i : N) -> Set) -> (\\ sub_hk : (h : (i : N) -> Nat) -> (k : Nat) -> B) -> (\\ mk_range : (B : Set) -> (n1 : Set) -> (n2 : Set) -> (p1 : (i : N) -> Set) -> (p2 : (i : N) -> Set) -> B) -> (\\ sub_hk : (k : Nat) -> h) -> B) -> (\\ B : Set) -> (\\ nil : B) -> (\\ op : AOp B nil) -> (\\ f1 : (i : N) -> B) -> (\\ f2 : (i : N) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (i : N) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ __ : N -> Nat)) (\\ k : Nat -> Nat) (\\ i : N -> Nat) -> (\\ n1 : Set -> Set) -> (\\ n2 : Set -> Set) -> (\\ p1 : (i : N) -> Set) -> (\\ p2 : (i : N) -> Set) -> (\\ sub_hk : (h : (i : N) -> Nat) -> (k : Nat) -> B) -> (\\ mk_range : (B : Set)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1047. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be a function from elements of $B$ and elements $__1$ of $B$ to elements of $B$. Let $f$ be a function from natural numbers to elements of $B$. Then if $n \\leq k$, then for all natural numbers $j$, if $n \\leq j$, then for all functions $Hind$ from functions from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and $j$ to elements of $Eq$ of $p (i)$ and absurdity to elements of $Eq$ of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $j$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$, for all functions $Hfalse$ from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and $j + 1$ to elements of $Eq$ of $p (i)$ and absurdity, for all natural numbers $x2571$ and $x2572$, $x2571 = x2572 (x2571 \\div x2572)+ mod (x2571 , x2572)$.\nassistant\n", "label": "Axiom let_clause_1047 : forall k : nat, forall n : nat, forall p : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : ((x__ : B) -> (__1 : B) -> B), forall f : ((x__ : nat) -> B), forall lenk : Leq n k, forall j : nat, forall leup : Leq n j, forall Hind : ((x__ : (i : nat) -> (x__ : Leq n i) -> (__1 : i < j) -> p i = false) -> bigop n (fun i => p i) B nil op (fun i => f i) = bigop j (fun i => p i) B nil op (fun i => f i)), forall Hfalse : ((i : nat) -> (x__ : Leq n i) -> (__1 : i < j + 1) -> p i = false), forall x2571 : nat, forall x2572 : nat, x2571 = x2572 * (x2571 / x2572) + mod x2571 x2572 .", "predict": "Axiom let_clause_1047 : forall k : nat, forall n : nat, forall p : ((i : nat) -> bool), forall B : set, forall nil : B, forall op : ((__1 : B) -> (i : nat) -> B), forall f : ((i : nat) -> B), forall nleqk : nat -> forall j : nat -> Hind : ((i : nat) -> (Leq : nat -> i) -> (__1 : Lt i j) -> Eq (p i) absurdity) -> Eq (bigop n (fun i => p i) B nil op (fun i => f i)) (bigop j (fun i => p i) B nil op (fun i => f i))) -> forall Hfalse : ((i : nat) -> (Leq : nat -> i) -> (__1 : Lt i (j + 1)) -> Eq (p i) absurdity), forall x2571 : nat, forall x2572 : nat, x2571 = x2572 (x2571 div x2572) + mod (x2571 , x2572), ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_10131. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n , m , n0 \\in N$. Anta att $max$ applicerat på summan av $n0$ och $1$ och $f$ är lika med $m$. Anta att $f$ applicerat på $m$ är lika med kontradiktion. Låt $i$ och $j$ vara naturliga tal. Anta att summan av $j$ och $1$ är mindre än summan av $n0$ och $1$. Då för alla naturliga tal $x7$, är $x7$ lika med summan av $m$ och $x7$.\nassistant\n", "label": "Axiom let_clause_10131 : forall f : ((x__ : nat) -> bool), forall n : nat, forall m : nat, forall n0 : nat, forall eqm : (max (n0 + 1) f = m), forall fm : (f m = false), forall i : nat, forall j : nat, forall ltj : (j + 1 < n0 + 1), forall x7 : nat, x7 = m + x7 .", "predict": "Axiom let_clause_10131 : forall f : nat -> bool, forall n : Nat, forall m : Nat, forall n0 : Nat, forall max : ((x : Nat) -> (y : Nat) -> Nat), forall f_m : bool, forall i : Nat, forall j : Nat, forall sum_j_1 : Nat, forall n0_1 : Nat, forall x7 : Nat, ((j + 1) < (n0 + 1)) -> (x7 = (m + x7)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1561. Soit $p , m , n \\in N$. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c \\in N$. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$. Alors si $a p - b m = 1$, alors $p a - m b = 1$.\nassistant\n", "label": "let_clause_1561 : p : Nat -> m : Nat -> n : Nat -> posn : Lt 0 p -> gcd1 : Eq (gcd p m) (nd 1) -> _clearme : divisible p (times m n) -> c : Nat -> nm : Eq (times m n) (times p c) -> a : Nat -> _clearme0 : ex Nat (b : Nat => or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> b : Nat -> _clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)) -> H : Eq (minus (times a p) (times b m)) (gcd p m) -> H0 : Eq (minus (times a p) (times b m)) (nd 1) -> Eq (minus (times p a) (times m b)) (nd 1) .", "predict": "let_clause_1561 : p : N -> m : N -> n : N -> 0 < p -> 1 = gcd p m -> p = m * n -> c : N -> m * n = p * c -> a : N -> _clearme0 : ex Nat (b : Nat => Eq (diff (a * p) (b * m)) (gcd p m) => Eq (diff (b * m) (a * p)) (gcd p m)) -> b : N -> gcd p m = a p - b m -> gcd p m = b m - a p -> a p - b m = 1 -> p a - m b = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_exp_to_divides. Let $p , n , m \\in N$. Assume that $p$ is prime. Then if $p$ is divisible by $n ^ m$, then $p$ is divisible by $n$.\nassistant\n", "label": "Axiom divides_exp_to_divides : forall p : nat, forall n : nat, forall m : nat, forall x__ : prime p, forall __1 : divisible p (pow n m), divisible p n .", "predict": "Axiom divides_exp_to_divides : forall p : N, forall n : N, forall m : N, p : prime -> p : n ^ m -> p : n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_upper_bound3. Låt $n , m , x \\in N$. Då $Nat$.\nassistant\n", "label": "Axiom let_upper_bound3 : forall n : nat, forall m : nat, forall x : nat, nat .", "predict": "Axiom let_upper_bound3 : nat -> nat -> nat -> nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDecidable_prime. For all natural numbers $n$, $decidable$ holds for $prime (n)$.\nassistant\n", "label": "Axiom decidable_prime : forall n : nat, decidable (prime n) .", "predict": "Axiom decidable_prime : nat -> decidable (prime n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_15691. Let $m , n , a , b \\in N$. Then if $0 < n$ and $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then $n c - m d = 1$.\nassistant\n", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : ex Nat (\\ d : N -> Eq (n :set) (m :set) 1)) -> (d : N) -> (c n - d m == 1) -> (n c - m d == 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_inv_ind. Soient $x1$ et $x2$ des nombres naturels. Supposons que $x1$ est inférieur ou ágal à $x2$. Soit $P$ une fonction des nombres naturels $_z724$ à des propositions. Soit $_H1$ une fonction des éléments $_z725$ de $Eq$ de $x2$ et de $x1$ à des éléments de $P$ de $x1$. Alors pour toutes les fonctions $_H2$ des nombres naturels $m$ et des éléments $_x_419$ de $Leq$ de $x1$ et de $m$ et des fonctions $_x_421$ des éléments $_z725$ de $Eq$ de $x2$ et de $m$ à des éléments de $P$ de $m$ et des éléments $_z725$ de $Eq$ de $x2$ et de la somme de $m$ et de $1$ à des éléments de $P$ de la somme de $m$ et de $1$, $P$ tient pour $x2$.\nassistant\n", "label": "Axiom le_inv_ind : forall x1 : nat, forall x2 : nat, forall _Hterm : Leq x1 x2, forall P : ((_z724 : nat) -> Prop), forall _H1 : ((_z725 : x2 = x1) -> P x1), forall _H2 : ((m : nat) -> (_x_419 : Leq x1 m) -> (_x_421 : (_z725 : x2 = m) -> P m) -> (_z725 : x2 = m + 1) -> P (m + 1)), P x2 .", "predict": "Axiom le_inv_ind : forall x1 : nat, forall x2 : nat, forall P : ((_z724 : nat) -> Prop), forall _H1 : ((_z725 : Eq x2 x1) -> P x1), forall _H2 : ((m : nat) -> (_x_419 : Leq x1 m) -> (_x_421 : (_z725 : Eq x2 m) -> P m) -> (_z725 : Eq x2 (m + 1)) -> P (m + 1)), P x2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_to_nat. Let $_b$ be a boolean. Then $Nat$.\nassistant\n", "label": "postulate bool_to_nat : (_b : bool) -> Nat", "predict": "postulate bool_to_nat : (_b : Boolean) -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nOrd_ord_rem. Soient $p$ et $q$ et $m$ des nombres naturels. Supposons que $0 < m$. Supposons que $p$ est premier. Supposons que $q$ est premier. Supposons que $q < p$. Alors $ord (ord_rem (m , p), q)= ord (m , q)$.\nassistant\n", "label": "ord_ord_rem : p : Nat -> q : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : prime q -> __3 : Lt q p -> Eq (ord (ord_rem m p) q) (ord m q) .", "predict": "ord_ord_rem : p : Nat -> q : Nat -> m : Nat -> 0 < m -> p : Prime -> q : Prime -> q < p -> ord (ord_rem (m , p), q) = ord (m , q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBigop_I. Pour tous les nombres naturels $n$, pour toutes les fonctions $p$ des nombres naturels à des valeurs booléennes, pour tous les ensembles $B$, pour tous les éléments $nil$ de $B$, pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, $bigop$ appliqué à la différence de $n$ et de $0$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $p$ appliqué à $i0$ appliqué à la somme de $i$ et de $0$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $0$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "postulate bigop_I : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (minus n 0) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i 0)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i 0))) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate bigop_I : (n : Nat) -> (p : (i : Nat) -> Bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (i : Nat) -> B) -> bigop (n - 0) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (\\ i0 : Nat -> 0) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (\\ i0 : Nat -> 0))) == bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_ind_body. For all functions $Q_$ from natural numbers $_x_365$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_366$ and elements $_x_368$ of $Q_$ of $x_366$ to elements of $Q_$ of the sum of $x_366$ and $1$, for all natural numbers $x_365$, $Q_$ holds for $x_365$.\nassistant\n", "label": "nat_ind_body : Q_ : (_x_365 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_366 : Nat -> _x_368 : Q_ x_366 -> Q_ (plus x_366 (nd 1))) -> x_365 : Nat -> Q_ x_365 .", "predict": "nat_ind_body : Q_ : (_x_365 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_366 : Nat -> _x_368 : Q_ x_366 -> Q_ (x_366 + 1)) -> x_365 : Nat -> Q_ x_365 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Då om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $m$ och $b$ och produkten av $p$ och $a$.\nassistant\n", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : (b : Nat) -> Eq (skillnaden mellan produkten av a och p och produkten av b och m) (det största gemensama delaret av p och m)) -> (b : N) -> (_ : Eq (skillnaden mellan produkten av a och p och produkten av b och m) (det största gemensama delaret av p och m)) -> (_1 : Eq (skillnaden mellan produkten av b och m och produkten av a och p) (det största gemensama delaret av p och m)) -> (_2 : Eq (skillnaden mellan produkten av b och m och produkten av a och p) 1) -> Eq (det största gemensama delaret av p och m) (skillnaden mellan produkten av m och b och produkten av p och a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_15611. Låt $p , m , n \\in N$. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Anta att skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Då om skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med $1$, så är skillnaden mellan produkten av $m$ och $b$ och produkten av $p$ och $a$ lika med $1$.\nassistant\n", "label": "Axiom let_clause_15611 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (b * m - a * p = gcd p m), forall H0 : (b * m - a * p = 1), m * b - p * a = 1 .", "predict": "Axiom let_clause_15611 : forall p : N, forall m : N, forall n : N, forall c : Nat, forall a : N, forall _clearme0 : ex Nat (fun b => Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m) /\\ Eq (skillnaden (produkten av b och m) (produkten av a och p)) (det största gemensama delaret av p och m)), forall b : N, ((skillnaden (produkten av a och p) (produkten av b och m)) = (det största gemensama delaret av p och m) \\/ (skillnaden (produkten av b och m) (produkten av a och p)) = (det största gemensama delaret av p och m)) /\\ (skillnaden (produkten av b och m) (produkten av a och p)) = (det största gemensama delaret av p och m)) -> ((skillnaden (produkten av b och m) (produkten av a och p)) = 1) -> (skillnaden (produkten av m och b) (produkten av p och a)) = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_to_not_lt. Låt $n$ och $m$ vara naturliga tal. Då om $n$ är mindre än eller lika med $m$, så är $m$ inte mindre än $n$.\nassistant\n", "label": "postulate le_to_not_lt : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> not (Lt m n)", "predict": "postulate le_to_not_lt : (n : Nat) -> (m : Nat) -> (n <= m) -> (m != n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_16003. Soit $m , n , a , b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nassistant\n", "label": "axiom let_clause_16003 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c", "predict": "axiom let_clause_16003 (m n a b : Nat) (c : Nat) (_clearme : ex Nat (λ d => Eq (diff (c * n) (d * m)) 1)) (d : Nat) : Bool => if (diff (c * n) (d * m)) == 1 || (diff (d * m) (c * n)) == 1 then if (diff (d * m) (c * n)) == 1 then div_cm_plus_grand m n == (m * d) - (n * c) else false else false"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15441. Let $p , q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0$ is less than $n$. Assume that $n$ is less than or equal to $m$. Assume that $n$ is less than or equal to the sum of $q$ and $1$. Assume that $n$ is not divisible by $m$. Let $a \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b$ be a natural number. Assume that the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ or the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Then if the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n", "label": "let_clause_15441 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n)) .", "predict": "let_clause_15441 : p : N -> q : N -> Hind : (m : N -> n : N -> Lt : 0 -> n -> __1 : Leq n m -> __2 : Leq n q -> ex : Nat -> a : Nat -> ex Nat (b : Nat => Eq (difference (product a n) (product b m)) (gcd_aux q m n) -> Eq (difference (product b m) (product a n)) (gcd_aux q m n))) -> m : N -> n : N -> 0 < n -> n <= m -> n <= (q + 1) -> n != (m * b) -> a : N -> _clearme : ex Nat (b : Nat => Eq (difference (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n)) -> Eq (difference (product b n) (product a (mod m n)) (gcd_aux q n (mod m n))) -> b : Nat -> difference (product a (mod m n)) (product b n) = gcd_aux q n (mod m n) -> or difference (product b n) (product a (mod m n)) = gcd_aux q n (mod m n)) -> _clearme : ex Nat (b : Nat => Eq (difference (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n)) -> Eq (difference (product b n) (product a (mod m n)) (gcd_aux q n (mod m n))) -> b : Nat -> difference (product a (mod m n)) (product b n) = gcd_aux q n (mod m n) -> or difference (product b n) (product a (mod m n)) = gcd_aux q n (mod m n)) -> gcd_aux q m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp4. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions. Then for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.\nassistant\n", "label": "Axiom Aop_rect_CProp4 : forall A : Set, forall _nil : A, forall Q_ : ((_x_875 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_875 : Aop A _nil, Q_ x_875 .", "predict": "Axiom Aop_rect_CProp4 : forall A : Set, forall _nil : A, forall Q_ : ((_x_875 : Aop A _nil) -> Prop), forall _H_mk_Aop : ((op : (__x : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_875 : Aop A _nil, Q_ x_875 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMin. Låt $__ , __1 \\in N$. Då $Nat$.\nassistant\n", "label": "min : __ : Nat -> __1 : Nat -> Nat .", "predict": "min : __ : N -> __1 : N -> Nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nassistant\n", "label": "axiom let_clause_16002 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c", "predict": "axiom let_clause_16002 (m n a b : Nat) (_clearme : (d : Nat) -> Eq (diff (c * n) (d * m)) 1) (d : Nat) : Eq (diff (c * n) (d * m)) 1) -> Eq (diff (d * m) (c * n)) 1) -> Eq (diff (d * m) (c * n)) 1) -> Eq (div_com_gcd n m) 1) : Eq (div_com_gcd (diff (c * n) (d * m)) (diff (d * m) (c * n))) (diff (m * d) (n * c)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p , m , n \\in N$. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller lika med $b m - a p$ och det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om $b m - a p = 1$, så $m b - p a = 1$.\nassistant\n", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (product a p) (product b m) (gcd p m))) -> (b : N) -> (_gcdpmm : gcd p m) -> (_pmm : product p m) -> (_a : N) -> (_b : N) -> (_gcdapm : gcd a p) -> (_apm : product a p) -> (_postulate let_clause_15611 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (product a p) (product b m) (gcd p m))) -> (b : N) -> (_gcdpmm : gcd p m) -> (_pmm : product p m) -> (_a : N) -> (_b : N) -> (_gcdapm : gcd a p) -> (_apm : product a p) -> (_gcdpma : gcd p a) -> (_pma : product p a) -> (_gcdpmm : gcd p m) -> (_pmm : product p m) -> (_b : N) -> (_let_clause_15611 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (product a p) (product b m) (gcd p m))) -> (b : N) -> (_gcdpmm : gcd p m) -> (_pmm : product p m) -> (_a : N) -> (_b : N) -> (_gcdapm : gcd a p) -> (_apm : product a p) -> (_gcdpma : gcd p a) -> (_pma : product p a) -> (_gcdpmm : gcd p m) -> (_pmm : product p m) -> (_b : N) -> (_gcdpmba : gcd p (m * b)) -> (_pmba : product p (m * b)) -> (_gcdbma : gcd b a) -> (_bma : product b a) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nF_false_to_le_max. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $n$ et $p$ des nombres naturels. Soit $__$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de $Eq$ appliqué à $f$ appliqué à $i$ et $true$. Alors pour toutes les fonctions $__1$ des nombres naturels $m$ et des éléments $__1$ de $Lt$ de $p$ et de $m$ à des éléments de $Eq$ de $f (m)$ et de contradiction, $max (n , f)\\leq p$.\nassistant\n", "label": "axiom f_false_to_le_max (f : (x__ : Nat) -> bool) (n p : Nat) (x__ : ex Nat (λ i => i < n ∧ f i = true)) (__1 : (m : Nat) -> (__1 : p < m) -> f m = false) : max n f ≤ p", "predict": "axiom f_false_to_le_max (f : Nat -> Bool) (n p : Nat) (__ : ex Nat (λ i => Lt i n ∧ Eq (f i) true)) (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) contradiction) : Nat.le (max n (f)) p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_15621. Soit $m , n , a , b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Alors pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $c n - d m = 1$, alors $n c - m d = 1$.\nassistant\n", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : (d : N) -> Eq (n * c - m * d) 1) -> (d : N) -> Eq (c * n - d * m) 1) -> Eq (n * c - m * d) 1) -> n * c - m * d)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNot_bertrand_to_le1. Soit $n \\in N$. Supposons que $2 ^ 7 \\leq n$. Soit $__1$ un élément de $not_bertrand$ de $n$. Alors $2 ^ (2 n \\div 3)\\leq 2 n ^ ((\\sqrt{ 2 n})\\div 2)$.\nassistant\n", "label": "not_bertrand_to_le1 : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> __1 : not_bertrand n -> Leq (pow (nd 2) (div (times (nd 2) n) (nd 3))) (pow (times (nd 2) n) (div (sqrt (times (nd 2) n)) (nd 2))) .", "predict": "not_bertrand_to_le1 : n : N -> __1 : not_bertrand n -> 2 ^ (2 n div 3) <= 2 n ^ ((sqrt 2 n) div 2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDop_rect_CProp0. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_967$ de $Dop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod (a , _nil)$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod (a , aop__o__op (A , _nil , sum , b , c))$ et de $aop__o__op (A , _nil , sum , prod (a , b), prod (a , c))$ à des éléments de $Q_$ de $mk_Dop (A , _nil , sum , prod , _null , _distr)$, pour tous les éléments $x_967$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_967$.\nassistant\n", "label": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967", "predict": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Set) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15591. Låt $n , m \\in N$. Anta att $0$ är mindre än $m$. Då om $0$ är lika med $n$, så om $0$ är delbart med $m$, så för alla naturliga tal $q$, om $m$ är lika med produkten av $0$ och $q$, så är $m$ lika med $n$.\nassistant\n", "label": "axiom let_clause_15591 (n m : Nat) (posn : 0 < m) (eqn0 : 0 = n) (_clearme : divisible 0 m) (q : Nat) (eqm : m = 0 * q) : m = n", "predict": "axiom let_clause_15591 (n m : N) (q : Nat) : m = n => 0 = n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_Psi_exp. Soit $n \\in N$. Alors $Psi$ appliqué à le produit de $2$ et de $n$ est inférieur ou ágal au produit de la puissance de $2$ et de $pred$ appliqué à le produit de $2$ et de $n$ et de $Psi$ appliqué à $n$.\nassistant\n", "label": "le_Psi_exp : n : Nat -> Leq (Psi (times (nd 2) n)) (times (pow (nd 2) (pred (times (nd 2) n))) (Psi n)) .", "predict": "le_Psi_exp : n : N -> Psi (2 * n) <= 2 ^ (pred (2 * n)) * Psi n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (n : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (Leq i0 n) -> (Leq (f i0) n)) -> (injf : injn f n) -> (a == b) -> f (a) = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_Type0_body. For all sets $_A$, for all functions $Q_$ from elements $_x_927$ of $range$ of $_A$ to sets, for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range (_A , _enum , _upto , _filter)$, for all elements $x_927$ of $range$ of $_A$, $Q_$ holds for $x_927$.\nassistant\n", "label": "Axiom range_rect_Type0_body : forall _A : Set, forall Q_ : ((_x_927 : range _A) -> Set), forall _H_mk_range : ((_enum : (x__ : nat) -> _A) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)), forall x_927 : range _A, Q_ x_927 .", "predict": "Axiom range_rect_Type0_body : forall _A : Set, forall Q_ : ((_x_927 : range _A) -> Set), forall _H_mk_range : ((_enum : (n : Set) -> _A) -> (_upto : Set) -> (_filter : (n : Set) -> Boolean) -> Q_ (mk_range _A _enum _upto _filter)), forall x_927 : range _A, Q_ x_927 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMax_spec_inv_ind. Låt $x1$ vara ett naturligt tal. Låt $x2$ vara en funktion från naturliga tal till sanningsvärden. Låt $x3$ vara ett naturligt tal. Låt $_Hterm$ vara ett element av $max_spec$ av $x1$ och $x2$ och $x3$. Låt $P$ vara en funktion från naturliga tal $_z1769$ till påståenden. Låt $_H1$ vara en funktion från naturliga tal $m$ och element $_x_975$ av $Lt$ av $m$ och $x1$ och element $_x_974$ av $Eq$ av $x2 (m)$ och $true$ och funktioner $_x_973$ från naturliga tal $i$ och element av $Lt$ av $m$ och $i$ och element $__1$ av $Lt$ av $i$ och $x1$ till element av $Eq$ av $x2 (i)$ och kontradiktion och element $_z1770$ av $Eq$ av $x3$ och $m$ till element av $P$ av $m$. Då för alla funktioner $_H2$ från funktioner $_x_976$ från naturliga tal $i$ och element av $Lt$ av $i$ och $x1$ till element av $Eq$ av $x2 (i)$ och kontradiktion och element $_z1770$ av $Eq$ av $x3$ och $0$ till element av $P$ av $0$, håller $P$ för $x3$.\nassistant\n", "label": "postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (_ : Nat) -> bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> (_ : Lt i x1) -> Eq (x2 i) false) -> (_z1770 : Eq x3 0) -> P 0) -> P x3", "predict": "postulate max_spec_inv_ind : (x1 : Nat) -> (x2 : (i : Nat) -> Bool) -> (x3 : Nat) -> (_Hterm : max_spec x1 x2 x3) -> (P : (_z1769 : Nat) -> Set) -> (_H1 : (m : Nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq x2 m true) -> (_x_973 : (i : Nat) -> (Lt m i) -> (__1 : Lt i x1) -> Eq x2 i) -> (_z1770 : Eq x3 m) -> P m) -> (_H2 : (_x_976 : (i : Nat) -> Lt i x1) -> (_z1770 : Eq x3 0) -> P 0) -> P x3"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_previous_prime7. Let $n$ and $m$ be natural numbers. Then if $nth_prime (n)< m$, then $Nat$.\nassistant\n", "label": "postulate let_previous_prime7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_previous_prime7 : (n : Nat) -> (m : Nat) -> nth_prime n < m -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSigma_p_dividesb1. Let $m , n , p , k \\in N$. Assume that $0 < n$ and $p$ is prime. Then if $p$ is not divisible by $n$ and $m \\leq k$, then $bigop$ applied to $k$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$ is equal to $m$.\nassistant\n", "label": "postulate sigma_p_dividesb1 : (m : Nat) -> (n : Nat) -> (p : Nat) -> (k : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> (__3 : Leq m k) -> Eq m (bigop k (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb1 : (m : N) -> (n : N) -> (p : N) -> (k : N) -> (p : N) -> n : N -> p : N -> m : N -> k : N -> bigop k (\\ i : N -> dividesb (exp p (i + 1)) (exp p m * n)) Nat 0 plus (\\ i : N -> 1)) -> m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nAop_discr. Soit $a1$ un ensemble. Alors pour tous les éléments $a2$ de $a1$, pour tous les éléments $x$ et $y$ de $Aop$ de $a1$ et de $a2$, si $x = y$, alors $match_Aop$ tient pour $a1$ et $a2$ et $Type2 + 1$ et la fonction qui envoie $__$ à $univ (Type2)$ et la fonction qui envoie $t0$ et $t1$ et $t2$ et $t3$ à $match_Aop$ appliqué à $a1$ et $a2$ et la somme de $Type2$ et de $1$ et la fonction qui envoie $__$ à $univ$ appliqué à $Type2$ et la fonction qui envoie $u0$ et $u1$ et $u2$ et $u3$ à $prod$ appliqué à la somme de $Type1$ et de $1$ et $Type1$ et $univ$ appliqué à $Type1$ et la fonction qui envoie $P$ à $prod$ appliqué à $Type1$ et $Type1$ et $prod$ appliqué à $Prop$ et $Type1$ et $Eq$ appliqué à $R0$ appliqué à $prod$ appliqué à $Set$ et $Set$ et $a1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Set$ et $Set$ et $a1$ et la fonction qui envoie $__1$ à $a1$ et $t0$ et $u0$ et la fonction qui envoie $e0$ à $prod$ appliqué à $Prop$ et $Type1$ et $Eq$ appliqué à $R1$ appliqué à $prod$ appliqué à $Set$ et $Set$ et $a1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Set$ et $Set$ et $a1$ et la fonction qui envoie $__1$ à $a1$ et $t0$ et la fonction qui envoie $x_19$ et $_x_20$ à la fonction qui envoie $x0$ et $p0$ à $prod$ appliqué à $Set$ et $Prop$ et $a1$ et la fonction qui envoie $a$ à $Eq$ appliqué à $x0$ appliqué à $a2$ et $a$ et $a$ appliqué à $x_19$ et $_x_20$ et $t1$ et $u0$ et $e0$ et $u1$ et la fonction qui envoie $e1$ à $prod$ appliqué à $Prop$ et $Type1$ et $Eq$ appliqué à $R2$ appliqué à $prod$ appliqué à $Set$ et $Set$ et $a1$ et la fonction qui envoie $__$ à $prod$ appliqué à $Set$ et $Set$ et $a1$ et la fonction qui envoie", "label": "axiom Aop_discr (a1 : Set) (a2 : a1) (x y : Aop a1 a2) (_e : x = y) : match_Aop a1 a2 (Type2 + 1) (λ x__ => univ Type2) (λ t0 => λ t1 => λ t2 => λ t3 => match_Aop a1 a2 (Type2 + 1) (λ x__ => univ Type2) (λ u0 => λ u1 => λ u2 => λ u3 => prod (Type1 + 1) Type1 (univ Type1) (λ P => prod Type1 Type1 (prod Prop Type1 (R0 (prod Set Set a1 (λ x__ => prod Set Set a1 (λ __1 => a1))) t0 = u0) (λ e0 => prod Prop Type1 (R1 (prod Set Set a1 (λ x__ => prod Set Set a1 (λ __1 => a1))) t0 (λ x_19 => λ _x_20 => (λ x0 => λ p0 => prod Set Prop a1 (λ a => x0 a2 a = a)) x_19 _x_20) t1 u0 e0 = u1) (λ e1 => prod Prop Type1 (R2 (prod Set Set a1 (λ x__ => prod Set Set a1 (λ __1 => a1))) t0", "predict": "axiom Aop_discr (a1 : Set) (a2 : Set) (x y : Aop a1 a2) : x = y -> match_Aop a1 a2 (Type2 + 1) (λ __ => univ (Type2)) (λ t0 => λ t1 => λ t2 => λ t3 => match_Aop a1 a2 (Type2 + 1) (λ __ => univ (Type2)) (λ u0 => λ u1 => λ u2 => λ u3 => prod (Type1 + 1) (Type1) (univ Type1) (λ P => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1) __) (λ __1 => prod Set Set a1 (λ a => t0 a2) __1)) (λ p0 => prod Set Prop a1 (λ a => Eq (x0 a2) a (λ x_19 => _x_20)) x0 p0)) (λ u0 => λ u1 => λ u2 => λ u3 => prod (Type1 + 1) (Type1) (univ Type1) (λ P => prod Type1 Type1 (prod Prop Type1 (Eq (R1 (prod Set Set a1) __) (λ __1 => prod Set Set a1 (λ a => t0 a2) __1)) (λ e0 => prod Prop Prop a1 (λ a => Eq (x0 a2) a (λ x_19 => _x_20)) x0 p0) (λ u0 => λ u1 => λ u2 => λ u3 => prod (Type1 + 1) (Type1) (univ Type1) (λ P => prod Type1 Type1 (prod Prop Type1 (Eq (R2 (prod Set Set a1) __) (λ __1 => prod Set Set a1 (λ a => t0 a2) __1)) (λ e1 => prod Prop Prop a1 (λ a => Eq (x0 a2) a (λ x_19 => _x_20)) x0 p0) (λ u0 => λ u1 => λ u2 => λ u3 => prod (Type1 + 1) (Type1) (univ Type1) (λ P"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_times_div_m_m. Pour tous les nombres naturels $n$ et $m$, si $0$ est inférieur à $m$, alors le produit du quotient de $n$ et de $m$ et de $m$ est inférieur ou ágal à $n$.\nassistant\n", "label": "le_times_div_m_m : n : Nat -> m : Nat -> __ : Lt 0 m -> Leq (times (div n m) m) n .", "predict": "le_times_div_m_m : n : Nat -> m : Nat -> 0 < m -> (n / m) * m <= n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLt_length_to_not_mem. Soit $n \\in N$. Soit $l$ une liste de nombres naturels. Soit $__$ un élément de $unique$ de $Nat$ et de $l$. Soit $__1$ une fonction des nombres naturels $x$ et des éléments $__1$ de $mem$ de $Nat$ et de $x$ et de $l$ à des éléments de $Lt$ de $x$ et de $n$. Alors si $length$ appliqué à $Nat$ et $l$ est inférieur à $n$, alors $ex$ tient pour $Nat$ et la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de la négation de $mem$ appliqué à $Nat$ et $i$ et $l$.\nassistant\n", "label": "lt_length_to_not_mem : n : Nat -> l : list Nat -> __ : unique Nat l -> __1 : (x : Nat -> __1 : mem Nat x l -> Lt x n) -> __2 : Lt (length Nat l) n -> ex Nat (i : Nat => and (Lt i n) (not (mem Nat i l))) .", "predict": "lt_length_to_not_mem : n : N -> l : List Nat -> __ : unique Nat l -> __1 : (x : Nat -> __1 : mem Nat x l -> Lt x n) -> length Nat l < n -> ex : Nat -> (i : Nat -> Lt i n) -> (i : Nat -> mem Nat i l) -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a$ be a natural number. Then if $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$, then if $a$ is less than or equal to $n$, then if $f$ applied to $a$ is equal to $i$, then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : ((i : N) -> N), forall n : N, forall permf : permut f n, forall i : N, forall j : N, forall a : N, (a <= n -> f a = i) -> (a <= n -> f a = i) -> forall b : N, (b <= n -> f b = j) -> (b <= n -> f b = j) -> forall __ : ((i0 : N) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, (a = b -> f a = i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1009. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $n$ et $m$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $f$ appliqué à $n$ est égal à contradiction. Supposons que $max$ appliqué à $m$ et $f$ est inférieur ou ágal à $n$. Supposons que $max$ appliqué à $m$ et $f$ est égal à $n$. Supposons que $prod$ tient pour $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $m$ et la fonction qui envoie $__$ à $Eq$ appliqué à $f$ appliqué à $i$ et contradiction et $max$ appliqué à $m$ et $f$ est égal à $0$. Soit $auto$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $f$ appliqué à $i$ et de contradiction. Alors si $max$ appliqué à $m$ et $f$ est égal à $0$, alors $0$ est égal à $n$.\nassistant\n", "label": "let_clause_1009 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> posn : Lt 0 n -> Hfn : Eq (f n) false -> Hmax : Leq (max m f) n -> Hmax0 : Eq (max m f) n -> _clearme : and (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i m) (__ : Lt i m => Eq (f i) false))) (Eq (max m f) 0) -> auto : (i : Nat -> __ : Lt i m -> Eq (f i) false) -> auto' : Eq (max m f) 0 -> Eq 0 n .", "predict": "let_clause_1009 : f : (Nat -> Bool) -> n : Nat -> m : Nat -> 0 < n -> f n = contradiction -> max m f < n -> max m f = n -> prod : Set Prop Nat (i : Nat => prod Prop Prop (Lt i m) (__ : Lt i m => Eq (f i) contradiction)) -> auto : (i : Nat -> Lt i m -> Eq (f i) contradiction) -> max m f = 0 -> 0 = n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i$ and $j$ be natural numbers. Assume that $i \\leq n$. Assume that $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$. Assume that $a \\leq n$. Assume that $f (a)= i$. Then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$, then if $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : nat -> nat, forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall a : N, forall b : nat, forall __ : ((i0 : nat) -> (Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall Hc : a = b, f a = i -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nBigop_distr. Soit $n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Alors pour tous les ensembles $B$, pour tous les éléments $nil$ de $B$, pour tous les éléments $R$ de $Dop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, pour tous les éléments $a$ de $B$, $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $let_aop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et la fonction qui envoie $i$ à $let_mop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et $a$ et $f$ appliqué à $i$ est égal à $let_mop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et $a$ et $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $let_aop$ appliqué à $n$ et $p$ et $B$ et $nil$ et $R$ et $f$ et $a$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "bigop_distr : n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> R : Dop B nil -> f : (__ : Nat -> B) -> a : B -> Eq (let_mop n p B nil R f a a (bigop n (i : Nat => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (i : Nat => f i))) (bigop n (i : Nat => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (i : Nat => let_mop n p B nil R f a a (f i))) .", "predict": "bigop_distr : n : N -> p : (i : N -> B) -> B : Set -> nil : B -> R : Dop B nil -> f : (i : N -> B) -> a : B -> bigop n (i : N => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (i : N => let_mop n p B nil R f a a (f i)) -> let_mop n p B nil R f a a (bigop n (i : N => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (i : N => f i)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDop_rect_Type2. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_951$ av $Dop$ av $A$ och $_nil$ till element av $Type2$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $Q_$ av $mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_951$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_951$.\nassistant\n", "label": "postulate Dop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_951 : Dop A _nil) -> Type2) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_951 : Dop A _nil) -> Q_ x_951", "predict": "postulate Dop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_951 : Dop A _nil) -> Set2) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_951 : Dop A _nil) -> Q_ x_951"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nP_ord_aux_to_not_mod_O. Let $p , n , m , q , r \\in N$. Assume that $1$ is less than $m$. Assume that $0$ is less than $n$. Then if $n$ is less than or equal to $p$, then if $p_ord_aux$ applied to $p$ and $n$ and $m$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $q$ and $r$, then $mod$ applied to $r$ and $m$ is not equal to $0$.\nassistant\n", "label": "axiom p_ord_aux_to_not_mod_O (p n m q r : Nat) (x__ : 1 < m) (__1 : 0 < n) (__2 : n ≤ p) (__3 : p_ord_aux p n m = mk_Prod Nat Nat q r) : ¬ (mod r m = 0)", "predict": "axiom p_ord_aux_to_not_mod_O (p n m q r : N) : (1 : N) < m -> (0 : N) < n -> (n : N) <= p -> (p_ord_aux p n m) = mk_Prod Nat Nat q r) -> (mod r m) ≠ 0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1686. Let $n , m \\in N$. Let $Hind$ be a function from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi$ applied to $p$ and the product of $pred$ applied to $p$ and the exponentiation of $2$ and the difference of the product of $2$ and $p$ and $3$. Let $a \\in N$. Then if $m$ is equal to the product of $2$ and $a$ or $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $1$ is less than the sum of the product of $2$ and $a$ and $1$, then if $0$ is less than $a$, then $pred$ applied to $m$ is equal to the sum of $a$ and $a$.\nassistant\n", "label": "Axiom let_clause_1686 : forall n : nat, forall m : nat, forall Hind : ((p : nat) -> (x__ : p < m) -> (__1 : 1 < p) -> Leq (Psi p) (pred p * pow 2 (2 * p - 3))), forall a : nat, forall _clearme : (m = 2 * a \\/ m = 2 * a + 1), forall Hm : (m = 2 * a + 1), forall Hlt : (1 < 2 * a + 1), forall Ha : (0 < a), pred m = a + a .", "predict": "Axiom let_clause_1686 : forall n : N, forall m : N, forall Hind : ((p : N) -> (__1 : Lt p m) -> (__2 : Lt 1 p) -> Leq (Psi p) (pred p) (exponentiation 2 (difference (product 2 p) 3))), forall a : N, if m = (product 2 a) or m = (sum (product 2 a) 1), if m = (sum (product 2 a) 1), if 1 < (sum (product 2 a) 1), if 0 < a, then pred m = (sum a a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_fact. Let $n$ and $i$ be natural numbers. Then if $0$ is less than $i$, then if $i$ is less than or equal to $n$, then $i$ is divisible by the factorial of $n$.\nassistant\n", "label": "axiom divides_fact (n i : Nat) (x__ : 0 < i) (__1 : i ≤ n) : divisible i (factorial n)", "predict": "axiom divides_fact (n i : Nat) : (0 < i) -> (i <= n) -> i / (n.factorial)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nFilter_divides. Soient $_n$ et $_m$ des nombres naturels. Soit $return_sort$ un élément de $Sort$. Soit $return_type$ une fonction des éléments $z$ de $divisible$ de $_n$ et de $_m$ à des éléments de $return_sort$. Soit $return$ une fonction des éléments $z$ de $divisible$ de $_n$ et de $_m$ à des éléments de $return_type$ de $z$. Alors si $_n$ est divisible par $_m$, alors $return_type$ tient pour $z$.\nassistant\n", "label": "postulate filter_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (return : (z : divisible _n _m) -> return_type z) -> (z : divisible _n _m) -> return_type z", "predict": "postulate filter_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (return : (z : divisible _n _m) -> return_type z) -> (_n : divisible _m) -> return_type _n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_inv_rect_CProp4. Let $x1$ be a set. Let $x2$ be an element of $x1$. Then for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1536$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op (x2 , a)$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op (a , x2)$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op (a , op (b , c))$ and $op (op (a , b), c)$ and elements $_z1537$ of $Eq$ of $Hterm$ and $mk_Aop (x1 , x2 , op , _nill , _nilr , _assoc)$ to elements of $P$ of $mk_Aop (x1 , x2 , op , _nill , _nilr , _assoc)$, $P$ holds for $Hterm$.\nassistant\n", "label": "axiom Aop_inv_rect_CProp4 (x1 : Set) (x2 : x1) (Hterm : Aop x1 x2) (P : (_z1536 : Aop x1 x2) -> Prop) (_H1 : (op : (x__ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> op x2 a = a) -> (_nilr : (a : x1) -> op a x2 = a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> op a (op b c) = op (op a b) c) -> (_z1537 : Hterm = mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) : P Hterm", "predict": "axiom Aop_inv_rect_CProp4 (x1 : Set) (x2 : Element x1) (Hterm : Aop x1 x2) (P : (_z1536 : Aop x1 x2) -> Proposition) (_H1 : (op : (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) : P Hterm"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b \\in N$. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Assume that $f (b)= j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$. Let $injf$ be an element of $injn$ of $f$ and $n$. Assume that $a = b$. Then $f (a)= i$.\nassistant\n", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (i : N) -> N) -> (n : N) -> (permf : permut f n) -> (i : N) -> (j : N) -> (a : N) -> (b : N) -> (__ : (i0 : N) -> (Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a : b) -> f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_inv_rect_Type0. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Dop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1728$ of $Dop$ of $x1$ and $x2$ to sets, for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $x1$ and $x2$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ and elements $_z1729$ of $Eq$ of $Hterm$ and $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$ to elements of $P$ of $mk_Dop$ applied to $x1$ and $x2$ and $sum$ and $prod$ and $_null$ and $_distr$, $P$ holds for $Hterm$.\nassistant\n", "label": "Dop_inv_rect_Type0 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1728 : Dop x1 x2 -> Set) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1729 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .", "predict": "Dop_inv_rect_Type0 : x1 : Set -> x2 : Set -> Hterm : Dop x1 x2 -> P : (_z1728 : Dop x1 x2 -> Set) -> _H1 : (sum : Aop x1 x2 -> prod : (x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1729 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nChecker_abl. Let $a , b \\in N$. Then for all lists $l$ of natural numbers, if $checker (cons (Nat , a , cons (Nat , b , l)))= true$, then $a < b$, $b \\leq 2 a$ and $checker (cons (Nat , b , l))= true$.\nassistant\n", "label": "postulate checker_abl : (a : Nat) -> (b : Nat) -> (l : list Nat) -> (_ : Eq (checker (cons Nat a (cons Nat b l))) true) -> and (and (Lt a b) (Leq b (times 2 a))) (Eq (checker (cons Nat b l)) true)", "predict": "postulate checker_abl : (a : N) -> (b : N) -> (l : List N) -> checker (cons Nat a (cons Nat b l)) -> a < b -> b <= 2 a -> checker (cons Nat b l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1075. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $bijf$ vara ett element av $bijn$ av $f$ och $n + 1$. Anta att $f (n + 1)= n + 1$. Låt $i \\in N$. Anta att $i \\leq n$. Låt $a \\in N$. Anta att $a \\leq n + 1$ och $f (a)= i$. Anta att $a \\leq n + 1$. Anta att $f (a)= i$. Anta att $a = n + 1$. Då $i = a$.\nassistant\n", "label": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a", "predict": "postulate let_clause_1075 : (f : (n : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (n + 1)) -> (i : Nat) -> (a : Nat) -> (a : Nat) -> (f a) -> (a : Nat) -> (i : Nat) -> (postulate let_clause_1075 : (f : (n : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (n + 1)) -> (i : Nat) -> (a : Nat) -> (a : Nat) -> (f a) -> (a : Nat) -> (i : Nat) -> (postulate let_clause_1075 : (f : (n : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (n + 1)) -> (i : Nat) -> (a : Nat) -> (a : Nat) -> (f a) -> (a : Nat) -> (i : Nat) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLstar_S. Soit $B$ un ensemble. Alors pour tous les éléments $R$ de $relation$ de $B$, pour tous les éléments $b1$ et $b$ de $B$, pour tous les éléments $__$ de $R$ de $b1$ et de $b$, pour tous les nombres naturels $l$, pour tous les éléments $b2$ de $B$, pour tous les éléments $__1$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$, $lstar$ tient pour $B$ et $R$ et $l + 1$ et $b1$ et $b2$.\nassistant\n", "label": "Axiom lstar_S : forall B : Set, forall R : relation B, forall b1 : B, forall b : B, forall x__ : R b1 b, forall l : nat, forall b2 : B, forall __1 : lstar B R l b b2, lstar B R (l + 1) b1 b2 .", "predict": "Axiom lstar_S : forall B : ensemble, forall R : relation B, forall b1 : B, forall b : B, forall __ : R b1 b, forall l : nat, forall b2 : B, forall __1 : lstar B R l b b2, lstar B R (l + 1) b1 b2 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nIter_body. Låt $H$ vara en mängd. Låt $__$ vara en funktion från element av $H$ till element av $H$. Låt $__1 \\in N$. Låt $__2$ vara ett element av $H$. Då $H$.\nassistant\n", "label": "postulate iter_body : (H : Set) -> (_ : (_ : H) -> H) -> (__1 : Nat) -> (__2 : H) -> H", "predict": "postulate iter_body : (H : Set) -> (__ : (x : H) -> H) -> (__1 : N) -> (__2 : H) -> H"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_16171. Let $p , m , n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $m$ and $b$ and the product of $p$ and $a$.\nassistant\n", "label": "Axiom let_clause_16171 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (b * m - a * p = gcd p m), forall H0 : (b * m - a * p = 1), gcd p m = m * b - p * a .", "predict": "Axiom let_clause_16171 : forall p : N, forall m : N, forall n : N, forall c : N, forall a : N, forall _clearme0 : ((b : N) -> Eq (diff (product a p) (product b m)) (gcd p m) -> Eq (diff (product b m) (product a p)) (gcd p m)), forall b : N, ((diff (product a p) (product b m)) = (gcd p m) -> (diff (product b m) (product a p)) = (gcd p m) -> (diff (product b m) (product a p)) = 1 -> gcd p m = (product m b) - (product p a)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_nth_prime_to_not_prime. Let $n , m \\in N$. Assume that $nth_prime$ applied to $n$ is less than $m$. Then if $m$ is less than $nth_prime$ applied to the sum of $n$ and $1$, then $m$ is not prime.\nassistant\n", "label": "postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> (__1 : Lt m (nth_prime (plus n 1))) -> not (prime m)", "predict": "postulate lt_nth_prime_to_not_prime : (n : N) -> (m : N) -> (nth_prime n) < m -> (m < nth_prime (n + 1)) -> m != prime"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDividesb_true_to_lt_O. Låt $n$ och $m$ vara naturliga tal. Anta att $0 < n$ och $m$ är delbart med $n$. Då $0 < m$.\nassistant\n", "label": "axiom dividesb_true_to_lt_O (n m : Nat) (x__ : 0 < n) (__1 : divisible m n) : 0 < m", "predict": "axiom dividesb_true_to_lt_O (n m : Nat) : 0 < n -> m % n = 0 -> 0 < m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nComm. Låt $A$ vara en mängd. Låt $nil$ vara ett element av $A$. Låt $xxx$ vara ett element av $ACop$ av $A$ och $nil$. Låt $a$ och $b$ vara element av $A$. Då är $op$ applicerat på $A$ och $nil$ och $aop$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ lika med $op$ applicerat på $A$ och $nil$ och $aop$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $a$.\nassistant\n", "label": "Axiom comm : forall A : Set, forall nil : A, forall xxx : ACop A nil, forall a : A, forall b : A, op A nil (aop A nil xxx) a b = op A nil (aop A nil xxx) b a .", "predict": "Axiom comm : forall A : set, forall nil : A, forall xxx : Aop A nil, forall a : A, forall b : A, op A nil (aop A nil xxx) a b = op A nil (aop A nil xxx) b a ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om $b m - a p = 1$, så $m b - p a = 1$.\nassistant\n", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (product a p) (product b m) (gcd p m))) -> (b : Nat) -> (_gcdpmm : (gcd p m) == (a p - b m) || (gcd p m) == (b m - a p)) -> (_gcdpmm' : gcd p m == b m - a p) -> (b : Nat) -> (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (product a p) (product b m) (gcd p m))) -> (b : Nat) -> (_gcdpmm : (gcd p m) == (a p - b m) || (gcd p m) == (b m - a p)) -> (_gcdpmm' : gcd p m == b m - a p) -> (postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (product a p) (product b m) (gcd p m))) -> (b : Nat) -> (_gcdpmm : (gcd p m) == (a p - b m) || (gcd p m) == (b m - a p)) -> (_gcdpmm' : gcd p m == b m - a p) -> (b : Nat) -> (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (product a p) (product b m) (gcd p m))) -> (b : Nat) -> (_gcdpmm : (gcd p m) == (a p - b m) || (gcd p m) == (b m - a p)) -> (_gcdpmm' : gcd p m == b m - a p) -> (b : Nat) -> (p : Nat) -> (m : Nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLt_4_to_le_B_exp. Soit $n \\in N$. Supposons que $4 < n$. Alors $B (2 n)\\leq 2 ^ (2 n - 2)$.\nassistant\n", "label": "postulate lt_4_to_le_B_exp : (n : Nat) -> (_ : Lt 4 n) -> Leq (B (times 2 n)) (pow 2 (minus (times 2 n) 2))", "predict": "postulate lt_4_to_le_B_exp : (n : N) -> (4 < n) -> B (2 n) <= 2 ^ (2 n - 2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_plus. Låt $n , m , p , q \\in N$. Då om $n < m$, så om $p < q$, så $n + p < m + q$.\nassistant\n", "label": "postulate lt_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Lt p q) -> Lt (plus n p) (plus m q)", "predict": "postulate lt_plus : (n : N) -> (m : N) -> (p : N) -> (q : N) -> n + p < m + q"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_times_times. Låt $a , b , c \\in N$. Anta att $0 < c$. Anta att $0 < b$. Då $a \\div b = a c \\div (b c)$.\nassistant\n", "label": "axiom div_times_times (a b c : Nat) (x__ : 0 < c) (__1 : 0 < b) : a / b = a * c / (b * c)", "predict": "axiom div_times_times (a b c : N) (Hc : 0 < c) (Hb : 0 < b) : a / b = a * c / (b * c)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_mod_to_divides. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < n$ and $p$ is divisible by $mod (m , n)$. Then if $p$ is divisible by $n$, then $p$ is divisible by $m$.\nassistant\n", "label": "Axiom divides_mod_to_divides : forall p : nat, forall m : nat, forall n : nat, forall x__ : (0 < n), forall __1 : divisible p (mod m n), forall __2 : divisible p n, divisible p m .", "predict": "Axiom divides_mod_to_divides : forall p : nat, forall m : nat, forall n : nat, 0 < n -> p % mod (m , n) -> p % n -> p % m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nFact_minus. Soient $n$ et $k$ des nombres naturels. Alors si $k < n$, alors $(n - (k + 1))! (n - k)= (n - k)!$.\nassistant\n", "label": "axiom fact_minus (n k : Nat) (x__ : k < n) : factorial (n - (k + 1)) * (n - k) = factorial (n - k)", "predict": "axiom fact_minus (n k : Nat) : Prop => k < n => (n - (k + 1))! (n - k) = (n - k)!"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPrime_to_primeb_true. Pour tous les nombres naturels $n$, si $n$ est premier, alors $primeb (n)= true$.\nassistant\n", "label": "axiom prime_to_primeb_true (n : Nat) (x__ : prime n) : primeb n = true", "predict": "axiom prime_to_primeb_true (n : Nat) : Bool := primeb n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_15611. Soit $p , m , n \\in N$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c \\in N$. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Alors si $b m - a p = 1$, alors $m b - p a = 1$.\nassistant\n", "label": "axiom let_clause_15611 (p m n : Nat) (posn : 0 < p) (gcd1 : gcd p m = 1) (_clearme : divisible p (m * n)) (c : Nat) (nm : m * n = p * c) (a : Nat) (_clearme0 : ex Nat (λ b => a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m)) (b : Nat) (_clearme1 : a * p - b * m = gcd p m ∨ b * m - a * p = gcd p m) (H : b * m - a * p = gcd p m) (H0 : b * m - a * p = 1) : m * b - p * a = 1", "predict": "axiom let_clause_15611 (p m n : Nat) (c : Nat) (a : Nat) (_clearme0 : ex Nat (λ b => Eq (a * p - b * m) (gcd p m))) (b : Nat) : Eq (gcd p m) (b * m - a * p) (if (gcd p m) = (a * p - b * m) => Eq (gcd p m) (b * m - a * p) => if (gcd p m) = (b * m - a * p) => if b * m - a * p = 1 => Eq (m * b - p * a) 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nEx_prime. För alla naturliga tal $n$, om $1$ är mindre än eller lika med $n$, så håller $ex$ för $Nat$ och funktionen som avbildar $m$ som konjunktionen av konjunktionen av $Lt$ applicerat på $n$ och $m$ och $Leq$ applicerat på $m$ och summan av fakulteten av $n$ och $1$ och $prime$ applicerat på $m$.\nassistant\n", "label": "postulate ex_prime : (n : Nat) -> (_ : Leq 1 n) -> ex Nat (\\ m : Nat -> and (and (Lt n m) (Leq m (plus (factorial n) 1))) (prime m))", "predict": "postulate ex_prime : (n : Nat) -> (ex : Nat) -> (m : Nat) -> (Lt : (x : Nat) -> (y : Nat) -> Nat) -> (Leq : (x : Nat) -> (y : Nat) -> Nat) -> (f : (x : Nat) -> Nat) -> (p : (x : Nat) -> Nat) -> (ex_prime : (n : Nat) -> (m : Nat) -> (Lt : (x : Nat) -> (y : Nat) -> Nat) -> (Leq : (x : Nat) -> (y : Nat) -> Nat) -> (f : (x : Nat) -> Nat) -> (p : (x : Nat) -> Nat) -> Nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNot_ord_O_to_divides. Låt $p , m \\in N$. Anta att $0 < m$. Anta att $p$ är primt. Anta att $ord (m , p)$ inte är lika med $0$. Då är $p$ delbart med $m$.\nassistant\n", "label": "axiom not_ord_O_to_divides (p m : Nat) (x__ : 0 < m) (__1 : prime p) (__2 : ¬ (ord m p = 0)) : divisible p m", "predict": "axiom not_ord_O_to_divides (p m : N) (Hc : 0 < m) (Hp : p :prime) (Hord : ord (m , p) ≠ 0) : p divides m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_m. För alla funktioner $f$ från naturliga tal till sanningsvärden, för alla naturliga tal $n$ och $b$, $Nat$.\nassistant\n", "label": "axiom let_m (f : (x__ : Nat) -> bool) (n b : Nat) : Nat", "predict": "axiom let_m (f : nat -> Bool) (n b : Nat) : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a \\in N$. Assume that $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$. Assume that $a$ is less than or equal to $n$. Assume that $f$ applied to $a$ is equal to $i$. Then for all natural numbers $b$, if $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$, then if $b$ is less than or equal to $n$, then if $f$ applied to $b$ is equal to $j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (h0 : a <= n) (h1 : f a = i) (h2 : a <= n) (h3 : f a = i) (b : Nat) (h4 : b <= n) (h5 : f b = j) (h6 : b <= n) (h7 : f b = j) (__ : (i0 : Nat) -> (Leq i0 n) -> Leq (f i0) n) (injf : (i0 : Nat) -> (i1 : Nat) -> (i2 : Nat) -> (i3 : Nat) -> (i4 : Nat) -> (i5 : Nat) -> (i6 : Nat) -> (i7 : Nat) -> (i8 : Nat) -> (i9 : Nat) -> (i10 : Nat) -> (i11 : Nat) -> (i12 : Nat) -> (i13 : Nat) -> (i14 : Nat) -> (i15 : Nat) -> (i16 : Nat) -> (i17 : Nat) -> (i18 : Nat) -> (i19 : Nat) -> (i20 : Nat) -> (i21 : Nat) -> (i22 : Nat) -> (i23 : Nat) -> (i24 : Nat) -> (i25 : Nat) -> (i26 : Nat) -> (i27 : Nat) -> (i28 : Nat) -> (i29 : Nat) -> (i30 : Nat) -> (i31 : Nat) -> (i32 : Nat) -> (i33 : Nat) -> (i34 : Nat) -> (i35 : Nat) -> (i36 : Nat) -> (i37 : Nat) -> (i38 : Nat) -> (i39 : Nat) -> (i40 : Nat) -> (i41 : Nat) -> (i42 : Nat) -> (i43 : Nat) -> (i44 : Nat) -> (i45 : Nat) -> (i46 : Nat) -> (i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInjective_plus_r. For all natural numbers $n$, $injective$ holds for $Nat$ and $Nat$ and the function that maps $m$ to the sum of $n$ and $m$.\nassistant\n", "label": "axiom injective_plus_r (n : Nat) : injective Nat Nat (λ m => n + m)", "predict": "axiom injective_plus_r (n : Nat) : Nat → Nat → (m : Nat) → Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_rect_Type4_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_863$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type4$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (_nil , a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (a , _nil)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op (a , op (b , c))$ et de $op (op (a , b), c)$ à des éléments de $Q_$ de $mk_Aop (A , _nil , op , _nill , _nilr , _assoc)$, pour tous les éléments $x_863$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_863$.\nassistant\n", "label": "Axiom Aop_rect_Type4_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_863 : Aop A _nil) -> Type4), forall _H_mk_Aop : ((op : (x__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> op _nil a = a) -> (_nilr : (a : A) -> op a _nil = a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> op a (op b c) = op (op a b) c) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_863 : Aop A _nil, Q_ x_863 .", "predict": "Axiom Aop_rect_Type4_body : forall A : Set, forall _nil : A, forall Q_ : ((_x_863 : Aop A _nil) -> Type4), forall _H_mk_Aop : ((op : (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op (_nil , a) a)) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)), forall x_863 : Aop A _nil, Q_ x_863 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1607. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Then if $0 < n$ and $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "let_clause_1607 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .", "predict": "let_clause_1607 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1 | Eq (d m - c n) 1) -> d : Nat -> c n - d m = 1 -> m d - n c = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_ind_body. Let $Q_$ be a function from natural numbers $_x_365$ to propositions. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_366$ and elements $_x_368$ of $Q_$ of $x_366$ to elements of $Q_$ of the sum of $x_366$ and $1$. Let $x_365 \\in N$. Then $Q_$ holds for $x_365$.\nassistant\n", "label": "axiom nat_ind_body (Q_ : (_x_365 : Nat) -> Prop) (_H_O : Q_ 0) (_H_S : (x_366 : Nat) -> (_x_368 : Q_ x_366) -> Q_ (x_366 + 1)) (x_365 : Nat) : Q_ x_365", "predict": "axiom nat_ind_body (Q_ : (_x_365 : N) -> P) (_H_O : Q_ 0) (_H_S : (x_366 : N) -> (_x_368 : Q_ x_366) -> Q_ (x_366 + 1)) (x_365 : N) : Q_ x_365"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFound_min_spec. Let $n , b \\in N$. Let $f$ be a function from natural numbers to booleans. Let $m$ be a natural number. Assume that $b$ is less than or equal to $m$. Assume that $m$ is less than the sum of $n$ and $b$. Assume that $f$ applied to $m$ is equal to $true$. Then for all functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, $min_spec$ holds for $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m", "predict": "postulate found_min_spec : (n : N) -> (b : N) -> (f : (i : N) -> Bool) -> (m : N) -> (__3 : (i : N) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) absurdity) -> min_spec n b f m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_10131. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $n$ et $m$ et $n0$ des nombres naturels. Supposons que $max$ appliqué à la somme de $n0$ et de $1$ et $f$ est égal à $m$. Supposons que $f$ appliqué à $m$ est égal à contradiction. Soit $i , j \\in N$. Supposons que la somme de $j$ et de $1$ est inférieure à la somme de $n0$ et de $1$. Alors pour tous les nombres naturels $x7$, $x7$ est égal à la somme de $m$ et de $x7$.\nassistant\n", "label": "axiom let_clause_10131 (f : (x__ : Nat) -> bool) (n m n0 : Nat) (eqm : max (n0 + 1) f = m) (fm : f m = false) (i j : Nat) (ltj : j + 1 < n0 + 1) (x7 : Nat) : x7 = m + x7", "predict": "axiom let_clause_10131 (f : Nat -> Bool) (n m n0 : Nat) (max : (x y : Nat) -> Nat) (f_m : Bool) (i j : Nat) (x7 : Nat) : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_10331. Låt $n \\in N$. Anta att $0 < n$. Låt $x2515$ och $x2516$ vara naturliga tal. Då $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "axiom let_clause_10331 (n : Nat) (posn : 0 < n) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_10331 (n : N) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod (x2515 , x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLtn_to_ltO. Let $n$ and $m$ be natural numbers. Then if $n$ is less than $m$, then $0$ is less than $m$.\nassistant\n", "label": "postulate ltn_to_ltO : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Lt 0 m", "predict": "postulate ltn_to_ltO : (n : Set Nat) -> (m : Set Nat) -> n < m -> 0 < m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDiv_mod_spec_rect_CProp3. Soit $_n , _m , _q , _r \\in N$. Alors pour toutes les fonctions $Q_$ des éléments $_x_845$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions, pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_847$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_846$ de $Eq$ de $_n$ et de $_q _m + _r$ à des éléments de $Q_$ de $div_mod_spec_intro (_n , _m , _q , _r , x_847 , x_846)$, pour tous les éléments $x_845$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_845$.\nassistant\n", "label": "Axiom div_mod_spec_rect_CProp3 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_845 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_847 : _r < _m) -> (x_846 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)), forall x_845 : div_mod_spec _n _m _q _r, Q_ x_845 .", "predict": "Axiom div_mod_spec_rect_CProp3 : forall _n : N, forall _m : N, forall _q : N, forall _r : N, forall Q_ : ((_x_845 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_847 : Lt _r _m) -> (x_846 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)), forall x_845 : div_mod_spec _n _m _q _r, Q_ x_845 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLeb_elim. För alla naturliga tal $n$ och $m$, för alla funktioner $P$ från sanningsvärden till påståenden, för alla funktioner $__$ från element av $Leq$ av $n$ och $m$ till element av $P$ av $true$, för alla funktioner $__1$ från element $__1$ av $not$ av $Leq$ applicerat på $n$ och $m$ till element av $P$ av kontradiktion, håller $P$ för $leb$ applicerat på $n$ och $m$.\nassistant\n", "label": "axiom leb_elim (n m : Nat) (P : (x__ : bool) -> Prop) (x__ : (x__ : n ≤ m) -> P true) (__1 : (__1 : ¬ (n ≤ m)) -> P false) : P (leb n m)", "predict": "axiom leb_elim (n m : Nat) (P : (Bool -> Set) ) (__ : (Leq n m -> P true) ) (__1 : (__1 : not (Leq n m)) -> P contradiction) : P (leb n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$. Alors si $a \\leq n$, alors si $f (a)= i$, alors pour tous les nombres naturels $b$, si $b \\leq n$ et $f (b)= j$, alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (Hc : a <= n) (Hd : f a = i) (b : Nat) (He : b <= n) (Hf : f b = j) (Hg : b <= n) (Hh : f b = j) (__ : (i0 : Nat) -> (x : Leq i0 n) -> Leq (f i0) n) (injf : injn f n) (Ha : a = b) : f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_max_spec. Let $_n$ be a natural number. Let $_f$ be a function from natural numbers to booleans. Let $return_sort$ be an element of $Sort$. Then for all functions $return_type$ from natural numbers and elements $z$ of $max_spec$ of $_n$ and $_f$ and $__$ to elements of $return_sort$, for all functions $case_found_max_spec$ from natural numbers $m$ and elements of $Lt$ of $m$ and $_n$ and elements $__1$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $__2$ from natural numbers $i$ and elements $__2$ of $Lt$ of $m$ and $i$ and elements $__3$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $return_type$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $__$ and $__1$ and $__2$, for all functions $case_not_found_max_spec$ from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $return_type$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $__$, for all natural numbers $__$, for all elements $z$ of $max_spec$ of $_n$ and $_f$ and $__$, $return_type$ holds for $__$ and $z$.\nassistant\n", "label": "match_max_spec : _n : Nat -> _f : (__ : Nat -> bool) -> return_sort : Sort -> return_type : (__ : Nat -> z : max_spec _n _f __ -> return_sort) -> case_found_max_spec : (m : Nat -> __ : Lt m _n -> __1 : Eq (_f m) true -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i _n -> Eq (_f i) false) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> case_not_found_max_spec : (__ : (i : Nat -> __ : Lt i _n -> Eq (_f i) false) -> return_type 0 (not_found_max_spec _n _f __)) -> __ : Nat -> z : max_spec _n _f __ -> return_type __ z .", "predict": "match_max_spec : _n : Nat -> _f : (Nat -> Bool) -> return_sort : Sort -> return_type : (Nat -> z : max_spec _n _f __ -> return_sort) -> case_found_max_spec : (m : Nat -> Lt : m -> _n -> __1 : Eq (_f m) true -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i _n -> Eq (_f i) absurdity) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> case_not_found_max_spec : (i : Nat -> Lt : i -> _n -> __ : Eq (_f i) absurdity -> return_type 0 (not_found_max_spec _n _f __)) -> __ : Nat -> z : max_spec _n _f __ -> return_type __ z ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1012. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $i$ vara naturliga tal. Låt $Hind$ vara en funktion från naturliga tal $b$ till element av $prod$ av $Prop$ och $Prop$ och $Eq$ applicerat på $f$ applicerat på $let_m2$ applicerat på $f$ och $n$ och $i$ och $b$ och kontradiktion och funktionen som avbildar $__$ som $Eq (let_m2 (f , n , i , b), i + b)$. Då för alla naturliga tal $b$, om $f (b)= true$, så om kontradiktion är lika med $f (b)$, så är $true$ lika med kontradiktion.\nassistant\n", "label": "let_clause_1012 : f : (__ : Nat -> bool) -> n : Nat -> i : Nat -> Hind : (b : Nat -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (__ : Eq (f (let_m2 f n i b)) false => Eq (let_m2 f n i b) (plus i b))) -> b : Nat -> fb : Eq (f b) true -> eqm : Eq (f b) false -> Eq false true .", "predict": "let_clause_1012 : f : nat -> Prop -> n : nat -> i : nat -> Hind : (b : nat -> prod Prop Prop (Eq (f (let_m2 f n i b)) i + b)) -> b : nat -> f (b) = true -> kontradiktion = f (b) -> true = kontradiktion ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProdF. For all sets $A$ and $B$, for all functions $_f$ from natural numbers to elements of $A$, for all functions $_g$ from natural numbers to elements of $B$, for all natural numbers $_m$ and $_x$, $Prod$ holds for $A$ and $B$.\nassistant\n", "label": "prodF : A : Set -> B : Set -> _f : (__ : Nat -> A) -> _g : (__ : Nat -> B) -> _m : Nat -> _x : Nat -> Prod A B .", "predict": "prodF : A : Set -> B : Set -> _f : Nat -> A -> _g : Nat -> B -> _m : Nat -> _x : Nat -> Prod A B ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMin_spec_ind_body. Låt $_n , _b \\in N$. Låt $_f$ vara en funktion från naturliga tal till sanningsvärden. Låt $Q_$ vara en funktion från naturliga tal $x_1075$ och element $_x_1076$ av $min_spec$ av $_n$ och $_b$ och $_f$ och $x_1075$ till påståenden. Då för alla funktioner $_H_found_min_spec$ från naturliga tal $m$ och element $x_1080$ av $Leq$ av $_b$ och $m$ och element $x_1079$ av $Lt$ av $m$ och $_n + _b$ och element $x_1078$ av $Eq$ av $_f (m)$ och $true$ och funktioner $x_1077$ från naturliga tal $i$ och element av $Leq$ av $_b$ och $i$ och element $__1$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $_f (i)$ och kontradiktion till element av $Q_$ av $m$ och $found_min_spec (_n , _b , _f , m , x_1080 , x_1079 , x_1078 , x_1077)$, för alla funktioner $_H_not_found_min_spec$ från funktioner $x_1081$ från naturliga tal $i$ och element av $Leq$ av $_b$ och $i$ och element $__1$ av $Lt$ av $i$ och $_n + _b$ till element av $Eq$ av $_f (i)$ och kontradiktion till element av $Q_$ av $_n + _b$ och $not_found_min_spec (_n , _b , _f , x_1081)$, för alla naturliga tal $x_1075$, för alla element $x_1076$ av $min_spec$ av $_n$ och $_b$ och $_f$ och $x_1075$, håller $Q_$ för $x_1075$ och $x_1076$.\nassistant\n", "label": "axiom min_spec_ind_body (_n _b : Nat) (_f : (x__ : Nat) -> bool) (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) (_H_found_min_spec : (m : Nat) -> (x_1080 : _b ≤ m) -> (x_1079 : m < _n + _b) -> (x_1078 : _f m = true) -> (x_1077 : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < m) -> _f i = false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (x__ : _b ≤ i) -> (__1 : i < _n + _b) -> _f i = false) -> Q_ (_n + _b) (not_found_min_spec _n _b _f x_1081)) (x_1075 : Nat) (x_1076 : min_spec _n _b _f x_1075) : Q_ x_1075 x_1076", "predict": "axiom min_spec_ind_body (_n _b : N) (_f : nat -> Bool) (Q_ : (x_1075 : N) -> (_x_1076 : min_spec _n _b _f x_1075) -> Bool) (_H_found_min_spec : (m : N) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (_n + _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : N) -> (Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) contradiction) -> (Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077))) (_H_not_found_min_spec : (x_1081 : (i : N) -> (Leq _b i) -> (__1 : Lt i (_n + _b)) -> Eq (_f i) contradiction) -> (Q_ (_n + _b) (not_found_min_spec _n _b _f x_1081))) (x_1075 : N) (x_1076 : min_spec _n _b _f x_1075) : Q_ x_1075 x_1076"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiv_mod_spec_rect_Type2. Soient $_n$ et $_m$ et $_q$ et $_r$ des nombres naturels. Soit $Q_$ une fonction des éléments $_x_825$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des éléments de $Type2$. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_827$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_826$ de $Eq$ de $_n$ et de $_q _m + _r$ à des éléments de $Q_$ de $div_mod_spec_intro (_n , _m , _q , _r , x_827 , x_826)$. Soit $x_825$ un élément de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$. Alors $Q_$ tient pour $x_825$.\nassistant\n", "label": "div_mod_spec_rect_Type2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_825 : div_mod_spec _n _m _q _r -> Type2) -> _H_div_mod_spec_intro : (x_827 : Lt _r _m -> x_826 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> x_825 : div_mod_spec _n _m _q _r -> Q_ x_825 .", "predict": "div_mod_spec_rect_Type2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_825 : div_mod_spec _n _m _q _r -> Type2) -> _H_div_mod_spec_intro : (x_827 : Lt _r _m -> x_826 : Eq _n (_q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> x_825 : div_mod_spec _n _m _q _r -> Q_ x_825 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nComm. Let $A$ be a set. Let $nil$ be an element of $A$. Then for all elements $xxx$ of $ACop$ of $A$ and $nil$, for all elements $a$ and $b$ of $A$, $op (A , nil , aop (A , nil , xxx), a , b)= op (A , nil , aop (A , nil , xxx), b , a)$.\nassistant\n", "label": "comm : A : Set -> nil : A -> xxx : ACop A nil -> a : A -> b : A -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a) .", "predict": "comm : A : Set -> nil : A -> xxx : ACop A nil -> a : A -> b : A -> op (A , nil , aop (A , nil , xxx) , a , b) = op (A , nil , aop (A , nil , xxx) , b , a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBigop_0. Let $n$ be a natural number. Let $B$ be a set. Then for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, $bigop$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to the sum of $i$ and $1$ and $f$ applied to $0$.\nassistant\n", "label": "bigop_0 : n : Nat -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> Eq (bigop (plus n (nd 1)) (i : Nat => true) B nil (op B nil op) (i : Nat => f i)) (op B nil op (bigop n (i : Nat => true) B nil (op B nil op) (i : Nat => f (plus i (nd 1)))) (f 0)) .", "predict": "bigop_0 : n : Nat -> B : Set -> nil : B -> op : Aop B nil -> f : (i : Nat -> B) -> bigop (n+1) (i : Nat => true) B nil (op B nil op) (i : Nat => f i) = op B nil op (bigop n (i : Nat => true) B nil (op B nil op) (i : Nat => f (i+1))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_max_to_pi_p_primeb. Soit $q , m \\in N$. Supposons que $0 < m$ et $q$ est inférieur à $max$ appliqué à la somme de $m$ et de $1$ et la fonction qui envoie $i$ à $andb$ appliqué à $primeb$ appliqué à $i$ et $dividesb$ appliqué à $i$ et $m$. Alors $bigop$ appliqué à $q$ et la fonction qui envoie $p$ à $andb$ appliqué à $primeb$ appliqué à $p$ et $dividesb$ appliqué à $p$ et $m$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à la puissance de $p$ et de $ord$ appliqué à $m$ et $p$ est égal à $m$.\nassistant\n", "label": "axiom lt_max_to_pi_p_primeb (q m : Nat) (x__ : 0 < m) (__1 : max (m + 1) (λ i => andb (primeb i) (dividesb i m)) < q) : m = bigop q (λ p => andb (primeb p) (dividesb p m)) Nat 1 times (λ p => pow p (ord m p))", "predict": "axiom lt_max_to_pi_p_primeb (q m : N) : (0 < m) -> (q < max (m + 1) (λ i => andb (primeb i) (dividesb i m))) -> bigop q (λ p => andb (primeb p) (dividesb p m)) Nat 1 times (λ p => power p (ord m p)) = m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_log_S. Soit $p , n \\in N$. Supposons que $1 < p$. Alors $\\log_ p {n}\\leq \\log_ p {n + 1}$.\nassistant\n", "label": "le_log_S : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> Leq (log p n) (log p (plus n (nd 1))) .", "predict": "le_log_S : p : N -> n : N -> 1 < p -> log_ p {n} <= log_ p {n + 1} ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLt_exp_to_lt1. Låt $a$ och $n$ och $m$ vara naturliga tal. Anta att $0 < a$. Anta att $n ^ a < m ^ a$. Då $n < m$.\nassistant\n", "label": "Axiom lt_exp_to_lt1 : forall a : nat, forall n : nat, forall m : nat, forall x__ : (0 < a), forall __1 : (pow n a < pow m a), n < m .", "predict": "Axiom lt_exp_to_lt1 : forall a : nat, forall n : nat, forall m : nat, 0 < a -> n ^ a < m ^ a -> n < m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nIso. For all sets $A$, $relation$ holds for $range (A)$.\nassistant\n", "label": "postulate iso : (A : Set) -> relation (range A)", "predict": "postulate iso : (A : Set) -> relation (range A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_inv_rect_Type4. Soit $x1$ un ensemble. Soit $x2$ un élément de $x1$. Soit $Hterm$ un élément de $Aop$ de $x1$ et de $x2$. Alors pour toutes les fonctions $P$ des éléments $_z1506$ de $Aop$ de $x1$ et de $x2$ à des éléments de $Type4$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments de $x1$ et des éléments $__1$ de $x1$ à des éléments de $x1$ et des fonctions $_nill$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op$ appliqué à $x2$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $x2$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ et des éléments $c$ de $x1$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ et des éléments $_z1507$ de $Eq$ de $Hterm$ et de $mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$ à des éléments de $P$ de $mk_Aop$ appliqué à $x1$ et $x2$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, $P$ tient pour $Hterm$.\nassistant\n", "label": "Axiom Aop_inv_rect_Type4 : forall x1 : Set, forall x2 : x1, forall Hterm : Aop x1 x2, forall P : ((_z1506 : Aop x1 x2) -> Type4), forall _H1 : ((op : (x__ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> op x2 a = a) -> (_nilr : (a : x1) -> op a x2 = a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> op a (op b c) = op (op a b) c) -> (_z1507 : Hterm = mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)), P Hterm .", "predict": "Axiom Aop_inv_rect_Type4 : forall x1 : Ensemble, forall x2 : Element x1, forall Hterm : Element Aop x1 x2, forall P : ((_z1506 : Aop x1 x2) -> Type4), forall _H1 : ((op : (x1 -> __1 : x1 -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)), P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$ and $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c \\in N$. Assume that $m n = p c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or equal to $b m - a p$ and the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Then if $b m - a p = 1$, then $m b - p a$ is equal to the greatest common divisor of $p$ and $m$.\nassistant\n", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m))) -> (b : Nat) -> (gcdp : Eq a p - b m) -> (gcdm : Eq b m - a p)) -> (b : Nat) -> (gcdp : Eq a p - b m) -> (gcdm : Eq b m - a p)) -> (b : Nat) -> (gcdp : Eq a p - b m) -> (gcdm : Eq b m - a p)) -> (b : Nat) -> (postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m))) -> (b : Nat) -> (gcdp : Eq a p - b m) -> (gcdm : Eq b m - a p)) -> (b : Nat) -> (postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m))) -> (b : Nat) -> (gcdp : Eq a p - b m) -> (gcdm : Eq b m - a p)) -> (b : Nat) -> (postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (diff (a * p) (b * m)) (gcd p m) (diff ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10131. Let $f$ be a function from natural numbers to booleans. Let $n , m , n0 \\in N$. Assume that $max (n0 + 1 , f)= m$. Assume that absurdity is equal to $f (m)$. Let $i , j \\in N$. Assume that $j + 1 < n0 + 1$. Let $x7 \\in N$. Then $x7 = m + x7$.\nassistant\n", "label": "let_clause_10131 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> n0 : Nat -> eqm : Eq (max (plus n0 (nd 1)) f) m -> fm : Eq (f m) false -> i : Nat -> j : Nat -> ltj : Lt (plus j (nd 1)) (plus n0 (nd 1)) -> x7 : Nat -> Eq x7 (plus m x7) .", "predict": "let_clause_10131 : f : (N -> Bool) -> n : N -> m : N -> n0 : N -> max (n0 + 1 , f) = m -> absurdity = f (m) -> i : N -> j : N -> j + 1 < n0 + 1 -> x7 : N -> x7 = m + x7 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_10335. Låt $n \\in N$. Anta att $0$ är mindre än $n$. Låt $x2515 , x2516 \\in N$. Då är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nassistant\n", "label": "Axiom let_clause_10335 : forall n : nat, forall posn : (0 < n), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_10335 : forall n : N, forall x2515 : N, forall x2516 : N, x2515 = (x2516 * (x2515 / x2516)) + mod x2515 x2516 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1258. Låt $b \\in N$. Då om $1$ är mindre än $b$, så för alla naturliga tal $n$, om produkten av potensen av $b$ och $n$ och $b$ är lika med $1$, så är produkten av $b$ och potensen av $b$ och $n$ lika med $1$.\nassistant\n", "label": "postulate let_clause_1258 : (b : Nat) -> (lt1b : Lt 1 b) -> (n : Nat) -> (H : Eq (times (pow b n) b) 1) -> Eq (times b (pow b n)) 1", "predict": "postulate let_clause_1258 : (b : N) -> (n : N) -> (b^n * b) == 1) -> (b * (b^n)) == 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15601. Låt $n , m \\in N$. Anta att $0$ är mindre än $m$. Då om $0$ är lika med $n$, så om $0$ är delbart med $m$, så för alla naturliga tal $q$, om $m$ är lika med produkten av $0$ och $q$, så är $n$ lika med $0$.\nassistant\n", "label": "let_clause_15601 : n : Nat -> m : Nat -> posn : Lt 0 m -> eqn0 : Eq 0 n -> _clearme : divisible 0 m -> q : Nat -> eqm : Eq m (times 0 q) -> Eq n 0 .", "predict": "let_clause_15601 : n : N -> m : N -> 0 < m -> 0 = n -> 0 % m -> q : N -> m = 0 * q -> n = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_to_congruent. Let $n , m , p \\in N$. Assume that $0$ is less than $p$. Assume that $m$ is less than or equal to $n$. Then if $p$ is divisible by the difference of $n$ and $m$, then $congruent$ holds for $n$ and $m$ and $p$.\nassistant\n", "label": "postulate divides_to_congruent : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Leq m n) -> (__2 : divisible p (minus n m)) -> congruent n m p", "predict": "postulate divides_to_congruent : (n : N) -> (m : N) -> (p : N) -> (0 : N) < p -> (m : N) <= n -> p : N -> congruent n m p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1575. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$. Låt $x1029$ vara ett naturligt tal. Då $x1029 = x1029 (n c - m d)$.\nassistant\n", "label": "Axiom let_clause_1575 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (c * n - d * m = 1), forall x1029 : nat, x1029 = x1029 * (n * c - m * d) .", "predict": "Axiom let_clause_1575 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ex Nat (fun d => Eq (Nat) (c n - d m) 1) (fun d => Eq (Nat) (d m - c n) 1), forall d : Nat, ((c n - d m) = 1) -> ((d m - c n) = 1) -> ((c n - d m) = 1), forall x1029 : Nat, x1029 = x1029 (n c - m d) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_max_n. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Alors pour tous les nombres naturels $n$, si $0$ est inférieur à $n$, alors $max$ appliqué à $n$ et $f$ est inférieur à $n$.\nassistant\n", "label": "axiom lt_max_n (f : (x__ : Nat) -> bool) (n : Nat) (x__ : 0 < n) : max n f < n", "predict": "axiom lt_max_n (f : Nat -> Bool) (n : Nat) : Bool := and (lt n 0) (lt (max n f) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_rect_CProp3_body. Låt $_n , _m , _q , _r \\in N$. Då för alla funktioner $Q_$ från element $_x_845$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden, för alla funktioner $_H_div_mod_spec_intro$ från element $x_847$ av $Lt$ av $_r$ och $_m$ och element $x_846$ av $Eq$ av $_n$ och summan av produkten av $_q$ och $_m$ och $_r$ till element av $Q_$ av $div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_847$ och $x_846$, för alla element $x_845$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_845$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp3_body (_n _m _q _r : Nat) (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_847 : _r < _m) -> (x_846 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) (x_845 : div_mod_spec _n _m _q _r) : Q_ x_845", "predict": "axiom div_mod_spec_rect_CProp3_body (_n _m _q _r : N) (Q_ : (_x_845 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_847 : Lt _r _m) -> (x_846 : Eq _n (sum _q _m _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) (x_845 : div_mod_spec _n _m _q _r) : Q_ x_845"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_16. Soit $n , m \\in N$. Supposons que $2 < m + 1$. Alors pour tous les nombres naturels $x32$, $x32 + 1 = x32 + 1$.\nassistant\n", "label": "postulate let_clause_16 : (n : Nat) -> (m : Nat) -> (lt2 : Lt 2 (plus m 1)) -> (x32 : Nat) -> Eq (plus x32 1) (plus x32 1)", "predict": "postulate let_clause_16 : (n : N) -> (m : N) -> (x32 : N) -> x32 + 1 = x32 + 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1561. Let $p , m , n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the difference of the product of $p$ and $a$ and the product of $m$ and $b$ is equal to $1$.\nassistant\n", "label": "Axiom let_clause_1561 : forall p : nat, forall m : nat, forall n : nat, forall posn : (0 < p), forall gcd1 : (gcd p m = 1), forall _clearme : divisible p (m * n), forall c : nat, forall nm : (m * n = p * c), forall a : nat, forall _clearme0 : ex nat (fun b => a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall b : nat, forall _clearme1 : (a * p - b * m = gcd p m \\/ b * m - a * p = gcd p m), forall H : (a * p - b * m = gcd p m), forall H0 : (a * p - b * m = 1), p * a - m * b = 1 .", "predict": "Axiom let_clause_1561 : forall p : N, forall m : N, forall n : N, forall c : N, forall a : N, forall _clearme0 : ((b : N) -> Eq (diff (product a p) (product b m)) (gcd p m) -> Eq (diff (product b m) (product a p)) (gcd p m)), forall b : N, ((diff (product a p) (product b m)) = (gcd p m) -> (diff (product b m) (product a p)) = (gcd p m) -> (diff (product a p) (product b m)) = 1 -> (diff (product p a) (product m b)) = 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1607. Let $m , n , a , b \\in N$. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that $c n - d m = 1$ or $d m - c n = 1$ and $d m - c n = 1$. Then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : (d : N) -> Eq (c n - d m) 1 || Eq (d m - c n) 1) -> (d : N) -> (m d - n c) == gcd m n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSub0_to_false. Let $h$ and $k$ be functions from natural numbers to natural numbers. Let $A$ be a set. Let $I$ and $J$ be elements of $range$ of $A$. Assume that $upto (A , I)= 0$. Let $__1$ be an element of $sub_hk$ of $h$ and $k$ and $A$ and $J$ and $I$. Let $i$ be a natural number. Then if $i < upto (A , J)$, then absurdity is equal to $filter (A , J , i)$.\nassistant\n", "label": "axiom sub0_to_false (h k : (x__ : Nat) -> Nat) (A : Set) (I J : range A) (x__ : upto A I = 0) (__1 : sub_hk h k A J I) (i : Nat) (__2 : i < upto A J) : filter A J i = false", "predict": "axiom sub0_to_false (h k : (x : Nat) -> Nat) (A : Set) (I J : range A) (__1 : sub_hk h k A J I) (i : Nat) : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15441. Låt $p , q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m$ och $n$ vara naturliga tal. Anta att $0 < n$. Anta att $n \\leq m$. Anta att $n \\leq q + 1$. Anta att $n$ inte är delbart med $m$. Låt $a$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Låt $b \\in N$. Anta att $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ eller $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Anta att $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$. Då $n b - a mod (m , n)= gcd_aux (q ,", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_15441 : (p : N) -> (q : N) -> (Hind : (m : N) -> (n : N) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> disjunktion (Eq (skillnaden (produkten a n) (produkten b m)) (gcd_aux q m n)) (Eq (skillnaden (produkten b m) (produkten a n)) (gcd_aux q m n)))) -> (m : N) -> (n : N) -> (0 : N) -> (n : N) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> disjunktion (Eq (skillnaden (a (mod m n)) (b n)) (gcd_aux q n (mod m n))) (Eq (skillnaden (b n) (a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : N) -> (n : N) -> (a : Nat) -> (_clearme : n <= q + 1) -> (n : Nat) -> (m : Nat) -> (0 : Nat) -> (n : Nat) -> (a : Nat) -> (_clearme : n <= m) -> (n : Nat) -> (q : Nat) -> (n : Nat) -> (m : Nat) -> (0 : Nat) -> (n : Nat) -> (a : Nat) -> (_clearme : n <= q + 1) -> (n : Nat) -> (m : Nat) -> (0 : Nat) -> (n : Nat) -> (a : Nat) -> (_postulate let_clause_15441 : (p : N) -> (q : N) -> (Hind : (m : N) -> (n : N) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> disjunktion (Eq (skillnaden (produkten a n) (produkten b m)) (gcd_aux q m n)) (Eq (skillnaden (produkten b m) (produkten a n)) (gcd_aux q m n)))) -> (m : N) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nBc_n_O. Soit $n \\in N$. Alors $bc (n , 0)= 1$.\nassistant\n", "label": "Axiom bc_n_O : forall n : nat, bc n 0 = 1 .", "predict": "Axiom bc_n_O : forall n : N, bc (n , 0) = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSub_hkO. Soient $h$ et $k$ des fonctions des nombres naturels à des nombres naturels. Soit $A$ un ensemble. Soient $I$ et $J$ des éléments de $range$ de $A$. Supposons que $upto (A , I)= 0$. Alors $sub_hk$ tient pour $h$ et $k$ et $A$ et $I$ et $J$.\nassistant\n", "label": "postulate sub_hkO : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> sub_hk h k A I J", "predict": "postulate sub_hkO : (h : Nat -> Nat) -> (k : Nat -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> upto (A , I) == 0 -> sub_hk h k A I J"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nF_false_to_le_max. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $n$ et $p$ des nombres naturels. Soit $__$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de $Eq$ appliqué à $f$ appliqué à $i$ et $true$. Soit $__1$ une fonction des nombres naturels $m$ et des éléments $__1$ de $Lt$ de $p$ et de $m$ à des éléments de $Eq$ de $f (m)$ et de contradiction. Alors $max (n , f)\\leq p$.\nassistant\n", "label": "axiom f_false_to_le_max (f : (x__ : Nat) -> bool) (n p : Nat) (x__ : ex Nat (λ i => i < n ∧ f i = true)) (__1 : (m : Nat) -> (__1 : p < m) -> f m = false) : max n f ≤ p", "predict": "axiom f_false_to_le_max (f : Nat -> Bool) (n p : Nat) (__ : ex Nat (λ i => Lt i n ∧ Eq (f i) true)) (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) contradiction) : Natleq (max n (f)) p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_16005. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "Axiom let_clause_16005 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c .", "predict": "Axiom let_clause_16005 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ((d : Nat) -> Eq (c * n - d * m) 1) -> (d : Nat) -> Eq (d * m - c * n) 1), forall d : Nat, ((c * n - d * m) = 1) -> (d * m - c * n) = 1 -> m * d - n * c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_to_mod. Låt $n$ och $m$ vara naturliga tal. Då om $n < m$, så $n = mod (n , m)$.\nassistant\n", "label": "Axiom le_to_mod : forall n : nat, forall m : nat, forall x__ : (n < m), n = mod n m .", "predict": "Axiom le_to_mod : forall n : nat, forall m : nat, nat -> nat -> nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDivides_gcd_aux_mn. Pour tous les nombres naturels $p$ et $m$ et $n$, si $0$ est inférieur à $n$, alors si $n$ est inférieur ou ágal à $m$, alors si $n$ est inférieur ou ágal à $p$, alors $gcd_aux$ appliqué à $p$ et $m$ et $n$ est divisible par $m$ et $gcd_aux$ appliqué à $p$ et $m$ et $n$ est divisible par $n$.\nassistant\n", "label": "axiom divides_gcd_aux_mn (p m n : Nat) (x__ : 0 < n) (__1 : n ≤ m) (__2 : n ≤ p) : divisible (gcd_aux p m n) m ∧ divisible (gcd_aux p m n) n", "predict": "axiom divides_gcd_aux_mn (p m n : Nat) : (0 < n) -> (n < m) -> (n < p) -> gcd_aux p m n % m -> gcd_aux p m n % n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_ind_body. Let $_n$ be a natural number. Then for all functions $Q_$ from natural numbers $x_417$ and elements $_x_418$ of $Leq$ of $_n$ and $x_417$ to propositions, for all elements $_H_le_n$ of $Q_$ of $_n$ and $le_n$ applied to $_n$, for all functions $_H_le_S$ from natural numbers $m$ and elements $x_419$ of $Leq$ of $_n$ and $m$ and elements $_x_421$ of $Q_$ of $m$ and $x_419$ to elements of $Q_$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $x_419$, for all natural numbers $x_417$, if $_n$ is less than or equal to $x_417$, then $Q_$ holds for $x_417$ and $x_418$.\nassistant\n", "label": "Axiom le_ind_body : forall _n : nat, forall Q_ : ((x_417 : nat) -> (_x_418 : Leq _n x_417) -> Prop), forall _H_le_n : Q_ _n (le_n _n), forall _H_le_S : ((m : nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (m + 1) (le_S _n m x_419)), forall x_417 : nat, forall x_418 : Leq _n x_417, Q_ x_417 x_418 .", "predict": "Axiom le_ind_body : forall _n : nat, forall Q_ : ((x_417 : nat) -> (_x_418 : Leq _n x_417) -> Prop), forall _H_le_n : Q_ _n (le_n _n), forall _H_le_S : ((m : nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (m + 1) (le_S _n m x_419)), forall x_417 : nat, forall _n : nat, _n <= x_417 -> Q_ x_417 x_418 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_inv_S. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $l$ vara ett naturligt tal. Låt $b1$ och $b2$ vara element av $B$. Låt $__$ vara ett element av $lstar$ av $B$ och $R$ och $l$ och $b1$ och $b2$. Låt $l0$ vara ett naturligt tal. Anta att $l0 + 1 = l$. Då håller $ex2$ för $B$ och funktionen som avbildar $b$ som $R (b1 , b)$ och funktionen som avbildar $b$ som $lstar (B , R , l0 , b , b2)$.\nassistant\n", "label": "lstar_inv_S : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar B R l b1 b2 -> l0 : Nat -> __1 : Eq (plus l0 (nd 1)) l -> ex2 B (b : B => R b1 b) (b : B => lstar B R l0 b b2) .", "predict": "lstar_inv_S : B : set -> R : relation B -> l : nat -> b1 : B -> b2 : B -> __ : lstar B R l b1 b2 -> l0 : nat -> l0 + 1 = l -> ex2 : B -> (b : B -> R (b1 , b)) -> (b : B -> lstar (B , R , l0 , b , b2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1062. Let $a , b , q , r , q1 , r1 \\in N$. Then for all elements $_clearme$ of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$, if $r < b$ and $a = q b + r$, then for all elements $_clearme0$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, if $r1 < b$ and $a = q1 b + r1$, then if $q$ is not less than or equal to $q1$, then $a = r1 + b q1$.\nassistant\n", "label": "let_clause_1062 : a : Nat -> b : Nat -> q : Nat -> r : Nat -> q1 : Nat -> r1 : Nat -> _clearme : div_mod_spec a b q r -> ltrb : Lt r b -> spec : Eq a (plus (times q b) r) -> _clearme0 : div_mod_spec a b q1 r1 -> ltr1b : Lt r1 b -> spec1 : Eq a (plus (times q1 b) r1) -> leqq1 : not (Leq q q1) -> Eq a (plus r1 (times b q1)) .", "predict": "let_clause_1062 : a : N -> b : N -> q : N -> r : N -> q1 : N -> r1 : N -> _clearme : div_mod_spec a b q r -> r < b -> a = q b + r -> _clearme0 : div_mod_spec a b q1 r1 -> r1 < b -> a = q1 b + r1 -> q > q1 -> a = r1 + b q1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1607. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nassistant\n", "label": "Axiom let_clause_1607 : forall m : nat, forall n : nat, forall a : nat, forall b : nat, forall posn : (0 < n), forall posm : (0 < m), forall pnm : (gcd n m = 1), forall c : nat, forall _clearme : ex nat (fun d => c * n - d * m = 1 \\/ d * m - c * n = 1), forall d : nat, forall _clearme0 : (c * n - d * m = 1 \\/ d * m - c * n = 1), forall H : (d * m - c * n = 1), gcd m n = m * d - n * c .", "predict": "Axiom let_clause_1607 : forall m : Nat, forall n : Nat, forall a : Nat, forall b : Nat, forall c : Nat, forall _clearme : ((d : Nat) -> Eq (c n - d m) 1) -> (d : Nat) -> Eq (d m - c n) 1), forall d : Nat, ((c n - d m) = 1) -> (d m - c n) -> m d - n c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDividesb_true_to_divides. För alla naturliga tal $n$ och $m$, om $dividesb (n , m)= true$, så är $n$ delbart med $m$.\nassistant\n", "label": "dividesb_true_to_divides : n : Nat -> m : Nat -> __ : Eq (dividesb n m) true -> divisible n m .", "predict": "dividesb_true_to_divides : n : Nat -> m : Nat -> dividesb (n , m) = true -> n : Divides m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMod_O_to_divides. Låt $n , m \\in N$. Anta att $0$ är mindre än $n$. Då om $mod$ applicerat på $m$ och $n$ är lika med $0$, så är $n$ delbart med $m$.\nassistant\n", "label": "mod_O_to_divides : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Eq (mod m n) 0 -> divisible n m .", "predict": "mod_O_to_divides : n : N -> m : N -> 0 < n -> mod m n = 0 -> n divides m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDivides_to_dividesb_true1. Soient $n$ et $m$ des nombres naturels. Supposons que $0$ est inférieur à $m$. Alors si $n$ est divisible par $m$, alors $dividesb$ appliqué à $n$ et $m$ est égal à $true$.\nassistant\n", "label": "axiom divides_to_dividesb_true1 (n m : Nat) (x__ : 0 < m) (__1 : divisible n m) : dividesb n m = true", "predict": "axiom divides_to_dividesb_true1 (n m : Nat) : (0 < m) -> (n % m = 0) -> dividesb n m = true"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLstar_r_inv_ind. Soit $x1$ un ensemble. Soit $x2$ un élément de $relation$ de $x1$. Soit $x3 \\in N$. Soient $x4$ et $x5$ des éléments de $x1$. Soit $_Hterm$ un élément de $lstar_r$ de $x1$ et de $x2$ et de $x3$ et de $x4$ et de $x5$. Soit $P$ une fonction des nombres naturels $_z2386$ et des éléments $_z2385$ de $x1$ et des éléments $_z2384$ de $x1$ à des propositions. Soit $_H1$ une fonction des éléments $b$ de $x1$ et des éléments $_z2389$ de $Eq$ de $x3$ et de $0$ et des éléments $_z2388$ de $Eq$ de $x4$ et de $b$ et des éléments $_z2387$ de $Eq$ de $x5$ et de $b$ à des éléments de $P$ de $0$ et de $b$ et de $b$. Soit $_H2$ une fonction des nombres naturels $l$ et des éléments $b1$ de $x1$ et des éléments $b$ de $x1$ et des éléments $_x_1340$ de $lstar_r$ de $x1$ et de $x2$ et de $l$ et de $b1$ et de $b$ et des éléments $b2$ de $x1$ et des éléments $_x_1339$ de $x2$ de $b$ et de $b2$ et des fonctions $_x_1342$ des éléments $_z2389$ de $Eq$ de $x3$ et de $l$ et des éléments $_z2388$ de $Eq$ de $x4$ et de $b1$ et des éléments $_z2387$ de $Eq$ de $x5$ et de $b$ à des éléments de $P$ de $l$ et de $b1$ et de $b$ et des éléments $_z2389$ de $Eq$ de $x3$ et de $l + 1$ et des éléments $_z2388$ de $Eq$ de $x4$ et de $b1$ et des éléments $_z2387$ de $Eq$ de $x5$ et de $b2$ à des éléments de $P$ de $l + 1$ et de $b1$ et de $b2$. Alors $P$ tient pour $x3$ et $x4$ et $x5$.\nassistant\n", "label": "axiom lstar_r_inv_ind (x1 : Set) (x2 : relation x1) (x3 : Nat) (x4 x5 : x1) (_Hterm : lstar_r x1 x2 x3 x4 x5) (P : (_z2386 : Nat) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) (_H1 : (b : x1) -> (_z2389 : x3 = 0) -> (_z2388 : x4 = b) -> (_z2387 : x5 = b) -> P 0 b b) (_H2 : (l : Nat) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : x3 = l) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b) -> P l b1 b) -> (_z2389 : x3 = l + 1) -> (_z2388 : x4 = b1) -> (_z2387 : x5 = b2) -> P (l + 1) b1 b2) : P x3 x4 x5", "predict": "axiom lstar_r_inv_ind (x1 : Set) (x2 : relation x1) (x3 : N) (x4 x5 : x1) (_Hterm : lstar_r x1 x2 x3 x4 x5) (P : (_z2386 : N) -> (_z2385 : x1) -> (_z2384 : x1) -> Prop) (_H1 : (b : x1) -> (_z2389 : Eq x3 0) -> (_z2388 : Eq x4 b) -> (_z2387 : Eq x5 b) -> P 0 b b) (_H2 : (l : N) -> (b1 : x1) -> (b : x1) -> (_x_1340 : lstar_r x1 x2 l b1 b) -> (b2 : x1) -> (_x_1339 : x2 b b2) -> (_x_1342 : (_z2389 : Eq x3 l) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b) -> P l b1 b) -> (_z2389 : Eq x3 (l + 1)) -> (_z2388 : Eq x4 b1) -> (_z2387 : Eq x5 b2) -> P (l + 1) b1 b2)) : P x3 x4 x5"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_S. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $n$ is less than or equal to the sum of $m$ and $1$.\nassistant\n", "label": "postulate le_S : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Leq n (plus m 1)", "predict": "postulate le_S : (n : Set) -> (m : Set) -> n <= m -> n <= (m + 1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1033. Let $n$ be a natural number. Assume that $2 ^ 7 \\leq n$. Let $p \\in N$. Assume that $\\sqrt{ (2 n)}+ 1 \\leq p$ and $p < 2 n + 1$. Then if $leb (2 , k (2 n , p))= true$ and $2 n < p ^ 2$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "Axiom let_clause_1033 : forall n : nat, forall len : Leq (pow 2 7) n, forall p : nat, forall lep : Leq (sqrt (2 * n) + 1) p, forall ltp : (p < 2 * n + 1), forall Hc : (leb 2 (k (2 * n) p) = true), forall H2n : (2 * n < pow p 2), forall x2515 : nat, forall x2516 : nat, x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516 .", "predict": "Axiom let_clause_1033 : forall n : nat, forall p : N, forall x2515 : nat, forall x2516 : nat, (2 ^ 7 <= n -> sqrt (2 * n) + 1 <= p -> p < 2 * n + 1 -> leb (2 , k (2 * n , p)) = true -> 2 * n < p ^ 2 -> x2515 = x2516 (x2515 div x2516) + mod (x2515 , x2516)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTimes_Sn_m. Let $n$ and $m$ be natural numbers. Then the sum of $m$ and the product of $n$ and $m$ is equal to the product of the sum of $n$ and $1$ and $m$.\nassistant\n", "label": "axiom times_Sn_m (n m : Nat) : m + n * m = (n + 1) * m", "predict": "axiom times_Sn_m (n m : Nat) : Nat := (n + 1) * m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_10471. Let $n1$ and $n2$ be natural numbers. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f1$ and $f2$ be functions from natural numbers to elements of $B$. Then for all elements $_clearme$ of $iso$ of $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, for all functions $h$ from natural numbers to natural numbers, for all elements $_clearme0$ of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$, for all functions $k$ from natural numbers to natural numbers, if $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1", "predict": "postulate let_clause_10471 : (n1 : Natural) -> (n2 : Natural) -> (p1 : (i : Natural) -> Boolean) -> (p2 : (i : Natural) -> Boolean) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (i : Natural) -> B) -> (f2 : (i : Natural) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (i : Natural) -> Natural) -> (_clearme0 : ex (prod Set Set Nat (\\ __ : Natural -> Nat)) (\\ k : Natural -> conjunction (conjunction (prod Set Prop Nat (\\ i : Natural -> prod Prop Prop (Lt i n1) (\\ __ : Prop -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Prop -> Eq (f1 i) (f2 (h i))))) (sub_hk h k) B) (mk_range B f1 n1 p1))) -> (k : (i : Natural) -> Natural) -> prod Set Prop Nat (\\ i : Natural -> Prod Prop Prop (Lt i n1) (\\ __ : Prop -> Prod Prop Prop (Eq (p1 i) true) (\\ __1 : Prop -> Eq (f1 i) (f2 (h i)))))) -> mklet_clause_10471 : (n1 : Natural) -> (n2 : Natural) -> (p1 : (i : Natural) -> Boolean) -> (p2 : (i : Natural) -> Boolean) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (i : Natural) -> B) -> (f2 : (i : Natural) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (i : Natural) -> Natural) -> (_clearme0 : ex (prod Set Set Nat (\\ __ : Natural -> Nat)) (\\ k : Natural -> conjunction (conjunction (prod Set Prop Nat (\\ i : Natural -> prod Prop Prop (Lt i n1) (\\ __ : Prop -> prod Prop Prop (Eq (p1 i) true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMin_f_g. Låt $f$ och $g$ vara funktioner från naturliga tal till sanningsvärden. Låt $n$ och $b$ vara naturliga tal. Låt $__$ vara en funktion från naturliga tal $i$ och element av $Leq$ av $b$ och $i$ och element $__1$ av $Lt$ av $i$ och summan av $n$ och $b$ till element av $Eq$ av $f$ applicerat på $i$ och $g$ applicerat på $i$. Då är $min$ applicerat på $n$ och $b$ och $f$ lika med $min$ applicerat på $n$ och $b$ och $g$.\nassistant\n", "label": "postulate min_f_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) (g i)) -> Eq (min n b f) (min n b g)", "predict": "postulate min_f_g : (f : (i : Nat) -> Bool) -> (g : (i : Nat) -> Bool) -> (n : Nat) -> (b : Nat) -> (__ : (i : Nat) -> (__1 : Lt i (sum n b)) -> Eq (f i) (g i))) -> min n b f == min n b g"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nS_pred. Låt $n \\in N$. Då om $0$ är mindre än $n$, så är summan av $pred$ applicerat på $n$ och $1$ lika med $n$.\nassistant\n", "label": "axiom S_pred (n : Nat) (x__ : 0 < n) : pred n + 1 = n", "predict": "axiom S_pred (n : N) : Summation (pred n) 1 = n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMax_spec_inv_ind. Let $x1$ be a natural number. Then for all functions $x2$ from natural numbers to booleans, for all natural numbers $x3$, for all elements $_Hterm$ of $max_spec$ of $x1$ and $x2$ and $x3$, for all functions $P$ from natural numbers $_z1769$ to propositions, for all functions $_H1$ from natural numbers $m$ and elements $_x_975$ of $Lt$ of $m$ and $x1$ and elements $_x_974$ of $Eq$ of $x2$ applied to $m$ and $true$ and functions $_x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $x1$ to elements of $Eq$ of $x2$ applied to $i$ and absurdity and elements $_z1770$ of $Eq$ of $x3$ and $m$ to elements of $P$ of $m$, for all functions $_H2$ from functions $_x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $x1$ to elements of $Eq$ of $x2$ applied to $i$ and absurdity and elements $_z1770$ of $Eq$ of $x3$ and $0$ to elements of $P$ of $0$, $P$ holds for $x3$.\nassistant\n", "label": "Axiom max_spec_inv_ind : forall x1 : nat, forall x2 : ((x__ : nat) -> bool), forall x3 : nat, forall _Hterm : max_spec x1 x2 x3, forall P : ((_z1769 : nat) -> Prop), forall _H1 : ((m : nat) -> (_x_975 : m < x1) -> (_x_974 : x2 m = true) -> (_x_973 : (i : nat) -> (x__ : m < i) -> (__1 : i < x1) -> x2 i = false) -> (_z1770 : x3 = m) -> P m), forall _H2 : ((_x_976 : (i : nat) -> (x__ : i < x1) -> x2 i = false) -> (_z1770 : x3 = 0) -> P 0), P x3 .", "predict": "Axiom max_spec_inv_ind : forall x1 : nat, forall x2 : ((m : nat) -> bool), forall x3 : nat, forall _Hterm : max_spec x1 x2 x3, forall P : ((_z1769 : nat) -> Prop), forall _H1 : ((m : nat) -> (_x_975 : Lt m x1) -> (_x_974 : Eq (x2 m) true) -> (_x_973 : (i : nat) -> (__1 : Lt i x1) -> Eq (x2 i) absurdity) -> (_z1770 : Eq x3 m) -> P m), forall _H2 : ((_x_976 : (i : nat) -> Lt i x1) -> (_z1770 : Eq x3 0) -> P 0), P x3 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1047. Låt $k , n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara en funktion från element av $B$ och element $__1$ av $B$ till element av $B$. Låt $f$ vara en funktion från naturliga tal till element av $B$. Anta att $n \\leq k$. Låt $j \\in N$. Anta att $n \\leq j$. Låt $Hind$ vara en funktion från funktioner från naturliga tal $i$ och element av $Leq$ av $n$ och $i$ och element $__1$ av $Lt$ av $i$ och $j$ till element av $Eq$ av $p (i)$ och kontradiktion till element av $Eq$ av $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $bigop$ applicerat på $j$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$. Då för alla funktioner $Hfalse$ från naturliga tal $i$ och element av $Leq$ av $n$ och $i$ och element $__1$ av $Lt$ av $i$ och $j + 1$ till element av $Eq$ av $p (i)$ och kontradiktion, för alla naturliga tal $x2571$ och $x2572$, $x2571 = x2572 (x2571 \\div x2572)+ mod (x2571 , x2572)$.\nassistant\n", "label": "axiom let_clause_1047 (k n : Nat) (p : (x__ : Nat) -> bool) (B : Set) (nil : B) (op : (x__ : B) -> (__1 : B) -> B) (f : (x__ : Nat) -> B) (lenk : n ≤ k) (j : Nat) (leup : n ≤ j) (Hind : (x__ : (i : Nat) -> (x__ : n ≤ i) -> (__1 : i < j) -> p i = false) -> bigop n (λ i => p i) B nil op (λ i => f i) = bigop j (λ i => p i) B nil op (λ i => f i)) (Hfalse : (i : Nat) -> (x__ : n ≤ i) -> (__1 : i < j + 1) -> p i = false) (x2571 x2572 : Nat) : x2571 = x2572 * (x2571 / x2572) + mod x2571 x2572", "predict": "axiom let_clause_1047 (k n : N) (p : (i : N) -> Bool) (B : Set) (nil : B) (op : (__1 : B) -> (i : N) -> B) (f : (i : N) -> B) (j : N) (Hind : (i : N) -> (__1 : Lt i j) -> Eq (p i) (contradiction)) (bigop : (n : N) -> (i : N) -> B -> Nil B -> Op B -> (i : N) -> B) (Hfalse : (i : N) -> (__1 : Leq n i) -> (__2 : Lt i (j + 1)) -> Eq (p i) (contradiction)) (x2571 x2572 : Nat) : x2571 = x2572 (x2571 \\div x2572) + mod (x2571 , x2572)) : Bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAop_rect_CProp1. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_883$ av $Aop$ av $A$ och $_nil$ till påståenden. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Låt $x_883$ vara ett element av $Aop$ av $A$ och $_nil$. Då håller $Q_$ för $x_883$.\nassistant\n", "label": "postulate Aop_rect_CProp1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_883 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_883 : Aop A _nil) -> Q_ x_883", "predict": "postulate Aop_rect_CProp1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_883 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (__ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_883 : Aop A _nil) -> Q_ x_883"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nPrime_to_primeb_true. Pour tous les nombres naturels $n$, si $n$ est premier, alors $primeb$ appliqué à $n$ est égal à $true$.\nassistant\n", "label": "prime_to_primeb_true : n : Nat -> __ : prime n -> Eq (primeb n) true .", "predict": "prime_to_primeb_true : n : Nat -> primeb n = true ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBigop_diff. Let $p$ be a function from natural numbers to booleans. Then for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $ACop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, for all natural numbers $i$ and $n$, if $i < n$ and $p (i)= true$, then $aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $bigop$ applied to $n$ and the function that maps $x$ to $andb$ applied to $notb$ applied to $eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ is equal to $bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$.\nassistant\n", "label": "bigop_diff : p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (__ : Nat -> B) -> i : Nat -> n : Nat -> __ : Lt i n -> __1 : Eq (p i) true -> Eq (bigop n (x : Nat => p x) B nil (aop__o__op B nil op) (x : Nat => f x)) (aop__o__op B nil op (f i) (bigop n (x : Nat => andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (x : Nat => f x))) .", "predict": "bigop_diff : p : (Nat -> Bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (Nat -> B) -> i : Nat -> n : Nat -> i < n -> p (i) = true -> aop__o__op : (B -> nil -> op) -> (f i) -> bigop : (n : Nat -> (x : Nat -> andb (notb (eqb i x)) (p x)) -> B -> nil -> aop__o__op) -> (x : Nat -> f x) -> bigop n (x : Nat => p x) B nil (aop__o__op B nil op) (x : Nat => f x) = bigop n (x : Nat => p x) B nil (aop__o__op B nil op) (x : Nat => f x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDiv_mod_spec_rect_CProp4_body. Soit $_n , _m , _q , _r \\in N$. Soit $Q_$ une fonction des éléments $_x_837$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_839$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_838$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_839$ et $x_838$. Alors pour tous les éléments $x_837$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_837$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp4_body (_n _m _q _r : Nat) (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_839 : _r < _m) -> (x_838 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) (x_837 : div_mod_spec _n _m _q _r) : Q_ x_837", "predict": "axiom div_mod_spec_rect_CProp4_body (_n _m _q _r : N) (Q_ : (_x_837 : div_mod_spec _n _m _q _r) -> Prop) (_H_div_mod_spec_intro : (x_839 : Lt _r _m) -> (x_838 : Eq _n (product _q _m _r)) -> (Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838))) (x_837 : div_mod_spec _n _m _q _r) : Q_ x_837"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLe_to_mod. Soient $n$ et $m$ des nombres naturels. Supposons que $n < m$. Alors $n = mod (n , m)$.\nassistant\n", "label": "axiom le_to_mod (n m : Nat) (x__ : n < m) : n = mod n m", "predict": "axiom le_to_mod (n m : Nat) : n < m -> n = mod n m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMin_not_exists. Let $f$ be a function from natural numbers to booleans. Let $n , b \\in N$. Then for all functions $__$ from natural numbers $i$ and elements of $Leq$ of $b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $n$ and $b$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, $min$ applied to $n$ and $b$ and $f$ is equal to the sum of $n$ and $b$.\nassistant\n", "label": "axiom min_not_exists (f : (x__ : Nat) -> bool) (n b : Nat) (x__ : (i : Nat) -> (x__ : b ≤ i) -> (__1 : i < n + b) -> f i = false) : min n b f = n + b", "predict": "axiom min_not_exists (f : Nat -> Bool) (n b : Nat) (__ : (i : Nat) -> (__1 : Lt i (n + b)) -> Eq (f i) absurdity) : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat : Nat :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_inv_S_dx. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $l \\in N$. Då för alla element $b1$ och $b2$ av $B$, för alla element $__$ av $lstar$ av $B$ och $R$ och summan av $l$ och $1$ och $b1$ och $b2$, håller $ex2$ för $B$ och funktionen som avbildar $b$ som $lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b$ och funktionen som avbildar $b$ som $R$ applicerat på $b$ och $b2$.\nassistant\n", "label": "lstar_inv_S_dx : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar B R (plus l (nd 1)) b1 b2 -> ex2 B (b : B => lstar B R l b1 b) (b : B => R b b2) .", "predict": "lstar_inv_S_dx : B : set -> R : relation B -> l : N -> b1 : B -> b2 : B -> __ : lstar B R (l+1) b1 b2 -> ex2 : B -> (b : B -> lstar B R l b1 b) -> (b : B -> R b b2) -> ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nP_ord_aux_to_exp. Soient $p$ et $n$ et $m$ et $q$ et $r$ des nombres naturels. Supposons que $0 < m$. Supposons que $p_ord_aux (p , n , m)= mk_Prod (Nat , Nat , q , r)$. Alors $n = m ^ q r$.\nassistant\n", "label": "Axiom p_ord_aux_to_exp : forall p : nat, forall n : nat, forall m : nat, forall q : nat, forall r : nat, forall x__ : (0 < m), forall __1 : (p_ord_aux p n m = mk_Prod nat nat q r), n = pow m q * r .", "predict": "Axiom p_ord_aux_to_exp : forall p : Nat, forall n : Nat, forall m : Nat, forall q : Nat, forall r : Nat, 0 < m -> mk_Prod (Nat , Nat , q , r) -> n = m ^ q r ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1575. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$. Let $x1029$ be a natural number. Then $x1029$ is equal to the product of $x1029$ and the difference of the product of $n$ and $c$ and the product of $m$ and $d$.\nassistant\n", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (_clearme : (d : Nat) -> Eq (difference (product c n) (product d m)) 1) -> (d : Nat) -> (x1029 : Nat) -> Eq (x1029) (product x1029 (difference (product c n) (product d m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_n_Sm_elim. Pour tous les nombres naturels $n$ et $m$, si $n$ est inférieur ou ágal à la somme de $m$ et de $1$, alors pour toutes les propositions $P$, pour toutes les fonctions $__1$ des éléments $__1$ de $Leq$ de la somme de $n$ et de $1$ et de la somme de $m$ et de $1$ à des éléments de $P$, pour toutes les fonctions $__2$ des éléments $__2$ de $Eq$ de $n$ et de la somme de $m$ et de $1$ à des éléments de $P$, $P$.\nassistant\n", "label": "Axiom le_n_Sm_elim : forall n : nat, forall m : nat, forall x__ : Leq n (m + 1), forall P : Prop, forall __1 : ((__1 : Leq (n + 1) (m + 1)) -> P), forall __2 : ((__2 : n = m + 1) -> P), P .", "predict": "Axiom le_n_Sm_elim : forall n : nat, forall m : nat, forall P : Prop, forall __1 : ((__1 : Leq (n + 1) (m + 1)) -> P), forall __2 : ((__2 : Eq n (m + 1)) -> P), P ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1033. Låt $n \\in N$. Anta att $2 ^ 7 \\leq n$. Låt $p \\in N$. Anta att $\\sqrt{ (2 n)}+ 1 \\leq p$. Anta att $p < 2 n + 1$. Anta att $leb (2 , k (2 n , p))= true$. Då om $2 n < p ^ 2$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant\n", "label": "let_clause_1033 : n : Nat -> len : Leq (pow (nd 2) (nd 7)) n -> p : Nat -> lep : Leq (plus (sqrt (times (nd 2) n)) (nd 1)) p -> ltp : Lt p (plus (times (nd 2) n) (nd 1)) -> Hc : Eq (leb (nd 2) (k (times (nd 2) n) p)) true -> H2n : Lt (times (nd 2) n) (pow p (nd 2)) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .", "predict": "let_clause_1033 : n : N -> p : N -> 2 ^ 7 <= n -> sqrt (2 n) + 1 <= p -> p < 2 n + 1 -> leb (2 , k (2 n , p)) = true -> 2 n < p ^ 2 -> x2515 : N -> x2516 : N -> x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_ind. For all functions $Q_$ from natural numbers $_x_365$ to propositions, for all elements $_H_O$ of $Q_$ of $0$, for all functions $_H_S$ from natural numbers $x_366$ and elements $_x_368$ of $Q_$ of $x_366$ to elements of $Q_$ of the sum of $x_366$ and $1$, for all natural numbers $x_365$, $Q_$ holds for $x_365$.\nassistant\n", "label": "Axiom nat_ind : forall Q_ : ((_x_365 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_366 : nat) -> (_x_368 : Q_ x_366) -> Q_ (x_366 + 1)), forall x_365 : nat, Q_ x_365 .", "predict": "Axiom nat_ind : forall Q_ : ((_x_365 : nat) -> Prop), forall _H_O : Q_ 0, forall _H_S : ((x_366 : nat) -> (_x_368 : Q_ x_366) -> Q_ (x_366 + 1)), forall x_365 : nat, Q_ x_365 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nP_ord_times. Låt $p$ och $a$ och $b$ och $qa$ och $ra$ och $qb$ och $rb$ vara naturliga tal. Anta att $p$ är primt. Då om $0 < a$, så om $0 < b$, så om $p_ord (a , p)= mk_Prod (Nat , Nat , qa , ra)$, så om $p_ord (b , p)= mk_Prod (Nat , Nat , qb , rb)$, så $p_ord (a b , p)= mk_Prod (Nat , Nat , qa + qb , ra rb)$.\nassistant\n", "label": "p_ord_times : p : Nat -> a : Nat -> b : Nat -> qa : Nat -> ra : Nat -> qb : Nat -> rb : Nat -> __ : prime p -> __1 : Lt 0 a -> __2 : Lt 0 b -> __3 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra) -> __4 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb)) .", "predict": "p_ord_times : p : Nat -> a : Nat -> b : Nat -> qa : Nat -> ra : Nat -> qb : Nat -> rb : Nat -> p_ord (a , p) = mk_Prod (Nat , Nat , qa , ra) -> p_ord (b , p) = mk_Prod (Nat , Nat , qb , rb) -> p_ord (a b , p) = mk_Prod (Nat , Nat , qa + qb , ra rb) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_16171. Let $p , m , n \\in N$. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Assume that $m n = p c$. Let $a$ be a natural number. Then for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if $b m - a p = 1$, then $m b - p a$ is equal to the greatest common divisor of $p$ and $m$.\nassistant\n", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m))) -> (b : N) -> (_gcdp_m : N) -> (_bma_p : N) -> (_bma_p_1 : N) -> (_postulate let_clause_16171 : (p : N) -> (m : N) -> (n : N) -> (c : N) -> (a : N) -> (_clearme0 : ex Nat (\\ b : N -> Eq (diff (a * p) (b * m)) (gcd p m) (diff (b * m) (a * p)) (gcd p m))) -> (b : N) -> (_gcdp_m : N) -> (_bma_p : N) -> (_bma_p_1 : N) -> (_bma_p_2 : N) -> (_bma_p_3 : N) -> (_bma_p_4 : N) -> (_bma_p_5 : N) -> (_bma_p_6 : N) -> (_bma_p_7 : N) -> (_bma_p_8 : N) -> (_bma_p_9 : N) -> (_bma_p_10 : N) -> (_bma_p_11 : N) -> (_bma_p_12 : N) -> (_bma_p_13 : N) -> (_bma_p_14 : N) -> (_bma_p_15 : N) -> (_bma_p_16 : N) -> (_bma_p_17 : N) -> (_bma_p_18 : N) -> (_bma_p_19 : N) -> (_bma_p_20 : N) -> (_bma_p_21 : N) -> (_bma_p_22 : N) -> (_bma_p_23 : N) -> (_bma_p_24 : N) -> (_bma_p_25 : N) -> (_bma_p_26 : N) -> (_b"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m , n , a , b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$. Då $m d - n c = 1$.\nassistant\n", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : ex Nat (\\ d : N -> Eq (c n - d m) 1)) -> (d : N) -> (m d - n c) = 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDivides_inv_ind. Soit $x1 , x2 \\in N$. Alors si $x1$ est divisible par $x2$, alors pour toutes les fonctions $P$ des éléments $_z2006$ de $divisible$ de $x1$ et de $x2$ à des propositions, pour toutes les fonctions $_H1$ des nombres naturels $q$ et des éléments $x_1193$ de $Eq$ de $x2$ et du produit de $x1$ et de $q$ et des éléments $_z2007$ de $Eq$ de $Hterm$ et de $quotient$ appliqué à $x1$ et $x2$ et $q$ et $x_1193$ à des éléments de $P$ de $quotient$ appliqué à $x1$ et $x2$ et $q$ et $x_1193$, $P$ tient pour $Hterm$.\nassistant\n", "label": "divides_inv_ind : x1 : Nat -> x2 : Nat -> Hterm : divisible x1 x2 -> P : (_z2006 : divisible x1 x2 -> Prop) -> _H1 : (q : Nat -> x_1193 : Eq x2 (times x1 q) -> _z2007 : Eq Hterm (quotient x1 x2 q x_1193) -> P (quotient x1 x2 q x_1193)) -> P Hterm .", "predict": "divides_inv_ind : x1 : N -> x2 : N -> P : (_z2006 : divisible(x1 x2) -> Prop) -> _H1 : (q : Nat -> x_1193 : Eq(x2 (x1 * q)) -> _z2007 : Eq(Hterm (quotient x1 x2 q x_1193) -> P (quotient x1 x2 q x_1193)) -> P Hterm) -> x1 : N -> x2 : N -> P : (_z2006 : divisible(x1 x2) -> Prop) -> _H1 : (q : Nat -> x_1193 : Eq(x2 (x1 * q)) -> _z2007 : Eq(Hterm (quotient x1 x2 q x_1193) -> P (quotient x1 x2 q x_1193)) -> P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_gcd_aux. Let $p$ and $m$ and $n$ and $d$ be natural numbers. Assume that $0$ is less than $n$. Assume that $n$ is less than or equal to $m$. Assume that $n$ is less than or equal to $p$. Then if $d$ is divisible by $m$, then if $d$ is divisible by $n$, then $d$ is divisible by $gcd_aux$ applied to $p$ and $m$ and $n$.\nassistant\n", "label": "postulate divides_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> (__3 : divisible d m) -> (__4 : divisible d n) -> divisible d (gcd_aux p m n)", "predict": "postulate divides_gcd_aux : (p : Natural) -> (m : Natural) -> (n : Natural) -> (d : Natural) -> (0 : Natural) < n -> n <= m -> n <= p -> (d : Natural) -> (d : Natural) -> (gcd_aux : (p : Natural) -> (m : Natural) -> (n : Natural) -> (d : Natural) -> (0 : Natural) < n -> n <= m -> n <= p -> (d : Natural) -> (d : Natural) -> Natural) -> d : Natural -> d : Natural -> gcd_aux p m n d (0 : Natural) < n n <= m n <= p d d"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOrd_ord_rem. For all natural numbers $p$ and $q$ and $m$, if $0 < m$, then if $p$ is prime, then if $q$ is prime, then if $q < p$, then $ord (ord_rem (m , p), q)= ord (m , q)$.\nassistant\n", "label": "Axiom ord_ord_rem : forall p : nat, forall q : nat, forall m : nat, forall x__ : (0 < m), forall __1 : prime p, forall __2 : prime q, forall __3 : (q < p), ord (ord_rem m p) q = ord m q .", "predict": "Axiom ord_ord_rem : forall p : nat, forall q : nat, forall m : nat, 0 < m -> p : prime -> q : prime -> q < p -> ord (ord_rem (m , p), q) = ord (m , q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nGcd_O_to_eq_O. För alla naturliga tal $m$ och $n$, om det största gemensama delaret av $m$ och $n$ är lika med $0$, så är $m$ lika med $0$ och $n$ är lika med $0$.\nassistant\n", "label": "Axiom gcd_O_to_eq_O : forall m : nat, forall n : nat, forall x__ : (gcd m n = 0), m = 0 /\\ n = 0 .", "predict": "Axiom gcd_O_to_eq_O : forall m : nat, forall n : nat, if gcd m n = 0 then m = 0 and n = 0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDiv_times_times. Soit $a , b , c \\in N$. Supposons que $0$ est inférieur à $c$. Supposons que $0$ est inférieur à $b$. Alors le quotient de $a$ et de $b$ est égal au quotient du produit de $a$ et de $c$ et du produit de $b$ et de $c$.\nassistant\n", "label": "Axiom div_times_times : forall a : nat, forall b : nat, forall c : nat, forall x__ : (0 < c), forall __1 : (0 < b), a / b = a * c / (b * c) .", "predict": "Axiom div_times_times : forall a : N, forall b : N, forall c : N, 0 < c -> 0 < b -> (a / b) = ((a * c) / (b * c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLog_exp. Let $p$ and $n$ and $m$ be natural numbers. Assume that $1 < p$. Then if $0 < m$, then $\\log_ p {(p ^ n m)}= n + \\log_ p {m}$.\nassistant\n", "label": "postulate log_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> Eq (log p (times (pow p n) m)) (plus n (log p m))", "predict": "postulate log_exp : (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (postulate log_exp : (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (postulate log_exp : (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (postulate log_exp : (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p : Set) -> (n : Set) -> (m : Set) -> (1 : Set) -> (0 : Set) -> (p :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop_rect_Type1. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_871$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type1$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $_nil$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $_nil$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $Q_$ de $mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_871$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_871$.\nassistant\n", "label": "Aop_rect_Type1 : A : Set -> _nil : A -> Q_ : (_x_871 : Aop A _nil -> Type1) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_871 : Aop A _nil -> Q_ x_871 .", "predict": "Aop_rect_Type1 : A : Set -> _nil : A -> Q_ : (_x_871 : Aop A _nil -> Type1) -> _H_mk_Aop : (op : (a : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_871 : Aop A _nil -> Q_ x_871 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n$ un nombre naturel. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i , j \\in N$. Supposons que $i \\leq n$ et $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$ et $a \\leq n$. Supposons que $f (a)= i$. Soit $b \\in N$. Supposons que $b \\leq n$ et $f (b)= j$ et $b \\leq n$. Supposons que $f (b)= j$. Alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= i$.\nassistant\n", "label": "axiom let_clause_1068 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = i", "predict": "axiom let_clause_1068 (f : Nat -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (a : Nat) (b : Nat) (__ : (i0 : Nat) -> (Leq i0 n) -> Nat) (injf : injn f n) : a = b -> f a = i"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_10331. Soit $n \\in N$. Supposons que $5$ est inférieur à $n$. Soit $m$ un nombre naturel. Supposons que $6$ est inférieur ou ágal à $m$. Supposons que la puissance de la somme de $m$ et de $1$ et de $2$ est inférieure ou ágale à la puissance de $2$ et de $m$. Soit $a$ un nombre naturel. Supposons que $6$ est inférieur ou ágal à $a$. Supposons que la somme du produit de $2$ et de la somme de $a$ et de $1$ et de $1$ est inférieure ou ágale à la puissance de $2$ et de $a$. Alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nassistant\n", "label": "axiom let_clause_10331 (n : Nat) (lt4n : 5 < n) (m : Nat) (le4m : 6 ≤ m) (Hind : pow (m + 1) 2 ≤ pow 2 m) (a : Nat) (lea : 6 ≤ a) (Hinda : 2 * (a + 1) + 1 ≤ pow 2 a) (x2515 x2516 : Nat) : x2515 = x2516 * (x2515 / x2516) + mod x2515 x2516", "predict": "axiom let_clause_10331 (n : N) (m : N) (a : N) (x2515 x2516 : N) : x2515 = (x2516 * (x2515 / x2516)) + (mod x2515 x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMin_spec_inv_ind. Let $x1 , x2 \\in N$. Let $x3$ be a function from natural numbers to booleans. Let $x4 \\in N$. Let $_Hterm$ be an element of $min_spec$ of $x1$ and $x2$ and $x3$ and $x4$. Then for all functions $P$ from natural numbers $_z1890$ to propositions, for all functions $_H1$ from natural numbers $m$ and elements $_x_1080$ of $Leq$ of $x2$ and $m$ and elements $_x_1079$ of $Lt$ of $m$ and the sum of $x1$ and $x2$ and elements $_x_1078$ of $Eq$ of $x3$ applied to $m$ and $true$ and functions $_x_1077$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $x3$ applied to $i$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and $m$ to elements of $P$ of $m$, for all functions $_H2$ from functions $_x_1081$ from natural numbers $i$ and elements of $Leq$ of $x2$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $x1$ and $x2$ to elements of $Eq$ of $x3$ applied to $i$ and absurdity and elements $_z1891$ of $Eq$ of $x4$ and the sum of $x1$ and $x2$ to elements of $P$ of the sum of $x1$ and $x2$, $P$ holds for $x4$.\nassistant\n", "label": "axiom min_spec_inv_ind (x1 x2 : Nat) (x3 : (x__ : Nat) -> bool) (x4 : Nat) (_Hterm : min_spec x1 x2 x3 x4) (P : (_z1890 : Nat) -> Prop) (_H1 : (m : Nat) -> (_x_1080 : x2 ≤ m) -> (_x_1079 : m < x1 + x2) -> (_x_1078 : x3 m = true) -> (_x_1077 : (i : Nat) -> (x__ : x2 ≤ i) -> (__1 : i < m) -> x3 i = false) -> (_z1891 : x4 = m) -> P m) (_H2 : (_x_1081 : (i : Nat) -> (x__ : x2 ≤ i) -> (__1 : i < x1 + x2) -> x3 i = false) -> (_z1891 : x4 = x1 + x2) -> P (x1 + x2)) : P x4", "predict": "axiom min_spec_inv_ind (x1 x2 : N) (x3 : (_z : N) -> Bool) (x4 : N) (_Hterm : min_spec x1 x2 x3 x4) (P : (_z1890 : N) -> Prop) (_H1 : (m : N) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (x1 + x2)) -> (_x_1078 : Eq x3 m true) -> (_x_1077 : (i : N) -> (__1 : Lt i m) -> Eq x3 i absurdity) -> (_z1891 : Eq x4 m) -> P m) (_H2 : (_x_1081 : (i : N) -> (__1 : Lt i (x1 + x2)) -> Eq x3 i absurdity) -> (_z1891 : Eq x4 (x1 + x2)) -> P (x1 + x2)) : P x4"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDop_rect_CProp0. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_967$ de $Dop$ de $A$ et de $_nil$ à des propositions. Soit $_H_mk_Dop$ une fonction des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod (a , _nil)$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod (a , aop__o__op (A , _nil , sum , b , c))$ et de $aop__o__op (A , _nil , sum , prod (a , b), prod (a , c))$ à des éléments de $Q_$ de $mk_Dop (A , _nil , sum , prod , _null , _distr)$. Soit $x_967$ un élément de $Dop$ de $A$ et de $_nil$. Alors $Q_$ tient pour $x_967$.\nassistant\n", "label": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967", "predict": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Set) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (a : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLstar_Conf3. Soient $A$ et $B$ des ensembles. Soit $succ$ un élément de $relation2$ de $A$ et de $B$. Soit $R$ un élément de $relation$ de $A$. Soit $__$ un élément de $Conf3$ de $A$ et de $B$ et de $succ$ et de $R$. Soit $l$ un nombre naturel. Alors $Conf3$ tient pour $A$ et $B$ et $succ$ et $lstar (A , R , l)$.\nassistant\n", "label": "axiom lstar_Conf3 (A B : Set) (succ : relation2 A B) (R : relation A) (x__ : Conf3 A B succ R) (l : Nat) : Conf3 A B succ (lstar A R l)", "predict": "axiom lstar_Conf3 (A B : Set) (succ : relation2 A B) (R : relation A) (__ : Conf3 A B succ R) (l : Nat) : Conf3 A B succ (lstar (A R l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1561. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Då för alla naturliga tal $c$, om produkten av $m$ och $n$ är lika med produkten av $p$ och $c$, så för alla naturliga tal $a$, för alla element $_clearme0$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$, för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$ lika med $1$.\nassistant\n", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (c : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (skillnaden (produkten av a och p) (produkten av b och m)) (det största gemensama delaret av p och m))) -> (b : Nat) -> (_clearme1 : (skillnaden (produkten av a och p) (produkten av b och m)) == (det största gemensama delaret av p och m) || (skillnaden (produkten av b och m) (produkten av a och p)) == (det största gemensama delaret av p och m)) -> (_clearme2 : (skillnaden (produkten av a och p) (produkten av b och m)) == (det största gemensama delaret av p och m)) -> (_clearme3 : (skillnaden (produkten av a och p) (produkten av b och m)) == 1) -> (produkten av p och a) - (produkten av m och b) == 1"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i , j \\in N$. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$. Då om $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nassistant\n", "label": "Axiom let_clause_1068 : forall f : ((x__ : nat) -> nat), forall n : nat, forall permf : permut f n, forall i : nat, forall j : nat, forall lein : Leq i n, forall lejn : Leq j n, forall a : nat, forall _clearme : (Leq a n /\\ f a = i), forall lean : Leq a n, forall fa : (f a = i), forall b : nat, forall _clearme0 : (Leq b n /\\ f b = j), forall lebn : Leq b n, forall fb : (f b = j), forall x__ : ((i0 : nat) -> (x__ : Leq i0 n) -> Leq (f i0) n), forall injf : injn f n, forall auto : (a = b), f a = i .", "predict": "Axiom let_clause_1068 : forall f : nat -> nat, forall n : N, forall permf : permut f n, forall i : N, forall j : N, forall a : N, a <= n -> forall b : N, b <= n -> forall __ : ((i0 : N) -> (Leq i0 n) -> Leq (f i0) n), forall injf : (injn f n), a = b -> f a = i ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLstar_inv_S. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $l \\in N$. Soient $b1$ et $b2$ des éléments de $B$. Soit $__$ un élément de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b2$. Soit $l0 \\in N$. Supposons que $l0 + 1 = l$. Alors $ex2$ tient pour $B$ et la fonction qui envoie $b$ à $R (b1 , b)$ et la fonction qui envoie $b$ à $lstar (B , R , l0 , b , b2)$.\nassistant\n", "label": "axiom lstar_inv_S (B : Set) (R : relation B) (l : Nat) (b1 b2 : B) (x__ : lstar B R l b1 b2) (l0 : Nat) (__1 : l0 + 1 = l) : ex2 B (λ b => R b1 b) (λ b => lstar B R l0 b b2)", "predict": "axiom lstar_inv_S (B : Set) (R : Set) (l : N) (b1 b2 : Set) (__ : lstar B R l b1 b2) (l0 : N) : (l0 + 1 = l) -> (ex2 : B -> R (b1 b)) -> (b : B) -> lstar (B R l0 b b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_exp. For all natural numbers $n$ and $m$ and $p$, if $0 < p$ and $n \\leq m$, then $p ^ n \\leq p ^ m$.\nassistant\n", "label": "Axiom le_exp : forall n : nat, forall m : nat, forall p : nat, forall x__ : (0 < p), forall __1 : Leq n m, Leq (pow p n) (pow p m) .", "predict": "Axiom le_exp : forall n : nat, forall m : nat, forall p : nat, 0 < p -> n <= m -> p ^ n <= p ^ m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nOr_div_mod. Soient $n$ et $q$ des nombres naturels. Supposons que $0 < q$. Alors $mod (n , q)+ 1 = q$ et $n + 1 = (n \\div q + 1)q$ ou $mod (n , q)+ 1 < q$ et $n + 1 = n \\div q q + (mod (n , q)+ 1)$.\nassistant\n", "label": "Axiom or_div_mod : forall n : nat, forall q : nat, forall x__ : (0 < q), mod n q + 1 = q /\\ n + 1 = (n / q + 1) * q \\/ (mod n q + 1 < q /\\ n + 1 = n / q * q + (mod n q + 1)) .", "predict": "Axiom or_div_mod : forall n : nat, forall q : nat, 0 < q -> mod (n , q)+ 1 = q -> n + 1 = (n \\div q + 1)q -> mod (n , q)+ 1 < q -> n + 1 = n \\div q q + (mod (n , q)+ 1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1544. Let $p$ and $q$ be natural numbers. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$ and $n \\leq m$. Assume that $n \\leq q + 1$ and $n$ is not divisible by $m$. Let $a \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Then for all natural numbers $b$, if $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$ or $b n - a mod (m , n)= gcd_aux (q , n , mod (m , n))$ and $a mod (m , n)- b n = gcd_aux (q , n , mod (m , n))$, then $a mod (m , n)- n b = gcd_aux (q , n , mod (m , n))$.\nassistant\n", "label": "axiom let_clause_1544 (p q : Nat) (Hind : (m : Nat) -> (n : Nat) -> (x__ : 0 < n) -> (__1 : n ≤ m) -> (__2 : n ≤ q) -> ex Nat (λ a => ex Nat (λ b => a * n - b * m = gcd_aux q m n ∨ b * m - a * n = gcd_aux q m n))) (m n : Nat) (posn : 0 < n) (lenm : n ≤ m) (lenS : n ≤ q + 1) (ndivnm : ¬ divisible n m) (a : Nat) (_clearme : ex Nat (λ b => a * mod m n - b * n = gcd_aux q n (mod m n) ∨ b * n - a * mod m n = gcd_aux q n (mod m n))) (b : Nat) (_clearme0 : a * mod m n - b * n = gcd_aux q n (mod m n) ∨ b * n - a * mod m n = gcd_aux q n (mod m n)) (H : a * mod m n - b * n = gcd_aux q n (mod m n)) : a * mod m n - n * b = gcd_aux q n (mod m n)", "predict": "axiom let_clause_1544 (p q : Nat) (Hind : (m : Nat) -> (n : Nat) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n q) -> ex : Nat (λ a => ex Nat (λ b => Eq (diff (product a n) (product b m)) (gcd_aux q m n)))) (m n : Nat) (0 < n) (n ≤ m) (n ≤ q + 1) (n ∉ div m) (a : N) (_clearme : ex (λ b => Eq (diff (product a (mod m n)) (product b n)) (gcd_aux q n (mod m n)) ∧ Eq (diff (product b n) (product a (mod m n))) (gcd_aux q n (mod m n)))) (b : Nat) : (a mod (m , n) - b n = gcd_aux (q , n , mod (m , n)) ∨ b n - a mod (m , n) = gcd_aux (q , n , mod (m , n))) → (a mod (m , n) - n b = gcd_aux (q , n , mod (m , n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nRange_inv_rect_CProp3. Låt $x1$ vara en mängd. Låt $Hterm$ vara ett element av $range$ av $x1$. Låt $P$ vara en funktion från element $_z1674$ av $range$ av $x1$ till påståenden. Låt $_H1$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $x1$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden och element $_z1675$ av $Eq$ av $Hterm$ och $mk_range (x1 , _enum , _upto , _filter)$ till element av $P$ av $mk_range (x1 , _enum , _upto , _filter)$. Då håller $P$ för $Hterm$.\nassistant\n", "label": "Axiom range_inv_rect_CProp3 : forall x1 : Set, forall Hterm : range x1, forall P : ((_z1674 : range x1) -> Prop), forall _H1 : ((_enum : (x__ : nat) -> x1) -> (_upto : nat) -> (_filter : (x__ : nat) -> bool) -> (_z1675 : Hterm = mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)), P Hterm .", "predict": "Axiom range_inv_rect_CProp3 : forall x1 : set, forall Hterm : range x1, forall P : ((_z1674 : range x1) -> claims), forall _H1 : ((_enum : nat -> x1) -> (_upto : nat) -> (_filter : nat -> bool) -> (_z1675 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)), P Hterm ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1607. Låt $m , n , a , b \\in N$. Då om $0 < n$, så om $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nassistant\n", "label": "axiom let_clause_1607 (m n a b : Nat) (posn : 0 < n) (posm : 0 < m) (pnm : gcd n m = 1) (c : Nat) (_clearme : ex Nat (λ d => c * n - d * m = 1 ∨ d * m - c * n = 1)) (d : Nat) (_clearme0 : c * n - d * m = 1 ∨ d * m - c * n = 1) (H : d * m - c * n = 1) : gcd m n = m * d - n * c", "predict": "axiom let_clause_1607 (m n a b : Nat) (c : Nat) (_clearme : ex Nat (λ d => Eq (c n - d m) 1 || Eq (d m - c n) 1)) (d : Nat) : Eq (m d - n c) (gcd m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1075. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $bijf$ un élément de $bijn$ de $f$ et de $n + 1$. Supposons que $f (n + 1)= n + 1$. Soit $i \\in N$. Supposons que $i \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n + 1$ et $f (a)= i$ et $a \\leq n + 1$. Supposons que $f (a)= i$ et $a = n + 1$. Alors $i = a$.\nassistant\n", "label": "let_clause_1075 : f : (__ : Nat -> Nat) -> n : Nat -> bijf : bijn f (plus n (nd 1)) -> fS : Eq (f (plus n (nd 1))) (plus n (nd 1)) -> i : Nat -> lein : Leq i n -> a : Nat -> _clearme : and (Leq a (plus n (nd 1))) (Eq (f a) i) -> lean : Leq a (plus n (nd 1)) -> fa : Eq (f a) i -> Hc : Eq a (plus n (nd 1)) -> Eq i a .", "predict": "let_clause_1075 : f : N -> N -> n : N -> bijf : bijn f n + 1 -> f (n + 1) = n + 1 -> i : N -> i <= n -> a : N -> a <= n + 1 -> f (a) = i -> a <= n + 1 -> f (a) = i -> a = n + 1 -> i = a ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLt_O_ord_rem. Soient $p$ et $n$ des nombres naturels. Supposons que $1 < p$. Supposons que $0 < n$. Alors $0 < ord_rem (n , p)$.\nassistant\n", "label": "postulate lt_O_ord_rem : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt 0 (ord_rem n p)", "predict": "postulate lt_O_ord_rem : (p : Nat) -> (n : Nat) -> (1 < p) -> (0 < n) -> 0 < ord_rem (n , p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1034. Soient $n$ et $m$ et $p$ des nombres naturels. Supposons que $0 < p$. Soient $x2515$ et $x2516$ des nombres naturels. Alors $x2515 = mod (x2515 , x2516)+ x2516 (x2515 \\div x2516)$.\nassistant\n", "label": "let_clause_1034 : n : Nat -> m : Nat -> p : Nat -> posp : Lt 0 p -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516))) .", "predict": "let_clause_1034 : n : Nat -> m : Nat -> p : Nat -> x2515 : Nat -> x2516 : Nat -> x2515 = mod (x2515 , x2516) + x2516 (x2515 \\div x2516) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_inv_plus_l. Soit $x , y , z \\in N$. Supposons que $x + y \\leq z$. Alors $x \\leq z - y$ et $y \\leq z$.\nassistant\n", "label": "postulate le_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq (plus x y) z) -> and (Leq x (minus z y)) (Leq y z)", "predict": "postulate le_inv_plus_l : (x : N) -> (y : N) -> (z : N) -> x + y <= z -> x <= z - y -> y <= z"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAxiom. Let $_n , _b \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $__ \\in N$. Then $min_spec$ applied to $_n$ and $_b$ and $_f$ and $__$ is a proposition.\nassistant\n", "label": "Axiom min_spec : forall _n : nat, forall _b : nat, forall _f : ((x__ : nat) -> bool), forall x__ : nat, Prop .", "predict": "Axiom min_spec : forall _n : N, forall _b : N, forall _f : (N -> Bool), forall __ : N, Prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDiv_mod_spec_intro. Soit $n , m , q , r \\in N$. Supposons que $r < m$. Alors si $n = q m + r$, alors $div_mod_spec$ tient pour $n$ et $m$ et $q$ et $r$.\nassistant\n", "label": "postulate div_mod_spec_intro : (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> (__1 : Eq n (plus (times q m) r)) -> div_mod_spec n m q r", "predict": "postulate div_mod_spec_intro : (n : N) -> (m : N) -> (q : N) -> (r : N) -> (r < m) -> (n = q m + r) -> div_mod_spec n m q r"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_16005. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nassistant\n", "label": "let_clause_16005 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .", "predict": "let_clause_16005 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> 1 = gcd n m -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (c n - d m) 1) -> d : Nat -> c n - d m = 1 -> m d - n c = gcd m n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i , j \\in N$. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a$ be a natural number. Assume that $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$. Assume that $a$ is less than or equal to $n$. Assume that $f$ applied to $a$ is equal to $i$. Let $b$ be a natural number. Assume that $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$. Assume that $b$ is less than or equal to $n$. Assume that $f$ applied to $b$ is equal to $j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$. Let $injf$ be an element of $injn$ of $f$ and $n$. Then if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $j$.\nassistant\n", "label": "axiom let_clause_1063 (f : (x__ : Nat) -> Nat) (n : Nat) (permf : permut f n) (i j : Nat) (lein : i ≤ n) (lejn : j ≤ n) (a : Nat) (_clearme : a ≤ n ∧ f a = i) (lean : a ≤ n) (fa : f a = i) (b : Nat) (_clearme0 : b ≤ n ∧ f b = j) (lebn : b ≤ n) (fb : f b = j) (x__ : (i0 : Nat) -> (x__ : i0 ≤ n) -> f i0 ≤ n) (injf : injn f n) (auto : a = b) : f a = j", "predict": "axiom let_clause_1063 (f : N -> N) (n : N) (permf : permut f n) (i j : N) (a : N) (b : N) (__ : (i0 : N) -> (x : Leq i0 n) -> Leq (f i0) n) (injf : injn f n) : a = b -> f a = j"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDiv_mod_spec_rect_CProp1. För alla naturliga tal $_n$ och $_m$ och $_q$ och $_r$, för alla funktioner $Q_$ från element $_x_853$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden, för alla funktioner $_H_div_mod_spec_intro$ från element $x_855$ av $Lt$ av $_r$ och $_m$ och element $x_854$ av $Eq$ av $_n$ och summan av produkten av $_q$ och $_m$ och $_r$ till element av $Q_$ av $div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_855$ och $x_854$, för alla element $x_853$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_853$.\nassistant\n", "label": "Axiom div_mod_spec_rect_CProp1 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_853 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_855 : _r < _m) -> (x_854 : _n = _q * _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)), forall x_853 : div_mod_spec _n _m _q _r, Q_ x_853 .", "predict": "Axiom div_mod_spec_rect_CProp1 : forall _n : nat, forall _m : nat, forall _q : nat, forall _r : nat, forall Q_ : ((_x_853 : div_mod_spec _n _m _q _r) -> Prop), forall _H_div_mod_spec_intro : ((x_855 : Lt _r _m) -> (x_854 : Eq _n (sum _q _m _r)) -> (Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854))), forall x_853 : div_mod_spec _n _m _q _r, Q_ x_853 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nPred. För alla naturliga tal $_n$, $Nat$.\nassistant\n", "label": "axiom pred (_n : Nat) : Nat", "predict": "axiom pred (_n : Nat) : Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPad_bigop_nil. Soient $k$ et $n$ des nombres naturels. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $Aop$ de $B$ et de $nil$. Soit $f$ une fonction des nombres naturels à des éléments de $B$. Supposons que $n \\leq k$. Alors pour toutes les fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Leq$ de $n$ et de $i$ et des éléments $__2$ de $Lt$ de $i$ et de $k$ à des éléments de $or$ de $Eq$ appliqué à $p$ appliqué à $i$ et contradiction et de $Eq (f (i), nil)$, $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "Axiom pad_bigop_nil : forall k : nat, forall n : nat, forall p : ((x__ : nat) -> bool), forall B : Set, forall nil : B, forall op : Aop B nil, forall f : ((x__ : nat) -> B), forall x__ : Leq n k, forall __1 : ((i : nat) -> (__1 : Leq n i) -> (__2 : i < k) -> p i = false \\/ f i = nil), bigop n (fun i => p i) B nil (op B nil op) (fun i => f i) = bigop k (fun i => p i) B nil (op B nil op) (fun i => f i) .", "predict": "Axiom pad_bigop_nil : forall k : nat, forall n : nat, forall p : ((i : nat) -> bool), forall B : Set, forall nil : B, forall op : Aop B nil, forall f : ((i : nat) -> B), forall n_leq_k : nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBigop_Strue. Soit $k$ un nombre naturel. Alors pour toutes les fonctions $p$ des nombres naturels à des valeurs booléennes, pour tous les ensembles $B$, pour tous les éléments $nil$ de $B$, pour toutes les fonctions $op$ des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $p$ appliqué à $k$ est égal à $true$, alors $bigop$ appliqué à la somme de $k$ et de $1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $op$ appliqué à $f$ appliqué à $k$ et $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nassistant\n", "label": "postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) true) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (op (f k) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)))", "predict": "postulate bigop_Strue : (k : Nat) -> (p : (Nat -> Bool)) -> (B : Set) -> (nil : B) -> (op : (B -> __1 : B) -> B) -> (f : (Nat -> B)) -> (p k == true) -> bigop (k + 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) == op (f k) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLe_iter. Låt $g$ vara en funktion från naturliga tal till naturliga tal. Låt $a \\in N$. Låt $__$ vara en funktion från naturliga tal $x$ till element av $Leq$ av $x$ och $g (x)$. Låt $i \\in N$. Då $a \\leq iter (Nat , g , i , a)$.\nassistant\n", "label": "axiom le_iter (g : (x__ : Nat) -> Nat) (a : Nat) (x__ : (x : Nat) -> x ≤ g x) (i : Nat) : a ≤ iter Nat g i a", "predict": "axiom le_iter (g : nat -> nat) (a : N) (__ : (x : Nat) -> Leq x (g x)) (i : Nat) : a <= iter (Nat , g , i , a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFound_min_spec. Let $n$ and $b$ be natural numbers. Let $f$ be a function from natural numbers to booleans. Let $m$ be a natural number. Assume that $b \\leq m$. Then if $m < n + b$, then if $f (m)= true$, then for all functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $f (i)$ and absurdity, $min_spec$ holds for $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "Axiom found_min_spec : forall n : nat, forall b : nat, forall f : ((x__ : nat) -> bool), forall m : nat, forall x__ : Leq b m, forall __1 : (m < n + b), forall __2 : (f m = true), forall __3 : ((i : nat) -> (__3 : Leq b i) -> (__4 : i < m) -> f i = false), min_spec n b f m .", "predict": "Axiom found_min_spec : forall n : nat, forall b : nat, forall f : ((i : nat) -> bool), forall m : nat, forall __3 : ((i : nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) absurdity), forall min_spec : ((i : nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) (f min)), m < n + b -> f m = true -> forall __3 : ((i : nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) absurdity), min_spec n b f m ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLprim_invariant. Soient $n$ et $i$ des nombres naturels. Soit $acc$ une liste de nombres naturels. Alors si $1$ est inférieur à $i$, alors pour tous les éléments $__1$ de $primes_below$ de $acc$ et de $i$, $primes_below$ tient pour $lprim$ appliqué à $n$ et $i$ et $acc$ et la somme de $n$ et de $i$.\nassistant\n", "label": "Axiom lprim_invariant : forall n : nat, forall i : nat, forall acc : list nat, forall x__ : (1 < i), forall __1 : primes_below acc i, primes_below (lprim n i acc) (n + i) .", "predict": "Axiom lprim_invariant : forall n : nat, forall i : nat, forall acc : list nat, forall __1 : primes_below acc i, primes_below (lprim n i acc) (n + i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1600. Låt $m , n , a , b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Då om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $n$ och $c$ och produkten av $m$ och $d$.\nassistant\n", "label": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_1600 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : ex Nat (\\ d : N -> Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1)) -> (d : N) -> (skillnaden (produkten av c och n) (produkten av d och m)) -> 1 -> skillnaden (produkten av d och m) (produkten av c och n)) -> 1) -> (skillnaden (produkten av c och n) (produkten av d und m)) -> 1) -> (skillnaden (produkten av c och n) (produkten av d und m)) -> 1) -> (skillnaden (produkten av c och n) (produkten av d und m)) -> 1) -> (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : ex Nat (\\ d : N -> Eq (skillnaden (produkten av c och n) (produkten av d och m)) 1)) -> (d : N) -> (skillnaden (produkten av c och n) (produkten av d und m)) -> 1) -> (skillnaden (produkten av d und m) (produkten av c und n)) -> 1) -> (skillnaden (produkten av c und n) (produkten av d und m)) -> 1) -> (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : ex Nat (\\ d : N -> Eq (skillnaden (produkten av c und n) (produkten av d und m)) 1)) -> (d : N) -> (skillnaden (produkten av c und n) (produkten av d und m)) -> 1) -> (m : N) -> (n : N) -> (a : N) -> (b : N) -> (c : N) -> (_clearme : ex Nat (\\ d : N -> Eq (skillnaden (produkten av c und n) (produkten av d und m)) "}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTheta_def. For all natural numbers $n$, $theta$ applied to $n$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $p$ to $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$.\nassistant\n", "label": "theta_def : n : Nat -> Eq (theta n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => p)) .", "predict": "theta_def : n : Nat -> theta n = bigop (n + 1) (p : Nat => primeb p) Nat 1 times (p : Nat => p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $g1$ och $g2$ vara funktioner från naturliga tal till naturliga tal. Låt $n1 \\in N$. Låt $Hind$ vara en funktion från funktioner från naturliga tal $i$ och element av $Lt$ av $i$ och $n1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$ och funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n1$ och element $__2$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$ till element av $Leq$ av $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$. Då för alla funktioner $H1$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$, för alla funktioner $H2$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$, om $p2 (n1)= true$, så om $p1 (n1)= true$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515 , x2516)$.\nassistant", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (p1 : (i : N) -> Bool) -> (p2 : (i : N) -> Bool) -> (g1 : (i : N) -> Nat) -> (g2 : (i : N) -> Nat) -> (n1 : N) -> (Hind : (i : N) -> (__1 : Eq p1 i true) -> (__1 : (i : N) -> (__1 : Lt i n1) -> (__2 : Eq p1 i true) -> Leq (g1 i) (g2 i)) -> Eq (p2 i) true) -> (bigop : (n1 : N) -> (i : N) -> p1 i -> Nat) -> (0 : Nat) -> (plus : (i : N) -> p1 i -> bigop n1 (i : N) -> p1 i -> Nat) -> (i : N) -> g1 i) -> (bigop : (n1 : N) -> (i : N) -> p2 i -> Nat) -> (0 : Nat) -> (plus : (i : N) -> p2 i -> bigop n1 (i : N) -> p2 i -> Nat) -> (i : N) -> g2 i) -> (H1 : (i : N) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq p1 i true) -> Eq (p2 i) true) -> (H2 : (i : N) -> (__1 : Lt i (n1 + 1)) -> (__1 : Eq p1 i true) -> Leq (g1 i) (g2 i)) -> (x2515 : Nat) -> (x2516 : Nat) -> (x2515 = x2516 (x2515 \\div x2516) + mod (x2515 , x2516))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLstar_r_sn. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Då för alla naturliga tal $l$, för alla element $b$ och $b2$ av $B$, för alla element $__$ av $lstar_r$ av $B$ och $R$ och $l$ och $b$ och $b2$, för alla element $b1$ av $B$, för alla element $__1$ av $R$ av $b1$ och $b$, håller $lstar_r$ för $B$ och $R$ och summan av $l$ och $1$ och $b1$ och $b2$.\nassistant\n", "label": "axiom lstar_r_sn (B : Set) (R : relation B) (l : Nat) (b b2 : B) (x__ : lstar_r B R l b b2) (b1 : B) (__1 : R b1 b) : lstar_r B R (l + 1) b1 b2", "predict": "axiom lstar_r_sn (B : Set) (R : Set) (l : Nat) (b b2 : B) (__ : lstar_r B R l b b2) (b1 : B) (__1 : R b1 b) : B := lstar_r B R (l + 1) b1 b2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_exp_to_eq. Let $p$ and $q$ and $m$ be natural numbers. Then if $p$ is prime, then if $q$ is prime, then if $p$ is divisible by the exponentiation of $q$ and $m$, then $p$ is equal to $q$.\nassistant\n", "label": "axiom divides_exp_to_eq (p q m : Nat) (x__ : prime p) (__1 : prime q) (__2 : divisible p (pow q m)) : p = q", "predict": "axiom divides_exp_to_eq (p q m : Nat) : pprime p -> qprime q -> pdivbyexp q m -> p = q"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_15692. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Alors si $0$ est inférieur à $n$, alors si $0$ est inférieur à $m$, alors si le diviseur commun plus grand de $n$ et de $m$ est égal à $1$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$ est égale à $1$.\nassistant\n", "label": "let_clause_15692 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .", "predict": "let_clause_15692 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> 0 < n -> 0 < m -> gcd n m = 1 -> c : Nat -> _clearme : ex Nat (d : Nat => Eq (diff (c * n) (d * m)) 1 -> Eq (diff (d * m) (c * n)) 1) -> d : Nat -> (diff (c * n) (d * m) = 1 -> diff (d * m) (c * n) = 1) -> diff (d * m) (c * n) = 1 -> m * d + n * c = 1 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop_rect_Type3_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_867$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type3$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $_nil$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $_nil$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $Q_$ de $mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$. Soit $x_867$ un élément de $Aop$ de $A$ et de $_nil$. Alors $Q_$ tient pour $x_867$.\nassistant\n", "label": "Aop_rect_Type3_body : A : Set -> _nil : A -> Q_ : (_x_867 : Aop A _nil -> Type3) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 .", "predict": "Aop_rect_Type3_body : A : Set -> _nil : A -> Q_ : (_x_867 : A -> Type3) -> _H_mk_Aop : (op : (a : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLt_sqrt_n. Soit $n \\in N$. Supposons que $1$ est inférieur à $n$. Alors la racine carrée de $n$ est inférieure à $n$.\nassistant\n", "label": "Axiom lt_sqrt_n : forall n : nat, forall x__ : (1 < n), sqrt n < n .", "predict": "Axiom lt_sqrt_n : forall n : N, 1 < n -> sqrt n < n ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLstar_ind_l_aux. Soit $B$ un ensemble. Soit $R$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des propositions. Soit $b2$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b2$. Soit $__1$ une fonction des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $__1$ de $R$ de $b1$ et de $b$ et des éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de la somme de $l$ et de $1$ et de $b1$. Soit $l$ un nombre naturel. Soient $b1$ et $b$ des éléments de $B$. Soit $__2$ un élément de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b$. Supposons que $b$ est égal à $b2$. Alors $P$ tient pour $l$ et $b1$.\nassistant\n", "label": "Axiom lstar_ind_l_aux : forall B : Set, forall R : ((x__ : B) -> (__1 : B) -> Prop), forall b2 : B, forall P : relation2 nat B, forall x__ : P 0 b2, forall __1 : ((l : nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1), forall l : nat, forall b1 : B, forall b : B, forall __2 : lstar B R l b1 b, forall __3 : (b = b2), P l b1 .", "predict": "Axiom lstar_ind_l_aux : forall B : set, forall R : ((__ : B) -> (__1 : B) -> Prop), forall b2 : B, forall P : (Nat -> B) -> (__ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1), forall l : Nat, forall b1 : B, forall b : B, forall __2 : lstar B R l b1 b, forall b2 : B, b : b2 -> P l b1 ."}