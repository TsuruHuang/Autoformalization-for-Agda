{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_to_dividesb_true1. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.true$.\nassistant\n", "label": "postulate divides_to_dividesb_true1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)", "predict": "postulate divides_to_dividesb_true1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNot_rect_CProp1_body. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_112$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_nmk$ från funktioner $x_113$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_113$, för alla element $x_112$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_112$.\nassistant\n", "label": "postulate Not_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_113 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))) -> (x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_112)", "predict": "postulate Not_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_113 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))) -> (x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_112)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nOption_inv_rect_CProp3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$, för alla funktioner $P$ från element $_z1080$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z1081$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.None$ applicerat på $x1$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.None$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_623$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1081$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.Some$ applicerat på $x1$ och $x_623$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.Some$ applicerat på $x1$ och $x_623$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "axiom option_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) (P : (_z1080 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) (_H1 : (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) (_H2 : (x_623 : cic.Term univs.Type0 x1) -> (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_623))) : cic.Term cic.prop (P Hterm)", "predict": "axiom option_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) (P : (_z1080 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) (_H1 : (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) (_H2 : (x_623 : cic.Term univs.Type0 x1) -> (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_623))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_plus. Låt $n1$ och $n2$ och $m1$ och $m2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n1$ och $n2$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m1$ och $m2$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $n1$ och $m1$ och $matita_arithmetics_nat.plus$ applicerat på $n2$ och $m2$.\nassistant\n", "label": "le_plus : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) .", "predict": "le_plus : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter. Let $T$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.\nassistant\n", "label": "filter : T : cic.Univ univs.Type0 -> _p : (__ : cic.Term univs.Type0 T -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list T) -> cic.Term univs.Type0 (matita_basics_lists_list.list T) .", "predict": "filter : T : cic.Univ univs.Type0 -> _p : (__ : cic.Term univs.Type0 T -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list T) -> cic.Term univs.Type0 (matita_basics_lists_list.list T) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nRange_rect_Type5. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_919$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$, för alla element $x_919$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_919$.\nassistant\n", "label": "range_rect_Type5 : _A : cic.Univ univs.Type0 -> Q_ : (_x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type5) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type5 (Q_ x_919) .", "predict": "range_rect_Type5 : _A : cic.Univ univs.Type0 -> Q_ : (_x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type5) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type5 (Q_ x_919) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPermut_fg. Pour toutes les fonctions $f$ et $g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $g$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à la fonction qui envoie $m$ à $f$ appliqué à $g$ appliqué à $m$ et $n$.\nassistant\n", "label": "postulate permut_fg : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (g m)) n)", "predict": "postulate permut_fg : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (g m)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_max_to_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "postulate lt_max_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)", "predict": "postulate lt_max_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_765$ from elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_762$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_762$ and elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_763$ and $x_762$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_763$ and $x_762$, $cic", "label": "postulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLength_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom length_body : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom length_body : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDPair_rect_Type3_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_644$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H_mk_DPair$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$, för alla element $x_644$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_644$.\nassistant\n", "label": "axiom DPair_rect_Type3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)", "predict": "axiom DPair_rect_Type3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLstar_step. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $R$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $b1$ et $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b1$ et $b2$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$ et $b2$.\nassistant\n", "label": "lstar_step : B : cic.Univ univs.Type0 -> R : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (R b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2) .", "predict": "lstar_step : B : cic.Univ univs.Type0 -> R : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (R b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nOrd_rem. Pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom ord_rem : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom ord_rem : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_conj$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_132$ and $x_131$, for all elements $x_130$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_130$.\nassistant\n", "label": "axiom And_rect_Type3 (_A _B : cic.Univ cic.prop) (Q_ : (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type3) (_H_conj : (x_132 : cic.Term cic.prop _A) -> (x_131 : cic.Term cic.prop _B) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) (x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type3 (Q_ x_130)", "predict": "axiom And_rect_Type3 (_A _B : cic.Univ cic.prop) (Q_ : (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type3) (_H_conj : (x_132 : cic.Term cic.prop _A) -> (x_131 : cic.Term cic.prop _B) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) (x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type3 (Q_ x_130)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_prim_n1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.\nassistant\n", "label": "postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)", "predict": "postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_m. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $n$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "let_m : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "let_m : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_Type3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.\nassistant\n", "label": "axiom list_rect_Type3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type3 (Q_ x_731)", "predict": "axiom list_rect_Type3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type3 (Q_ x_731)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_gcd_l. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $n$.\nassistant\n", "label": "postulate divides_gcd_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n)", "predict": "postulate divides_gcd_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_previous_prime4. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "let_previous_prime4 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "let_previous_prime4 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLog_i_2n. Let $n$ and $i$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $i$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom log_i_2n (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n i)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log i (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "axiom log_i_2n (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n i)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log i (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nACop. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Univ$ för $univs.Type0$.\nassistant\n", "label": "postulate ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0", "predict": "postulate ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_16003. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of", "label": "axiom let_clause_16003 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (", "predict": "axiom let_clause_16003 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arith"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSum_rect_Type0. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.\nassistant\n", "label": "Sum_rect_Type0 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type0) -> _H_inl : (x_552 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> _H_inr : (x_553 : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type0 (Q_ x_551) .", "predict": "Sum_rect_Type0 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type0) -> _H_inl : (x_552 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> _H_inr : (x_553 : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type0 (Q_ x_551) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_rect_CProp4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_704$.\nassistant\n", "label": "Prod_rect_CProp4 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_704) .", "predict": "Prod_rect_CProp4 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_704) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAop_rect_CProp4_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_795$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic", "label": "postulate Aop_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_795)", "predict": "postulate Aop_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_795 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_795)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nEq_times_plus_to_congruent. Soient $n$ et $m$ et $p$ et $r$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $r$ et $p$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_congruence.congruent$ appliqué à $n$ et $m$ et $p$.\nassistant\n", "label": "axiom eq_times_plus_to_congruent (n m p r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m))) : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)", "predict": "axiom eq_times_plus_to_congruent (n m p r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m))) : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nVoid_rect_CProp4. Låt $Q_$ vara en funktion från element $_x_489$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x_489$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_489$.\nassistant\n", "label": "axiom void_rect_CProp4 (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)", "predict": "axiom void_rect_CProp4 (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDpi1__o__coerc_pair_sigma. Låt $x0$ och $x1$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $x2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $x3$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $cic.prop$, för alla element $x4$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $matita_basics_types.Prod$ applicerat på $x0$ och $x1$ och $x2$, för alla element $x5$ av $cic.Term$ av $cic.prop$ och $x3$ applicerat på $matita_basics_types.snd$ applicerat på $x0$ och $x1$ och $matita_basics_types.dpi1$ applicerat på $matita_basics_types.Prod$ applicerat på $x0$ och $x1$ och $x2$ och $x4$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x0$ och $matita_basics_types.Sig$ applicerat på $x1$ och funktionen som avbildar $x$ som $x3$ applicerat på $x$.\nassistant\n", "label": "dpi1__o__coerc_pair_sigma : x0 : cic.Univ univs.Type0 -> x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 (matita_basics_types.Prod x0 x1) -> cic.Univ univs.Type0) -> x3 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> x4 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_types.Prod x0 x1) x2) -> x5 : cic.Term cic.prop (x3 (matita_basics_types.snd x0 x1 (matita_basics_types.dpi1 (matita_basics_types.Prod x0 x1) x2 x4))) -> cic.Term univs.Type0 (matita_basics_types.Prod x0 (matita_basics_types.Sig x1 (x : cic.Term univs.Type0 x1 => x3 x))) .", "predict": "dpi1__o__coerc_pair_sigma : x0 : cic.Univ univs.Type0 -> x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 (matita_basics_types.Prod x0 x1) -> cic.Univ univs.Type0) -> x3 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> x4 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_types.Prod x0 x1) x2) -> x5 : cic.Term cic.prop (x3 (matita_basics_types.snd x0 x1 (matita_basics_types.dpi1 (matita_basics_types.Prod x0 x1) x2 x4))) -> cic.Term univs.Type0 (matita_basics_types.Prod x0 (matita_basics_types.Sig x1 (x : cic.Term univs.Type0 x1 => x3 x))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLtransitive. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_basics_relations.predicate$ appliqué à $cic.prod$ appliqué à $univs.Type0$ et $univs.Type0$ et $matita_arithmetics_nat.nat$ et la fonction qui envoie $__$ à $matita_basics_relations.relation$ appliqué à $B$.\nassistant\n", "label": "Axiom ltransitive : forall B : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.predicate (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __ => matita_basics_relations.relation B))) .", "predict": "Axiom ltransitive : forall B : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.predicate (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __ => matita_basics_relations.relation B))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z143$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z144$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom True_inv_rect_Type2 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z143 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2), forall _H1 : ((_z144 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type2 (P matita_basics_logic.I)), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom True_inv_rect_Type2 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z143 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2), forall _H1 : ((_z144 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type2 (P matita_basics_logic.I)), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDpi1__o__op. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_basics_lists_list.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_807$ and $_x_808$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.\nassistant\n", "label": "axiom dpi1__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1)) -> cic.Univ univs.Type0) (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2)) (_x_807 _x_808 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0", "predict": "axiom dpi1__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1)) -> cic.Univ univs.Type0) (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2)) (_x_807 _x_808 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nACop_rect_CProp5_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_905$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_905$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_905$.\nassistant\n", "label": "Axiom ACop_rect_CProp5_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_905) .", "predict": "Axiom ACop_rect_CProp5_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_905) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat. $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "postulate nat : cic.Univ univs.Type0", "predict": "postulate nat : cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_Psil1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.\nassistant\n", "label": "le_Psil1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => n))) .", "predict": "le_Psil1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDiv_mod_spec_rect_Type4. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_813$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_815$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_814$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_815$ och $x_814$, för alla element $x_813$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_813$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type4 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4), forall _H_div_mod_spec_intro : ((x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))), forall x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type4 (Q_ x_813) .", "predict": "Axiom div_mod_spec_rect_Type4 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4), forall _H_div_mod_spec_intro : ((x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))), forall x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type4 (Q_ x_813) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPrime_to_divides_M. Pour tous les éléments $m$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $p$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_binomial.M$ appliqué à $m$.\nassistant\n", "label": "Axiom prime_to_divides_M : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S m) p), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))), cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_binomial.M m)) .", "predict": "Axiom prime_to_divides_M : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S m) p), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))), cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_binomial.M m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAop_rect_Type3. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_787$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type3$ och $Q", "label": "axiom Aop_rect_Type3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type3 (Q_ x_787)", "predict": "axiom Aop_rect_Type3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type3 (Q_ x_787)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_CProp4_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_929$.\nassistant\n", "label": "Axiom range_rect_CProp4_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_929) .", "predict": "Axiom range_rect_CProp4_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_929) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nExample1. $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_primes.smallest_factor$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate example1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "postulate example1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMax_spec_ind_body. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_9", "label": "Axiom max_spec_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop), forall _H_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))),", "predict": "Axiom max_spec_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop), forall _H_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))), forall _H_not_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.not_found_max_spec _n _f m x"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter_unit. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom filter_unit : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 matita_basics_types.unit, cic.Term return_sort (return_type z) .", "predict": "Axiom filter_unit : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 matita_basics_types.unit, cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBi_symmetric. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom bi_symmetric : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B), cic.Univ cic.prop .", "predict": "Axiom bi_symmetric : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDPair_rect_CProp2_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_658$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_DPair$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$, för alla element $x_658$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_658$.\nassistant\n", "label": "Axiom DPair_rect_CProp2_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_658) .", "predict": "Axiom DPair_rect_CProp2_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_658) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nSig_rect_Type3_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_670$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H_mk_Sig$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$, för alla element $x_670$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_670$.\nassistant\n", "label": "axiom Sig_rect_Type3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term univs.Type3 (Q_ x_670)", "predict": "axiom Sig_rect_Type3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term univs.Type3 (Q_ x_670)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_plus. För alla element $n1$ och $n2$ och $m1$ och $m2$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n1$ och $n2$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m1$ och $m2$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $n1$ och $m1$ och $matita_arithmetics_nat.plus$ applicerat på $n2$ och $m2$.\nassistant\n", "label": "le_plus : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) .", "predict": "le_plus : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nSum_inv_rect_CProp2. För alla element $x1$ och $x2$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1020$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_572$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1021$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_572$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_572$, för alla funktioner $_H2$ från element $x_573$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1021$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_573$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_573$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nEq_rect_CProp2. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Då för alla element $_x$ av $cic.Term$ av $univs.Type2$ och $A$, för alla funktioner $Q_$ från element $x_31$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_32$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_31$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_refl$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$, för alla element $x_31$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_32$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_31$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_31$ och $x_32$.\nassistant\n", "label": "Axiom eq_rect_CProp2 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_31 : cic.Term univs.Type2 A, forall x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31), cic.Term cic.prop (Q_ x_31 x_32) .", "predict": "Axiom eq_rect_CProp2 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_31 : cic.Term univs.Type2 A) -> (_x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_31 : cic.Term univs.Type2 A, forall x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31), cic.Term cic.prop (Q_ x_31 x_32) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFold_sum. För alla element $A$ och $B$ av $cic.Univ$ av $univs.Type0$, för alla element $I$ och $J$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $op$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $B$ och $nil$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_basics_lists_list.op$ applicerat på $B$ och $nil$ och $op$ och $matita_basics_lists_list.fold$ applicerat på $A$ och $B$ och $matita_basics_lists_list.op$ applicerat på $B$ och $nil$ och $op$ och $nil$ och funktionen som avbildar $i$ som $matita_basics_bool.true$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $I$ och $matita_basics_lists_list.fold$ applicerat på $A$ och $B$ och $matita_basics_lists_list.op$ applicerat på $B$ och $nil$ och $op$ och $nil$ och funktionen som avbildar $i$ som $matita_basics_bool.true$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $J$ och $matita_basics_lists_list.fold$ applicerat på $A$ och $B$ och $matita_basics_lists_list.op$ applicerat på $B$ och $nil$ och $op$ och $nil$ och funktionen som avbildar $i$ som $matita_basics_bool.true$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_basics_lists_list.append$ applicerat på $A$ och $I$ och $J$.\nassistant\n", "label": "postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))", "predict": "postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDivides_fact_to_le. Låt $p$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_factorial.fact$ applicerat på $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $p$ och $n$.\nassistant\n", "label": "divides_fact_to_le : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)) -> cic.Term cic.prop (matita_arithmetics_nat.le p n) .", "predict": "divides_fact_to_le : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)) -> cic.Term cic.prop (matita_arithmetics_nat.le p n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nStart_lop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nUnit_rect_CProp1_body. Pour toutes les fonctions $Q_$ des éléments $_x_517$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_it$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_517$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_517$.\nassistant\n", "label": "Axiom unit_rect_CProp1_body : forall Q_ : ((_x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_517 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_517) .", "predict": "Axiom unit_rect_CProp1_body : forall Q_ : ((_x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_517 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_517) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nFilter_list. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "axiom filter_list (_A : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_list (_A : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_CProp0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements", "label": "Dop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_967) .", "predict": "Dop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_967) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "axiom range (_A : cic.Univ univs.Type0) : cic.Univ univs.Type0", "predict": "axiom range (_A : cic.Univ univs.Type0) : cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.\nassistant\n", "label": "axiom list_rect_CProp3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_761)", "predict": "axiom list_rect_CProp3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_761)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAnd_rect_Type4_body. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_122$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H_conj$ des éléments $x_124$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_123$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_124$ et $x_123$, pour tous les éléments $x_122$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_122$.\nassistant\n", "label": "Axiom And_rect_Type4_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4), forall _H_conj : ((x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))), forall x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type4 (Q_ x_122) .", "predict": "Axiom And_rect_Type4_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4), forall _H_conj : ((x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))), forall x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type4 (Q_ x_122) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEq_p_ord_q_O. Låt $p$ och $n$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord$ applicerat på $n$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $q$ och $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $q$ och $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom eq_p_ord_q_O (p n q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q matita_arithmetics_nat.O))", "predict": "axiom eq_p_ord_q_O (p n q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nProd_rect_Type3_body. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_696$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type3$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_696$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_696$.\nassistant\n", "label": "postulate Prod_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type3 (Q_ x_696)", "predict": "postulate Prod_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type3 (Q_ x_696)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nCongruent_pi. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $n$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_congruence.congruent$ appliqué à $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $matita_arithmetics_div_and_mod.mod$ appliqué à $f$ appliqué à $i$ et $p$ et $p$.\nassistant\n", "label": "postulate congruent_pi : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_div_and_mod.mod (f i) p)) p)", "predict": "postulate congruent_pi : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_div_and_mod.mod (f i) p)) p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDop_rect_CProp4_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_957$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applic", "label": "postulate Dop_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)", "predict": "postulate Dop_rect_CProp4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nVoid_rect_Type4_body. Pour toutes les fonctions $Q_$ des éléments $_x_483$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $univs.Type4$, pour tous les éléments $x_483$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_483$.\nassistant\n", "label": "void_rect_Type4_body : Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type4) -> x_483 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type4 (Q_ x_483) .", "predict": "void_rect_Type4_body : Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type4) -> x_483 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type4 (Q_ x_483) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nUnit_inv_rect_Type2. Pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, pour toutes les fonctions $P$ des éléments $_z924$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H1$ des éléments $_z925$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom unit_inv_rect_Type2 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2), forall _H1 : ((_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom unit_inv_rect_Type2 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2), forall _H1 : ((_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_ind_r_aux. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.\nassistant\n", "label": "Axiom lstar_ind_r_aux : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B), forall __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1), forall __1 : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1), cic.Term cic.prop (P l b2) .", "predict": "Axiom lstar_ind_r_aux : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B), forall __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1), forall __1 : ((l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1), cic.Term cic.prop (P l b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_895$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_895$.\nassistant\n", "label": "Axiom ACop_rect_Type3_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type3 (Q_ x_895) .", "predict": "Axiom ACop_rect_Type3_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_895 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type3 (Q_ x_895) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNot_rect_Type3_body. Soit $_A$ un élément de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $Q_$ des éléments $_x_88$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type3$, pour toutes les fonctions $_H_nmk$ des fonctions $x_89$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_89$, pour tous les éléments $x_88$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_88$.\nassistant\n", "label": "axiom Not_rect_Type3_body (_A : cic.Univ cic.prop) (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type3 (Q_ x_88)", "predict": "axiom Not_rect_Type3_body (_A : cic.Univ cic.prop) (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type3 (Q_ x_88)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_to_le. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n$ et $m$.\nassistant\n", "label": "Axiom divides_to_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "Axiom divides_to_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_inv_rect_Type3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z335$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z336$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "And_inv_rect_Type3 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ univs.Type3) -> _H1 : (x_132 : cic.Term cic.prop x1 -> x_131 : cic.Term cic.prop x2 -> _z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131)) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm) .", "predict": "And_inv_rect_Type3 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ univs.Type3) -> _H1 : (x_132 : cic.Term cic.prop x1 -> x_131 : cic.Term cic.prop x2 -> _z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131)) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z353$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z354$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom And_inv_rect_Type0 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type0) (_H1 : (x_144 : cic.Term cic.prop x1) -> (x_143 : cic.Term cic.prop x2) -> (_z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom And_inv_rect_Type0 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type0) (_H1 : (x_144 : cic.Term cic.prop x1) -> (x_143 : cic.Term cic.prop x2) -> (_z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAll_inv_append. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $l1$ et $l2$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.And$ appliqué à $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $l1$ et $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $l2$.\nassistant\n", "label": "postulate All_inv_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_lists_list.All A P l1) (matita_basics_lists_list.All A P l2))", "predict": "postulate All_inv_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_lists_list.All A P l1) (matita_basics_lists_list.All A P l2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nB2. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "B2 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "B2 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nTrue_inv_rect_Type1. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors pour toutes les fonctions $P$ des éléments $_z149$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $_z150$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom True_inv_rect_Type1 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1), forall _H1 : ((_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom True_inv_rect_Type1 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1), forall _H1 : ((_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_O_gcd. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.\nassistant\n", "label": "axiom lt_O_gcd (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))", "predict": "axiom lt_O_gcd (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nVoid_rect_CProp4_body. Låt $Q_$ vara en funktion från element $_x_489$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x_489$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_489$.\nassistant\n", "label": "void_rect_CProp4_body : Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_489 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_489) .", "predict": "void_rect_CProp4_body : Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ cic.prop) -> x_489 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term cic.prop (Q_ x_489) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDivides_to_mod_O. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom divides_to_mod_O (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)", "predict": "axiom divides_to_mod_O (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_plus_Sn_r. For all elements $a$ and $x$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $x$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "axiom lt_plus_Sn_r (a x n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus a x) (matita_arithmetics_nat.S n)))", "predict": "axiom lt_plus_Sn_r (a x n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus a x) (matita_arithmetics_nat.S n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrime_to_primeb_true. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.true$.\nassistant\n", "label": "Axiom prime_to_primeb_true : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true) .", "predict": "Axiom prime_to_primeb_true : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_pi. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g2$", "label": "postulate le_pi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))", "predict": "postulate le_pi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g1 i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g2 i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nInv_ltransitive. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_relations.predicate$ applicerat på $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $__$ som $matita_basics_relations.relation$ applicerat på $B$.\nassistant\n", "label": "Axiom inv_ltransitive : forall B : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.predicate (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __ => matita_basics_relations.relation B))) .", "predict": "Axiom inv_ltransitive : forall B : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.predicate (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __ => matita_basics_relations.relation B))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNill. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.\nassistant\n", "label": "postulate nill : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a)", "predict": "postulate nill : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z149$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom True_inv_rect_Type1 (Hterm : cic.Term cic.prop matita_basics_logic.True) (P : (_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) (_H1 : (_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom True_inv_rect_Type1 (Hterm : cic.Term cic.prop matita_basics_logic.True) (P : (_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) (_H1 : (_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_rect_Type3_body. For all functions $Q_$ from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_true$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.\nassistant\n", "label": "postulate bool_rect_Type3_body : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)", "predict": "postulate bool_rect_Type3_body : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nOption. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, $cic.Univ$ tient pour $univs.Type0$.\nassistant\n", "label": "postulate option : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate option : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_prim_log. Let $n$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $b$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $b$ and $n$.\nassistant\n", "label": "axiom le_prim_log (n b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log b (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_nat.S (matita_arithmetics_log.log b n))))", "predict": "axiom le_prim_log (n b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log b (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_nat.S (matita_arithmetics_log.log b n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnique_filter. Let $S$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$.\nassistant\n", "label": "Axiom unique_filter : forall S : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), forall f : ((__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term cic.prop (matita_basics_lists_list.unique S l), cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l)) .", "predict": "Axiom unique_filter : forall S : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), forall f : ((__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term cic.prop (matita_basics_lists_list.unique S l), cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_n_O_elim. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $matita_arithmetics_nat.O$, för alla funktioner $P$ från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $n$.\nassistant\n", "label": "postulate le_n_O_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P n)", "predict": "postulate le_n_O_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : cic.Term cic.prop (P matita_arithmetics_nat.O)) -> cic.Term cic.prop (P n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nList_elim_left. Pour tous les éléments $S$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.nil$ appliqué à $S$, pour toutes les fonctions $__1$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $S$ et des éléments $tl$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $tl$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.append$ appliqué à $S$ et $tl$ et $matita_basics_lists_list.cons$ appliqué à $S$ et $a$ et $matita_basics_lists_list.nil$ appliqué à $S$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $l$.\nassistant\n", "label": "Axiom list_elim_left : forall S : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (P (matita_basics_lists_list.nil S)), forall __1 : ((a : cic.Term univs.Type0 S) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__1 : cic.Term cic.prop (P tl)) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))), forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), cic.Term cic.prop (P l) .", "predict": "Axiom list_elim_left : forall S : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (P (matita_basics_lists_list.nil S)), forall __1 : ((a : cic.Term univs.Type0 S) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__1 : cic.Term cic.prop (P tl)) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))), forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), cic.Term cic.prop (P l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nACop_rect_Type1_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_899$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_899$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_899$.\nassistant\n", "label": "axiom ACop_rect_Type1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type1 (Q_ x_899)", "predict": "axiom ACop_rect_Type1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type1 (Q_ x_899)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1692. Pour tous les éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $a$ et $x358$ et $x359$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_sigma_pi.plusAC$ et $x358$ et $matita_arithmetics_nat.times$ appliqué à $x358$ et $x359$ et $matita_arithmetics_nat.times$ appliqué à $x358$ et $matita_arithmetics_nat.S$ appliqué à $x359$.\nassistant\n", "label": "let_clause_1692 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359))) .", "predict": "let_clause_1692 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTrue_rect_CProp0. För alla funktioner $Q_$ från element $_x_64$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_I$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_64$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_64$.\nassistant\n", "label": "axiom True_rect_CProp0 (Q_ : (_x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_64 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_64)", "predict": "axiom True_rect_CProp0 (Q_ : (_x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_64 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_64)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMatch_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$,", "label": "Axiom match_Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort), forall case_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term return_sort (return_type z) .", "predict": "Axiom match_Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort), forall case_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nUniv. Soit $s$ un élément de $Sort$. Alors $Univ$ tient pour $succ$ appliqué à $s$.\nassistant\n", "label": "postulate univ : (s : Sort) -> Univ (succ s)", "predict": "postulate univ : (s : Sort) -> Univ (succ s)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_ind_body. Let $_n$ and $_m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_1192$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $x_1193$, for all elements $x_1192$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1192$.\nassistant\n", "label": "axiom divides_ind_body (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term cic.prop (Q_ x_1192)", "predict": "axiom divides_ind_body (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term cic.prop (Q_ x_1192)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nBool_rect_CProp4_body. För alla funktioner $Q_$ från element $_x_347$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_347$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_347$.\nassistant\n", "label": "axiom bool_rect_CProp4_body (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_347)", "predict": "axiom bool_rect_CProp4_body (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_347)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOr_ind_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_or_introl$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_introl$ applied to $_A$ and $_B$ and $x_171$, for all functions $_H_or_intror$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.or_intror$ applied to $_A$ and $_B$ and $x_172$, for all elements $x_170$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_170$.\nassistant\n", "label": "Axiom Or_ind_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop), forall _H_or_introl : ((x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))), forall _H_or_intror : ((x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))), forall x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B), cic.Term cic.prop (Q_ x_170) .", "predict": "Axiom Or_ind_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ cic.prop), forall _H_or_introl : ((x_171 : cic.Term cic.prop _A) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))), forall _H_or_intror : ((x_172 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))), forall x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B), cic.Term cic.prop (Q_ x_170) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_rect_CProp5. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.\nassistant\n", "label": "axiom option_rect_CProp5 (_A : cic.Univ univs.Type0) (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_618)", "predict": "axiom option_rect_CProp5 (_A : cic.Univ univs.Type0) (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_618)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPi1. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $f$, $cic.Term$ tient pour $univs.Type0$ et $A$.\nassistant\n", "label": "postulate pi1 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term univs.Type0 A", "predict": "postulate pi1 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nBertrand. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_chebyshev_bertrand.bertrand$ appliqué à $n$.\nassistant\n", "label": "Axiom bertrand : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) .", "predict": "Axiom bertrand : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_921$.\nassistant\n", "label": "axiom range_rect_Type3 (_A : cic.Univ univs.Type0) (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type3 (Q_ x_921)", "predict": "axiom range_rect_Type3 (_A : cic.Univ univs.Type0) (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type3 (Q_ x_921)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBijn_transpose_l. För alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $n$ och $i$ och $j$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $f$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på funktionen som avbildar $p$ som $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $j$ och $f$ applicerat på $p$ och $n$.\nassistant\n", "label": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)", "predict": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_inv_ltransitive. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.inv_ltransitive$ applied to $B$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$.\nassistant\n", "label": "Axiom lstar_inv_ltransitive : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), cic.Term cic.prop (matita_arithmetics_lstar.inv_ltransitive B (matita_arithmetics_lstar.lstar B R)) .", "predict": "Axiom lstar_inv_ltransitive : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), cic.Term cic.prop (matita_arithmetics_lstar.inv_ltransitive B (matita_arithmetics_lstar.lstar B R)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nACop_rect_Type2_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_897$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_897$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_897$.\nassistant\n", "label": "ACop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type2) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type2 (Q_ x_897) .", "predict": "ACop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type2) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type2 (Q_ x_897) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_1$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_1$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_1$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1$ and $x_2$.\nassistant\n", "label": "Axiom eq_ind_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_1 : cic.Term univs.Type2 A, forall x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1), cic.Term cic.prop (Q_ x_1 x_2) .", "predict": "Axiom eq_ind_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_1 : cic.Term univs.Type2 A, forall x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1), cic.Term cic.prop (Q_ x_1 x_2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_rect_Type3. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_nmk$ from functions $x_89$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_89$, for all elements $x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_88$.\nassistant\n", "label": "Axiom Not_rect_Type3 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3), forall _H_nmk : ((x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))), forall x_88 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type3 (Q_ x_88) .", "predict": "Axiom Not_rect_Type3 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3), forall _H_nmk : ((x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))), forall x_88 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type3 (Q_ x_88) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFilter_Sig. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "Axiom filter_Sig : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_Sig : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAssociative_append. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.associative$ applicerat på $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.append$ applicerat på $A$.\nassistant\n", "label": "postulate associative_append : (A : cic.Univ univs.Type0) -> cic.Term cic.prop (matita_basics_relations.associative (matita_basics_lists_list.list A) (matita_basics_lists_list.append A))", "predict": "postulate associative_append : (A : cic.Univ univs.Type0) -> cic.Term cic.prop (matita_basics_relations.associative (matita_basics_lists_list.list A) (matita_basics_lists_list.append A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPrime_to_lt_O. Soit $p$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$.\nassistant\n", "label": "Axiom prime_to_lt_O : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) .", "predict": "Axiom prime_to_lt_O : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_ind_body. Let $Q_$ be a function from elements $_x_40$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_40$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_40$.\nassistant\n", "label": "True_ind_body : Q_ : (_x_40 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_40 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_40) .", "predict": "True_ind_body : Q_ : (_x_40 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_40 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_40) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_rect_Type0. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_793$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de", "label": "Axiom Aop_rect_Type0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type0 (Q_ x_793) .", "predict": "Axiom Aop_rect_Type0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type0 (Q_ x_793) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nUnit_inv_rect_Type1. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$. Då för alla funktioner $P$ från element $_z930$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från element $_z931$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.unit$ och $Hterm$ och $matita_basics_types.it$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.it$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "postulate unit_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate unit_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_Type4. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_721$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_723$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_722$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_725$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $x_722$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_723$ and $x_722$, for all elements $x_721$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_721$.\nassistant\n", "label": "axiom list_rect_Type4 (_A : cic.Univ univs.Type0) (Q_ : (_x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type4) (_H_nil : cic.Term univs.Type4 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_723 : cic.Term univs.Type0 _A) -> (x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_725 : cic.Term univs.Type4 (Q_ x_722)) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.cons _A x_723 x_722))) (x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type4 (Q_ x_721)", "predict": "axiom list_rect_Type4 (_A : cic.Univ univs.Type0) (Q_ : (_x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type4) (_H_nil : cic.Term univs.Type4 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_723 : cic.Term univs.Type0 _A) -> (x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_725 : cic.Term univs.Type4 (Q_ x_722)) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.cons _A x_723 x_722))) (x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type4 (Q_ x_721)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nFilter_False. För alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "Axiom filter_False : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop matita_basics_logic.False, cic.Term return_sort (return_type z) .", "predict": "Axiom filter_False : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop matita_basics_logic.False, cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nPrimes_below_to_bertrand. Pour tous les éléments $pm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $pm$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_chebyshev_bertrand256.primes_below$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $pm$, pour toutes les fonctions $__2$ des éléments $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $p$ et $l$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $pp$ à $matita_basics_logic.And$ appliqué à $matita_basics_logic.And$ appliqué à $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $pp$ et $l$ et $matita_arithmetics_nat.lt$ appliqué à $pp$ et $p$ et $matita_arithmetics_nat.le$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $pp$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt", "label": "primes_below_to_bertrand : pm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime pm) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm)) -> __2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (pp : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) .", "predict": "primes_below_to_bertrand : pm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime pm) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm)) -> __2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (pp : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt pm n) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_None$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_611$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_611$, for all elements $x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_610$.\nassistant\n", "label": "Axiom option_rect_Type0_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0), forall _H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))), forall x_610 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type0 (Q_ x_610) .", "predict": "Axiom option_rect_Type0_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0), forall _H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))), forall x_610 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type0 (Q_ x_610) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop__o__op. Pour tous les éléments $x0$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x1$ de $cic.Term$ de $univs.Type0$ et de $x0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x0$ et $x1$, pour tous les éléments $_x_887$ et $_x_888$ de $cic.Term$ de $univs.Type0$ et de $x0$, $cic.Term$ tient pour $univs.Type0$ et $x0$.\nassistant\n", "label": "aop__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1) -> _x_887 : cic.Term univs.Type0 x0 -> _x_888 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 .", "predict": "aop__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1) -> _x_887 : cic.Term univs.Type0 x0 -> _x_888 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_15621. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $pnm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $d$ av $cic.Term$ av $univs.Type0", "label": "axiom let_clause_15621 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.n", "predict": "axiom let_clause_15621 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_16004. För alla element $m$ och $n$ och $a$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $pnm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arith", "label": "postulate let_clause_16004 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_ar", "predict": "postulate let_clause_16004 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div a b)) (matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nSum_inv_rect_CProp3. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1014$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_567$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1015$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_567$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_567$, för alla funktioner $_H2$ från element $x_568$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1015$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_568$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_568$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "axiom Sum_inv_rect_CProp3 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z1014 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_567 : cic.Term univs.Type0 x1) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_567))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_567))) (_H2 : (x_568 : cic.Term univs.Type0 x2) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_568))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Sum_inv_rect_CProp3 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z1014 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_567 : cic.Term univs.Type0 x1) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_567))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_567))) (_H2 : (x_568 : cic.Term univs.Type0 x2) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_568))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nChecker_body. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.\nassistant\n", "label": "Axiom checker_body : forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "Axiom checker_body : forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_plus. Soient $n1$ et $n2$ et $m1$ et $m2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n1$ et $n2$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $m1$ et $m2$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $n1$ et $m1$ et $matita_arithmetics_nat.plus$ appliqué à $n2$ et $m2$.\nassistant\n", "label": "le_plus : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) .", "predict": "le_plus : n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLhd_cons_ltl. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.append$ applicerat på $A$ och $matita_basics_lists_list.lhd$ applicerat på $A$ och $l$ och $n$ och $matita_basics_lists_list.ltl$ applicerat på $A$ och $l$ och $n$ och $l$.\nassistant\n", "label": "Axiom lhd_cons_ltl : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l) .", "predict": "Axiom lhd_cons_ltl : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_minus_gcd_aux. Let $p$ and $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$.\nassistant\n", "label": "eq_minus_gcd_aux : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux p m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux p m n))))) .", "predict": "eq_minus_gcd_aux : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux p m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux p m n))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_to_div_mod_spec. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $m$ och $n$ och $matita_arithmetics_div_and_mod.div$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)", "predict": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTimes_n_O. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom times_n_O (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times n matita_arithmetics_nat.O))", "predict": "axiom times_n_O (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times n matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAop_inv_rect_CProp1. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1554$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type", "label": "postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1554 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1555 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1554 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1555 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nRange_rect_Type0. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_927$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_927$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_927$.\nassistant\n", "label": "Axiom range_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type0 (Q_ x_927) .", "predict": "Axiom range_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type0 (Q_ x_927) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_exp. För alla element $n$ och $m$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $n$ och $matita_arithmetics_exp.exp$ applicerat på $p$ och $m$.\nassistant\n", "label": "lt_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) .", "predict": "lt_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nList_discr. Låt $a1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x$ och $y$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $a1$, för alla element $_e$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $a1$ och $x$ och $y$, håller $cic.Term$ för $univs.Type2$ och $matita_basics_lists_list.match_list$ applicerat på $a1$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och $matita_basics_lists_list.match_list$ applicerat på $a1$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $cic.prod$ applicerat på $univs.Type1$ och $univs.Type1$ och $P$ och funktionen som avbildar $_z47$ som $P$ och funktionen som avbildar $u0$ och $u1$ som $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $P$ och $y$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_lists_list.match_list$ applicerat på $a1$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $P$ och funktionen", "label": "Axiom list_discr : forall a1 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall y : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list a1)) x y), cic.Term univs.Type2 (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 P (fun _z47 => P))) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) y) (fun t0 => fun t1 => matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1)", "predict": "Axiom list_discr : forall a1 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall y : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list a1)) x y), cic.Term univs.Type2 (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 P (fun _z47 => P))) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) y) (fun t0 => fun t1 => matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun _e0 => P)) (fun _z48 => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nUnit_rect_Type4. Låt $Q_$ vara en funktion från element $_x_497$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $univs.Type4$. Då för alla element $_H_it$ av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_497$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_497$.\nassistant\n", "label": "Axiom unit_rect_Type4 : forall Q_ : ((_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4), forall _H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it), forall x_497 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term univs.Type4 (Q_ x_497) .", "predict": "Axiom unit_rect_Type4 : forall Q_ : ((_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4), forall _H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it), forall x_497 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term univs.Type4 (Q_ x_497) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nMonotonic_lt_times_l. Pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $c$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.monotonic$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.lt$ et la fonction qui envoie $t$ à $matita_arithmetics_nat.times$ appliqué à $t$ et $c$.\nassistant\n", "label": "Axiom monotonic_lt_times_l : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times t c)) .", "predict": "Axiom monotonic_lt_times_l : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times t c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNat_rect_Type3_body. Låt $Q_$ vara en funktion från element $_x_377$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $univs.Type3$. Då för alla element $_H_O$ av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H_S$ från element $x_378$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_380$ av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $x_378$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_378$, för alla element $x_377$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_377$.\nassistant\n", "label": "axiom nat_rect_Type3_body (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type3 (Q_ x_377)", "predict": "axiom nat_rect_Type3_body (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type3 (Q_ x_377)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_Type2_body. Let $Q_$ be a function from elements $_x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $_H_true$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_338$.\nassistant\n", "label": "Axiom bool_rect_Type2_body : forall Q_ : ((_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2), forall _H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false), forall x_338 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type2 (Q_ x_338) .", "predict": "Axiom bool_rect_Type2_body : forall Q_ : ((_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2), forall _H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false), forall x_338 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type2 (Q_ x_338) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nUnit_inv_rect_CProp0. Pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, pour toutes les fonctions $P$ des éléments $_z966$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z967$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom unit_inv_rect_CProp0 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z966 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H1 : (_z967 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) : cic.Term cic.prop (P Hterm)", "predict": "axiom unit_inv_rect_CProp0 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z966 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H1 : (_z967 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNat_inv_rect_Type1. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $P$ des éléments $_z677$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $_z678$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.O$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H2$ des éléments $x_386$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_x_388$ des éléments $_z678$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $x_386$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $x_386$ et des éléments $_z678$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.S$ appliqué à $x_386$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_386$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "nat_inv_rect_Type1 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z677 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type1) -> _H1 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type1 (P matita_arithmetics_nat.O)) -> _H2 : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_388 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_386) -> cic.Term univs.Type1 (P x_386)) -> _z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_386)) -> cic.Term univs.Type1 (P (matita_arithmetics_nat.S x_386))) -> cic.Term univs.Type1 (P Hterm) .", "predict": "nat_inv_rect_Type1 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z677 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type1) -> _H1 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type1 (P matita_arithmetics_nat.O)) -> _H2 : (x_386 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_388 : (_z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_386) -> cic.Term univs.Type1 (P x_386)) -> _z678 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_386)) -> cic.Term univs.Type1 (P (matita_arithmetics_nat.S x_386))) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1012. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $n$ och $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $Hind$ från element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $cic.prop$ och $cic.prod$ applicerat på $cic.prop$ och $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $matita_arithmetics_minimization.let_m2$ applicerat på $f$ och $n$ och $i$ och $b$ och $matita_basics_bool.false$ och funktionen som avbildar $__$ som $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.let_m2$ applicerat på $f$ och $n$ och $i$ och $b$ och $matita_arithmetics_nat.plus$ applicerat på $i$ och $b$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $fb$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $b$ och $matita_basics_bool.true$, för alla element $eqm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $b$ och $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type", "label": "axiom let_clause_1012 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) (λ __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m2 f n i b) (matita_arithmetics_nat.plus i b)))) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true)", "predict": "axiom let_clause_1012 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) (λ __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m2 f n i b) (matita_arithmetics_nat.plus i b)))) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCongruent. For all elements $_n$ and $_m$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate congruent : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate congruent : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNat_inv_rect_Type0. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $P$ des éléments $_z683$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H1$ des éléments $_z684$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.O$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H2$ des éléments $x_390$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_x_392$ des éléments $_z684$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $x_390$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $x_390$ et des éléments $_z684$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.S$ appliqué à $x_390$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_390$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom nat_inv_rect_Type0 (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) (_H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) (_H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390)) -> cic.Term univs.Type0 (P x_390)) -> (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom nat_inv_rect_Type0 (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) (_H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) (_H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390)) -> cic.Term univs.Type0 (P x_390)) -> (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1561. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $", "label": "axiom let_clause_1561 (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (", "predict": "axiom let_clause_1561 (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)))))) : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.times b m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_rect_Type0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.\nassistant\n", "label": "postulate DPair_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)", "predict": "postulate DPair_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSig_inv_rect_Type3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1182$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1183$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sig_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1182 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1183 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate Sig_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1182 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1183 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_Psi_exp1. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$.\nassistant\n", "label": "postulate le_Psi_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S n)))))", "predict": "postulate le_Psi_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S n)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_exp_to_le. Pour tous les éléments $b$ et $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $b$ et $n$ et $matita_arithmetics_exp.exp$ appliqué à $b$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n$ et $m$.\nassistant\n", "label": "Axiom le_exp_to_le : forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "Axiom le_exp_to_le : forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) (matita_arithmetics_exp.exp b m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nTrue_discr. Soient $x$ et $y$ des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors pour tous les éléments $_e$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $x$ et $y$, $cic.Term$ tient pour $univs.Type2$ et $matita_basics_logic.match_True$ appliqué à $cic.succ$ appliqué à $univs.Type2$ et la fonction qui envoie $__$ à $cic.univ$ appliqué à $univs.Type2$ et $matita_basics_logic.match_True$ appliqué à $cic.succ$ appliqué à $univs.Type2$ et la fonction qui envoie $__$ à $cic.univ$ appliqué à $univs.Type2$ et $cic.prod$ appliqué à $cic.succ$ appliqué à $univs.Type1$ et $univs.Type1$ et $cic.univ$ appliqué à $univs.Type1$ et la fonction qui envoie $P$ à $cic.prod$ appliqué à $univs.Type1$ et $univs.Type1$ et $P$ et la fonction qui envoie $_z5$ à $P$ et $y$ et $x$.\nassistant\n", "label": "postulate True_discr : (x : cic.Term cic.prop matita_basics_logic.True) -> (y : cic.Term cic.prop matita_basics_logic.True) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x y)) -> cic.Term univs.Type2 (matita_basics_logic.match_True (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop matita_basics_logic.True -> cic.univ univs.Type2) (matita_basics_logic.match_True (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop matita_basics_logic.True -> cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 P (\\ _z5 : cic.Term univs.Type1 P -> P))) y) x)", "predict": "postulate True_discr : (x : cic.Term cic.prop matita_basics_logic.True) -> (y : cic.Term cic.prop matita_basics_logic.True) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x y)) -> cic.Term univs.Type2 (matita_basics_logic.match_True (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop matita_basics_logic.True -> cic.univ univs.Type2) (matita_basics_logic.match_True (cic.succ univs.Type2) (\\ __ : cic.Term cic.prop matita_basics_logic.True -> cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 P (\\ _z5 : cic.Term univs.Type1 P -> P))) y) x)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPlus_minus_plus_plus_l. Pour tous les éléments $z$ et $x$ et $y$ et $h$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $z$ et $matita_arithmetics_nat.plus$ appliqué à $x$ et $h$ et $matita_arithmetics_nat.plus$ appliqué à $y$ et $h$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $z$ et $x$ et $y$.\nassistant\n", "label": "Axiom plus_minus_plus_plus_l : forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall h : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z (matita_arithmetics_nat.plus x h)) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) y)) .", "predict": "Axiom plus_minus_plus_plus_l : forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall h : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z (matita_arithmetics_nat.plus x h)) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_to_lt_to_lt. Pour tous les éléments $n$ et $m$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $n$ et $p$.\nassistant\n", "label": "Axiom le_to_lt_to_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p), cic.Term cic.prop (matita_arithmetics_nat.lt n p) .", "predict": "Axiom le_to_lt_to_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p), cic.Term cic.prop (matita_arithmetics_nat.lt n p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_to_div. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $n$ and $m$.\nassistant\n", "label": "divides_to_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m) .", "predict": "divides_to_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nAop_rect_Type2_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_789$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univ", "label": "Axiom Aop_rect_Type2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type2 (Q_ x_789) .", "predict": "Axiom Aop_rect_Type2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type2), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type2 (Q_ x_789) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSig_inv_rect_Type0. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1200$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1201$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate Sig_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1200 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1201 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate Sig_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1200 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1201 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nUnit_rect_Type0_body. Pour toutes les fonctions $Q_$ des éléments $_x_507$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_H_it$ de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_507$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_507$.\nassistant\n", "label": "axiom unit_rect_Type0_body (Q_ : (_x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0) (_H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it)) (x_507 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type0 (Q_ x_507)", "predict": "axiom unit_rect_Type0_body (Q_ : (_x_507 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0) (_H_it : cic.Term univs.Type0 (Q_ matita_basics_types.it)) (x_507 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type0 (Q_ x_507)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nList_rect_CProp3_body. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_761$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_nil$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_763$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_762$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_765$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_762$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_763$ och $x_762$, för alla element $x_761$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_761$.\nassistant\n", "label": "axiom list_rect_CProp3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_761)", "predict": "axiom list_rect_CProp3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_761)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDpi1__o__aop__o__op. Låt $x0$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x1$ av $cic.Term$ av $univs.Type0$ och $x0$, för alla funktioner $x2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $x3$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ och $x2$, för alla element $_x_887$ och $_x_888$ av $cic.Term$ av $univs.Type0$ och $x0$, håller $cic.Term$ för $univs.Type0$ och $x0$.\nassistant\n", "label": "axiom dpi1__o__aop__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) (_x_887 _x_888 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0", "predict": "axiom dpi1__o__aop__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) (_x_887 _x_888 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_ind_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_80$, for all elements $x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_79$.\nassistant\n", "label": "Not_ind_body : _A : cic.Univ cic.prop -> Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_80 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_79) .", "predict": "Not_ind_body : _A : cic.Univ cic.prop -> Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_80 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_79) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nEq_minus_S_pred. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $m$ och $matita_arithmetics_nat.pred$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$.\nassistant\n", "label": "postulate eq_minus_S_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m)))", "predict": "postulate eq_minus_S_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_aop. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $p$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $B$ och $nil$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $B$ och $nil$.\nassistant\n", "label": "postulate let_aop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)", "predict": "postulate let_aop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nSucc. Supposons que $Sort$. Alors $Sort$.\nassistant\n", "label": "axiom succ (x : Sort) : Sort", "predict": "axiom succ (x : Sort) : Sort"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_15311. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, pour tous les éléments $d$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $eqm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $p$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $p$.\nassistant\n", "label": "axiom let_clause_15311 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (d p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p)))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p)))", "predict": "axiom let_clause_15311 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (d p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p)))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDistr. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $nil$, för alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.prod$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $nil$ och $matita_arithmetics_bigops.sum$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $nil$ och $matita_arithmetics_bigops.sum$ applicerat på $A$ och $nil$ och $xxx$ och $matita_arithmetics_bigops.prod$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ och $matita_arithmetics_bigops.prod$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $c$.\nassistant\n", "label": "Axiom distr : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) .", "predict": "Axiom distr : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_plus_to_minus_r. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.\nassistant\n", "label": "axiom le_plus_to_minus_r (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c)) : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b))", "predict": "axiom le_plus_to_minus_r (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c)) : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAop_rect_Type0_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_793$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $", "label": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)", "predict": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAop_inv_rect_CProp2. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1548$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term", "label": "postulate Aop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nACop_inv_rect_Type4. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1572$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H1$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1573$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nList_divides_true. Pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.list_divides$ appliqué à $l$ et $n$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $p$ à $matita_basics_logic.And$ appliqué à $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $p$ et $l$ et $matita_arithmetics_primes.divides$ appliqué à $p$ et $n$.\nassistant\n", "label": "axiom list_divides_true (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ p => matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) (matita_arithmetics_primes.divides p n)))", "predict": "axiom list_divides_true (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ p => matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) (matita_arithmetics_primes.divides p n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_m. För alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $n$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "let_m : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "let_m : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_sqrt_n1. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_sqrt.sqrt$ appliqué à $n$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_sqrt.sqrt$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom le_sqrt_n1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_sqrt.sqrt n))) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) .", "predict": "Axiom le_sqrt_n1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_sqrt.sqrt n))) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLstar_singlevalued. För alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation2$ applicerat på $B$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_relations.singlevalued$ applicerat på $B$ och $B$ och $R$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.singlevalued$ applicerat på $B$ och $B$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$.\nassistant\n", "label": "Axiom lstar_singlevalued : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation2 B B), forall __ : cic.Term cic.prop (matita_basics_relations.singlevalued B B R), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.singlevalued B B (matita_arithmetics_lstar.lstar B R l)) .", "predict": "Axiom lstar_singlevalued : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation2 B B), forall __ : cic.Term cic.prop (matita_basics_relations.singlevalued B B R), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.singlevalued B B (matita_arithmetics_lstar.lstar B R l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDop_rect_Type1_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_953$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $c", "label": "postulate Dop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)", "predict": "postulate Dop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1686. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $Hind$ från element $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $m$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$ till element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.pred$ applicerat på $p$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $a$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $un", "label": "Axiom let_clause_1686 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_b", "predict": "Axiom let_clause_1686 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))), cic.Term cic.prop (matita_arithmetics_nat.eq (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_O_theta. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$.\nassistant\n", "label": "lt_O_theta : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) .", "predict": "lt_O_theta : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDPair_inv_rect_Type1. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1128$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1129$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "DPair_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ univs.Type1) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm) .", "predict": "DPair_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ univs.Type1) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nList_rect_CProp2. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_nil$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_768$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_767$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_770$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_767$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_768$ och $x_767$, för alla element $x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_766$.\nassistant\n", "label": "list_rect_CProp2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_768 : cic.Term univs.Type0 _A -> x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_770 : cic.Term cic.prop (Q_ x_767) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_766) .", "predict": "list_rect_CProp2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_768 : cic.Term univs.Type0 _A -> x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_770 : cic.Term cic.prop (Q_ x_767) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_766) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1600. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $pnm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $d$", "label": "Axiom let_clause_1600 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (", "predict": "Axiom let_clause_1600 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDivides_to_div. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $m$ et $n$ et $n$ et $m$.\nassistant\n", "label": "divides_to_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m) .", "predict": "divides_to_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_to_not_ord_O. For all elements $p$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate divides_to_not_ord_O : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O))", "predict": "postulate divides_to_not_ord_O : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMatch_nat. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $return_sort$, för alla element $case_O$ av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $case_S$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_nat.S$ applicerat på $__$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "match_nat : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ return_sort) -> case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O) -> case_S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))) -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z) .", "predict": "match_nat : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ return_sort) -> case_O : cic.Term return_sort (return_type matita_arithmetics_nat.O) -> case_S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type (matita_arithmetics_nat.S __))) -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nACop_rect_Type0. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_901$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_901$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_901$.\nassistant\n", "label": "ACop_rect_Type0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type0) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type0 (Q_ x_901) .", "predict": "ACop_rect_Type0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type0) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type0 (Q_ x_901) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nUnit_inv_rect_Type1. Pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, pour toutes les fonctions $P$ des éléments $_z930$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $_z931$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate unit_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate unit_inv_rect_Type1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z930 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H1 : (_z931 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type1 (P matita_basics_types.it)) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSum_inv_ind. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z972$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $x_522$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z973$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_522$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_522$, pour toutes les fonctions $_H2$ des éléments $x_523$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z973$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_523$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_523$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate Sum_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z972 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_522 : cic.Term univs.Type0 x1) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_522))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_522))) -> (_H2 : (x_523 : cic.Term univs.Type0 x2) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sum_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z972 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_522 : cic.Term univs.Type0 x1) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_522))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_522))) -> (_H2 : (x_523 : cic.Term univs.Type0 x2) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDividesb_true_to_divides. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $n$ och $m$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$.\nassistant\n", "label": "postulate dividesb_true_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m)", "predict": "postulate dividesb_true_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nSub_hk. För alla funktioner $__$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $A$ av $cic.Univ$ av $univs.Type0$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $matita_arithmetics_bigops.range$ applicerat på $A$.\nassistant\n", "label": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_ord_rem. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord_rem$ applied to $m$ and $n$ and $m$.\nassistant\n", "label": "postulate lt_ord_rem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord_rem m n) m)", "predict": "postulate lt_ord_rem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord_rem m n) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1266$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1267$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Prod_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1266 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type0) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1267 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type0 (P Hterm) .", "predict": "Prod_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1266 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type0) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1267 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPlus_n_O. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate plus_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus n matita_arithmetics_nat.O))", "predict": "postulate plus_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus n matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNill. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.\nassistant\n", "label": "postulate nill : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)", "predict": "postulate nill : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDivides_gcd_mod. För alla element $m$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_gcd.gcd$ applicerat på $m$ och $n$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $m$ och $n$.\nassistant\n", "label": "Axiom divides_gcd_mod : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n))) .", "predict": "Axiom divides_gcd_mod : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_ACop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_ACop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term return_sort (return_type z) .", "predict": "filter_ACop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nEq_minus_gcd. Låt $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $a$ som $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $b$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $a$ och $n$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$.\nassistant\n", "label": "eq_minus_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m))))) .", "predict": "eq_minus_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nUnique_filter. Soit $S$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $S$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.unique$ appliqué à $S$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.unique$ appliqué à $S$ et $matita_basics_lists_list.filter$ appliqué à $S$ et $f$ et $l$.\nassistant\n", "label": "postulate unique_filter : (S : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique S l)) -> cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l))", "predict": "postulate unique_filter : (S : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique S l)) -> cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDecidable_prime. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.decidable$ appliqué à $matita_arithmetics_primes.prime$ appliqué à $n$.\nassistant\n", "label": "decidable_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.prime n)) .", "predict": "decidable_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.prime n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_662$.\nassistant\n", "label": "DPair_rect_CProp0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_662) .", "predict": "DPair_rect_CProp0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_662) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLeb_true_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "postulate leb_true_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)", "predict": "postulate leb_true_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_Type4_body. Let $Q_$ be a function from elements $_x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type4$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_497$.\nassistant\n", "label": "postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)", "predict": "postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nSum_rect_Type2_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_541$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_inl$ från element $x_542$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_542$, för alla funktioner $_H_inr$ från element $x_543$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_543$, för alla element $x_541$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_541$.\nassistant\n", "label": "Sum_rect_Type2_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type2) -> _H_inl : (x_542 : cic.Term univs.Type0 _A -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> _H_inr : (x_543 : cic.Term univs.Type0 _B -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type2 (Q_ x_541) .", "predict": "Sum_rect_Type2_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type2) -> _H_inl : (x_542 : cic.Term univs.Type0 _A -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> _H_inr : (x_543 : cic.Term univs.Type0 _B -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type2 (Q_ x_541) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_prime_times_2. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "postulate not_prime_times_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))", "predict": "postulate not_prime_times_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nOption_rect_Type0_body. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_610$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type0$, för alla element $_H_None$ av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_611$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_611$, för alla element $x_610$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_610$.\nassistant\n", "label": "postulate option_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) -> (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) -> (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type0 (Q_ x_610)", "predict": "postulate option_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) -> (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) -> (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type0 (Q_ x_610)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nEqb_sym. Pour tous les éléments $a$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_nat.eqb$ appliqué à $a$ et $b$ et $matita_arithmetics_nat.eqb$ appliqué à $b$ et $a$.\nassistant\n", "label": "eqb_sym : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb a b) (matita_arithmetics_nat.eqb b a)) .", "predict": "eqb_sym : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb a b) (matita_arithmetics_nat.eqb b a)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nFilter_Aop. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "Axiom filter_Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_Aop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10332. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "let_clause_10332 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "let_clause_10332 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nBool_rect_CProp3_body. Pour toutes les fonctions $Q_$ des éléments $_x_353$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_true$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_353$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_353$.\nassistant\n", "label": "Axiom bool_rect_CProp3_body : forall Q_ : ((_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_353 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_353) .", "predict": "Axiom bool_rect_CProp3_body : forall Q_ : ((_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_353 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_353) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAop_ind. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_861$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop", "label": "postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_861)", "predict": "postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_861)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_inv_rect_CProp3. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1477$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom div_mod_spec_inv_rect_CProp3 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1476 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1477 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) : cic.Term cic.prop (P Hterm)", "predict": "axiom div_mod_spec_inv_rect_CProp3 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1476 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1477 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nSnd_eq. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_basics_types.snd$ appliqué à $A$ et $B$ et $matita_basics_types.mk_Prod$ appliqué à $A$ et $B$ et $a$ et $b$ et $b$.\nassistant\n", "label": "axiom snd_eq (A B : cic.Univ univs.Type0) (a : cic.Term univs.Type0 A) (b : cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b)", "predict": "axiom snd_eq (A B : cic.Univ univs.Type0) (a : cic.Term univs.Type0 A) (b : cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_to_mod. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $m$.\nassistant\n", "label": "Axiom le_to_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_div_and_mod.mod n m)) .", "predict": "Axiom le_to_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_div_and_mod.mod n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPi_p_primeb. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och funktionen som avbildar $p$ som $matita_arithmetics_primes.primeb$ applicerat på $p$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ och funktionen som avbildar $p$ som $matita_arithmetics_exp.exp$ applicerat på $p$ och $matita_arithmetics_ord.ord$ applicerat på $n$ och $p$.\nassistant\n", "label": "pi_p_primeb : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)))) .", "predict": "pi_p_primeb : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nType3. $cic.Sort$.\nassistant\n", "label": "Axiom Type3 : cic.Sort .", "predict": "Axiom Type3 : cic.Sort ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_to_not_eq_O. För alla element $n$ och $m$ och $q$ och $r$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $n$ och $m$ och $q$ och $r$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom div_mod_spec_to_not_eq_O (n m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r)) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O))", "predict": "axiom div_mod_spec_to_not_eq_O (n m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r)) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nTrue_to_le_max. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Alors pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $m$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $m$ et $matita_arithmetics_minimization.max$ appliqué à $n$ et $f$.\nassistant\n", "label": "true_to_le_max : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_minimization.max n f)) .", "predict": "true_to_le_max : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_minimization.max n f)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_ind_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.\nassistant\n", "label": "lstar_ind_r : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> __2 : cic.Term cic.prop (R b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> cic.Term cic.prop (P l b2) .", "predict": "lstar_ind_r : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> __ : cic.Term cic.prop (P matita_arithmetics_nat.O b1) -> __1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b) -> __2 : cic.Term cic.prop (R b b2) -> __3 : cic.Term cic.prop (P l b) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> cic.Term cic.prop (P l b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nProd_rect_CProp2_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_710$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $x_710$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_710$.\nassistant\n", "label": "axiom Prod_rect_CProp2_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_710 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_710 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_710)", "predict": "axiom Prod_rect_CProp2_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_710 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_710 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_710)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDop_rect_Type1_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_953$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à", "label": "postulate Dop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)", "predict": "postulate Dop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type1 (Q_ x_953)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_primr. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "postulate le_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))", "predict": "postulate le_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSucc. Si $Sort$, alors $Sort$.\nassistant\n", "label": "postulate succ : Sort -> Sort", "predict": "postulate succ : Sort -> Sort"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z179$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z180$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "True_inv_rect_CProp1 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z179 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z180 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) .", "predict": "True_inv_rect_CProp1 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z179 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z180 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBool_rect_Type0. Soit $Q_$ une fonction des éléments $_x_344$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_H_true$ de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_344$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_344$.\nassistant\n", "label": "postulate bool_rect_Type0 : (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) -> (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ x_344)", "predict": "postulate bool_rect_Type0 : (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) -> (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) -> (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ x_344)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_theta. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$.\nassistant\n", "label": "postulate le_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))", "predict": "postulate le_theta : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nACop_rect_Type4. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_891$.\nassistant\n", "label": "Axiom ACop_rect_Type4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type4 (Q_ x_891) .", "predict": "Axiom ACop_rect_Type4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type4 (Q_ x_891) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_prim_log. För alla element $n$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_log.log$ applicerat på $b$ och $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_log.log$ applicerat på $b$ och $n$.\nassistant\n", "label": "le_prim_log : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log b (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_nat.S (matita_arithmetics_log.log b n)))) .", "predict": "le_prim_log : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log b (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_nat.S (matita_arithmetics_log.log b n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDecidable_not. Pour tous les éléments $P$ de $cic.Univ$ de $cic.prop$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.decidable$ appliqué à $P$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.decidable$ appliqué à $matita_basics_logic.Not$ appliqué à $P$.\nassistant\n", "label": "postulate decidable_not : (P : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Not P))", "predict": "postulate decidable_not : (P : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Not P))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMonotonic. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_R$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Univ$ för $cic.prop$.\nassistant\n", "label": "axiom monotonic (A : cic.Univ univs.Type0) (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop", "predict": "axiom monotonic (A : cic.Univ univs.Type0) (_R : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_CProp3_body. For all functions $Q_$ from elements $_x_75$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_75$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_75$.\nassistant\n", "label": "Axiom False_rect_CProp3_body : forall Q_ : ((_x_75 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_75 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_75) .", "predict": "Axiom False_rect_CProp3_body : forall Q_ : ((_x_75 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_75 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_75) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_17041. Låt $m$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $a$ och $x1029$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1029$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_sigma_pi.plusAC$ och $x1029$ och $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom let_clause_17041 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) .", "predict": "Axiom let_clause_17041 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nFilter_min_spec. Låt $_n$ och $_b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $_n$ och $_b$ och $_f$ och $__$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $_n$ och $_b$ och $_f$ och $__$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $_n$ och $_b$ och $_f$ och $__$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "axiom filter_min_spec (_n _b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_min_spec (_n _b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) (return : (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Term return_sort (return_type z)) (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNot_rect_Type3. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_88$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H_nmk$ från funktioner $x_89$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_89$, för alla element $x_88$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_88$.\nassistant\n", "label": "postulate Not_rect_Type3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) -> (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) -> (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type3 (Q_ x_88)", "predict": "postulate Not_rect_Type3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) -> (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) -> (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type3 (Q_ x_88)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1012. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.let_m2$ applied to $f$ and $n$ and $i$ and $b$ and $matita_basics_bool.false$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.let_m2$ applied to $f$ and $n$ and $i$ and $b$ and $matita_arithmetics_nat.plus$ applied to $i$ and $b$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $fb$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $b$ and $matita_basics_bool.true$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $b$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita", "label": "Axiom let_clause_1012 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) (fun __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m2 f n i b) (matita_arithmetics_nat.plus i b)))), forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true), forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true) .", "predict": "Axiom let_clause_1012 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m2 f n i b)) matita_basics_bool.false) (fun __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m2 f n i b) (matita_arithmetics_nat.plus i b)))), forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true), forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.false matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nNot_rect_CProp0_body. Pour tous les éléments $_A$ de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_115$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_nmk$ des fonctions $x_116$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_116$, pour tous les éléments $x_115$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_115$.\nassistant\n", "label": "postulate Not_rect_CProp0_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)", "predict": "postulate Not_rect_CProp0_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_CProp3. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.\nassistant\n", "label": "nat_rect_CProp3 : Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_404 : cic.Term cic.prop (Q_ x_402) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_401) .", "predict": "nat_rect_CProp3 : Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_404 : cic.Term cic.prop (Q_ x_402) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_401) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_rect_CProp3. För alla element $_n$ och $_m$ och $_q$ och $_r$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $Q_$ från element $_x_845$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_847$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_846$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_847$ och $x_846$, för alla element $x_845$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_845$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp3 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_845)", "predict": "axiom div_mod_spec_rect_CProp3 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_845)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMinus_plus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$.\nassistant\n", "label": "axiom minus_plus (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.plus m p)))", "predict": "axiom minus_plus (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.plus m p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProj1. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $A$.\nassistant\n", "label": "Axiom proj1 : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.And A B), cic.Term cic.prop A .", "predict": "Axiom proj1 : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.And A B), cic.Term cic.prop A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nProd_rect_CProp5. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_706$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_706$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_706$.\nassistant\n", "label": "Axiom Prod_rect_CProp5 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_706) .", "predict": "Axiom Prod_rect_CProp5 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_706) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBinomial_law. Let $a$ and $b$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $k$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $k$ to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.bc$ applied to $n$ and $k$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $n$ and $k$ and $matita_arithmetics_exp.exp$ applied to $b$ and $k$.\nassistant\n", "label": "postulate binomial_law : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.plus a b) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k))) (matita_arithmetics_exp.exp b k))))", "predict": "postulate binomial_law : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.plus a b) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k))) (matita_arithmetics_exp.exp b k))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nVoid_rect_Type0_body. For all functions $Q_$ from elements $_x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_488$.\nassistant\n", "label": "void_rect_Type0_body : Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type0) -> x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type0 (Q_ x_488) .", "predict": "void_rect_Type0_body : Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type0) -> x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type0 (Q_ x_488) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nSig_inv_rect_CProp0. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1230$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1231$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Sig_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ cic.prop) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm) .", "predict": "Sig_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ cic.prop) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSplit_rev_body. Soit $H$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $H$, pour tous les éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_types.Prod$ appliqué à $matita_basics_lists_list.list$ appliqué à $H$ et $matita_basics_lists_list.list$ appliqué à $H$.\nassistant\n", "label": "postulate split_rev_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))", "predict": "postulate split_rev_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_eq. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_refl$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.\nassistant\n", "label": "axiom match_eq (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) (case_refl : cic.Term return_sort (return_type _x (matita_basics_logic.refl A _x))) (__ : cic.Term univs.Type2 A) (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) : cic.Term return_sort (return_type __ z)", "predict": "axiom match_eq (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type2 A) -> (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort) (case_refl : cic.Term return_sort (return_type _x (matita_basics_logic.refl A _x))) (__ : cic.Term univs.Type2 A) (z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) : cic.Term return_sort (return_type __ z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nBool_rect_CProp2_body. Pour toutes les fonctions $Q_$ des éléments $_x_356$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_true$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_356$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_356$.\nassistant\n", "label": "Axiom bool_rect_CProp2_body : forall Q_ : ((_x_356 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_356 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_356) .", "predict": "Axiom bool_rect_CProp2_body : forall Q_ : ((_x_356 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_356 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_356) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nACop_rect_Type4_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_891$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_891$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_891$.\nassistant\n", "label": "postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)", "predict": "postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDivides_times_to_divides. Pour tous les éléments $p$ et $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Or$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $p$ et $n$ et $matita_arithmetics_primes.divides$ appliqué à $p$ et $m$.\nassistant\n", "label": "divides_times_to_divides : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_primes.divides p n) (matita_arithmetics_primes.divides p m)) .", "predict": "divides_times_to_divides : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_primes.divides p n) (matita_arithmetics_primes.divides p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBijn_transpose_l. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $n$ och $i$ och $j$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $f$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på funktionen som avbildar $p$ som $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $j$ och $f$ applicerat på $p$ och $n$.\nassistant\n", "label": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)", "predict": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1532. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate let_clause_1532 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_1532 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nEq_ind_r. För alla element $A$ av $cic.Univ$ av $univs.Type2$, för alla element $a$ av $cic.Term$ av $univs.Type2$ och $A$, för alla funktioner $P$ från element $x$ av $cic.Term$ av $univs.Type2$ och $A$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $x$ och $a$ till element av $cic.Univ$ av $cic.prop$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $a$ och $matita_basics_logic.refl$ applicerat på $A$ och $a$, för alla element $x$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $p$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $x$ och $a$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $x$ och $p$.\nassistant\n", "label": "eq_ind_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term cic.prop (P x p) .", "predict": "eq_ind_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term cic.prop (P x p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nFilter_Aop. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDpi1__o__aop. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ and $x2$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$.\nassistant\n", "label": "Axiom dpi1__o__aop : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : ((__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0), forall x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2), cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1) .", "predict": "Axiom dpi1__o__aop : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : ((__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0), forall x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2), cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_mod_aux_m_m. Soient $p$ et $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_div_and_mod.mod_aux$ appliqué à $p$ et $n$ et $m$ et $m$.\nassistant\n", "label": "le_mod_aux_m_m : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m) .", "predict": "le_mod_aux_m_m : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nOption_ind_body. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_586$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_None$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_587$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_587$, för alla element $x_586$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_586$.\nassistant\n", "label": "axiom option_ind_body (_A : cic.Univ univs.Type0) (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_586)", "predict": "axiom option_ind_body (_A : cic.Univ univs.Type0) (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_586)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1116$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1117$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom DPair_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1116 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1117 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type3 (P Hterm) .", "predict": "Axiom DPair_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1116 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1117 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_Psi_BPsi. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_chebyshev_factorization.B$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $n$.\nassistant\n", "label": "postulate le_Psi_BPsi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "postulate le_Psi_BPsi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nEq_transpose. Pour tous les éléments $i$ et $j$ et $k$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $j$ et $i$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $i$ et $k$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $j$ et $k$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_permutation.transpose$ appliqué à $i$ et $j$ et $n$ et $matita_arithmetics_permutation.transpose$ appliqué à $i$ et $k$ et $matita_arithmetics_permutation.transpose$ appliqué à $k$ et $j$ et $matita_arithmetics_permutation.transpose$ appliqué à $i$ et $k$ et $n$.\nassistant\n", "label": "eq_transpose : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i)) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k)) -> __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n)))) .", "predict": "eq_transpose : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i)) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k)) -> __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_CProp4. For all functions $Q_$ from elements $_x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_509$.\nassistant\n", "label": "postulate unit_rect_CProp4 : (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_509)", "predict": "postulate unit_rect_CProp4 : (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_509)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nVoid_rect_Type4. Låt $Q_$ vara en funktion från element $_x_483$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $univs.Type4$. Då för alla element $x_483$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_483$.\nassistant\n", "label": "Axiom void_rect_Type4 : forall Q_ : ((_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4), forall x_483 : cic.Term univs.Type0 matita_basics_types.void, cic.Term univs.Type4 (Q_ x_483) .", "predict": "Axiom void_rect_Type4 : forall Q_ : ((_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4), forall x_483 : cic.Term univs.Type0 matita_basics_types.void, cic.Term univs.Type4 (Q_ x_483) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPlus_minus_plus_plus_l. Pour tous les éléments $z$ et $x$ et $y$ et $h$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $z$ et $matita_arithmetics_nat.plus$ appliqué à $x$ et $h$ et $matita_arithmetics_nat.plus$ appliqué à $y$ et $h$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $z$ et $x$ et $y$.\nassistant\n", "label": "postulate plus_minus_plus_plus_l : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z (matita_arithmetics_nat.plus x h)) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) y))", "predict": "postulate plus_minus_plus_plus_l : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z (matita_arithmetics_nat.plus x h)) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) y))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_ord_rem. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $n$.\nassistant\n", "label": "axiom divides_ord_rem (p n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) n)", "predict": "axiom divides_ord_rem (p n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_plus_to_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "axiom le_plus_to_minus (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)", "predict": "axiom le_plus_to_minus (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDop_rect_CProp5. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_959$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_big", "label": "Dop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_959) .", "predict": "Dop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_959) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_inv_ind. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then for all functions $P$ from elements $_z125$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate True_inv_ind : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z125 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z126 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_ind : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z125 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z126 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nVoid_rect_Type0. Pour toutes les fonctions $Q_$ des éléments $_x_488$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x_488$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_488$.\nassistant\n", "label": "void_rect_Type0 : Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type0) -> x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type0 (Q_ x_488) .", "predict": "void_rect_Type0 : Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type0) -> x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type0 (Q_ x_488) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDiv_mod_spec_rect_Type4_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_813$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_815$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_814$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_815$ och $x_814$, för alla element $x_813$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_813$.\nassistant\n", "label": "div_mod_spec_rect_Type4_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type4) -> _H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) -> x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type4 (Q_ x_813) .", "predict": "div_mod_spec_rect_Type4_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type4) -> _H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) -> x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type4 (Q_ x_813) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nList_divides_false. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$. Alors pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.list_divides$ appliqué à $l$ et $n$ et $matita_basics_bool.false$, pour tous les éléments $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $p$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $p$ et $n$.\nassistant\n", "label": "axiom list_divides_false (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.false)) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))", "predict": "axiom list_divides_false (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.false)) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_aop. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$.\nassistant\n", "label": "axiom let_aop (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (a : cic.Term univs.Type0 B) : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)", "predict": "axiom let_aop (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (a : cic.Term univs.Type0 B) : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEx_ind_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_236$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex_intro$ applied to $A$ and $_P$ and $x$ and $x_236$, for all elements $x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_235$.\nassistant\n", "label": "ex_ind_body : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Univ cic.prop) -> _H_ex_intro : (x : cic.Term univs.Type0 A -> x_236 : cic.Term cic.prop (_P x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term cic.prop (Q_ x_235) .", "predict": "ex_ind_body : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Univ cic.prop) -> _H_ex_intro : (x : cic.Term univs.Type0 A -> x_236 : cic.Term cic.prop (_P x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term cic.prop (Q_ x_235) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_O_ord_rem. För alla element $p$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_ord.ord_rem$ applicerat på $n$ och $p$.\nassistant\n", "label": "lt_O_ord_rem : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_ord.ord_rem n p)) .", "predict": "lt_O_ord_rem : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_ord.ord_rem n p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nBi_relation. För alla element $__$ och $__1$ av $cic.Univ$ av $univs.Type0$, håller $cic.Univ$ för $univs.Type0$.\nassistant\n", "label": "bi_relation : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 .", "predict": "bi_relation : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_ord_rem. För alla element $p$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_ord.ord_rem$ applicerat på $n$ och $p$ och $n$.\nassistant\n", "label": "postulate divides_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) n)", "predict": "postulate divides_ord_rem : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nMem_append_l2. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $l1$ et $l2$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $A$ et $a$ et $l2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.mem$ appliqué à $A$ et $a$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$.\nassistant\n", "label": "postulate mem_append_l2 : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2)) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))", "predict": "postulate mem_append_l2 : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l2)) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nP_ord_inv. Pour tous les éléments $_p$ et $_m$ et $_x$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom p_ord_inv (_p _m _x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom p_ord_inv (_p _m _x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nP_ord_aux_to_not_mod_O. For all elements $p$ and $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $r$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "p_ord_aux_to_not_mod_O : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O)) .", "predict": "p_ord_aux_to_not_mod_O : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nF_min_true. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $i$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_basics_bool.true$.\nassistant\n", "label": "postulate f_min_true : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.min n b f)) matita_basics_bool.true)", "predict": "postulate f_min_true : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.min n b f)) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nO. $cic.Term$ håller för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "O : cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "O : cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nACop_rect_Type5_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_893$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_893$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_893$.\nassistant\n", "label": "ACop_rect_Type5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type5) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type5 (Q_ x_893) .", "predict": "ACop_rect_Type5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type5) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type5 (Q_ x_893) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_n_O_to_eq. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $n$.\nassistant\n", "label": "le_n_O_to_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) .", "predict": "le_n_O_to_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nChecker_abl. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $a$ and $b$ and $matita_arithmetics_nat.le$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.true$.\nassistant\n", "label": "checker_abl : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true)) .", "predict": "checker_abl : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFst. Pour tous les éléments $A$ et $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $A$ et $B$, $cic.Term$ tient pour $univs.Type0$ et $A$.\nassistant\n", "label": "Axiom fst : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B), cic.Term univs.Type0 A .", "predict": "Axiom fst : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B), cic.Term univs.Type0 A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAop_rect_CProp5. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_797$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$", "label": "axiom Aop_rect_CProp5 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_797)", "predict": "axiom Aop_rect_CProp5 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_797)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_or_gt. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "eq_or_gt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) .", "predict": "eq_or_gt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPi_p_primeb_dividesb. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et la fonction qui envoie $p$ à $matita_basics_bool.andb$ appliqué à $matita_arithmetics_primes.primeb$ appliqué à $p$ et $matita_arithmetics_primes.dividesb$ appliqué à $p$ et $n$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $p$ à $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_ord.ord$ appliqué à $n$ et $p$.\nassistant\n", "label": "axiom pi_p_primeb_dividesb (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p n)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p))))", "predict": "axiom pi_p_primeb_dividesb (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p n)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_inv_rect_CProp2. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1284$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1285$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Prod_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Prod_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nCongruent_exp_pred_SO. Pour tous les éléments $p$ et $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $p$ et $a$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_congruence.congruent$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $a$ et $matita_arithmetics_nat.pred$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$.\nassistant\n", "label": "Axiom congruent_exp_pred_SO : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)), cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_exp.exp a (matita_arithmetics_nat.pred p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) .", "predict": "Axiom congruent_exp_pred_SO : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)), cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_exp.exp a (matita_arithmetics_nat.pred p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nSmallest_factor_to_prime. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_primes.smallest_factor$ appliqué à $n$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.prime$ appliqué à $n$.\nassistant\n", "label": "Axiom smallest_factor_to_prime : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n), cic.Term cic.prop (matita_arithmetics_primes.prime n) .", "predict": "Axiom smallest_factor_to_prime : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n), cic.Term cic.prop (matita_arithmetics_primes.prime n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10334. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "Axiom let_clause_10334 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_10334 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1134$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1135$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum_inv_rect_CProp2. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1020$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1021$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_572$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_572$, for all functions $_H2$ from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1021$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_573$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_573$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLstar_O. Pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$, pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $matita_arithmetics_nat.O$ et $b$ et $b$.\nassistant\n", "label": "lstar_O : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R matita_arithmetics_nat.O b b) .", "predict": "lstar_O : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R matita_arithmetics_nat.O b b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1662$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1663$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate range_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1662 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type0) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1663 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate range_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1662 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type0) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1663 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nSmallest_factor_to_min. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_primes.smallest_factor$ applicerat på $n$ och $matita_arithmetics_minimization.min$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.eqb$ applicerat på $matita_arithmetics_div_and_mod.mod$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom smallest_factor_to_min (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (λ m => matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))", "predict": "axiom smallest_factor_to_min (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (λ m => matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMatch_ACop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "postulate match_ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ return_sort) -> (case_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_ACop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ return_sort) -> (case_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nB1. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom B1 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom B1 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPad_bigop. För alla element $k$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $p$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $k$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $matita_basics_bool.match_bool$ applicerat på $univs.Type0$ och funktionen som avbildar $_0$ som $matita_basics_bool.bool$ och $matita_basics_bool.false$ och $p$ applicerat på $i$ och $matita_arithmetics_nat.leb$ applicerat på $n$ och $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nassistant\n", "label": "postulate pad_bigop : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.match_bool univs.Type0 (\\ _0 : cic.Term univs.Type0 matita_basics_bool.bool -> matita_basics_bool.bool) matita_basics_bool.false (p i) (matita_arithmetics_nat.leb n i)) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate pad_bigop : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.match_bool univs.Type0 (\\ _0 : cic.Term univs.Type0 matita_basics_bool.bool -> matita_basics_bool.bool) matita_basics_bool.false (p i) (matita_arithmetics_nat.leb n i)) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiv_mod_spec_rect_CProp5. Pour tous les éléments $_n$ et $_m$ et $_q$ et $_r$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Q_$ des éléments $_x_841$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_843$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_842$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_843$ et $x_842$, pour tous les éléments $x_841$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_841$.\nassistant\n", "label": "div_mod_spec_rect_CProp5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) -> x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_841) .", "predict": "div_mod_spec_rect_CProp5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) -> x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_841) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_le. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $x$.\nassistant\n", "label": "minus_le : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus x y) x) .", "predict": "minus_le : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus x y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_10331. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $x2515$ och $x2516$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2515$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x2516$ och $matita_arithmetics_div_and_mod.div$ applicerat på $x2515$ och $x2516$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $x2515$ och $x2516$.\nassistant\n", "label": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEqb_elim. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.eqb$ applied to $n$ and $m$.\nassistant\n", "label": "axiom eqb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))", "predict": "axiom eqb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z611$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z612$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z612$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "bool_inv_rect_Type1 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z611 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type1) -> _H1 : (_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type1 (P matita_basics_bool.true)) -> _H2 : (_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type1 (P matita_basics_bool.false)) -> cic.Term univs.Type1 (P Hterm) .", "predict": "bool_inv_rect_Type1 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z611 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type1) -> _H1 : (_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type1 (P matita_basics_bool.true)) -> _H2 : (_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type1 (P matita_basics_bool.false)) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1560. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom let_clause_1560 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)", "predict": "axiom let_clause_1560 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDop_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1740$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $x2$ et $x2$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_b", "label": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPair_eq1. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $a1$ och $a2$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $a1$ och $b1$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $a2$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $a1$ och $a2$.\nassistant\n", "label": "pair_eq1 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> a1 : cic.Term univs.Type0 A -> a2 : cic.Term univs.Type0 A -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2) .", "predict": "pair_eq1 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> a1 : cic.Term univs.Type0 A -> a2 : cic.Term univs.Type0 A -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTransitive_sub. Pour toutes les fonctions $h1$ et $k1$ et $h2$ et $k2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $I$ et $J$ et $K$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_bigops.sub_hk$ appliqué à $h1$ et $k1$ et $A$ et $I$ et $J$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_bigops.sub_hk$ appliqué à $h2$ et $k2$ et $A$ et $J$ et $K$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_bigops.sub_hk$ appliqué à la fonction qui envoie $x$ à $h2$ appliqué à $h1$ appliqué à $x$ et la fonction qui envoie $x$ à $k1$ appliqué à $k2$ appliqué à $x$ et $A$ et $I$ et $K$.\nassistant\n", "label": "axiom transitive_sub (h1 k1 h2 k2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (A : cic.Univ univs.Type0) (I J K : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (__ : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h1 k1 A I J)) (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h2 k2 A J K)) : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (λ x => h2 (h1 x)) (λ x => k1 (k2 x)) A I K)", "predict": "axiom transitive_sub (h1 k1 h2 k2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (A : cic.Univ univs.Type0) (I J K : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (__ : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h1 k1 A I J)) (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h2 k2 A J K)) : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (λ x => h2 (h1 x)) (λ x => k1 (k2 x)) A I K)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nEq_rect_Type3. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_x$ de $cic.Term$ de $univs.Type2$ et de $A$, pour toutes les fonctions $Q_$ des éléments $x_10$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_11$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_10$ à des éléments de $cic.Univ$ de $univs.Type3$, pour tous les éléments $_H_refl$ de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$, pour tous les éléments $x_10$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $x_11$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_10$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_10$ et $x_11$.\nassistant\n", "label": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)", "predict": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAnd_rect_Type1. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_138$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H_conj$ från element $x_140$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_139$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_140$ och $x_139$, för alla element $x_138$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_138$.\nassistant\n", "label": "postulate And_rect_Type1 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)", "predict": "postulate And_rect_Type1 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nFact_pi_p2. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_factorial.fact$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et la fonction qui envoie $p$ à $matita_arithmetics_primes.primeb$ appliqué à $p$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $p$ à $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_log.log$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $mat", "label": "axiom fact_pi_p2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_nat.times (matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))) (matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))", "predict": "axiom fact_pi_p2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_nat.times (matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))) (matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nInv_eq_minus_O. För alla element $x$ och $y$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $x$ och $y$ och $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x$ och $y$.\nassistant\n", "label": "postulate inv_eq_minus_O : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)", "predict": "postulate inv_eq_minus_O : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1188$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1189$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Sig_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom Sig_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nSum_ind. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_521$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_inl$ från element $x_522$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_522$, för alla funktioner $_H_inr$ från element $x_523$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_523$, för alla element $x_521$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_521$.\nassistant\n", "label": "postulate Sum_ind : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)", "predict": "postulate Sum_ind : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDivides_smallest_factor_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_primes.smallest_factor$ appliqué à $n$ et $n$.\nassistant\n", "label": "postulate divides_smallest_factor_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor n) n)", "predict": "postulate divides_smallest_factor_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor n) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBigop_false. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.\nassistant\n", "label": "bigop_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.false) B nil op (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) nil) .", "predict": "bigop_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.false) B nil op (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPermut_transpose_r. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $m$ et $i$ et $j$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $j$ et $m$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à la fonction qui envoie $n$ à $f$ appliqué à $matita_arithmetics_permutation.transpose$ appliqué à $i$ et $j$ et $n$ et $m$.\nassistant\n", "label": "Axiom permut_transpose_r : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le j m), forall __2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun n => f (matita_arithmetics_permutation.transpose i j n)) m) .", "predict": "Axiom permut_transpose_r : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le j m), forall __2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun n => f (matita_arithmetics_permutation.transpose i j n)) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_discr. Let $a1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_DPair$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_DPair$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$", "label": "axiom DPair_discr (a1 : cic.Univ univs.Type0) (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ univs.Type0) (x y : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((λ x0 => λ p0 => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (λ x0 => λ p0 => a2 x0) t1 u0 e0) u1) (λ _e1 => P))) (λ _z41 => P))) y) x)", "predict": "axiom DPair_discr (a1 : cic.Univ univs.Type0) (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ univs.Type0) (x y : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((λ x0 => λ p0 => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (λ x0 => λ p0 => a2 x0) t1 u0 e0) u1) (λ _e1 => P))) (λ _z41 => P))) y) x)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nEq_length_to_mem. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $matita_arithmetics_nat.nat$ et $l$ et $matita_arithmetics_nat.S$ appliqué à $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.unique$ appliqué à $matita_arithmetics_nat.nat$ et $l$, pour toutes les fonctions $__2$ des éléments $x$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $x$ et $l$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $x$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $n$ et $l$.\nassistant\n", "label": "postulate eq_length_to_mem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) (matita_arithmetics_nat.S n))) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__2 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.le x n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l)", "predict": "postulate eq_length_to_mem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) (matita_arithmetics_nat.S n))) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__2 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.le x n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMin_spec. Let $_n$ and $_b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom min_spec (_n _b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop", "predict": "axiom min_spec (_n _b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nGcd_O_to_eq_O. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate gcd_O_to_eq_O : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))", "predict": "postulate gcd_O_to_eq_O : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPermut_fg. Låt $f$ och $g$ vara funktioner från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $f$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $g$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på funktionen som avbildar $m$ som $f$ applicerat på $g$ applicerat på $m$ och $n$.\nassistant\n", "label": "permut_fg : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n) -> __1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => f (g m)) n) .", "predict": "permut_fg : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n) -> __1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => f (g m)) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNat_ind. Soit $Q_$ une fonction des éléments $_x_365$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_O$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H_S$ des éléments $x_366$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_368$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_366$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_366$, pour tous les éléments $x_365$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_365$.\nassistant\n", "label": "axiom nat_ind (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_365)", "predict": "axiom nat_ind (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_365)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nSub_comp_l. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $R$ et $R1$ et $R2$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_relations.subR$ appliqué à $A$ et $R1$ et $R2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.subR$ appliqué à $A$ et $matita_basics_relations.Rcomp$ appliqué à $A$ et $R1$ et $R$ et $matita_basics_relations.Rcomp$ appliqué à $A$ et $R2$ et $R$.\nassistant\n", "label": "Axiom sub_comp_l : forall A : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R1 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R2 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2), cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 R) (matita_basics_relations.Rcomp A R2 R)) .", "predict": "Axiom sub_comp_l : forall A : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R1 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R2 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2), cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 R) (matita_basics_relations.Rcomp A R2 R)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_congruent. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "axiom divides_to_congruent (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m))) : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)", "predict": "axiom divides_to_congruent (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m))) : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom match_Prod (_A _B : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term return_sort (return_type z)", "predict": "axiom match_Prod (_A _B : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLength_body. För alla element $H$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom length_body (H : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom length_body (H : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nCompose. Soient $A$ et $B$ et $C$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $C$, pour toutes les fonctions $_g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $_x$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $univs.Type0$ et $C$.\nassistant\n", "label": "postulate compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_x : cic.Term univs.Type0 A) -> cic.Term univs.Type0 C", "predict": "postulate compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_x : cic.Term univs.Type0 A) -> cic.Term univs.Type0 C"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAnd_rect_Type2_body. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_134$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_conj$ från element $x_136$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_135$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_136$ och $x_135$, för alla element $x_134$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_134$.\nassistant\n", "label": "And_rect_Type2_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type2) -> _H_conj : (x_136 : cic.Term cic.prop _A -> x_135 : cic.Term cic.prop _B -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type2 (Q_ x_134) .", "predict": "And_rect_Type2_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type2) -> _H_conj : (x_136 : cic.Term cic.prop _A -> x_135 : cic.Term cic.prop _B -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type2 (Q_ x_134) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig_rect_CProp2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.\nassistant\n", "label": "axiom Sig_rect_CProp2_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_684)", "predict": "axiom Sig_rect_CProp2_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_684)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nK. Pour tous les éléments $_n$ et $_p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom k : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom k : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNat_rect_Type3. Låt $Q_$ vara en funktion från element $_x_377$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $univs.Type3$. Då för alla element $_H_O$ av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H_S$ från element $x_378$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_380$ av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $x_378$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_378$, för alla element $x_377$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_377$.\nassistant\n", "label": "axiom nat_rect_Type3 (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type3 (Q_ x_377)", "predict": "axiom nat_rect_Type3 (Q_ : (_x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) (_H_O : cic.Term univs.Type3 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : cic.Term univs.Type3 (Q_ x_378)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_nat.S x_378))) (x_377 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type3 (Q_ x_377)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_minr. Låt $i$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $matita_arithmetics_nat.min$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $m$.\nassistant\n", "label": "Axiom le_minr : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m)), cic.Term cic.prop (matita_arithmetics_nat.le i m) .", "predict": "Axiom le_minr : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m)), cic.Term cic.prop (matita_arithmetics_nat.le i m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDpi2. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $f$, håller $cic.Term$ för $univs.Type0$ och $f$ applicerat på $matita_basics_types.dpi1$ applicerat på $A$ och $f$ och $xxx$.\nassistant\n", "label": "axiom dpi2 (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) : cic.Term univs.Type0 (f (matita_basics_types.dpi1 A f xxx))", "predict": "axiom dpi2 (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) : cic.Term univs.Type0 (f (matita_basics_types.dpi1 A f xxx))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_div_to_times. För alla element $n$ och $m$ och $q$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $q$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $q$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $matita_arithmetics_nat.times$ applicerat på $q$ och $m$.\nassistant\n", "label": "postulate lt_div_to_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times q m))", "predict": "postulate lt_div_to_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times q m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_rect_Type3. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_921$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_921$.\nassistant\n", "label": "postulate range_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type3 (Q_ x_921)", "predict": "postulate range_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type3) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_921 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type3 (Q_ x_921)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_15611. Soient $p$ et $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $gcd1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $nm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $p$ et $c$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $b$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$", "label": "Axiom let_clause_15611 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m))", "predict": "Axiom let_clause_15611 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m))))), cic.prop (matita_basics_logic.eq (cic.lift"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_893$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_893$.\nassistant\n", "label": "postulate ACop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type5 (Q_ x_893)", "predict": "postulate ACop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type5 (Q_ x_893)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z131$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z132$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate True_inv_rect_Type4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z131 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H1 : (_z132 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type4 (P matita_basics_logic.I)) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate True_inv_rect_Type4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z131 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) -> (_H1 : (_z132 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type4 (P matita_basics_logic.I)) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNill_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $nil$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $nil$ och $a$ och $a$.\nassistant\n", "label": "axiom nill_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)", "predict": "axiom nill_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nACop_rect_CProp2. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_909$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_909$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_909$.\nassistant\n", "label": "axiom ACop_rect_CProp2 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_909)", "predict": "axiom ACop_rect_CProp2 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_909)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTrue_inv_rect_Type2. För alla element $Hterm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, för alla funktioner $P$ från element $_z143$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H1$ från element $_z144$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.True$ och $Hterm$ och $matita_basics_logic.I$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_basics_logic.I$, håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "True_inv_rect_Type2 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z143 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type2) -> _H1 : (_z144 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term univs.Type2 (P matita_basics_logic.I)) -> cic.Term univs.Type2 (P Hterm) .", "predict": "True_inv_rect_Type2 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z143 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type2) -> _H1 : (_z144 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term univs.Type2 (P matita_basics_logic.I)) -> cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLstar_r_O. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$, pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_lstar.lstar_r$ appliqué à $B$ et $R$ et $matita_arithmetics_nat.O$ et $b$ et $b$.\nassistant\n", "label": "lstar_r_O : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b) .", "predict": "lstar_r_O : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nExp_ord. Låt $p$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $matita_arithmetics_ord.ord$ applicerat på $n$ och $p$ och $matita_arithmetics_ord.ord_rem$ applicerat på $n$ och $p$.\nassistant\n", "label": "Axiom exp_ord : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)) (matita_arithmetics_ord.ord_rem n p))) .", "predict": "Axiom exp_ord : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)) (matita_arithmetics_ord.ord_rem n p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nUnique. Pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $H$, $cic.Univ$ tient pour $cic.prop$.\nassistant\n", "label": "axiom unique (H : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Univ cic.prop", "predict": "axiom unique (H : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNat_rect_CProp3_body. Pour toutes les fonctions $Q_$ des éléments $_x_401$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_O$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H_S$ des éléments $x_402$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_404$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_402$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_402$, pour tous les éléments $x_401$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_401$.\nassistant\n", "label": "Axiom nat_rect_CProp3_body : forall Q_ : ((_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))), forall x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_401) .", "predict": "Axiom nat_rect_CProp3_body : forall Q_ : ((_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))), forall x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_401) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nReverse_cons. Pour tous les éléments $S$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $S$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $S$ et $matita_basics_lists_list.reverse$ appliqué à $S$ et $matita_basics_lists_list.cons$ appliqué à $S$ et $a$ et $l$ et $matita_basics_lists_list.append$ appliqué à $S$ et $matita_basics_lists_list.reverse$ appliqué à $S$ et $l$ et $matita_basics_lists_list.cons$ appliqué à $S$ et $a$ et $matita_basics_lists_list.nil$ appliqué à $S$.\nassistant\n", "label": "postulate reverse_cons : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))", "predict": "postulate reverse_cons : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nRev_append_body. För alla element $H$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ och $__1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$.\nassistant\n", "label": "postulate rev_append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)", "predict": "postulate rev_append_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNot_rect_Type2. Soit $_A$ un élément de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $Q_$ des éléments $_x_91$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_nmk$ des fonctions $x_92$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_92$, pour tous les éléments $x_91$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_91$.\nassistant\n", "label": "Axiom Not_rect_Type2 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type2), forall _H_nmk : ((x_92 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))), forall x_91 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type2 (Q_ x_91) .", "predict": "Axiom Not_rect_Type2 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type2), forall _H_nmk : ((x_92 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))), forall x_91 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type2 (Q_ x_91) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_to_div. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $m$ et $n$ et $n$ et $m$.\nassistant\n", "label": "Axiom divides_to_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m) .", "predict": "Axiom divides_to_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNat_rect_Type4. Låt $Q_$ vara en funktion från element $_x_369$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $univs.Type4$. Då för alla element $_H_O$ av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H_S$ från element $x_370$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_372$ av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $x_370$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_370$, för alla element $x_369$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_369$.\nassistant\n", "label": "postulate nat_rect_Type4 : (Q_ : (_x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type4) -> (_H_O : cic.Term univs.Type4 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_370 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_372 : cic.Term univs.Type4 (Q_ x_370)) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_nat.S x_370))) -> (x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type4 (Q_ x_369)", "predict": "postulate nat_rect_Type4 : (Q_ : (_x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type4) -> (_H_O : cic.Term univs.Type4 (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_370 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_372 : cic.Term univs.Type4 (Q_ x_370)) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_nat.S x_370))) -> (x_369 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type4 (Q_ x_369)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nTrue_rect_Type1_body. För alla funktioner $Q_$ från element $_x_50$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type1$, för alla element $_H_I$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_50$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_50$.\nassistant\n", "label": "postulate True_rect_Type1_body : (Q_ : (_x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) -> (_H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I)) -> (x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type1 (Q_ x_50)", "predict": "postulate True_rect_Type1_body : (Q_ : (_x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) -> (_H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I)) -> (x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type1 (Q_ x_50)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nSameF_upto. För alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $A$ av $cic.Univ$ av $univs.Type0$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $cic.prod$ applicerat på $univs.Type0$ och $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $__1$ som $A$.\nassistant\n", "label": "Axiom sameF_upto : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __1 => A))) .", "predict": "Axiom sameF_upto : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __1 => A))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nSplit_len. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $A$ et $matita_basics_types.fst$ appliqué à $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.split$ appliqué à $A$ et $l$ et $n$ et $n$.\nassistant\n", "label": "axiom split_len (A : cic.Univ univs.Type0) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))) n)", "predict": "axiom split_len (A : cic.Univ univs.Type0) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_Psi_BPsi. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_chebyshev_factorization.B$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $n$.\nassistant\n", "label": "postulate le_Psi_BPsi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "postulate le_Psi_BPsi : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_inv_rect_CProp3. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z167$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z168$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "True_inv_rect_CProp3 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z167 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) .", "predict": "True_inv_rect_CProp3 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z167 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNot_inv_rect_Type0. För alla element $x1$ av $cic.Univ$ av $cic.prop$, för alla element $Hterm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $x1$, för alla funktioner $P$ från element $_z287$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H1$ från funktioner $x_98$ från element $__$ av $cic.Term$ av $cic.prop$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ och element $_z288$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.Not$ applicerat på $x1$ och $Hterm$ och $matita_basics_logic.nmk$ applicerat på $x1$ och $x_98$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_logic.nmk$ applicerat på $x1$ och $x_98$, håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "postulate Not_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z287 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type0) -> (_H1 : (x_98 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z288 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate Not_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z287 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type0) -> (_H1 : (x_98 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z288 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P (matita_basics_logic.nmk x1 x_98))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nBool_rect_Type3. Pour toutes les fonctions $Q_$ des éléments $_x_335$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type3$, pour tous les éléments $_H_true$ de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_335$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_335$.\nassistant\n", "label": "bool_rect_Type3 : Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false) -> x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3 (Q_ x_335) .", "predict": "bool_rect_Type3 : Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false) -> x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3 (Q_ x_335) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nCons_injective_r. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $a1$ och $a2$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $l1$ och $l2$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.cons$ applicerat på $A$ och $a1$ och $l1$ och $matita_basics_lists_list.cons$ applicerat på $A$ och $a2$ och $l2$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l1$ och $l2$.\nassistant\n", "label": "postulate cons_injective_r : (A : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)", "predict": "postulate cons_injective_r : (A : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDistr_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $nil$, för alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.prod$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $nil$ och $matita_arithmetics_bigops.sum$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $nil$ och $matita_arithmetics_bigops.sum$ applicerat på $A$ och $nil$ och $xxx$ och $matita_arithmetics_bigops.prod$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ och $matita_arithmetics_bigops.prod$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $c$.\nassistant\n", "label": "distr_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) .", "predict": "distr_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_ind. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_811$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_810$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_811$ och $x_810$, för alla element $x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_809$.\nassistant\n", "label": "axiom div_mod_spec_ind (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_809)", "predict": "axiom div_mod_spec_ind (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_809)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nUnit_rect_CProp5_body. Pour toutes les fonctions $Q_$ des éléments $_x_511$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_it$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_511$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_511$.\nassistant\n", "label": "axiom unit_rect_CProp5_body (Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_511 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_511)", "predict": "axiom unit_rect_CProp5_body (Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_511 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_511)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nRange_rect_Type2. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$, för alla element $x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_923$.\nassistant\n", "label": "axiom range_rect_Type2 (_A : cic.Univ univs.Type0) (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type2 (Q_ x_923)", "predict": "axiom range_rect_Type2 (_A : cic.Univ univs.Type0) (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type2 (Q_ x_923)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nUnit_rect_Type3_body. Pour toutes les fonctions $Q_$ des éléments $_x_501$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type3$, pour tous les éléments $_H_it$ de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_501$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_501$.\nassistant\n", "label": "unit_rect_Type3_body : Q_ : (_x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type3) -> _H_it : cic.Term univs.Type3 (Q_ matita_basics_types.it) -> x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type3 (Q_ x_501) .", "predict": "unit_rect_Type3_body : Q_ : (_x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type3) -> _H_it : cic.Term univs.Type3 (Q_ matita_basics_types.it) -> x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type3 (Q_ x_501) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_plus_div. Låt $m$ och $n$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $m$ och $q$ och $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $q$ och $matita_arithmetics_div_and_mod.div$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $m$ och $n$ och $q$.\nassistant\n", "label": "postulate le_plus_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div m q) (matita_arithmetics_div_and_mod.div n q)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus m n) q))", "predict": "postulate le_plus_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div m q) (matita_arithmetics_div_and_mod.div n q)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus m n) q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_exp_priml. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nassistant\n", "label": "postulate le_exp_priml : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))", "predict": "postulate le_exp_priml : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nOrd_rem. Pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "ord_rem : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "ord_rem : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_to_not_le. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_nat.le$ applicerat på $m$ och $n$.\nassistant\n", "label": "lt_to_not_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n)) .", "predict": "lt_to_not_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAop_inv_rect_Type0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1398$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic", "label": "axiom Aop_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) (P : (_z1398 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type0) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1399 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom Aop_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) (P : (_z1398 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type0) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1399 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPsi. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom Psi : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom Psi : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nGcd_O_l. Låt $m$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $matita_arithmetics_nat.O$ och $m$ och $m$.\nassistant\n", "label": "gcd_O_l : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m) .", "predict": "gcd_O_l : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPair_destruct_2. För alla element $A$ och $B$ av $cic.Univ$ av $univs.Type0$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $a$ och $b$ och $c$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $b$ och $matita_basics_types.snd$ applicerat på $A$ och $B$ och $c$.\nassistant\n", "label": "pair_destruct_2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 B -> c : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b (matita_basics_types.snd A B c)) .", "predict": "pair_destruct_2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 B -> c : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b (matita_basics_types.snd A B c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nEq_rect_Type3_r. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type2$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type2$ et de $A$, pour toutes les fonctions $P$ des éléments $x$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$ à des éléments de $cic.Univ$ de $univs.Type3$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $a$ et $matita_basics_logic.refl$ appliqué à $A$ et $a$, pour tous les éléments $x$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $p$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$, $cic.Term$ tient pour $univs.Type3$ et $P$ appliqué à $x$ et $p$.\nassistant\n", "label": "postulate eq_rect_Type3_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type3) -> (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type3 (P x p)", "predict": "postulate eq_rect_Type3_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type3) -> (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type3 (P x p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom ACop_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom ACop_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type2) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLt_exp. Pour tous les éléments $n$ et $m$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $p$ et $n$ et $matita_arithmetics_exp.exp$ appliqué à $p$ et $m$.\nassistant\n", "label": "lt_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) .", "predict": "lt_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNth_opt. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_types.option$ appliqué à $A$.\nassistant\n", "label": "Axiom nth_opt : forall A : cic.Univ univs.Type0, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term univs.Type0 (matita_basics_types.option A) .", "predict": "Axiom nth_opt : forall A : cic.Univ univs.Type0, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term univs.Type0 (matita_basics_types.option A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nSig_rect_Type1_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_674$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_674$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_674$.\nassistant\n", "label": "Axiom Sig_rect_Type1_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type1 (Q_ x_674) .", "predict": "Axiom Sig_rect_Type1_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type1 (Q_ x_674) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTimes_2_pred. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "times_2_pred : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred n)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) .", "predict": "times_2_pred : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred n)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_rect_Type3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.\nassistant\n", "label": "postulate option_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)", "predict": "postulate option_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMonotonic_le_minus_r. Pour tous les éléments $p$ et $q$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $q$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $n$ et $p$ et $matita_arithmetics_nat.minus$ appliqué à $n$ et $q$.\nassistant\n", "label": "axiom monotonic_le_minus_r (p q n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))", "predict": "axiom monotonic_le_minus_r (p q n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_to_le_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "Axiom true_to_le_min : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le b m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m) .", "predict": "Axiom true_to_le_min : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le b m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDistributive_times_plus. $cic.Term$ håller för $cic.prop$ och $matita_basics_relations.distributive$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.times$ och $matita_arithmetics_nat.plus$.\nassistant\n", "label": "distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus) .", "predict": "distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExteqR. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_R$ and $_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom exteqR : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _R : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall _S : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), cic.Univ cic.prop .", "predict": "Axiom exteqR : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _R : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall _S : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nSum_inv_rect_CProp2. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1020$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $x_572$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1021$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_572$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_572$, pour toutes les fonctions $_H2$ des éléments $x_573$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1021$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_573$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_573$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_873$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_n", "label": "axiom Aop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type0 (Q_ x_873)", "predict": "axiom Aop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type0 (Q_ x_873)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDiv_mod_spec_inv_rect_CProp1. Pour tous les éléments $x1$ et $x2$ et $x3$ et $x4$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $Hterm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $x1$ et $x2$ et $x3$ et $x4$, pour toutes les fonctions $P$ des éléments $_z1488$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $x1$ et $x2$ et $x3$ et $x4$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $x_855$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $x4$ et $x2$ et des éléments $x_854$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x1$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x3$ et $x2$ et $x4$ et des éléments $_z1489$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $x1$ et $x2$ et $x3$ et $x4$ et $Hterm$ et $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $x1$ et $x2$ et $x3$ et $x4$ et $x_855$ et $x_854$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $x1$ et $x2$ et $x3$ et $x4$ et $x_855$ et $x_854$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom div_mod_spec_inv_rect_CProp1 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) : cic.Term cic.prop (P Hterm)", "predict": "axiom div_mod_spec_inv_rect_CProp1 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z161$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "True_inv_rect_CProp4 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z161 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) .", "predict": "True_inv_rect_CProp4 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z161 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nBool_rect_CProp5_body. Soit $Q_$ une fonction des éléments $_x_350$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_true$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_350$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_350$.\nassistant\n", "label": "axiom bool_rect_CProp5_body (Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_350 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_350)", "predict": "axiom bool_rect_CProp5_body (Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_350 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_350)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNat_case. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.O$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $__1$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.S$ applicerat på $m$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $n$.\nassistant\n", "label": "postulate nat_case : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)", "predict": "postulate nat_case : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEx2_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.\nassistant\n", "label": "postulate ex2_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) -> (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term cic.prop (Q_ x_274)", "predict": "postulate ex2_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) -> (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term cic.prop (Q_ x_274)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nList_ind_body. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_716$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_nil$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $_H_cons$ des éléments $x_718$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_717$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_720$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_717$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_718$ et $x_717$, pour tous les éléments $x_716$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_716$.\nassistant\n", "label": "list_ind_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_718 : cic.Term univs.Type0 _A -> x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_720 : cic.Term cic.prop (Q_ x_717) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_716) .", "predict": "list_ind_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_718 : cic.Term univs.Type0 _A -> x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_720 : cic.Term cic.prop (Q_ x_717) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_716) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDivides_to_dividesb_true1. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $n$ och $m$ och $matita_basics_bool.true$.\nassistant\n", "label": "divides_to_dividesb_true1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) .", "predict": "divides_to_dividesb_true1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_inv_rect_Type1. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1392$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type", "label": "Axiom Aop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2), forall P : ((_z1392 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1393 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom Aop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2), forall P : ((_z1392 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1393 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_minus_to_plus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$.\nassistant\n", "label": "le_minus_to_plus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m)) .", "predict": "le_minus_to_plus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_1595. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $primepn$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $primepm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $lt1gcd$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $m$, för alla element $H$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_primes.smallest_factor$ applicerat på $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $m$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $", "label": "let_clause_1595 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) -> H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m)) .", "predict": "let_clause_1595 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) -> H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$,", "label": "axiom Aop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_879)", "predict": "axiom Aop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_879)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nFact_minus. Låt $n$ och $k$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $k$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_factorial.fact$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $k$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $k$ och $matita_arithmetics_factorial.fact$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $k$.\nassistant\n", "label": "axiom fact_minus (n k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt k n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S k))) (matita_arithmetics_nat.minus n k)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k)))", "predict": "axiom fact_minus (n k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt k n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S k))) (matita_arithmetics_nat.minus n k)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.\nassistant\n", "label": "DPair_rect_CProp4_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_652) .", "predict": "DPair_rect_CProp4_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_652) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_to_not_le. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$.\nassistant\n", "label": "axiom lt_to_not_le (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n))", "predict": "axiom lt_to_not_le (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nAop_rect_Type2_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_869$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$", "label": "axiom Aop_rect_Type2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type2 (Q_ x_869)", "predict": "axiom Aop_rect_Type2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type2 (Q_ x_869)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nExp_exp_times. Soient $n$ et $p$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $n$ et $p$ et $q$ et $matita_arithmetics_exp.exp$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $p$ et $q$.\nassistant\n", "label": "axiom exp_exp_times (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))", "predict": "axiom exp_exp_times (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFmax_false. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom fmax_false : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) .", "predict": "Axiom fmax_false : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_rect_CProp2. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_850$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_849$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp2 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_849)", "predict": "axiom div_mod_spec_rect_CProp2 (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_849)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nBool_inv_ind. För alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla funktioner $P$ från element $_z587$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z588$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$, för alla funktioner $_H2$ från element $_z588$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "bool_inv_ind : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z587 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) .", "predict": "bool_inv_ind : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z587 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nFilter_False. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "filter_False : return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z) .", "predict": "filter_False : return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAop_rect_CProp4_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_875$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de", "label": "Axiom Aop_rect_CProp4_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_875) .", "predict": "Axiom Aop_rect_CProp4_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_875) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1542$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $", "label": "Aop_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) .", "predict": "Axiom Aop_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPair_destruct_1. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $c$.\nassistant\n", "label": "pair_destruct_1 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 B -> c : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c)) .", "predict": "pair_destruct_1 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 B -> c : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_exp. Soient $n$ et $m$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $p$ et $n$ et $matita_arithmetics_exp.exp$ appliqué à $p$ et $m$.\nassistant\n", "label": "Axiom le_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) .", "predict": "Axiom le_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_inv_S. För alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$, för alla element $l0$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $l0$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $l$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $B$ och funktionen som avbildar $b$ som $R$ applicerat på $b1$ och $b$ och funktionen som avbildar $b$ som $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l0$ och $b$ och $b2$.\nassistant\n", "label": "lstar_inv_S : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> l0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S matita_arithmetics_nat.O)) l) -> cic.Term cic.prop (matita_basics_logic.ex2 B (b : cic.Term univs.Type0 B => R b1 b) (b : cic.Term univs.Type0 B => matita_arithmetics_lstar.lstar B R l0 b b2)) .", "predict": "lstar_inv_S : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> l0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus l0 (matita_arithmetics_nat.S matita_arithmetics_nat.O)) l) -> cic.Term cic.prop (matita_basics_logic.ex2 B (b : cic.Term univs.Type0 B => R b1 b) (b : cic.Term univs.Type0 B => matita_arithmetics_lstar.lstar B R l0 b b2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_theta. För alla element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applicerat på $m$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$.\nassistant\n", "label": "Axiom le_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) .", "predict": "Axiom le_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_inv_rect_Type1. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1260$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1261$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Prod_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type1) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P Hterm) .", "predict": "Prod_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type1) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDivides. För alla element $_n$ och $_m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Univ$ för $cic.prop$.\nassistant\n", "label": "Axiom divides : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom divides : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nACop_rect_CProp4. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_903$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_903$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_903$.\nassistant\n", "label": "axiom ACop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_903)", "predict": "axiom ACop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_903)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_660$.\nassistant\n", "label": "DPair_rect_CProp1 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_660) .", "predict": "DPair_rect_CProp1 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_660) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nEq_p_ord_inv. Soient $p$ et $m$ et $x$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord_inv$ appliqué à $p$ et $m$ et $x$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_ord.ord_rem$ appliqué à $x$ et $p$ et $m$ et $matita_arithmetics_ord.ord$ appliqué à $x$ et $p$.\nassistant\n", "label": "eq_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.p_ord_inv p m x) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_ord.ord_rem x p) m) (matita_arithmetics_ord.ord x p))) .", "predict": "eq_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.p_ord_inv p m x) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_ord.ord_rem x p) m) (matita_arithmetics_ord.ord x p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nXorb. Pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_bool.bool$.\nassistant\n", "label": "postulate xorb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate xorb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSig_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1200$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1201$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sig_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1200 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1201 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate Sig_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1200 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1201 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nEqb. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.\nassistant\n", "label": "postulate eqb : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate eqb : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nMin_body. Soient $__$ et $__1$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $__2$ des éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom min_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom min_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_O_n. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.O$ et $n$.\nassistant\n", "label": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)", "predict": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTimes_pi. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $p$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla funktioner $f$ och $g$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ och funktionen som avbildar $i$ som $matita_arithmetics_nat.times$ applicerat på $f$ applicerat på $i$ och $g$ applicerat på $i$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ och funktionen som avbildar $i$ som $g$ applicerat på $i$.\nassistant\n", "label": "axiom times_pi (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_nat.times (f i) (g i))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => f i)) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g i))))", "predict": "axiom times_pi (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_nat.times (f i) (g i))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => f i)) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g i))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTimes_body. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "times_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "times_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMinus_minus_associative. Soient $x$ et $y$ et $z$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $z$ et $y$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $y$ et $x$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $x$ et $matita_arithmetics_nat.minus$ appliqué à $y$ et $z$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $x$ et $y$ et $z$.\nassistant\n", "label": "axiom minus_minus_associative (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le y x)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus x y) z))", "predict": "axiom minus_minus_associative (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le y x)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus x y) z))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nConf3. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation2$ appliqué à $A$ et $B$, pour tous les éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$, $cic.Univ$ tient pour $cic.prop$.\nassistant\n", "label": "Axiom Conf3 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_relations.relation2 A B), forall __1 : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop .", "predict": "Axiom Conf3 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_relations.relation2 A B), forall __1 : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIncreasing_to_le. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_arithmetics_nat.le$ applied to $m$ and $f$ applied to $i$.\nassistant\n", "label": "axiom increasing_to_le (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_arithmetics_nat.le m (f i)))", "predict": "axiom increasing_to_le (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_arithmetics_nat.le m (f i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1674$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1675$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "range_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1674 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1675 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) .", "predict": "range_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1674 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1675 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLe_to_le_max. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_minimization.max$ applicerat på $n$ och $f$ och $matita_arithmetics_minimization.max$ applicerat på $m$ och $f$.\nassistant\n", "label": "axiom le_to_le_max (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max m f))", "predict": "axiom le_to_le_max (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max m f))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nSig_rect_Type5. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_668$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_668$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_668$.\nassistant\n", "label": "Sig_rect_Type5 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type5) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type5 (Q_ x_668) .", "predict": "Sig_rect_Type5 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type5) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_668 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type5 (Q_ x_668) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLe_plus_to_le. För alla element $a$ och $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $a$ och $n$ och $matita_arithmetics_nat.plus$ applicerat på $a$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$.\nassistant\n", "label": "le_plus_to_le : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a n) (matita_arithmetics_nat.plus a m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "le_plus_to_le : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a n) (matita_arithmetics_nat.plus a m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nMatch_ex2. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_P$ och $_Q$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $A$ och $_P$ och $_Q$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_ex2_intro$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__$ av $cic.Term$ av $cic.prop$ och $_P$ applicerat på $x$ och element $__1$ av $cic.Term$ av $cic.prop$ och $_Q$ applicerat på $x$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_logic.ex2_intro$ applicerat på $A$ och $_P$ och $_Q$ och $x$ och $__$ och $__1$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $A$ och $_P$ och $_Q$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "Axiom match_ex2 : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort), forall case_ex2_intro : ((x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))), forall z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term return_sort (return_type z) .", "predict": "Axiom match_ex2 : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort), forall case_ex2_intro : ((x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> (__1 : cic.Term cic.prop (_Q x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))), forall z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDop_inv_rect_CProp3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1740$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $", "label": "axiom Dop_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Dop_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_inv_rect_CProp3. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $P$ from elements $_z695$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z696$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_404$ from elements $_z696$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_402$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_402$ and elements $_z696$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "nat_inv_rect_CProp3 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z695 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (_z696 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> _H2 : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_404 : (_z696 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_402) -> cic.Term cic.prop (P x_402)) -> _z696 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_402)) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_402))) -> cic.Term cic.prop (P Hterm) .", "predict": "nat_inv_rect_CProp3 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z695 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (_z696 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> _H2 : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_404 : (_z696 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_402) -> cic.Term cic.prop (P x_402)) -> _z696 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_402)) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_402))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_rect_CProp2. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_766$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_768$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_767$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_770$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_767$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_768$ and $x_767$, for all elements $x_766$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_766$.\nassistant\n", "label": "postulate list_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)", "predict": "postulate list_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.\nassistant\n", "label": "Prod_rect_Type3_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type3) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type3 (Q_ x_696) .", "predict": "Prod_rect_Type3_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type3) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type3 (Q_ x_696) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1078. For all elements $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $ltrb$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $b$, for all elements $spec$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $b$ and $r$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, for all elements $ltr1b$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r1$ and $b$, for all elements $spec1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q1$ and $b$ and $r1$, for all elements $leqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $q1$, for all elements $ltqq1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $q1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $un", "label": "let_clause_1078 : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r) -> ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b) -> spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r)) -> _clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1) -> ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b) -> spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1)) -> leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1) -> ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q))) .", "predict": "let_clause_1078 : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r) -> ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b) -> spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r)) -> _clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1) -> ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b) -> spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1)) -> leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1) -> ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nACop_rect_Type5. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_893$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_893$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_893$.\nassistant\n", "label": "postulate ACop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type5 (Q_ x_893)", "predict": "postulate ACop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type5 (Q_ x_893)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nFilter_range. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "filter_range : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term return_sort (return_type z) .", "predict": "filter_range : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_plus_to_minus. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "axiom le_plus_to_minus (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)", "predict": "axiom le_plus_to_minus (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1560. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "let_clause_1560 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) .", "predict": "let_clause_1560 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_gcd_l. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $n$.\nassistant\n", "label": "postulate divides_gcd_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n)", "predict": "postulate divides_gcd_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nFst. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $A$ et $B$, $cic.Term$ tient pour $univs.Type0$ et $A$.\nassistant\n", "label": "postulate fst : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A", "predict": "postulate fst : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAop_rect_Type0_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_793$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $un", "label": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)", "predict": "postulate Aop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFilter_max_spec. För alla element $_n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $__$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $__$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $__$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "postulate filter_max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBi_symmetric. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "bi_symmetric : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Univ cic.prop .", "predict": "bi_symmetric : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBertrand_down. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.\nassistant\n", "label": "Axiom bertrand_down : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) .", "predict": "Axiom bertrand_down : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_unit. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_it$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.it$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "match_unit : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ return_sort) -> case_it : cic.Term return_sort (return_type matita_basics_types.it) -> z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term return_sort (return_type z) .", "predict": "match_unit : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ return_sort) -> case_it : cic.Term return_sort (return_type matita_basics_types.it) -> z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nPair_eq1. För alla element $A$ och $B$ av $cic.Univ$ av $univs.Type0$, för alla element $a1$ och $a2$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $a1$ och $b1$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $a2$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $a1$ och $a2$.\nassistant\n", "label": "Axiom pair_eq1 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall a1 : cic.Term univs.Type0 A, forall a2 : cic.Term univs.Type0 A, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2) .", "predict": "Axiom pair_eq1 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall a1 : cic.Term univs.Type0 A, forall a2 : cic.Term univs.Type0 A, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_CProp0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_780$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_777$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_778$ and $x_777$, for all elements $x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_776$.\nassistant\n", "label": "axiom list_rect_CProp0_body (_A : cic.Univ univs.Type0) (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_776)", "predict": "axiom list_rect_CProp0_body (_A : cic.Univ univs.Type0) (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_776)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nReverse_cons. För alla element $S$ av $cic.Univ$ av $univs.Type0$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $S$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $S$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $S$ och $matita_basics_lists_list.reverse$ applicerat på $S$ och $matita_basics_lists_list.cons$ applicerat på $S$ och $a$ och $l$ och $matita_basics_lists_list.append$ applicerat på $S$ och $matita_basics_lists_list.reverse$ applicerat på $S$ och $l$ och $matita_basics_lists_list.cons$ applicerat på $S$ och $a$ och $matita_basics_lists_list.nil$ applicerat på $S$.\nassistant\n", "label": "reverse_cons : S : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 S -> l : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))) .", "predict": "reverse_cons : S : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 S -> l : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a l)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_inv_step. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$, för alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$ och $b2$, håller $cic.Term$ för $cic.prop$ och $R$ applicerat på $b1$ och $b2$.\nassistant\n", "label": "lstar_inv_step : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2) -> cic.Term cic.prop (R b1 b2) .", "predict": "lstar_inv_step : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2) -> cic.Term cic.prop (R b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nSig_inv_rect_Type1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $x2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $cic.prop$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1194$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $x2$ applicerat på $pi1$ och element $_z1195$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sig$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $x1$ och $x2$ och $pi1$ och $_pi2$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "axiom Sig_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type1) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom Sig_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type1) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nACop_rect_Type2_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_897$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_897$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_897$.\nassistant\n", "label": "Axiom ACop_rect_Type2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type2 (Q_ x_897) .", "predict": "Axiom ACop_rect_Type2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type2 (Q_ x_897) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_S_times_2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom le_S_times_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))", "predict": "axiom le_S_times_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_15591. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.\nassistant\n", "label": "axiom let_clause_15591 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)", "predict": "axiom let_clause_15591 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLe_plus_b. Soient $b$ et $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n$ et $m$.\nassistant\n", "label": "axiom le_plus_b (b n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n b) m)) : cic.Term cic.prop (matita_arithmetics_nat.le n m)", "predict": "axiom le_plus_b (b n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n b) m)) : cic.Term cic.prop (matita_arithmetics_nat.le n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOption_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1056$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_603$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_603$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_603$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "option_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1056 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ univs.Type2) -> _H1 : (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term univs.Type2 (P (matita_basics_types.None x1))) -> _H2 : (x_603 : cic.Term univs.Type0 x1 -> _z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_603)) -> cic.Term univs.Type2 (P (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P Hterm) .", "predict": "option_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1056 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ univs.Type2) -> _H1 : (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term univs.Type2 (P (matita_basics_types.None x1))) -> _H2 : (x_603 : cic.Term univs.Type0 x1 -> _z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_603)) -> cic.Term univs.Type2 (P (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDPair_inv_rect_Type3. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1116$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type3$, pour toutes les fonctions $_H1$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1117$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$, $cic.Term$ tient pour $univs.Type3$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom DPair_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1116 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1117 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type3 (P Hterm) .", "predict": "Axiom DPair_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1116 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1117 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type3 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDistributive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ and $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom distributive (A : cic.Univ univs.Type0) (_f _g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop", "predict": "axiom distributive (A : cic.Univ univs.Type0) (_f _g : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLt_mod_m_m. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $m$ et $m$.\nassistant\n", "label": "lt_mod_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.mod n m) m) .", "predict": "lt_mod_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.mod n m) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNilr. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $a$.\nassistant\n", "label": "postulate nilr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a nil) a)", "predict": "postulate nilr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a nil) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_bertrand_to_le1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom not_bertrand_to_le1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))", "predict": "axiom not_bertrand_to_le1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLe_prim_n1. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $n$.\nassistant\n", "label": "axiom le_prim_n1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)", "predict": "axiom le_prim_n1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nProd_inv_ind. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1236$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1237$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDPair_rect_CProp3. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_656$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_DPair$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$, pour tous les éléments $x_656$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_656$.\nassistant\n", "label": "Axiom DPair_rect_CProp3 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_656) .", "predict": "Axiom DPair_rect_CProp3 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_656) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_minus_to_plus. För alla element $n$ och $m$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $matita_arithmetics_nat.plus$ applicerat på $p$ och $m$.\nassistant\n", "label": "Axiom le_minus_to_plus : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p), cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m)) .", "predict": "Axiom le_minus_to_plus : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p), cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_1531. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $eqm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom let_clause_1531 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "axiom let_clause_1531 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_to_congruent. Pour tous les éléments $n$ et $m$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $m$ et $n$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_nat.minus$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_congruence.congruent$ appliqué à $n$ et $m$ et $p$.\nassistant\n", "label": "Axiom divides_to_congruent : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m)), cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p) .", "predict": "Axiom divides_to_congruent : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m)), cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_le. For all elements $_n$ and $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_le : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z) .", "predict": "filter_le : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNilr_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $a$.\nassistant\n", "label": "nilr_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a nil) a) .", "predict": "nilr_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a nil) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_r_sn. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.\nassistant\n", "label": "axiom lstar_r_sn (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) (b1 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (R b1 b)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)", "predict": "axiom lstar_r_sn (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) (b1 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (R b1 b)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTimes_n_1. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom times_n_1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "axiom times_n_1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDiv_p_ord_inv. Soient $p$ et $m$ et $x$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_ord.ord$ appliqué à $x$ et $p$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_ord.p_ord_inv$ appliqué à $p$ et $m$ et $x$ et $m$ et $matita_arithmetics_ord.ord_rem$ appliqué à $x$ et $p$.\nassistant\n", "label": "Axiom div_p_ord_inv : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord_rem x p)) .", "predict": "Axiom div_p_ord_inv : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord_rem x p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nMonotonic_le_minus_l. Soient $p$ et $q$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $q$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $q$ et $n$ et $matita_arithmetics_nat.minus$ appliqué à $p$ et $n$.\nassistant\n", "label": "monotonic_le_minus_l : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le q p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) .", "predict": "monotonic_le_minus_l : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le q p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nRelation3. Soient $__$ et $__1$ et $__2$ des éléments de $cic.Univ$ de $univs.Type0$. Alors $cic.Univ$ tient pour $univs.Type0$.\nassistant\n", "label": "relation3 : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 .", "predict": "relation3 : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLt_to_le_to_lt_times. Pour tous les éléments $n$ et $m$ et $p$ et $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $p$ et $q$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $q$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.times$ appliqué à $n$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $q$.\nassistant\n", "label": "postulate lt_to_le_to_lt_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p q)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times m q))", "predict": "postulate lt_to_le_to_lt_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p q)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times m q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLeq_sqrt_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.\nassistant\n", "label": "postulate leq_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n)", "predict": "postulate leq_sqrt_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLe_exp_Psil. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nassistant\n", "label": "axiom le_exp_Psil (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))", "predict": "axiom le_exp_Psil (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDpi1__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_basics_lists_list.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_807$ and $_x_808$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.\nassistant\n", "label": "dpi1__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1) -> cic.Univ univs.Type0) -> x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2) -> _x_807 : cic.Term univs.Type0 x0 -> _x_808 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 .", "predict": "dpi1__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : (__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1) -> cic.Univ univs.Type0) -> x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2) -> _x_807 : cic.Term univs.Type0 x0 -> _x_808 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nACop_inv_rect_CProp2. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1614$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $b$ et $a$ et des éléments $_z1615$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom ACop_inv_rect_CProp2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1614 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1615 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)", "predict": "axiom ACop_inv_rect_CProp2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1614 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1615 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBigop_sum. For all elements $k1$ and $k2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.plus$ applied to $k1$ and $k2$ and the function that maps $i$ to $matita_basics_bool.match_bool$ applied to $univs.Type0$ and the function that maps $__$ to $matita_basics_bool.bool$ and $p1$ applied to", "label": "axiom bigop_sum (k1 k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (λ i => p1 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f i)) (matita_arithmetics_bigops.bigop k2 (λ i => p2 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_arithmetics_nat.leb k2 i))))", "predict": "axiom bigop_sum (k1 k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (λ i => p1 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f i)) (matita_arithmetics_bigops.bigop k2 (λ i => p2 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_arithmetics_nat.leb k2 i))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.\nassistant\n", "label": "axiom DPair_rect_Type3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)", "predict": "axiom DPair_rect_Type3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_r_sn. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.\nassistant\n", "label": "postulate lstar_r_sn : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) -> (b1 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)", "predict": "postulate lstar_r_sn : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) -> (b1 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNth. Pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $H$, pour tous les éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $H$, $cic.Term$ tient pour $univs.Type0$ et $H$.\nassistant\n", "label": "axiom nth (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (H : cic.Univ univs.Type0) (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) (__2 : cic.Term univs.Type0 H) : cic.Term univs.Type0 H", "predict": "axiom nth (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (H : cic.Univ univs.Type0) (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) (__2 : cic.Term univs.Type0 H) : cic.Term univs.Type0 H"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNot_rect_Type0_body. Soit $_A$ un élément de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $Q_$ des éléments $_x_97$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_nmk$ des fonctions $x_98$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_98$, pour tous les éléments $x_97$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_97$.\nassistant\n", "label": "axiom Not_rect_Type0_body (_A : cic.Univ cic.prop) (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type0 (Q_ x_97)", "predict": "axiom Not_rect_Type0_body (_A : cic.Univ cic.prop) (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type0 (Q_ x_97)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_B_Psi4. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_chebyshev_factorization.B$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.\nassistant\n", "label": "postulate le_B_Psi4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)))", "predict": "postulate le_B_Psi4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nSigma_const. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $matita_basics_bool.true$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $i$ som $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nassistant\n", "label": "postulate sigma_const : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)", "predict": "postulate sigma_const : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLhd_cons_ltl. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.append$ applicerat på $A$ och $matita_basics_lists_list.lhd$ applicerat på $A$ och $l$ och $n$ och $matita_basics_lists_list.ltl$ applicerat på $A$ och $l$ och $n$ och $l$.\nassistant\n", "label": "lhd_cons_ltl : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l) .", "predict": "lhd_cons_ltl : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFact_body. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate fact_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate fact_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNot_inv_rect_Type2. För alla element $x1$ av $cic.Univ$ av $cic.prop$, för alla element $Hterm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $x1$, för alla funktioner $P$ från element $_z275$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H1$ från funktioner $x_92$ från element $__$ av $cic.Term$ av $cic.prop$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ och element $_z276$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.Not$ applicerat på $x1$ och $Hterm$ och $matita_basics_logic.nmk$ applicerat på $x1$ och $x_92$ till element av $cic.Term$ av $univs.Type2$ och $P$ applicerat på $matita_basics_logic.nmk$ applicerat på $x1$ och $x_92$, håller $cic.Term$ för $univs.Type2$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "axiom Not_inv_rect_Type2 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom Not_inv_rect_Type2 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFalse_rect_CProp2_body. För alla funktioner $Q_$ från element $_x_76$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $cic.prop$, för alla element $x_76$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_76$.\nassistant\n", "label": "postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)", "predict": "postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAssoc. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.\nassistant\n", "label": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))", "predict": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_r_ind. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$, för alla funktioner $Q_$ från element $x_1337$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $x_1336$ av $cic.Term$ av $univs.Type0$ och $B$ och element $x_1335$ av $cic.Term$ av $univs.Type0$ och $B$ och element $_x_1338$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $_R$ och $x_1337$ och $x_1336$ och $x_1335$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_lstar_r_O$ från element $b$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.O$ och $b$ och $b$ och $matita_arithmetics_lstar.lstar_r_O$ applicerat på $B$ och $_R$ och $b$, för alla funktioner $_H_lstar_r_S$ från element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $b1$ av $cic.Term$ av $univs.Type0$ och $B$ och element $b$ av $cic.Term$ av $univs.Type0$ och $B$ och element $x_1340$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $cic.Term$ av $univs.Type0$ och $B$ och element $x_1339$ av $cic.Term$ av $cic.prop$ och $_R$ applicerat på $b$ och $b2$ och element $_x_1342$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $l$ och $b1$ och $b$ och $x_1340$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applic", "label": "lstar_r_ind : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita", "predict": "lstar_r_ind : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339 _x_1342))) -> x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMod_O_to_divides. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$.\nassistant\n", "label": "axiom mod_O_to_divides (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_primes.divides n m)", "predict": "axiom mod_O_to_divides (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_primes.divides n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLet_clause_1559. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $divnm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $d$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $auto$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.O$ et $d$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $n$.\nassistant\n", "label": "axiom let_clause_1559 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)", "predict": "axiom let_clause_1559 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nConf3. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom Conf3 (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_relations.relation2 A B)) (__1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop", "predict": "axiom Conf3 (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_relations.relation2 A B)) (__1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10331. Let $p$ and $n$ and $n1$ and $q$ and $p1$ and $p2$ and $qa$ and $ra$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $p2$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "Axiom let_clause_10331 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall qa : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall ra : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S (matita_arithmetics_nat.S p2))) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra)), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_10331 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall qa : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall ra : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.S (matita_arithmetics_nat.S p2))) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra)), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nGcd_SO_n. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate gcd_SO_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "postulate gcd_SO_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEq_map. För alla element $A$ och $B$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $f$ och $g$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla funktioner $__$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $f$ applicerat på $x$ och $g$ applicerat på $x$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $B$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $f$ och $l$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $g$ och $l$.\nassistant\n", "label": "axiom eq_map (A B : cic.Univ univs.Type0) (f g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : (x : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f x) (g x))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.map A B f l) (matita_basics_lists_list.map A B g l))", "predict": "axiom eq_map (A B : cic.Univ univs.Type0) (f g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : (x : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f x) (g x))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.map A B f l) (matita_basics_lists_list.map A B g l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExp_sigma. For all elements $n$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $a$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate exp_sigma : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "postulate exp_sigma : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1542$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic", "label": "axiom Aop_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Aop_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNilr_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $a$.\nassistant\n", "label": "axiom nilr_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a nil) a)", "predict": "axiom nilr_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a nil) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Univ$ tient pour $univs.Type0$.\nassistant\n", "label": "Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> cic.Univ univs.Type0 .", "predict": "Aop : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nACop_inv_rect_CProp0. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1626$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1627$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "Axiom ACop_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1626 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1627 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom ACop_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1626 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1627 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPrimes_below_to_bertrand. Pour tous les éléments $pm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $pm$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_chebyshev_bertrand256.primes_below$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $pm$, pour toutes les fonctions $__2$ des éléments $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $p$ et $l$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $pp$ à $matita_basics_logic.And$ appliqué à $matita_basics_logic.And$ appliqué à $matita_basics_lists_list.mem$ appliqué à $matita_arithmetics_nat.nat$ et $pp$ et $l$ et $matita_arithmetics_nat.lt$ appliqué à $pp$ et $p$ et $matita_arithmetics_nat.le$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $pp$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous", "label": "axiom primes_below_to_bertrand (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)", "predict": "axiom primes_below_to_bertrand (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDistr. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.\nassistant\n", "label": "postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))", "predict": "postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nProd_rect_CProp5_body. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_706$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_706$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_706$.\nassistant\n", "label": "Prod_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_706) .", "predict": "Prod_rect_CProp5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_706 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_706) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_le_to_leb_false. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "Axiom not_le_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) .", "predict": "Axiom not_le_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDiv_mod_spec_intro. Soient $n$ et $m$ et $q$ et $r$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $r$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $q$ et $m$ et $r$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $n$ et $m$ et $q$ et $r$.\nassistant\n", "label": "Axiom div_mod_spec_intro : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt r m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)), cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r) .", "predict": "Axiom div_mod_spec_intro : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt r m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)), cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.\nassistant\n", "label": "DPair_rect_CProp4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_652) .", "predict": "DPair_rect_CProp4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_652) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMatch_bool. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $return_sort$, för alla element $case_true$ av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_bool.true$, för alla element $case_false$ av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_bool.false$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "postulate match_bool : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) -> (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) -> (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) -> (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type z)", "predict": "postulate match_bool : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) -> (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) -> (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) -> (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNat_inv_rect_Type0. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $P$ des éléments $_z683$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H1$ des éléments $_z684$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.O$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H2$ des éléments $x_390$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_x_392$ des éléments $_z684$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $x_390$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $x_390$ et des éléments $_z684$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.S$ appliqué à $x_390$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_390$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "nat_inv_rect_Type0 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) -> _H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390) -> cic.Term univs.Type0 (P x_390)) -> _z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390)) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P Hterm) .", "predict": "nat_inv_rect_Type0 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) -> _H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390) -> cic.Term univs.Type0 (P x_390)) -> _z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390)) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLt_plus. Låt $n$ och $m$ och $p$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $n$ och $p$ och $matita_arithmetics_nat.plus$ applicerat på $m$ och $q$.\nassistant\n", "label": "postulate lt_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus m q))", "predict": "postulate lt_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus m q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nAnd_rect_Type5. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_126$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_conj$ från element $x_128$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_127$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_128$ och $x_127$, för alla element $x_126$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_126$.\nassistant\n", "label": "Axiom And_rect_Type5 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5), forall _H_conj : ((x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))), forall x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type5 (Q_ x_126) .", "predict": "Axiom And_rect_Type5 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5), forall _H_conj : ((x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))), forall x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type5 (Q_ x_126) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAop_inv_rect_Type2. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1518$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$", "label": "postulate Aop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate Aop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nFact_to_exp1. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_factorial.fact$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.pred$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_factorial.fact$ appliqué à $n$ et $matita_arithmetics_factorial.fact$ appliqué à $n$.\nassistant\n", "label": "postulate fact_to_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)))", "predict": "postulate fact_to_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nProd_inv_rect_Type1. För alla element $x1$ och $x2$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1260$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1261$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "axiom Prod_inv_rect_Type1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type1) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom Prod_inv_rect_Type1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type1) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nSig_inv_rect_Type2. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1188$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1189$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom Sig_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom Sig_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1188 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1189 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nOption_discr. Låt $a1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x$ och $y$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $a1$, för alla element $_e$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $a1$ och $x$ och $y$, håller $cic.Term$ för $univs.Type2$ och $matita_basics_types.match_option$ applicerat på $a1$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och $matita_basics_types.match_option$ applicerat på $a1$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $cic.prod$ applicerat på $univs.Type1$ och $univs.Type1$ och $P$ och funktionen som avbildar $_z37$ som $P$ och funktionen som avbildar $u0$ som $cic.prod$ applicerat på $cic.succ$ applicerat på $univs.Type1$ och $univs.Type1$ och $cic.univ$ applicerat på $univs.Type1$ och funktionen som avbildar $P$ som $P$ och $y$ och funktionen som avbildar $t0$ som $matita_basics_types.match_option$ applicerat på $a1$ och $cic.succ$ applicerat på $univ", "label": "Axiom option_discr : forall a1 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_types.option a1), forall y : cic.Term univs.Type0 (matita_basics_types.option a1), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option a1)) x y), cic.Term univs.Type2 (matita_basics_types.match_option a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (matita_basics_types.match_option a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 P (fun _z37 => P))) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) y) (fun t0 => matita_basics_types.match_option a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun _e0 => P)) (fun _z38 => P))) y) x) .", "predict": "Axiom option_discr : forall a1 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_types.option a1), forall y : cic.Term univs.Type0 (matita_basics_types.option a1), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option a1)) x y), cic.Term univs.Type2 (matita_basics_types.match_option a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (matita_basics_types.match_option a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 P (fun _z37 => P))) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) y) (fun t0 => matita_basics_types.match_option a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) (fun u0 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun _e0 => P)) (fun _z38 => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_Type4_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_813$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type4_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4), forall _H_div_mod_spec_intro : ((x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))), forall x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type4 (Q_ x_813) .", "predict": "Axiom div_mod_spec_rect_Type4_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4), forall _H_div_mod_spec_intro : ((x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))), forall x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type4 (Q_ x_813) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nUnit_ind. För alla funktioner $Q_$ från element $_x_495$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_it$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_495$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_495$.\nassistant\n", "label": "axiom unit_ind (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_495 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_495)", "predict": "axiom unit_ind (Q_ : (_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_495 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_495)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nCr_pair2. $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chinese_reminder.cr_pair$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom cr_pair2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "axiom cr_pair2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nTimes_body. Soient $__$ et $__1$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "times_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "times_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nEx_inv_ind. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z455$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $x$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $x_236$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $x$ et des éléments $_z456$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.ex$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_logic.ex_intro$ appliqué à $x1$ et $x2$ et $x$ et $x_236$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.ex_intro$ appliqué à $x1$ et $x2$ et $x$ et $x_236$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom ex_inv_ind (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) (P : (_z455 : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) -> cic.Univ cic.prop) (_H1 : (x : cic.Term univs.Type0 x1) -> (x_236 : cic.Term cic.prop (x2 x)) -> (_z456 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2)) Hterm (matita_basics_logic.ex_intro x1 x2 x x_236))) -> cic.Term cic.prop (P (matita_basics_logic.ex_intro x1 x2 x x_236))) : cic.Term cic.prop (P Hterm)", "predict": "axiom ex_inv_ind (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) (P : (_z455 : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) -> cic.Univ cic.prop) (_H1 : (x : cic.Term univs.Type0 x1) -> (x_236 : cic.Term cic.prop (x2 x)) -> (_z456 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2)) Hterm (matita_basics_logic.ex_intro x1 x2 x x_236))) -> cic.Term cic.prop (P (matita_basics_logic.ex_intro x1 x2 x x_236))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDecidable_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$.\nassistant\n", "label": "postulate decidable_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m))", "predict": "postulate decidable_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEx2_commute. Låt $A0$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $P0$ och $P1$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A0$ till element av $cic.Univ$ av $cic.prop$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $A0$ och funktionen som avbildar $x0$ som $P0$ applicerat på $x0$ och funktionen som avbildar $x0$ som $P1$ applicerat på $x0$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $A0$ och funktionen som avbildar $x0$ som $P1$ applicerat på $x0$ och funktionen som avbildar $x0$ som $P0$ applicerat på $x0$.\nassistant\n", "label": "axiom ex2_commute (A0 : cic.Univ univs.Type0) (P0 P1 : (__ : cic.Term univs.Type0 A0) -> cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.ex2 A0 (λ x0 => P0 x0) (λ x0 => P1 x0))) : cic.Term cic.prop (matita_basics_logic.ex2 A0 (λ x0 => P1 x0) (λ x0 => P0 x0))", "predict": "axiom ex2_commute (A0 : cic.Univ univs.Type0) (P0 P1 : (__ : cic.Term univs.Type0 A0) -> cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.ex2 A0 (λ x0 => P0 x0) (λ x0 => P1 x0))) : cic.Term cic.prop (matita_basics_logic.ex2 A0 (λ x0 => P1 x0) (λ x0 => P0 x0))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nMonotonic_le_times_r. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.monotonic$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.le$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.times$ applicerat på $n$ och $m$.\nassistant\n", "label": "Axiom monotonic_le_times_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (fun m => matita_arithmetics_nat.times n m)) .", "predict": "Axiom monotonic_le_times_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (fun m => matita_arithmetics_nat.times n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMax_spec_ind_body. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla funktioner $Q_$ från element $x_971$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_972$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $_n$ och $_f$ och $x_971$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_found_max_spec$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $x_975$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $_n$ och element $x_974$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $x_973$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $_n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $i$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $m$ och $matita_arithmetics_minimization.found_max_spec$ applicerat på $_n$ och $_f$ och $m$ och", "label": "postulate max_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop) -> (_H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x", "predict": "postulate max_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop) -> (_H_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) ->"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nOption_map_none. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $x$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $B$ och $matita_basics_types.option_map$ applicerat på $A$ och $B$ och $f$ och $x$ och $matita_basics_types.None$ applicerat på $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $A$ och $x$ och $matita_basics_types.None$ applicerat på $A$.\nassistant\n", "label": "axiom option_map_none (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))", "predict": "axiom option_map_none (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSum_rect_Type2. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_541$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_inl$ des éléments $x_542$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_542$, pour toutes les fonctions $_H_inr$ des éléments $x_543$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_543$, pour tous les éléments $x_541$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_541$.\nassistant\n", "label": "postulate Sum_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2) -> (_H_inl : (x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> (_H_inr : (x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> (x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type2 (Q_ x_541)", "predict": "postulate Sum_rect_Type2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type2) -> (_H_inl : (x_542 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inl _A _B x_542))) -> (_H_inr : (x_543 : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.inr _A _B x_543))) -> (x_541 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type2 (Q_ x_541)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter_Aop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_Type3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_670$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_670$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_670$.\nassistant\n", "label": "Sig_rect_Type3_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type3) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type3 (Q_ x_670) .", "predict": "Sig_rect_Type3_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type3) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type3 (Q_ x_670) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_plus. Pour tous les éléments $n$ et $m$ et $p$ et $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $p$ et $q$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $n$ et $p$ et $matita_arithmetics_nat.plus$ appliqué à $m$ et $q$.\nassistant\n", "label": "axiom lt_plus (n m p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p q)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus m q))", "predict": "axiom lt_plus (n m p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p q)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus m q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLstar_ind_l. Pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $R$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $P$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation2$ appliqué à $matita_arithmetics_nat.nat$ et $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.O$ et $b2$, pour toutes les fonctions $__1$ des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b1$ et $b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b$ et $b2$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $l$ et $b$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $l$ et $b1$.\nassistant\n", "label": "postulate lstar_ind_l : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b1)", "predict": "postulate lstar_ind_l : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPrime_nth_prime. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$.\nassistant\n", "label": "axiom prime_nth_prime (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.nth_prime n))", "predict": "axiom prime_nth_prime (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.nth_prime n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nOr. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, håller $cic.Univ$ för $cic.prop$.\nassistant\n", "label": "axiom Or (_A _B : cic.Univ cic.prop) : cic.Univ cic.prop", "predict": "axiom Or (_A _B : cic.Univ cic.prop) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $m$.\nassistant\n", "label": "le_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div m n) m) .", "predict": "le_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div m n) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLog_times_l. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_log.log$ applicerat på $p$ och $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $m$ och $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $m$.\nassistant\n", "label": "postulate log_times_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)))", "predict": "postulate log_times_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_unit. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_unit : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term return_sort (return_type z) .", "predict": "filter_unit : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNot_zero. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Univ$ för $cic.prop$.\nassistant\n", "label": "not_zero : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop .", "predict": "not_zero : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z299$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z300$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_107$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_107$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Not_inv_rect_CProp3 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) (_H1 : (x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Not_inv_rect_CProp3 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) (_H1 : (x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_10331. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $lt4n$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $le4m$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $Hind$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $lea$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arith", "label": "Axiom let_clause_10331 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m), forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a), forall Hinda : cic.Term cic.prop (matita_ar", "predict": "Axiom let_clause_10331 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m), forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a), cic.Term cic.prop (matita_arithmetics_nat.le a n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_exp_to_eq. For all elements $p$ and $q$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $q$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $q$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $p$ and $q$.\nassistant\n", "label": "divides_exp_to_eq : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.prime q) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp q m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) p q) .", "predict": "divides_exp_to_eq : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.prime q) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp q m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) p q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_fwd_plus_plus_ge. Soient $m1$ et $m2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $m2$ et $m1$, pour tous les éléments $n1$ et $n2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $m1$ et $n1$ et $matita_arithmetics_nat.plus$ appliqué à $m2$ et $n2$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n1$ et $n2$.\nassistant\n", "label": "postulate le_fwd_plus_plus_ge : (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m2 m1)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus m1 n1) (matita_arithmetics_nat.plus m2 n2))) -> cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)", "predict": "postulate le_fwd_plus_plus_ge : (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m2 m1)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus m1 n1) (matita_arithmetics_nat.plus m2 n2))) -> cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMin_spec_to_min. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Alors pour tous les éléments $n$ et $b$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_minimization.min_spec$ appliqué à $n$ et $b$ et $f$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$ et $m$.\nassistant\n", "label": "axiom min_spec_to_min (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n b m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)", "predict": "axiom min_spec_to_min (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n b m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_iter. Soit $g$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $__$ des éléments $x$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $x$ et $g$ appliqué à $x$, pour tous les éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $a$ et $matita_arithmetics_iteration.iter$ appliqué à $matita_arithmetics_nat.nat$ et $g$ et $i$ et $a$.\nassistant\n", "label": "postulate le_iter : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a))", "predict": "postulate le_iter : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nFilter_Not. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Då för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "filter_Not : _A : cic.Univ cic.prop -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term return_sort (return_type z) .", "predict": "filter_Not : _A : cic.Univ cic.prop -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1098$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_635$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1099$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_635$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_635$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom option_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.option x1), forall P : ((_z1098 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop), forall _H1 : ((_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))), forall _H2 : ((x_635 : cic.Term univs.Type0 x1) -> (_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_635))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_635))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom option_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.option x1), forall P : ((_z1098 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop), forall _H1 : ((_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))), forall _H2 : ((x_635 : cic.Term univs.Type0 x1) -> (_z1099 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_635))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_635))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop_rect_CProp0. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_885$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué", "label": "Aop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_885) .", "predict": "Aop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_885) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_inv_ind. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z906$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z907$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom unit_inv_ind : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z906 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) .", "predict": "Axiom unit_inv_ind : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z906 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1206$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1207$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Sig_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Sig_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNat_rect_Type0. Låt $Q_$ vara en funktion från element $_x_389$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $univs.Type0$. Då för alla element $_H_O$ av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H_S$ från element $x_390$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_392$ av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $x_390$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_390$, för alla element $x_389$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_389$.\nassistant\n", "label": "axiom nat_rect_Type0 (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (Q_ x_389)", "predict": "axiom nat_rect_Type0 (Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type0) (_H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_392 : cic.Term univs.Type0 (Q_ x_390)) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) (x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (Q_ x_389)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLt_smallest_factor_to_not_divides. För alla element $n$ och $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $i$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $matita_arithmetics_primes.smallest_factor$ applicerat på $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $i$ och $n$.\nassistant\n", "label": "Axiom lt_smallest_factor_to_not_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n)), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n)) .", "predict": "Axiom lt_smallest_factor_to_not_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_primes.smallest_factor n)), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_rect_Type2. For all functions $Q_$ from elements $_x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_I$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_48$.\nassistant\n", "label": "axiom True_rect_Type2 (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) (x_48 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type2 (Q_ x_48)", "predict": "axiom True_rect_Type2 (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) (x_48 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type2 (Q_ x_48)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Sig$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $", "label": "Axiom Sig_discr : forall a1 : cic.Univ univs.Type0, forall a2 : ((__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop), forall x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((fun x0 => fun p0 => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (fun x_19 => fun _x_20 => cic.lift cic.prop univs.Type0 ((fun x0 => fun p0 => a2 x0) x_19 _x_20)) t1 u0 e0) u1) (fun _e1 => P))) (fun _z43 => P))) y) x) .", "predict": "Axiom Sig_discr : forall a1 : cic.Univ univs.Type0, forall a2 : ((__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop), forall x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((fun x0 => fun p0 => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (fun x0 => fun p0 => a2 x0) t1 u0 e0) u1) (fun _e1 => P))) (fun _z45 => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAssoc_plus1. För alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $c$ och $matita_arithmetics_nat.plus$ applicerat på $b$ och $a$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $b$ och $c$ och $a$.\nassistant\n", "label": "postulate assoc_plus1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus c (matita_arithmetics_nat.plus b a)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus b c) a))", "predict": "postulate assoc_plus1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus c (matita_arithmetics_nat.plus b a)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus b c) a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nP_ord. Pour tous les éléments $_n$ et $_m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom p_ord : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) .", "predict": "Axiom p_ord : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_lt_times_r. For all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $t$ to $matita_arithmetics_nat.times$ applied to $c$ and $t$.\nassistant\n", "label": "Axiom monotonic_lt_times_r : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times c t)) .", "predict": "Axiom monotonic_lt_times_r : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times c t)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNot_not_bertrand_to_bertrand1. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applicerat på $n$, för alla element $x$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $x$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $x$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla funktioner $__3$ från element $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x$ och $p$ och element $__4$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.prime$ applicerat på $p$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $p$ som $matita_basics_logic.And$ applicerat på $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $n$ och $p$ och $matita_arithmetics_nat.le$ applicerat på $p$ och $x$ och $matita_arithmetics_primes.prime$ applicerat på $p$.\nassistant\n", "label": "not_not_bertrand_to_bertrand1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n x) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> __3 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt x p) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime p))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_nat.le p x)) (matita_arithmetics_primes.prime p))) .", "predict": "not_not_bertrand_to_bertrand1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n x) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> __3 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt x p) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime p))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_nat.le p x)) (matita_arithmetics_primes.prime p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_fact_10. $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom le_fact_10 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) .", "predict": "Axiom le_fact_10 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMonotonic_le_minus_r. Let $p$ and $q$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $q$.\nassistant\n", "label": "axiom monotonic_le_minus_r (p q n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))", "predict": "axiom monotonic_le_minus_r (p q n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nUnit_rect_CProp2. Soit $Q_$ une fonction des éléments $_x_515$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_it$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_515$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_515$.\nassistant\n", "label": "Axiom unit_rect_CProp2 : forall Q_ : ((_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_515 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_515) .", "predict": "Axiom unit_rect_CProp2 : forall Q_ : ((_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_515 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_515) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDpi2. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $f$, $cic.Term$ tient pour $univs.Type0$ et $f$ appliqué à $matita_basics_types.dpi1$ appliqué à $A$ et $f$ et $xxx$.\nassistant\n", "label": "postulate dpi2 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) -> cic.Term univs.Type0 (f (matita_basics_types.dpi1 A f xxx))", "predict": "postulate dpi2 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) -> cic.Term univs.Type0 (f (matita_basics_types.dpi1 A f xxx))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDop_rect_Type5_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_947$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à", "label": "postulate Dop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)", "predict": "postulate Dop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_squareS_exp. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nassistant\n", "label": "Axiom le_squareS_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) .", "predict": "Axiom le_squareS_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPlus_body. Pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom plus_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom plus_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nMdef. Soit $m$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_binomial.M$ appliqué à $m$ et $matita_arithmetics_binomial.bc$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$ et $m$.\nassistant\n", "label": "Axiom Mdef : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.M m) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) m)) .", "predict": "Axiom Mdef : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.M m) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nFilter_Dop. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "axiom filter_Dop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_Dop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_to_mod_O. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom divides_to_mod_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) .", "predict": "Axiom divides_to_mod_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLt_plus_to_lt_l. Soient $n$ et $p$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $p$ et $n$ et $matita_arithmetics_nat.plus$ appliqué à $q$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $p$ et $q$.\nassistant\n", "label": "postulate lt_plus_to_lt_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)", "predict": "postulate lt_plus_to_lt_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus p n) (matita_arithmetics_nat.plus q n))) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDivides_to_div_mod_spec. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $m$ et $n$ et $matita_arithmetics_div_and_mod.div$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.O$.\nassistant\n", "label": "divides_to_div_mod_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O) .", "predict": "divides_to_div_mod_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFilter_ex2. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_P$ et $_Q$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex2$ appliqué à $A$ et $_P$ et $_Q$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex2$ appliqué à $A$ et $_P$ et $_Q$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex2$ appliqué à $A$ et $_P$ et $_Q$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "Axiom filter_ex2 : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_ex2 : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_ind_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_915$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_915$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_915$.\nassistant\n", "label": "postulate range_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_915)", "predict": "postulate range_ind_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_915)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFilter_Aop. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDPair_rect_CProp4. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_652$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_DPair$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$, för alla element $x_652$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_652$.\nassistant\n", "label": "Axiom DPair_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_652) .", "predict": "Axiom DPair_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_652) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTheta_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.\nassistant\n", "label": "postulate theta_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))", "predict": "postulate theta_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSinglevalued. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation2$ applied to $A$ and $B$.\nassistant\n", "label": "Axiom singlevalued : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B)) .", "predict": "Axiom singlevalued : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nProd_rect_CProp4. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_704$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_704$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_704$.\nassistant\n", "label": "axiom Prod_rect_CProp4 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_704)", "predict": "axiom Prod_rect_CProp4 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_704)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_SO_smallest_factor. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom le_SO_smallest_factor : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n) .", "predict": "Axiom le_SO_smallest_factor : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLenght_to_nil. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l$ och $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l$ och $matita_basics_lists_list.nil$ applicerat på $A$.\nassistant\n", "label": "Axiom lenght_to_nil : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A)) .", "predict": "Axiom lenght_to_nil : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nProd_inv_rect_CProp1. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1290$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1291$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom Prod_inv_rect_CProp1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Prod_inv_rect_CProp1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1290 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1291 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nBigop_Sfalse. Låt $k$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $p$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p$ applicerat på $k$ och $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.S$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nassistant\n", "label": "axiom bigop_Sfalse (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (λ i => p i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil op (λ i => f i)))", "predict": "axiom bigop_Sfalse (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (λ i => p i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil op (λ i => f i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nRev_append. Pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $H$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_lists_list.list$ appliqué à $H$.\nassistant\n", "label": "rev_append : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) .", "predict": "rev_append : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLstar_ind_l. För alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $R$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Univ$ av $cic.prop$, för alla element $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $P$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation2$ applicerat på $matita_arithmetics_nat.nat$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$ och $b2$, för alla funktioner $__1$ från element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $b1$ av $cic.Term$ av $univs.Type0$ och $B$ och element $b$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $cic.prop$ och $R$ applicerat på $b1$ och $b$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b$ och $b2$ och element $__3$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $l$ och $b$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $b1$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $l$ och $b1$.\nassistant\n", "label": "axiom lstar_ind_l (B : cic.Univ univs.Type0) (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) (b2 : cic.Term univs.Type0 B) (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 : cic.Term univs.Type0 B) (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) : cic.Term cic.prop (P l b1)", "predict": "axiom lstar_ind_l (B : cic.Univ univs.Type0) (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) (b2 : cic.Term univs.Type0 B) (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 : cic.Term univs.Type0 B) (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) : cic.Term cic.prop (P l b1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLength_unique_le. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.unique$ applicerat på $matita_arithmetics_nat.nat$ och $l$, för alla funktioner $__1$ från element $x$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.mem$ applicerat på $matita_arithmetics_nat.nat$ och $x$ och $l$ till element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_basics_lists_list.length$ applicerat på $matita_arithmetics_nat.nat$ och $l$ och $n$.\nassistant\n", "label": "postulate length_unique_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n)", "predict": "postulate length_unique_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__1 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt x n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBijn_n_Sn. För alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $f$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $f$ och $matita_arithmetics_nat.S$ applicerat på $n$.\nassistant\n", "label": "postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))", "predict": "postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDivides_ind. Soient $_n$ et $_m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $Q_$ des éléments $_x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_quotient$ des éléments $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1193$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_m$ et $matita_arithmetics_nat.times$ appliqué à $_n$ et $q$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_primes.quotient$ appliqué à $_n$ et $_m$ et $q$ et $x_1193$, pour tous les éléments $x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_1192$.\nassistant\n", "label": "axiom divides_ind (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term cic.prop (Q_ x_1192)", "predict": "axiom divides_ind (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term cic.prop (Q_ x_1192)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_elim2. For all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $__1$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $__2$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom nat_elim2 : forall R : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R matita_arithmetics_nat.O n)), forall __1 : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)), forall __2 : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (R n m)) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (R n m) .", "predict": "Axiom nat_elim2 : forall R : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R matita_arithmetics_nat.O n)), forall __1 : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)), forall __2 : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (R n m)) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (R n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFalse_rect_CProp5. Pour toutes les fonctions $Q_$ des éléments $_x_74$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_74$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_74$.\nassistant\n", "label": "Axiom False_rect_CProp5 : forall Q_ : ((_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_74 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_74) .", "predict": "Axiom False_rect_CProp5 : forall Q_ : ((_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_74 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_74) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAssoc_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $nil$, pour tous les éléments $a$ et $b$ et $c$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_basics_lists_list.op$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $matita_basics_lists_list.op$ appliqué à $A$ et $nil$ et $xxx$ et $b$ et $c$ et $matita_basics_lists_list.op$ appliqué à $A$ et $nil$ et $xxx$ et $matita_basics_lists_list.op$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $b$ et $c$.\nassistant\n", "label": "Axiom assoc_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c)) .", "predict": "Axiom assoc_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nK. Låt $_n$ och $_p$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom k : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom k : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nProd_inv_rect_Type1. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1260$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1261$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $x1$ och $x2$ och $_fst$ och $_snd$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "Prod_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type1) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P Hterm) .", "predict": "Prod_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1260 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ univs.Type1) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1261 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMax. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate max : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate max : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nOp_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $_xxx$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $nil$, för alla element $_x_807$ och $_x_808$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $univs.Type0$ och $A$.\nassistant\n", "label": "axiom op_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (_xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) (_x_807 _x_808 : cic.Term univs.Type0 A) : cic.Term univs.Type0 A", "predict": "axiom op_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (_xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) (_x_807 _x_808 : cic.Term univs.Type0 A) : cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nRange_rect_CProp5. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_931$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_931$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_931$.\nassistant\n", "label": "range_rect_CProp5 : _A : cic.Univ univs.Type0 -> Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_931) .", "predict": "range_rect_CProp5 : _A : cic.Univ univs.Type0 -> Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_931) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nDop_rect_Type5. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_947$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a", "label": "postulate Dop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)", "predict": "postulate Dop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nStreicherK. Soit $T$ un élément de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $t$ de $cic.Term$ de $univs.Type2$ et de $T$, pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $T$ et $t$ et $t$ à des éléments de $cic.Univ$ de $univs.Type2$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_basics_logic.refl$ appliqué à $T$ et $t$, pour tous les éléments $p$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $T$ et $t$ et $t$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $p$.\nassistant\n", "label": "streicherK : T : cic.Univ univs.Type2 -> t : cic.Term univs.Type2 T -> P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)) -> p : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Term univs.Type2 (P p) .", "predict": "streicherK : T : cic.Univ univs.Type2 -> t : cic.Term univs.Type2 T -> P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)) -> p : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Term univs.Type2 (P p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTrue_min. För alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $b$ och $matita_basics_bool.true$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.min$ applicerat på $n$ och $b$ och $f$ och $b$.\nassistant\n", "label": "true_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) b) .", "predict": "true_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_log_S. Soient $p$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_log.log$ appliqué à $p$ et $n$ et $matita_arithmetics_log.log$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $n$.\nassistant\n", "label": "postulate le_log_S : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p (matita_arithmetics_nat.S n)))", "predict": "postulate le_log_S : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p (matita_arithmetics_nat.S n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDivides_to_ord. För alla element $p$ och $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_ord.ord_rem$ applicerat på $n$ och $p$ och $matita_arithmetics_ord.ord_rem$ applicerat på $m$ och $p$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_ord.ord$ applicerat på $n$ och $p$ och $matita_arithmetics_ord.ord$ applicerat på $m$ och $p$.\nassistant\n", "label": "axiom divides_to_ord (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p)))", "predict": "axiom divides_to_ord (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nBool_ind. Låt $Q_$ vara en funktion från element $_x_326$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_326$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_326$.\nassistant\n", "label": "axiom bool_ind (Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_326 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_326)", "predict": "axiom bool_ind (Q_ : (_x_326 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_326 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_326)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nVoid_rect_CProp4_body. For all functions $Q_$ from elements $_x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_489$.\nassistant\n", "label": "axiom void_rect_CProp4_body (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)", "predict": "axiom void_rect_CProp4_body (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nOption_rect_Type1. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_606$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type1$, för alla element $_H_None$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_607$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_607$, för alla element $x_606$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_606$.\nassistant\n", "label": "postulate option_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)", "predict": "postulate option_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nEq_rect_Type4_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type2$, pour tous les éléments $_x$ de $cic.Term$ de $univs.Type2$ et de $A$, pour toutes les fonctions $Q_$ des éléments $x_4$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $_x_5$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_4$ à des éléments de $cic.Univ$ de $univs.Type4$, pour tous les éléments $_H_refl$ de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $_x$ et $matita_basics_logic.refl$ appliqué à $A$ et $_x$, pour tous les éléments $x_4$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $x_5$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $_x$ et $x_4$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_4$ et $x_5$.\nassistant\n", "label": "postulate eq_rect_Type4_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_4 : cic.Term univs.Type2 A) -> (_x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Univ univs.Type4) -> (_H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_4 : cic.Term univs.Type2 A) -> (x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Term univs.Type4 (Q_ x_4 x_5)", "predict": "postulate eq_rect_Type4_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_4 : cic.Term univs.Type2 A) -> (_x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Univ univs.Type4) -> (_H_refl : cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_4 : cic.Term univs.Type2 A) -> (x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4)) -> cic.Term univs.Type4 (Q_ x_4 x_5)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMax_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.\nassistant\n", "label": "axiom max_f_g (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g))", "predict": "axiom max_f_g (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nFalse_rect_CProp0. För alla funktioner $Q_$ från element $_x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $cic.prop$, för alla element $x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_78$.\nassistant\n", "label": "axiom False_rect_CProp0 (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_78 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_78)", "predict": "axiom False_rect_CProp0 (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_78 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_78)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nProd_rect_CProp1_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_712$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_712$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_712$.\nassistant\n", "label": "Prod_rect_CProp1_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_712) .", "predict": "Prod_rect_CProp1_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_712) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDiv_mod_spec_rect_Type5_body. Pour tous les éléments $_n$ et $_m$ et $_q$ et $_r$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Q_$ des éléments $_x_817$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_819$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_818$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_819$ et $x_818$, pour tous les éléments $x_817$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_817$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type5_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5), forall _H_div_mod_spec_intro : ((x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))), forall x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type5 (Q_ x_817) .", "predict": "Axiom div_mod_spec_rect_Type5_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5), forall _H_div_mod_spec_intro : ((x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))), forall x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type5 (Q_ x_817) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nSum_rect_Type5. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_531$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_inl$ des éléments $x_532$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_532$, pour toutes les fonctions $_H_inr$ des éléments $x_533$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_533$, pour tous les éléments $x_531$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_531$.\nassistant\n", "label": "axiom Sum_rect_Type5 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type5 (Q_ x_531)", "predict": "axiom Sum_rect_Type5 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type5 (Q_ x_531)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSig_rect_Type2_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_672$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_672$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_672$.\nassistant\n", "label": "postulate Sig_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type2 (Q_ x_672)", "predict": "postulate Sig_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type2 (Q_ x_672)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_73. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $x134$ and $x135$ and $x136$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $x136$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $x136$.\nassistant\n", "label": "Axiom let_clause_73 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136))) .", "predict": "Axiom let_clause_73 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLeq_sqrt_n. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_sqrt.sqrt$ applicerat på $n$ och $matita_arithmetics_sqrt.sqrt$ applicerat på $n$ och $n$.\nassistant\n", "label": "axiom leq_sqrt_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n)", "predict": "axiom leq_sqrt_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_clause_1585. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $m$ och $n$, för alla element $d$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $auto$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $m$, för alla element $auto'$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $d$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $n$.\nassistant\n", "label": "postulate let_clause_1585 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)", "predict": "postulate let_clause_1585 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nList_inv_ind. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1302$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1303$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.nil$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.nil$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_718$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $x_717$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ et des fonctions $_x_720$ des éléments $_z1303$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $x_717$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x_717$ et des éléments $_z1303$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_718$ et $x_717$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $", "label": "axiom list_inv_ind (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1302 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_718 : cic.Term univs.Type0 x1) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_720 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_717)) -> cic.Term cic.prop (P x_717)) -> (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_718 x_717))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_718 x_717))) : cic.Term cic.prop (P Hterm)", "predict": "axiom list_inv_ind (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1302 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_718 : cic.Term univs.Type0 x1) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_720 : (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_717)) -> cic.Term cic.prop (P x_717)) -> (_z1303 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_718 x_717))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_718 x_717))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNot_exists_to_forall. För alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $i$ som $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ och $P$ applicerat på $i$, för alla element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Not$ applicerat på $P$ applicerat på $i$.\nassistant\n", "label": "not_exists_to_forall : P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i)))) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.Not (P i)) .", "predict": "not_exists_to_forall : P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i)))) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.Not (P i)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nTrue_inv_rect_CProp3. Pour tous les éléments $Hterm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$, pour toutes les fonctions $P$ des éléments $_z167$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z168$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "True_inv_rect_CProp3 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z167 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) .", "predict": "True_inv_rect_CProp3 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z167 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_10131. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n0$ and $f$ and $m$, for all elements $fm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltj$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $j$ and $matita_arithmetics_nat.S$ applied to $n0$, for all elements $x7$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x7$ and $matita_arithmetics_nat.plus$ applied to $m$ and $x7$.\nassistant\n", "label": "axiom let_clause_10131 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m)) (fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) (i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0))) (x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7))", "predict": "axiom let_clause_10131 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m)) (fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) (i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0))) (x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMap_append. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $B$ and $matita_basics_lists_list.append$ applied to $B$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l1$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l2$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.\nassistant\n", "label": "map_append : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.append B (matita_basics_lists_list.map A B f l1) (matita_basics_lists_list.map A B f l2)) (matita_basics_lists_list.map A B f (matita_basics_lists_list.append A l1 l2))) .", "predict": "map_append : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.append B (matita_basics_lists_list.map A B f l1) (matita_basics_lists_list.map A B f l2)) (matita_basics_lists_list.map A B f (matita_basics_lists_list.append A l1 l2))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1320$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_740$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $x_737$ and elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_738$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_73", "label": "list_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1320 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type2) -> _H1 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type2 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_738 : cic.Term univs.Type0 x1 -> x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_740 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_737) -> cic.Term univs.Type2 (P x_737)) -> _z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_738 x_737)) -> cic.Term univs.Type2 (P (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P Hterm) .", "predict": "list_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1320 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type2) -> _H1 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type2 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_738 : cic.Term univs.Type0 x1 -> x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_740 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_737) -> cic.Term univs.Type2 (P x_737)) -> _z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_738 x_737)) -> cic.Term univs.Type2 (P (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPred. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate pred : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate pred : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_inv_step. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $b1$ and $b2$.\nassistant\n", "label": "postulate lstar_inv_step : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) -> cic.Term cic.prop (R b1 b2)", "predict": "postulate lstar_inv_step : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) -> cic.Term cic.prop (R b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFilter_case. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $p$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $x$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.mem$ applicerat på $A$ och $x$ och $l$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_lists_list.mem$ applicerat på $A$ och $x$ och $matita_basics_lists_list.filter$ applicerat på $A$ och $p$ och $l$ och $matita_basics_lists_list.mem$ applicerat på $A$ och $x$ och $matita_basics_lists_list.filter$ applicerat på $A$ och funktionen som avbildar $x0$ som $matita_basics_bool.notb$ applicerat på $p$ applicerat på $x0$ och $l$.\nassistant\n", "label": "postulate filter_case : (A : cic.Univ univs.Type0) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A x l)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.mem A x (matita_basics_lists_list.filter A p l)) (matita_basics_lists_list.mem A x (matita_basics_lists_list.filter A (\\ x0 : cic.Term univs.Type0 A -> matita_basics_bool.notb (p x0)) l)))", "predict": "postulate filter_case : (A : cic.Univ univs.Type0) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A x l)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.mem A x (matita_basics_lists_list.filter A p l)) (matita_basics_lists_list.mem A x (matita_basics_lists_list.filter A (\\ x0 : cic.Term univs.Type0 A -> matita_basics_bool.notb (p x0)) l)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_Psi_exp. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.pred$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $n$.\nassistant\n", "label": "le_Psi_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) .", "predict": "le_Psi_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDivides_mod. För alla element $p$ och $m$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $m$ och $n$.\nassistant\n", "label": "divides_mod : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p m) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_div_and_mod.mod m n)) .", "predict": "divides_mod : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p m) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_div_and_mod.mod m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nOpt_cons_tail_expand. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $l$ et $matita_basics_lists_list.option_cons$ appliqué à $A$ et $matita_basics_lists_list.option_hd$ appliqué à $A$ et $l$ et $matita_basics_lists_list.tail$ appliqué à $A$ et $l$.\nassistant\n", "label": "axiom opt_cons_tail_expand (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.option_cons A (matita_basics_lists_list.option_hd A l) (matita_basics_lists_list.tail A l)))", "predict": "axiom opt_cons_tail_expand (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.option_cons A (matita_basics_lists_list.option_hd A l) (matita_basics_lists_list.tail A l)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nUnit_rect_CProp3_body. För alla funktioner $Q_$ från element $_x_513$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_it$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_513$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_513$.\nassistant\n", "label": "unit_rect_CProp3_body : Q_ : (_x_513 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H_it : cic.Term cic.prop (Q_ matita_basics_types.it) -> x_513 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop (Q_ x_513) .", "predict": "unit_rect_CProp3_body : Q_ : (_x_513 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H_it : cic.Term cic.prop (Q_ matita_basics_types.it) -> x_513 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term cic.prop (Q_ x_513) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nRange_rect_CProp0_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_939$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_939$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_939$.\nassistant\n", "label": "Axiom range_rect_CProp0_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_939) .", "predict": "Axiom range_rect_CProp0_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_939) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_singlevalued. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $B$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.singlevalued$ applied to $B$ and $B$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.singlevalued$ applied to $B$ and $B$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$.\nassistant\n", "label": "postulate lstar_singlevalued : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation2 B B)) -> (__ : cic.Term cic.prop (matita_basics_relations.singlevalued B B R)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.singlevalued B B (matita_arithmetics_lstar.lstar B R l))", "predict": "postulate lstar_singlevalued : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation2 B B)) -> (__ : cic.Term cic.prop (matita_basics_relations.singlevalued B B R)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.singlevalued B B (matita_arithmetics_lstar.lstar B R l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nNill. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $nil$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $nil$ och $a$ och $a$.\nassistant\n", "label": "nill : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a) .", "predict": "nill : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDecidable_eq_nat. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "axiom decidable_eq_nat (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))", "predict": "axiom decidable_eq_nat (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEx2_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.\nassistant\n", "label": "ex2_ind_body : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ cic.prop) -> _H_ex2_intro : (x : cic.Term univs.Type0 A -> x_276 : cic.Term cic.prop (_P x) -> x_275 : cic.Term cic.prop (_Q x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term cic.prop (Q_ x_274) .", "predict": "ex2_ind_body : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ cic.prop) -> _H_ex2_intro : (x : cic.Term univs.Type0 A -> x_276 : cic.Term cic.prop (_P x) -> x_275 : cic.Term cic.prop (_Q x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term cic.prop (Q_ x_274) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNth_prime. Soit $__$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "nth_prime : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "nth_prime : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLt_n_nth_prime_n. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $matita_arithmetics_primes.nth_prime$ applicerat på $n$.\nassistant\n", "label": "Axiom lt_n_nth_prime_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.nth_prime n)) .", "predict": "Axiom lt_n_nth_prime_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.nth_prime n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEq_p_ord_inv. Låt $p$ och $m$ och $x$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord_inv$ applicerat på $p$ och $m$ och $x$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_ord.ord_rem$ applicerat på $x$ och $p$ och $m$ och $matita_arithmetics_ord.ord$ applicerat på $x$ och $p$.\nassistant\n", "label": "axiom eq_p_ord_inv (p m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.p_ord_inv p m x) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_ord.ord_rem x p) m) (matita_arithmetics_ord.ord x p)))", "predict": "axiom eq_p_ord_inv (p m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.p_ord_inv p m x) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_ord.ord_rem x p) m) (matita_arithmetics_ord.ord x p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDiv_mod_spec_inv_rect_Type3. Låt $x1$ och $x2$ och $x3$ och $x4$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $Hterm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från element $_z1446$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H1$ från element $x_823$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x4$ och $x2$ och element $x_822$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x3$ och $x2$ och $x4$ och element $_z1447$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $Hterm$ och $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_823$ och $x_822$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_823$ och $x_822$, håller $cic.Term$ för $univs", "label": "div_mod_spec_inv_rect_Type3 : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> P : (_z1446 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> cic.Univ univs.Type3) -> _H1 : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2) -> x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4)) -> _z1447 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> cic.Term univs.Type3 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P Hterm) .", "predict": "div_mod_spec_inv_rect_Type3 : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> P : (_z1446 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> cic.Univ univs.Type3) -> _H1 : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2) -> x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4)) -> _z1447 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> cic.Term univs.Type3 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLt_times_n_to_lt_l. Låt $n$ och $p$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $p$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $q$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $q$.\nassistant\n", "label": "lt_times_n_to_lt_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times p n) (matita_arithmetics_nat.times q n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q) .", "predict": "lt_times_n_to_lt_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times p n) (matita_arithmetics_nat.times q n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_divides. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "Axiom list_divides : forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "Axiom list_divides : forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nTimes_exp. Soient $n$ et $m$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $n$ et $p$ et $matita_arithmetics_exp.exp$ appliqué à $m$ et $p$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.times$ appliqué à $n$ et $m$ et $p$.\nassistant\n", "label": "postulate times_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times n m) p))", "predict": "postulate times_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times n m) p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDPair_ind. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_638$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_DPair$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$, för alla element $x_638$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_638$.\nassistant\n", "label": "Axiom DPair_ind : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_638) .", "predict": "Axiom DPair_ind : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_638) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_73. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $x134$ et $x135$ et $x136$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.plus$ appliqué à $x134$ et $matita_arithmetics_nat.plus$ appliqué à $x135$ et $x136$ et $matita_arithmetics_nat.plus$ appliqué à $x135$ et $matita_arithmetics_nat.plus$ appliqué à $x134$ et $x136$.\nassistant\n", "label": "postulate let_clause_73 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> (x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))", "predict": "postulate let_clause_73 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> (x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_SO_smallest_factor. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$.\nassistant\n", "label": "postulate lt_SO_smallest_factor : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))", "predict": "postulate lt_SO_smallest_factor : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_ord_sigma_p. For all elements $n$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $x$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $x$ and $m$ and $n$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $x$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $n$ and $x$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $x$ and $matita_arithmetics_nat.S$ applied to $i$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom eq_ord_sigma_p : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.prime x), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp x m) n), forall __3 : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S m))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord n x) (matita_arithmetics_bigops.bigop m (fun i => matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S i)) n) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_nat.S matita_arithmetics_nat.O))) .", "predict": "Axiom eq_ord_sigma_p : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.prime x), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp x m) n), forall __3 : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S m))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord n x) (matita_arithmetics_bigops.bigop m (fun i => matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S i)) n) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFilter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate filter_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nSub_assoc_l. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $R1$ och $R2$ och $R3$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.subR$ applicerat på $A$ och $matita_basics_relations.Rcomp$ applicerat på $A$ och $R1$ och $matita_basics_relations.Rcomp$ applicerat på $A$ och $R2$ och $R3$ och $matita_basics_relations.Rcomp$ applicerat på $A$ och $matita_basics_relations.Rcomp$ applicerat på $A$ och $R1$ och $R2$ och $R3$.\nassistant\n", "label": "Axiom sub_assoc_l : forall A : cic.Univ univs.Type0, forall R1 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R2 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R3 : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3)) .", "predict": "Axiom sub_assoc_l : forall A : cic.Univ univs.Type0, forall R1 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R2 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R3 : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLstar_S. För alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$, för alla element $b1$ och $b$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $R$ applicerat på $b1$ och $b$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $matita_arithmetics_nat.plus$ applicerat på $l$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $b1$ och $b2$.\nassistant\n", "label": "axiom lstar_S (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 b : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (R b1 b)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b2 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)", "predict": "axiom lstar_S (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 b : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (R b1 b)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b2 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLt_M. Soit $m$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_binomial.M$ appliqué à $m$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $m$.\nassistant\n", "label": "postulate lt_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_binomial.M m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))", "predict": "postulate lt_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_binomial.M m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom min : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom min : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOption_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1050$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z1051$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1051$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_599$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_599$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "option_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1050 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ univs.Type3) -> _H1 : (_z1051 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term univs.Type3 (P (matita_basics_types.None x1))) -> _H2 : (x_599 : cic.Term univs.Type0 x1 -> _z1051 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_599)) -> cic.Term univs.Type3 (P (matita_basics_types.Some x1 x_599))) -> cic.Term univs.Type3 (P Hterm) .", "predict": "option_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1050 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ univs.Type3) -> _H1 : (_z1051 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term univs.Type3 (P (matita_basics_types.None x1))) -> _H2 : (x_599 : cic.Term univs.Type0 x1 -> _z1051 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_599)) -> cic.Term univs.Type3 (P (matita_basics_types.Some x1 x_599))) -> cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBdef. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_factorization.B$ appliqué à $n$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et la fonction qui envoie $p$ à $matita_arithmetics_primes.primeb$ appliqué à $p$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $p$ à $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_log.log$ appliqué à $p$ et $n$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $i$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate Bdef : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))", "predict": "postulate Bdef : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_zero. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom not_zero (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop", "predict": "axiom not_zero (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTrue_rect_Type5_body. För alla funktioner $Q_$ från element $_x_44$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type5$, för alla element $_H_I$ av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_44$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_44$.\nassistant\n", "label": "True_rect_Type5_body : Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type5) -> _H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I) -> x_44 : cic.Term cic.prop matita_basics_logic.True -> cic.Term univs.Type5 (Q_ x_44) .", "predict": "True_rect_Type5_body : Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type5) -> _H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I) -> x_44 : cic.Term cic.prop matita_basics_logic.True -> cic.Term univs.Type5 (Q_ x_44) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nVoid_rect_Type5_body. Soit $Q_$ une fonction des éléments $_x_484$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $univs.Type5$. Alors pour tous les éléments $x_484$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_484$.\nassistant\n", "label": "void_rect_Type5_body : Q_ : (_x_484 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type5) -> x_484 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type5 (Q_ x_484) .", "predict": "void_rect_Type5_body : Q_ : (_x_484 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type5) -> x_484 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type5 (Q_ x_484) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAop_rect_Type3_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_867$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term", "label": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_867)", "predict": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_867)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_inv_rect_CProp4. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z942$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z943$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "unit_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z942 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z943 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) .", "predict": "unit_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z942 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z943 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExp_to_log_r. Let $b$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $b$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_log.log$ applied to $b$ and $m$.\nassistant\n", "label": "exp_to_log_r : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) m) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_log.log b m)) .", "predict": "exp_to_log_r : b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp b n) m) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_log.log b m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nMod_plus_times. Låt $m$ och $q$ och $r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $r$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $q$ och $m$ och $r$ och $m$ och $r$.\nassistant\n", "label": "Axiom mod_plus_times : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt r m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r) m) r) .", "predict": "Axiom mod_plus_times : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt r m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r) m) r) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nRange_rect_CProp5_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_931$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_931$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_931$.\nassistant\n", "label": "Axiom range_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_931) .", "predict": "Axiom range_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_931) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nPrime_to_lt_SO. Soit $p$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$.\nassistant\n", "label": "prime_to_lt_SO : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) .", "predict": "prime_to_lt_SO : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTrue_rect_Type0_body. Låt $Q_$ vara en funktion från element $_x_52$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type0$. Då för alla element $_H_I$ av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_52$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_52$.\nassistant\n", "label": "axiom True_rect_Type0_body (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)", "predict": "axiom True_rect_Type0_body (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nSmallest_factor_to_prime. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_primes.smallest_factor$ applicerat på $n$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $n$.\nassistant\n", "label": "axiom smallest_factor_to_prime (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n)) : cic.Term cic.prop (matita_arithmetics_primes.prime n)", "predict": "axiom smallest_factor_to_prime (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n)) : cic.Term cic.prop (matita_arithmetics_primes.prime n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMatch_bool. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_true$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.true$, for all elements $case_false$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.false$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom match_bool : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort), forall case_true : cic.Term return_sort (return_type matita_basics_bool.true), forall case_false : cic.Term return_sort (return_type matita_basics_bool.false), forall z : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term return_sort (return_type z) .", "predict": "Axiom match_bool : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort), forall case_true : cic.Term return_sort (return_type matita_basics_bool.true), forall case_false : cic.Term return_sort (return_type matita_basics_bool.false), forall z : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_gcd_times. Let $m$ and $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $p$.\nassistant\n", "label": "Axiom le_gcd_times : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p))) .", "predict": "Axiom le_gcd_times : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_log_S. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "le_log_S : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p (matita_arithmetics_nat.S n))) .", "predict": "le_log_S : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p (matita_arithmetics_nat.S n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRev_append_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "axiom rev_append_body (H : cic.Univ univs.Type0) (__ __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Term univs.Type0 (matita_basics_lists_list.list H)", "predict": "axiom rev_append_body (H : cic.Univ univs.Type0) (__ __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Term univs.Type0 (matita_basics_lists_list.list H)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nTrue_inv_rect_CProp0. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors pour toutes les fonctions $P$ des éléments $_z185$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z186$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate True_inv_rect_CProp0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nExample4. $cic.Term$ håller för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.primeb$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_bool.true$.\nassistant\n", "label": "Axiom example4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) matita_basics_bool.true) .", "predict": "Axiom example4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nSub_reflexive. Pour tous les éléments $T$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $T$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.subR$ appliqué à $T$ et $R$ et $R$.\nassistant\n", "label": "Axiom sub_reflexive : forall T : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation T), cic.Term cic.prop (matita_basics_relations.subR T R R) .", "predict": "Axiom sub_reflexive : forall T : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation T), cic.Term cic.prop (matita_basics_relations.subR T R R) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_658$.\nassistant\n", "label": "axiom DPair_rect_CProp2_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_658)", "predict": "axiom DPair_rect_CProp2_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_658)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nInjective_plus_r. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.injective$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.plus$ applicerat på $n$ och $m$.\nassistant\n", "label": "postulate injective_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))", "predict": "postulate injective_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLt_minus_to_plus. Pour tous les éléments $a$ et $b$ et $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $a$ et $b$ et $c$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $a$ et $matita_arithmetics_nat.plus$ appliqué à $c$ et $b$.\nassistant\n", "label": "postulate lt_minus_to_plus : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus c b))", "predict": "postulate lt_minus_to_plus : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus c b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAop_inv_rect_CProp2. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1548$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de", "label": "Aop_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) .", "predict": "Aop_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nExists_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, håller $cic.Univ$ för $cic.prop$.\nassistant\n", "label": "Axiom Exists_body : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop .", "predict": "Axiom Exists_body : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPlus_plus_comm_23. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $z$ and $y$.\nassistant\n", "label": "Axiom plus_plus_comm_23 : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y)) .", "predict": "Axiom plus_plus_comm_23 : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nQuotient. Låt $n$ och $m$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$.\nassistant\n", "label": "quotient : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) .", "predict": "quotient : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDop_ind. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_943$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics", "label": "Axiom Dop_ind : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_943) .", "predict": "Axiom Dop_ind : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_943) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSum_inv_rect_CProp3. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1014$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $x_567$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1015$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_567$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_567$, pour toutes les fonctions $_H2$ des éléments $x_568$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1015$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_568$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_568$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate Sum_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1014 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_567 : cic.Term univs.Type0 x1) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_567))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_567))) -> (_H2 : (x_568 : cic.Term univs.Type0 x2) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sum_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1014 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_567 : cic.Term univs.Type0 x1) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_567))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_567))) -> (_H2 : (x_568 : cic.Term univs.Type0 x2) -> (_z1015 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_568))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1506$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$", "label": "Aop_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type4) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm) .", "predict": "Aop_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type4) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nList_rect_Type1_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_741$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$, pour tous les éléments $_H_nil$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$, pour toutes les fonctions $_H_cons$ des éléments $x_743$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_742$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_745$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $x_742$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_743$ et $x_742$, pour tous les éléments $x_741$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_741$.\nassistant\n", "label": "list_rect_Type1_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type1) -> _H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_743 : cic.Term univs.Type0 _A -> x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_745 : cic.Term univs.Type1 (Q_ x_742) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))) -> x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type1 (Q_ x_741) .", "predict": "list_rect_Type1_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type1) -> _H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_743 : cic.Term univs.Type0 _A -> x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_745 : cic.Term univs.Type1 (Q_ x_742) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))) -> x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type1 (Q_ x_741) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDpi1__o__aop__o__op. For all elements $x0$ of $cic.Univ$ of $univs.Type0$, for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.\nassistant\n", "label": "postulate dpi1__o__aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0", "predict": "postulate dpi1__o__aop__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLt_exp_log. Soient $p$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $n$ et $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_log.log$ appliqué à $p$ et $n$.\nassistant\n", "label": "Axiom lt_exp_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) .", "predict": "Axiom lt_exp_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_clause_10332. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $le_n$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.\nassistant\n", "label": "postulate let_clause_10332 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "postulate let_clause_10332 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPsi_4. $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom Psi_4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))) .", "predict": "Axiom Psi_4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "And : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop .", "predict": "And : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nNot_divides_S_fact. Soient $n$ et $i$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $i$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $i$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_factorial.fact$ appliqué à $n$.\nassistant\n", "label": "postulate not_divides_S_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n))))", "predict": "postulate not_divides_S_fact : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides i (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLstar_lstar_r. För alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $b1$ och $b2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_lstar.lstar_r$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b2$.\nassistant\n", "label": "lstar_lstar_r : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) .", "predict": "lstar_lstar_r : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nFmin_false. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Alors pour tous les éléments $n$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $cic.prod$ appliqué à $cic.prop$ et $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $matita_arithmetics_minimization.let_m$ appliqué à $f$ et $n$ et $b$ et $matita_basics_bool.false$ et la fonction qui envoie $__$ à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_minimization.let_m$ appliqué à $f$ et $n$ et $b$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$.\nassistant\n", "label": "fmin_false : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m f n b) (matita_arithmetics_nat.plus n b))) .", "predict": "fmin_false : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (cic.prod cic.prop cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.let_m f n b)) matita_basics_bool.false) => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.let_m f n b) (matita_arithmetics_nat.plus n b))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLhd. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "Axiom lhd : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_lists_list.list H) .", "predict": "Axiom lhd : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_lists_list.list H) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPlus_plus_comm_23. Låt $x$ och $y$ och $z$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x$ och $y$ och $z$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x$ och $z$ och $y$.\nassistant\n", "label": "postulate plus_plus_comm_23 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y))", "predict": "postulate plus_plus_comm_23 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTail. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.\nassistant\n", "label": "tail : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) .", "predict": "tail : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nPsi_1. $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "Psi_1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) .", "predict": "Psi_1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDop_inv_rect_CProp0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1758$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $", "label": "axiom Dop_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1758 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1759 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Dop_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1758 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1759 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLePsi_r2. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $n$ et $matita_arithmetics_chebyshev_chebyshev_psi.prim$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $n$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $n$.\nassistant\n", "label": "Axiom lePsi_r2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) .", "predict": "Axiom lePsi_r2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAll_primes. Let $_l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "all_primes : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Univ cic.prop .", "predict": "all_primes : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDiv_mod_spec_rect_Type5_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_817$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_819$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_818$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_819$ och $x_818$, för alla element $x_817$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_817$.\nassistant\n", "label": "postulate div_mod_spec_rect_Type5_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)", "predict": "postulate div_mod_spec_rect_Type5_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nFilter_option. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "Axiom filter_option : forall _A : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_option : forall _A : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nAnd_inv_rect_Type4. Pour tous les éléments $x1$ et $x2$ de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z329$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H1$ des éléments $x_124$ de $cic.Term$ de $cic.prop$ et de $x1$ et des éléments $x_123$ de $cic.Term$ de $cic.prop$ et de $x2$ et des éléments $_z330$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.And$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_124$ et $x_123$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_124$ et $x_123$, $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom And_inv_rect_Type4 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type4) (_H1 : (x_124 : cic.Term cic.prop x1) -> (x_123 : cic.Term cic.prop x2) -> (_z330 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P (matita_basics_logic.conj x1 x2 x_124 x_123))) : cic.Term univs.Type4 (P Hterm)", "predict": "axiom And_inv_rect_Type4 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type4) (_H1 : (x_124 : cic.Term cic.prop x1) -> (x_123 : cic.Term cic.prop x2) -> (_z330 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P (matita_basics_logic.conj x1 x2 x_124 x_123))) : cic.Term univs.Type4 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1648. Let $n$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$ of $cic", "label": "let_clause_1648 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q))) -> _clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q", "predict": "let_clause_1648 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q))) -> _clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q))) -> divq : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n1) q) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNot_rect_Type0. Pour tous les éléments $_A$ de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_97$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H_nmk$ des fonctions $x_98$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_logic.nmk$ appliqué à $_A$ et $x_98$, pour tous les éléments $x_97$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_97$.\nassistant\n", "label": "axiom Not_rect_Type0 (_A : cic.Univ cic.prop) (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type0 (Q_ x_97)", "predict": "axiom Not_rect_Type0 (_A : cic.Univ cic.prop) (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type0 (Q_ x_97)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDop_rect_Type2. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_951$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $", "label": "Dop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type2 (Q_ x_951) .", "predict": "Dop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type2 (Q_ x_951) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nTrue_rect_Type3. Låt $Q_$ vara en funktion från element $_x_46$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type3$. Då för alla element $_H_I$ av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_46$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_46$.\nassistant\n", "label": "Axiom True_rect_Type3 : forall Q_ : ((_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3), forall _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I), forall x_46 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type3 (Q_ x_46) .", "predict": "Axiom True_rect_Type3 : forall Q_ : ((_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3), forall _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I), forall x_46 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type3 (Q_ x_46) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nEq_B_Bk. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_chebyshev_factorization.B$ applicerat på $n$ och $matita_arithmetics_chebyshev_bertrand.Bk$ applicerat på $n$.\nassistant\n", "label": "eq_B_Bk : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n)) .", "predict": "eq_B_Bk : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_CProp4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_903$.\nassistant\n", "label": "axiom ACop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_903)", "predict": "axiom ACop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_903)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFilter_range. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "postulate filter_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nExp_to_fact1. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_factorial.fact$ applicerat på $n$ och $matita_arithmetics_factorial.fact$ applicerat på $n$ och $matita_arithmetics_factorial.fact$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nassistant\n", "label": "axiom exp_to_fact1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "axiom exp_to_fact1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nSplit_rev. Låt $H$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $__$ och $__1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, för alla element $__2$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $matita_basics_lists_list.list$ applicerat på $H$ och $matita_basics_lists_list.list$ applicerat på $H$.\nassistant\n", "label": "postulate split_rev : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))", "predict": "postulate split_rev : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSig_rect_CProp0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_688$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_688$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_688$.\nassistant\n", "label": "postulate Sig_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_688)", "predict": "postulate Sig_rect_CProp0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_688)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nNot_bertrand_to_le_B. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_chebyshev_bertrand.not_bertrand$ appliqué à $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_factorization.B$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à", "label": "Axiom not_bertrand_to_le_B : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) .", "predict": "Axiom not_bertrand_to_le_B : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (mat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nMod. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom mod (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom mod (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_ord_log. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_ord.ord$ applied to $n$ and $p$ and $matita_arithmetics_log.log$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom le_ord_log : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_log.log p n)) .", "predict": "Axiom le_ord_log : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_log.log p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNat_inv_ind. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $P$ des éléments $_z653$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z654$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.O$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H2$ des éléments $x_366$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_x_368$ des éléments $_z654$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $x_366$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x_366$ et des éléments $_z654$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.S$ appliqué à $x_366$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_366$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "nat_inv_ind : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z653 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> _H2 : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_368 : (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_366) -> cic.Term cic.prop (P x_366)) -> _z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_366)) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_366))) -> cic.Term cic.prop (P Hterm) .", "predict": "nat_inv_ind : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z653 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> _H2 : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_368 : (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_366) -> cic.Term cic.prop (P x_366)) -> _z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_366)) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_366))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1033. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $lt1p$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $m$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "Axiom let_clause_1033 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt1p : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_1033 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt1p : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_Psi_BPsi1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "Axiom le_Psi_BPsi1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) .", "predict": "Axiom le_Psi_BPsi1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFilter_True. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDivides_to_dividesb_true1. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $n$ och $m$ och $matita_basics_bool.true$.\nassistant\n", "label": "axiom divides_to_dividesb_true1 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)", "predict": "axiom divides_to_dividesb_true1 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_plus_to_le. För alla element $a$ och $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $a$ och $n$ och $matita_arithmetics_nat.plus$ applicerat på $a$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$.\nassistant\n", "label": "postulate le_plus_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a n) (matita_arithmetics_nat.plus a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)", "predict": "postulate le_plus_to_le : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a n) (matita_arithmetics_nat.plus a m))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nEq_minus_gcd_aux. Låt $p$ och $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $a$ som $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $b$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_gcd.gcd_aux$ applicerat på $p$ och $m$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $a$ och $n$ och $matita_arithmetics_gcd.gcd_aux$ applicerat på $p$ och $m$ och $n$.\nassistant\n", "label": "Axiom eq_minus_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux p m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux p m n))))) .", "predict": "Axiom eq_minus_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux p m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux p m n))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_rect_CProp3. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_622$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_623$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_623$, for all elements $x_622$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_622$.\nassistant\n", "label": "Axiom option_rect_CProp3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_623 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))), forall x_622 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_622) .", "predict": "Axiom option_rect_CProp3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_623 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))), forall x_622 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_622) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDecidable_or. Let $P$ and $Q$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $Q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.Or$ applied to $P$ and $Q$.\nassistant\n", "label": "postulate decidable_or : (P : cic.Univ cic.prop) -> (Q : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> (__1 : cic.Term cic.prop (matita_basics_logic.decidable Q)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Or P Q))", "predict": "postulate decidable_or : (P : cic.Univ cic.prop) -> (Q : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> (__1 : cic.Term cic.prop (matita_basics_logic.decidable Q)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Or P Q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLe_times_to_le_div2. Soient $m$ et $n$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $q$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $q$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $q$ et $m$.\nassistant\n", "label": "Axiom le_times_to_le_div2 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.times m q)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div n q) m) .", "predict": "Axiom le_times_to_le_div2 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.times m q)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div n q) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_S_mod. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.\nassistant\n", "label": "axiom permut_S_mod (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n)", "predict": "axiom permut_S_mod (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDivides_d_times_gcd. Soient $m$ et $n$ et $d$ et $c$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $c$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $m$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$.\nassistant\n", "label": "divides_d_times_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m)) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd n m))) .", "predict": "divides_d_times_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m)) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nRange_rect_Type4_body. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_917$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$, för alla element $x_917$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_917$.\nassistant\n", "label": "axiom range_rect_Type4_body (_A : cic.Univ univs.Type0) (Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type4 (Q_ x_917)", "predict": "axiom range_rect_Type4_body (_A : cic.Univ univs.Type0) (Q_ : (_x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type4) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_917 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type4 (Q_ x_917)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_exp1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$.\nassistant\n", "label": "postulate lt_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))", "predict": "postulate lt_exp1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLet_upper_bound. För alla element $__$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate let_upper_bound : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_upper_bound : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1585. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom let_clause_1585 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)", "predict": "axiom let_clause_1585 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nMem_append_l1. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $l1$ et $l2$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $A$ et $a$ et $l1$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.mem$ appliqué à $A$ et $a$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$.\nassistant\n", "label": "postulate mem_append_l1 : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l1)) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))", "predict": "postulate mem_append_l1 : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l1)) -> cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nNot_eq_to_eqb_false. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.eqb$ applicerat på $n$ och $m$ och $matita_basics_bool.false$.\nassistant\n", "label": "Axiom not_eq_to_eqb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) .", "predict": "Axiom not_eq_to_eqb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDiv_mod_spec_ind_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_811$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_810$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_811$ och $x_810$, för alla element $x_809$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_809$.\nassistant\n", "label": "axiom div_mod_spec_ind_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_809)", "predict": "axiom div_mod_spec_ind_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_809)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nInv_eq_minus_O. Pour tous les éléments $x$ et $y$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $x$ et $y$ et $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $x$ et $y$.\nassistant\n", "label": "axiom inv_eq_minus_O (x y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_nat.le x y)", "predict": "axiom inv_eq_minus_O (x y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_nat.le x y)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nAnd_rect_CProp4_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_146$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_conj$ från element $x_148$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_147$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_148$ och $x_147$, för alla element $x_146$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_146$.\nassistant\n", "label": "Axiom And_rect_CProp4_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))), forall x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_146) .", "predict": "Axiom And_rect_CProp4_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_148 : cic.Term cic.prop _A) -> (x_147 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))), forall x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_146) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMk_range. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $A$, för alla element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $A$.\nassistant\n", "label": "mk_range : A : cic.Univ univs.Type0 -> _enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A) .", "predict": "mk_range : A : cic.Univ univs.Type0 -> _enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDecidable_divides. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.decidable$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$.\nassistant\n", "label": "axiom decidable_divides (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.divides n m))", "predict": "axiom decidable_divides (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.divides n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNat_rect_CProp4. Soit $Q_$ une fonction des éléments $_x_393$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_O$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H_S$ des éléments $x_394$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_396$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_394$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_394$, pour tous les éléments $x_393$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_393$.\nassistant\n", "label": "axiom nat_rect_CProp4 (Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : cic.Term cic.prop (Q_ x_394)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) (x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_393)", "predict": "axiom nat_rect_CProp4 (Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : cic.Term cic.prop (Q_ x_394)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) (x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_393)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAssoc. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $nil$, för alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $c$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ och $c$.\nassistant\n", "label": "assoc : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c)) .", "predict": "assoc : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) -> a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nEq_f. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type2$. Alors pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type2$ et de $A$ à des éléments de $cic.Term$ de $univs.Type2$ et de $B$, pour tous les éléments $x$ et $y$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $y$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $B$ et $f$ appliqué à $x$ et $f$ appliqué à $y$.\nassistant\n", "label": "Axiom eq_f : forall A : cic.Univ univs.Type2, forall B : cic.Univ univs.Type2, forall f : ((__ : cic.Term univs.Type2 A) -> cic.Term univs.Type2 B), forall x : cic.Term univs.Type2 A, forall y : cic.Term univs.Type2 A, forall __ : cic.Term cic.prop (matita_basics_logic.eq A x y), cic.Term cic.prop (matita_basics_logic.eq B (f x) (f y)) .", "predict": "Axiom eq_f : forall A : cic.Univ univs.Type2, forall B : cic.Univ univs.Type2, forall f : ((__ : cic.Term univs.Type2 A) -> cic.Term univs.Type2 B), forall x : cic.Term univs.Type2 A, forall y : cic.Term univs.Type2 A, forall __ : cic.Term cic.prop (matita_basics_logic.eq A x y), cic.Term cic.prop (matita_basics_logic.eq B (f x) (f y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_rect_Type2_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.\nassistant\n", "label": "range_rect_Type2_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type2) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type2 (Q_ x_923) .", "predict": "range_rect_Type2_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type2) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type2 (Q_ x_923) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBinomial_law. För alla element $a$ och $b$ och $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $a$ och $b$ och $n$ och $matita_arithmetics_bigops.bigop$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och funktionen som avbildar $k$ som $matita_basics_bool.true$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $k$ som $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_binomial.bc$ applicerat på $n$ och $k$ och $matita_arithmetics_exp.exp$ applicerat på $a$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $k$ och $matita_arithmetics_exp.exp$ applicerat på $b$ och $k$.\nassistant\n", "label": "postulate binomial_law : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.plus a b) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k))) (matita_arithmetics_exp.exp b k))))", "predict": "postulate binomial_law : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.plus a b) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k))) (matita_arithmetics_exp.exp b k))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nM. Soit $_m$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "M : _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "M : _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPosition_of_aux_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_found$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $_l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $_acc$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.option$ applicerat på $matita_arithmetics_nat.nat$.\nassistant\n", "label": "position_of_aux_body : A : cic.Univ univs.Type0 -> _found : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _acc : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat) .", "predict": "position_of_aux_body : A : cic.Univ univs.Type0 -> _found : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _acc : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLet_clause_1034. Låt $n$ och $m$ och $q$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $x2515$ och $x2516$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x2515$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_div_and_mod.mod$ applicerat på $x2515$ och $x2516$ och $matita_arithmetics_nat.times$ applicerat på $x2516$ och $matita_arithmetics_div_and_mod.div$ applicerat på $x2515$ och $x2516$.\nassistant\n", "label": "Axiom let_clause_1034 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)))) .", "predict": "Axiom let_clause_1034 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_le_times_r. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom monotonic_le_times_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (fun m => matita_arithmetics_nat.times n m)) .", "predict": "Axiom monotonic_le_times_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (fun m => matita_arithmetics_nat.times n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMinus_minus. För alla element $n$ och $m$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $p$ och $m$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $p$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $matita_arithmetics_nat.minus$ applicerat på $m$ och $p$.\nassistant\n", "label": "minus_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le p m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus p (matita_arithmetics_nat.minus n m)) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.minus m p))) .", "predict": "minus_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le p m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus p (matita_arithmetics_nat.minus n m)) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.minus m p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNilr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $a$.\nassistant\n", "label": "axiom nilr_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a nil) a)", "predict": "axiom nilr_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a nil) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nSig_rect_CProp1. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_686$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_686$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_686$.\nassistant\n", "label": "postulate Sig_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_686)", "predict": "postulate Sig_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_686 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_686)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTo_min. Låt $i$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $matita_arithmetics_nat.min$ applicerat på $n$ och $m$.\nassistant\n", "label": "axiom to_min (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i m)) : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))", "predict": "axiom to_min (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i m)) : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1559. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.\nassistant\n", "label": "Axiom let_clause_1559 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n) .", "predict": "Axiom let_clause_1559 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nMatch_list. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$, för alla element $case_nil$ av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $case_cons$ från element $__$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $__$ och $__1$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "match_list : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ return_sort) -> case_nil : cic.Term return_sort (return_type (matita_basics_lists_list.nil _A)) -> case_cons : (__ : cic.Term univs.Type0 _A -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term return_sort (return_type (matita_basics_lists_list.cons _A __ __1))) -> z : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term return_sort (return_type z) .", "predict": "match_list : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ return_sort) -> case_nil : cic.Term return_sort (return_type (matita_basics_lists_list.nil _A)) -> case_cons : (__ : cic.Term univs.Type0 _A -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term return_sort (return_type (matita_basics_lists_list.cons _A __ __1))) -> z : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAop_rect_Type5. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_785$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type5$ och $", "label": "postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)", "predict": "postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nSplit_len. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_basics_lists_list.length$ applicerat på $A$ och $matita_basics_types.fst$ applicerat på $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.split$ applicerat på $A$ och $l$ och $n$ och $n$.\nassistant\n", "label": "Axiom split_len : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))) n) .", "predict": "Axiom split_len : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split A l n))) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLeb_true_to_le. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.leb$ applicerat på $n$ och $m$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$.\nassistant\n", "label": "leb_true_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "leb_true_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nExp_2. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_exp.exp$ applicerat på $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $n$.\nassistant\n", "label": "postulate exp_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n))", "predict": "postulate exp_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nCoerc_pair_sigma. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.snd$ applied to $A$ and $B$ and $p$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $matita_basics_types.Sig$ applied to $B$ and the function that maps $x$ to $P$ applied to $x$.\nassistant\n", "label": "Axiom coerc_pair_sigma : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall p : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall __ : cic.Term cic.prop (P (matita_basics_types.snd A B p)), cic.Term univs.Type0 (matita_basics_types.Prod A (matita_basics_types.Sig B (fun x => P x))) .", "predict": "Axiom coerc_pair_sigma : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall p : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall __ : cic.Term cic.prop (P (matita_basics_types.snd A B p)), cic.Term univs.Type0 (matita_basics_types.Prod A (matita_basics_types.Sig B (fun x => P x))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.\nassistant\n", "label": "postulate eq_rect_Type1_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) -> (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_16 : cic.Term univs.Type2 A) -> (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Term univs.Type1 (Q_ x_16 x_17)", "predict": "postulate eq_rect_Type1_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) -> (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_16 : cic.Term univs.Type2 A) -> (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Term univs.Type1 (Q_ x_16 x_17)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBc_n_O. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate bc_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "postulate bc_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMap_append. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $l1$ och $l2$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $B$ och $matita_basics_lists_list.append$ applicerat på $B$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $f$ och $l1$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $f$ och $l2$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $f$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $l2$.\nassistant\n", "label": "postulate map_append : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.append B (matita_basics_lists_list.map A B f l1) (matita_basics_lists_list.map A B f l2)) (matita_basics_lists_list.map A B f (matita_basics_lists_list.append A l1 l2)))", "predict": "postulate map_append : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.append B (matita_basics_lists_list.map A B f l1) (matita_basics_lists_list.map A B f l2)) (matita_basics_lists_list.map A B f (matita_basics_lists_list.append A l1 l2)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nSum_rect_CProp0_body. För alla element $_A$ och $_B$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_581$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_inl$ från element $x_582$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_582$, för alla funktioner $_H_inr$ från element $x_583$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_583$, för alla element $x_581$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_581$.\nassistant\n", "label": "Sum_rect_CProp0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_582 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> _H_inr : (x_583 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_581) .", "predict": "Sum_rect_CProp0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ cic.prop) -> _H_inl : (x_582 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> _H_inr : (x_583 : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term cic.prop (Q_ x_581) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_iter. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $g$ applied to $x$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$.\nassistant\n", "label": "axiom le_iter (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a))", "predict": "axiom le_iter (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiscr_minus_x_xy. Pour tous les éléments $x$ et $y$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x$ et $matita_arithmetics_nat.minus$ appliqué à $x$ et $y$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x$ et $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $y$ et $matita_arithmetics_nat.O$.\nassistant\n", "label": "discr_minus_x_xy : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x (matita_arithmetics_nat.minus x y)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)) .", "predict": "discr_minus_x_xy : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x (matita_arithmetics_nat.minus x y)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_rect_CProp2_body. Let $Q_$ be a function from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.\nassistant\n", "label": "axiom nat_rect_CProp2_body (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_405)", "predict": "axiom nat_rect_CProp2_body (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_405)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nIff_not. För alla element $A$ och $B$ av $cic.Univ$ av $cic.prop$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.iff$ applicerat på $A$ och $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.iff$ applicerat på $matita_basics_logic.Not$ applicerat på $A$ och $matita_basics_logic.Not$ applicerat på $B$.\nassistant\n", "label": "axiom iff_not (A B : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Not A) (matita_basics_logic.Not B))", "predict": "axiom iff_not (A B : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Not A) (matita_basics_logic.Not B))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDop_inv_rect_Type1. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1722$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $x2$ et $x2$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_b", "label": "axiom Dop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom Dop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nExp_sigma. Pour tous les éléments $n$ et $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $p$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $a$ et $matita_arithmetics_exp.exp$ appliqué à $a$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.plus$ et la fonction qui envoie $i$ à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "exp_sigma : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)))) .", "predict": "exp_sigma : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => a)) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_SO_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "Axiom divides_SO_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) .", "predict": "Axiom divides_SO_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nBool_rect_Type3_body. Pour toutes les fonctions $Q_$ des éléments $_x_335$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type3$, pour tous les éléments $_H_true$ de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $univs.Type3$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_335$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_335$.\nassistant\n", "label": "postulate bool_rect_Type3_body : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)", "predict": "postulate bool_rect_Type3_body : (Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false)) -> (x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type3 (Q_ x_335)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDPair_rect_CProp5_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_654$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_DPair$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$, pour tous les éléments $x_654$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_654$.\nassistant\n", "label": "DPair_rect_CProp5_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_654) .", "predict": "DPair_rect_CProp5_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_654) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_inv_rect_CProp1. Let $x1$ and $x2$ and $x3$ and $x4$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1488$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1489$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom div_mod_spec_inv_rect_CProp1 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) : cic.Term cic.prop (P Hterm)", "predict": "axiom div_mod_spec_inv_rect_CProp1 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLog_exp. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.\nassistant\n", "label": "axiom log_exp (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))", "predict": "axiom log_exp (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDivides_mod. Låt $p$ och $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_div_and_mod.mod$ applicerat på $m$ och $n$.\nassistant\n", "label": "postulate divides_mod : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_div_and_mod.mod m n))", "predict": "postulate divides_mod : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_div_and_mod.mod m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_divides_to_gcd_aux. Let $p$ and $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom not_divides_to_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) .", "predict": "Axiom not_divides_to_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nOption_inv_rect_CProp4. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1074$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1075$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_615$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1075$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_615$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_615$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate option_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1074 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_615 : cic.Term univs.Type0 x1) -> (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate option_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1074 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_615 : cic.Term univs.Type0 x1) -> (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLe_Psi_BPsi1. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_chebyshev_factorization.B$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $n$.\nassistant\n", "label": "axiom le_Psi_BPsi1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "axiom le_Psi_BPsi1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_plus_n. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $m$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $m$.\nassistant\n", "label": "postulate le_plus_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m))", "predict": "postulate le_plus_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nBool_rect_Type5. Soit $Q_$ une fonction des éléments $_x_332$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type5$. Alors pour tous les éléments $_H_true$ de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_332$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_332$.\nassistant\n", "label": "Axiom bool_rect_Type5 : forall Q_ : ((_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5), forall _H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false), forall x_332 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type5 (Q_ x_332) .", "predict": "Axiom bool_rect_Type5 : forall Q_ : ((_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5), forall _H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false), forall x_332 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type5 (Q_ x_332) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLstar_r_O. Pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $R$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $B$, pour tous les éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_lstar.lstar_r$ appliqué à $B$ et $R$ et $matita_arithmetics_nat.O$ et $b$ et $b$.\nassistant\n", "label": "lstar_r_O : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b) .", "predict": "lstar_r_O : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b : cic.Term univs.Type0 B -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_CProp0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_37$ and $x_38$.\nassistant\n", "label": "axiom eq_rect_CProp0_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_37 : cic.Term univs.Type2 A) (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) : cic.Term cic.prop (Q_ x_37 x_38)", "predict": "axiom eq_rect_CProp0_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_37 : cic.Term univs.Type2 A) (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) : cic.Term cic.prop (Q_ x_37 x_38)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDivides_to_divides_ord_rem. Soient $p$ et $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_ord.ord_rem$ appliqué à $n$ et $p$ et $matita_arithmetics_ord.ord_rem$ appliqué à $m$ et $p$.\nassistant\n", "label": "Axiom divides_to_divides_ord_rem : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) .", "predict": "Axiom divides_to_divides_ord_rem : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.\nassistant\n", "label": "axiom eq_rect_Type1 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) (x_16 : cic.Term univs.Type2 A) (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) : cic.Term univs.Type1 (Q_ x_16 x_17)", "predict": "axiom eq_rect_Type1 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) (x_16 : cic.Term univs.Type2 A) (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) : cic.Term univs.Type1 (Q_ x_16 x_17)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nProj2. Soient $A$ et $B$ des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $A$ et $B$, $cic.Term$ tient pour $cic.prop$ et $B$.\nassistant\n", "label": "Axiom proj2 : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.And A B), cic.Term cic.prop B .", "predict": "Axiom proj2 : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.And A B), cic.Term cic.prop B ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nNat_inv_ind. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $P$ från element $_z653$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z654$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.O$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H2$ från element $x_366$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_x_368$ från element $_z654$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $x_366$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x_366$ och element $_z654$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.S$ applicerat på $x_366$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_366$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "Axiom nat_inv_ind : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z653 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall _H2 : ((x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_366)) -> cic.Term cic.prop (P x_366)) -> (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_366))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_366))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom nat_inv_ind : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z653 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall _H2 : ((x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_366)) -> cic.Term cic.prop (P x_366)) -> (_z654 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_366))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_366))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMod_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom mod_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O) .", "predict": "Axiom mod_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_ord. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_ord.ord$ applied to $n$ and $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$.\nassistant\n", "label": "axiom divides_to_ord (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p)))", "predict": "axiom divides_to_ord (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDividesb_div_true. Låt $d$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $d$ och $n$ och $matita_basics_bool.true$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $matita_arithmetics_div_and_mod.div$ applicerat på $n$ och $d$ och $n$ och $matita_basics_bool.true$.\nassistant\n", "label": "Axiom dividesb_div_true : forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb d n) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb (matita_arithmetics_div_and_mod.div n d) n) matita_basics_bool.true) .", "predict": "Axiom dividesb_div_true : forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb d n) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb (matita_arithmetics_div_and_mod.div n d) n) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nAll_inv_append. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla element $l1$ och $l2$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.All$ applicerat på $A$ och $P$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $l2$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_basics_lists_list.All$ applicerat på $A$ och $P$ och $l1$ och $matita_basics_lists_list.All$ applicerat på $A$ och $P$ och $l2$.\nassistant\n", "label": "Axiom All_inv_append : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2)), cic.Term cic.prop (matita_basics_logic.And (matita_basics_lists_list.All A P l1) (matita_basics_lists_list.All A P l2)) .", "predict": "Axiom All_inv_append : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2)), cic.Term cic.prop (matita_basics_logic.And (matita_basics_lists_list.All A P l1) (matita_basics_lists_list.All A P l2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nBool_rect_CProp5_body. Låt $Q_$ vara en funktion från element $_x_350$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_350$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_350$.\nassistant\n", "label": "postulate bool_rect_CProp5_body : (Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_350)", "predict": "postulate bool_rect_CProp5_body : (Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_350 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_350)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAndb_elim. Låt $b1$ och $b2$ vara element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_bool.match_bool$ applicerat på $cic.type$ applicerat på $cic.z$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $cic.prop$ och $P$ applicerat på $b2$ och $P$ applicerat på $matita_basics_bool.false$ och $b1$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $matita_basics_bool.andb$ applicerat på $b1$ och $b2$.\nassistant\n", "label": "andb_elim : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ cic.prop) (P b2) (P matita_basics_bool.false) b1) -> cic.Term cic.prop (P (matita_basics_bool.andb b1 b2)) .", "predict": "andb_elim : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ cic.prop) (P b2) (P matita_basics_bool.false) b1) -> cic.Term cic.prop (P (matita_basics_bool.andb b1 b2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_log_S. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "Axiom le_log_S : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p (matita_arithmetics_nat.S n))) .", "predict": "Axiom le_log_S : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p (matita_arithmetics_nat.S n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nEx2_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_P$ och $_Q$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_274$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $A$ och $_P$ och $_Q$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_ex2_intro$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $x_276$ av $cic.Term$ av $cic.prop$ och $_P$ applicerat på $x$ och element $x_275$ av $cic.Term$ av $cic.prop$ och $_Q$ applicerat på $x$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.ex2_intro$ applicerat på $A$ och $_P$ och $_Q$ och $x$ och $x_276$ och $x_275$, för alla element $x_274$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex2$ applicerat på $A$ och $_P$ och $_Q$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_274$.\nassistant\n", "label": "axiom ex2_ind_body (A : cic.Univ univs.Type0) (_P _Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) : cic.Term cic.prop (Q_ x_274)", "predict": "axiom ex2_ind_body (A : cic.Univ univs.Type0) (_P _Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) : cic.Term cic.prop (Q_ x_274)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nUnit_inv_rect_Type3. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$. Alors pour toutes les fonctions $P$ des éléments $_z918$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type3$, pour toutes les fonctions $_H1$ des éléments $_z919$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_types.it$, $cic.Term$ tient pour $univs.Type3$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom unit_inv_rect_Type3 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z918 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type3), forall _H1 : ((_z919 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type3 (P matita_basics_types.it)), cic.Term univs.Type3 (P Hterm) .", "predict": "Axiom unit_inv_rect_Type3 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z918 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type3), forall _H1 : ((_z919 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type3 (P matita_basics_types.it)), cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nTrue_rect_Type5_body. Låt $Q_$ vara en funktion från element $_x_44$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type5$. Då för alla element $_H_I$ av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_44$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_44$.\nassistant\n", "label": "postulate True_rect_Type5_body : (Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type5) -> (_H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I)) -> (x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type5 (Q_ x_44)", "predict": "postulate True_rect_Type5_body : (Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type5) -> (_H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I)) -> (x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type5 (Q_ x_44)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nProd_rect_CProp1_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_712$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $x_712$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_712$.\nassistant\n", "label": "Axiom Prod_rect_CProp1_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_712) .", "predict": "Axiom Prod_rect_CProp1_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_712) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nXorb. Pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_bool.bool$.\nassistant\n", "label": "axiom xorb (__ __1 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 matita_basics_bool.bool", "predict": "axiom xorb (__ __1 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLog_exp. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.\nassistant\n", "label": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))", "predict": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_n_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "mod_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O) .", "predict": "mod_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_map_some. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all elements $v$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $B$ and $matita_basics_types.option_map$ applied to $A$ and $B$ and $f$ and $x$ and $matita_basics_types.Some$ applied to $B$ and $v$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $y$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $y$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $y$ and $v$.\nassistant\n", "label": "Axiom option_map_some : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall x : cic.Term univs.Type0 (matita_basics_types.option A), forall v : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.Some B v)), cic.Term cic.prop (matita_basics_logic.ex A (fun y => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f y) v))) .", "predict": "Axiom option_map_some : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall x : cic.Term univs.Type0 (matita_basics_types.option A), forall v : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.Some B v)), cic.Term cic.prop (matita_basics_logic.ex A (fun y => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f y) v))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nNat_inv_rect_Type2. Pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $P$ des éléments $_z671$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H1$ des éléments $_z672$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.O$ à des éléments de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H2$ des éléments $x_382$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_x_384$ des éléments $_z672$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $x_382$ à des éléments de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $x_382$ et des éléments $_z672$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $Hterm$ et $matita_arithmetics_nat.S$ appliqué à $x_382$ à des éléments de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_382$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate nat_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z671 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H1 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type2 (P matita_arithmetics_nat.O)) -> (_H2 : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_382)) -> cic.Term univs.Type2 (P x_382)) -> (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate nat_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z671 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) -> (_H1 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type2 (P matita_arithmetics_nat.O)) -> (_H2 : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_382)) -> cic.Term univs.Type2 (P x_382)) -> (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nNill_body. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $nil$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $nil$ och $a$ och $a$.\nassistant\n", "label": "Axiom nill_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) .", "predict": "Axiom nill_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nList_inv_rect_CProp4. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1338$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1339$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.nil$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.nil$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_753$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $x_752$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ et des fonctions $_x_755$ des éléments $_z1339$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $x_752$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x_752$ et des éléments $_z1339$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_753$ et $x_752$ à des éléments de $cic.Term$ de $cic.prop$ et de $", "label": "axiom list_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1338 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_753 : cic.Term univs.Type0 x1) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_755 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_752)) -> cic.Term cic.prop (P x_752)) -> (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_753 x_752))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_753 x_752))) : cic.Term cic.prop (P Hterm)", "predict": "axiom list_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1338 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_753 : cic.Term univs.Type0 x1) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_755 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_752)) -> cic.Term cic.prop (P x_752)) -> (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_753 x_752))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_753 x_752))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_rect_CProp1_body. Let $Q_$ be a function from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.\nassistant\n", "label": "Axiom nat_rect_CProp1_body : forall Q_ : ((_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))), forall x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_409) .", "predict": "Axiom nat_rect_CProp1_body : forall Q_ : ((_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))), forall x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_409) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nP_ord_aux_to_not_mod_O. For all elements $p$ and $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $r$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom p_ord_aux_to_not_mod_O (p n m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O))", "predict": "axiom p_ord_aux_to_not_mod_O (p n m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTransitive_congruent. Let $p$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and the function that maps $n$ and $m$ to $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "transitive_congruent : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_congruence.congruent n m p)) .", "predict": "transitive_congruent : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_congruence.congruent n m p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nGcd_O_to_eq_O. Soient $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.And$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom gcd_O_to_eq_O (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))", "predict": "axiom gcd_O_to_eq_O (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nEnum. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $A$, pour tous les éléments $_x_942$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $A$.\nassistant\n", "label": "enum : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A .", "predict": "enum : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> _x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_B2_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.B2$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate le_B2_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))", "predict": "postulate le_B2_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nBi_transitive. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $_R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.bi_relation$ applicerat på $A$ och $B$, håller $cic.Univ$ för $cic.prop$.\nassistant\n", "label": "axiom bi_transitive (A B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) : cic.Univ cic.prop", "predict": "axiom bi_transitive (A B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nB_SSSSSSSO. $cic.Term$ håller för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_chebyshev_factorization.B$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $mat", "label": "postulate B_SSSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (mat", "predict": "postulate B_SSSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPi_p_primeb5. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et la fonction qui envoie $p$ à $matita_arithmetics_primes.primeb$ appliqué à $p$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $p$ à $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_log.log$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.times$ et la fonction qui envoie $i$ à $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $matita_arithmetics_exp.exp$ appliqué à $p$ et $matita_arithmetics_nat.S$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et la fonction qui envoie", "label": "Axiom pi_p_primeb5 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => mat", "predict": "Axiom pi_p_primeb5 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nTrue_min. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $b$ och $matita_basics_bool.true$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.min$ applicerat på $n$ och $b$ och $f$ och $b$.\nassistant\n", "label": "postulate true_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) b)", "predict": "postulate true_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) b)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAssoc. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $nil$, för alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $c$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ och $c$.\nassistant\n", "label": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))", "predict": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nSig_rect_CProp4. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_678$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Sig$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$, för alla element $x_678$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_678$.\nassistant\n", "label": "axiom Sig_rect_CProp4 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_678)", "predict": "axiom Sig_rect_CProp4 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_678 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_678)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAnd_rect_CProp3_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_154$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_conj$ från element $x_156$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_155$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_156$ och $x_155$, för alla element $x_154$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_154$.\nassistant\n", "label": "axiom And_rect_CProp3_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_154)", "predict": "axiom And_rect_CProp3_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_154)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nPrim. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate prim : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate prim : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPair_elim. Låt $A$ och $B$ och $C$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $T$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$, för alla element $p$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $C$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $lft$ av $cic.Term$ av $univs.Type0$ och $A$ och element $rgt$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ och $T$ applicerat på $lft$ och $rgt$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $p$ och $matita_basics_types.match_Prod$ applicerat på $A$ och $B$ och $univs.Type0$ och funktionen som avbildar $_0$ som $C$ och funktionen som avbildar $lft$ och $rgt$ som $T$ applicerat på $lft$ och $rgt$ och $p$.\nassistant\n", "label": "pair_elim : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> T : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> p : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> __1 : cic.Term univs.Type0 C -> cic.Univ cic.prop) -> __ : (lft : cic.Term univs.Type0 A -> rgt : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (_0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) => C) (lft : cic.Term univs.Type0 A => rgt : cic.Term univs.Type0 B => T lft rgt) p)) .", "predict": "pair_elim : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> T : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> p : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> __1 : cic.Term univs.Type0 C -> cic.Univ cic.prop) -> __ : (lft : cic.Term univs.Type0 A -> rgt : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (_0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) => C) (lft : cic.Term univs.Type0 A => rgt : cic.Term univs.Type0 B => T lft rgt) p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nGcd_n_times_nm. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $m$ et $n$.\nassistant\n", "label": "postulate gcd_n_times_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_nat.times n m)) n)", "predict": "postulate gcd_n_times_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_nat.times n m)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nPermut_mod. Pour tous les éléments $p$ et $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_arithmetics_primes.divides$ appliqué à $p$ et $a$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à la fonction qui envoie $n$ à $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $n$ et $p$ et $matita_arithmetics_nat.pred$ appliqué à $p$.\nassistant\n", "label": "Axiom permut_mod : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun n => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p)) .", "predict": "Axiom permut_mod : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun n => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNat_inv_rect_CProp1. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $P$ från element $_z707$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z708$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.O$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H2$ från element $x_410$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_x_412$ från element $_z708$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $x_410$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x_410$ och element $_z708$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.S$ applicerat på $x_410$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_410$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "axiom nat_inv_rect_CProp1 (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (_z707 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H1 : (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) (_H2 : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_410)) -> cic.Term cic.prop (P x_410)) -> (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_410))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_410))) : cic.Term cic.prop (P Hterm)", "predict": "axiom nat_inv_rect_CProp1 (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (_z707 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H1 : (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) (_H2 : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_410)) -> cic.Term cic.prop (P x_410)) -> (_z708 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_410))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_410))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSub_assoc_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R1$ and $R2$ and $R3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R3$ and $matita_basics_relations.Rcomp$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R2$ and $R3$.\nassistant\n", "label": "postulate sub_assoc_l : (A : cic.Univ univs.Type0) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R3 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3))", "predict": "postulate sub_assoc_l : (A : cic.Univ univs.Type0) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R3 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPad_bigop1. For all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $k$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil", "label": "axiom pad_bigop1 (k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ i => p i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil op (λ i => f i)))", "predict": "axiom pad_bigop1 (k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ i => p i) B nil op (λ i => f i)) (matita_arithmetics_bigops.bigop k (λ i => p i) B nil op (λ i => f i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFalse_rect_Type3. Let $Q_$ be a function from elements $_x_69$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type3$. Then for all elements $x_69$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_69$.\nassistant\n", "label": "postulate False_rect_Type3 : (Q_ : (_x_69 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type3) -> (x_69 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ x_69)", "predict": "postulate False_rect_Type3 : (Q_ : (_x_69 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type3) -> (x_69 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ x_69)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nPrime_to_lt_SO. Pour tous les éléments $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$.\nassistant\n", "label": "prime_to_lt_SO : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) .", "predict": "prime_to_lt_SO : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_clause_1544. Pour tous les éléments $p$ et $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Hind$ des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $q$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $a$ à $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $b$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $q$ et $m$ et $n$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $a$ et $n$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $q$ et $m$ et $n$, pour tous les éléments $m$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $", "label": "Axiom let_clause_1544 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term un", "predict": "Axiom let_clause_1544 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus (matita_arithmetics_nat.times p n) (matita_arithmetics_nat.times q m))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times p"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15691. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_ar", "label": "Axiom let_clause_15691 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O", "predict": "Axiom let_clause_15691 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S mat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_rect_Type0. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_nmk$ from functions $x_98$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_98$, for all elements $x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_97$.\nassistant\n", "label": "axiom Not_rect_Type0 (_A : cic.Univ cic.prop) (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type0 (Q_ x_97)", "predict": "axiom Not_rect_Type0 (_A : cic.Univ cic.prop) (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type0 (Q_ x_97)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nExp_body. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "exp_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "exp_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nPlus_minus_associative. Soient $x$ et $y$ et $z$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $z$ et $y$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.plus$ appliqué à $x$ et $matita_arithmetics_nat.minus$ appliqué à $y$ et $z$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $x$ et $y$ et $z$.\nassistant\n", "label": "postulate plus_minus_associative : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x y) z))", "predict": "postulate plus_minus_associative : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x y) z))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_previous_prime6. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom let_previous_prime6 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom let_previous_prime6 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nEqb_elim. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $P$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $__$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_bool.true$, pour toutes les fonctions $__1$ des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Not$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_bool.false$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $matita_arithmetics_nat.eqb$ appliqué à $n$ et $m$.\nassistant\n", "label": "axiom eqb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))", "predict": "axiom eqb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nSigma_const. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_bigops.bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.plus$ et la fonction qui envoie $i$ à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.\nassistant\n", "label": "axiom sigma_const (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)", "predict": "axiom sigma_const (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nOption_inv_rect_CProp3. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1080$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1081$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_623$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1081$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_623$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_623$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "postulate option_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1080 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_623 : cic.Term univs.Type0 x1) -> (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate option_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1080 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_623 : cic.Term univs.Type0 x1) -> (_z1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_623))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_885$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and", "label": "Axiom Aop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_885) .", "predict": "Axiom Aop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_885 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_885) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_rect_Type2_body. Let $Q_$ be a function from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.\nassistant\n", "label": "unit_rect_Type2_body : Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it) -> x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type2 (Q_ x_503) .", "predict": "unit_rect_Type2_body : Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it) -> x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type2 (Q_ x_503) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDop_inv_rect_Type3. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1710$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H1$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type", "label": "axiom Dop_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type3 (P Hterm)", "predict": "axiom Dop_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type3 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_CProp0. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.\nassistant\n", "label": "nat_rect_CProp0 : Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_416 : cic.Term cic.prop (Q_ x_414) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_413) .", "predict": "nat_rect_CProp0 : Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_416 : cic.Term cic.prop (Q_ x_414) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_413) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nBool_rect_Type1. Låt $Q_$ vara en funktion från element $_x_341$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $univs.Type1$. Då för alla element $_H_true$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_341$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_341$.\nassistant\n", "label": "axiom bool_rect_Type1 (Q_ : (_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1) (_H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false)) (x_341 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type1 (Q_ x_341)", "predict": "axiom bool_rect_Type1 (Q_ : (_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1) (_H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false)) (x_341 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type1 (Q_ x_341)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLt_O_bc. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $m$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_binomial.bc$ appliqué à $n$ et $m$.\nassistant\n", "label": "postulate lt_O_bc : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m))", "predict": "postulate lt_O_bc : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nHd. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_d$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "hd : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _d : cic.Term univs.Type0 A -> cic.Term univs.Type0 A .", "predict": "hd : A : cic.Univ univs.Type0 -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _d : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMod_cr_pair. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $a$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $b$ et $n$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.And$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_chinese_reminder.cr_pair$ appliqué à $m$ et $n$ et $a$ et $b$ et $m$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_chinese_reminder.cr_pair$ appliqué à $m$ et $n$ et $a$ et $b$ et $n$ et $b$.\nassistant\n", "label": "axiom mod_cr_pair (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt b n)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) m) a) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) n) b))", "predict": "axiom mod_cr_pair (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt b n)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) m) a) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_chinese_reminder.cr_pair m n a b) n) b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nAssoc_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $nil$, pour tous les éléments $a$ et $b$ et $c$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $nil$ et $xxx$ et $b$ et $c$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $nil$ et $xxx$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $b$ et $c$.\nassistant\n", "label": "postulate assoc_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))", "predict": "postulate assoc_body : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nACop_rect_CProp2_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_909$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_909$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_909$.\nassistant\n", "label": "axiom ACop_rect_CProp2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_909)", "predict": "axiom ACop_rect_CProp2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_909)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nList_rect_Type2. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_736$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$, för alla element $_H_nil$ av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_738$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_737$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_740$ av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $x_737$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_738$ och $x_737$, för alla element $x_736$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_736$.\nassistant\n", "label": "postulate list_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) -> (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type2 (Q_ x_736)", "predict": "postulate list_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) -> (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type2 (Q_ x_736)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMatch_lstar_r. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$", "label": "postulate match_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (case_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)", "predict": "postulate match_lstar_r : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Univ return_sort) -> (case_lstar_r_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> (case_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b)) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (_R b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b __ b2 __1))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2)) -> cic.Term return_sort (return_type __ __1 __2 z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMinus_plus_minus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $z$ and $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.plus$ applied to $x$ and $y$.\nassistant\n", "label": "Axiom minus_plus_minus_l : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le y z), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.plus x y)) .", "predict": "Axiom minus_plus_minus_l : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le y z), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.plus x y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_rect_CProp5_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.\nassistant\n", "label": "axiom option_rect_CProp5_body (_A : cic.Univ univs.Type0) (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_618)", "predict": "axiom option_rect_CProp5_body (_A : cic.Univ univs.Type0) (Q_ : (_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) (_H_Some : (x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))) (x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term cic.prop (Q_ x_618)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nTrue_rect_Type4. För alla funktioner $Q_$ från element $_x_42$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type4$, för alla element $_H_I$ av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_42$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_42$.\nassistant\n", "label": "axiom True_rect_Type4 (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) (x_42 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type4 (Q_ x_42)", "predict": "axiom True_rect_Type4 (Q_ : (_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4) (_H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I)) (x_42 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type4 (Q_ x_42)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDiv_mod. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $m$ et $m$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $m$.\nassistant\n", "label": "axiom div_mod (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) (matita_arithmetics_div_and_mod.mod n m)))", "predict": "axiom div_mod (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) (matita_arithmetics_div_and_mod.mod n m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.\nassistant\n", "label": "Sig_rect_Type4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type4) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type4 (Q_ x_666) .", "predict": "Sig_rect_Type4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type4) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type4 (Q_ x_666) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nCongruent_n_mod_times. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $p$ and $p$.\nassistant\n", "label": "congruent_n_mod_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p) .", "predict": "congruent_n_mod_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_4_to_le_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "lt_4_to_le_Psi_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) .", "predict": "lt_4_to_le_Psi_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nVoid_rect_CProp4_body. Pour toutes les fonctions $Q_$ des éléments $_x_489$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_489$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_489$.\nassistant\n", "label": "Axiom void_rect_CProp4_body : forall Q_ : ((_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_489 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_489) .", "predict": "Axiom void_rect_CProp4_body : forall Q_ : ((_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_489 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_489) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nDPair_rect_Type4. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_640$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_mk_DPair$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$, för alla element $x_640$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_640$.\nassistant\n", "label": "axiom DPair_rect_Type4 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type4 (Q_ x_640)", "predict": "axiom DPair_rect_Type4 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type4 (Q_ x_640)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_Psi_BPsi1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "axiom le_Psi_BPsi1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "axiom le_Psi_BPsi1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nRange_rect_Type2. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $_A$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $_A$ och $_enum$ och $_upto$ och $_filter$, för alla element $x_923$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_923$.\nassistant\n", "label": "range_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type2) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type2 (Q_ x_923) .", "predict": "range_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type2) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type2 (Q_ x_923) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nNot_rect_Type2. För alla element $_A$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_91$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_nmk$ från funktioner $x_92$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_92$, för alla element $x_91$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_91$.\nassistant\n", "label": "Axiom Not_rect_Type2 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type2), forall _H_nmk : ((x_92 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))), forall x_91 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type2 (Q_ x_91) .", "predict": "Axiom Not_rect_Type2 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type2), forall _H_nmk : ((x_92 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))), forall x_91 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type2 (Q_ x_91) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBdef. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom Bdef : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) .", "predict": "Axiom Bdef : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_Type1. For all functions $Q_$ from elements $_x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_71$.\nassistant\n", "label": "Axiom False_rect_Type1 : forall Q_ : ((_x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type1), forall x_71 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type1 (Q_ x_71) .", "predict": "Axiom False_rect_Type1 : forall Q_ : ((_x_71 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type1), forall x_71 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type1 (Q_ x_71) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMonotonic_le_minus_l. Let $p$ and $q$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $q$ and $n$ and $matita_arithmetics_nat.minus$ applied to $p$ and $n$.\nassistant\n", "label": "postulate monotonic_le_minus_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n))", "predict": "postulate monotonic_le_minus_l : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $i$.\nassistant\n", "label": "axiom eq_fact_pi_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ i => matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => i)))", "predict": "axiom eq_fact_pi_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ i => matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "divides_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "divides_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nMinus_Sn_n. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et $n$.\nassistant\n", "label": "minus_Sn_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n)) .", "predict": "minus_Sn_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nRange_inv_rect_Type0. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1662$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_H1$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ et des éléments $_z1663$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.range$ appliqué à $x1$ et $Hterm$ et $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom range_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1662 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type0), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1663 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term univs.Type0 (P Hterm) .", "predict": "Axiom range_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1662 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type0), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1663 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nMk_range. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_bigops.range$ appliqué à $A$.\nassistant\n", "label": "postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)", "predict": "postulate mk_range : (A : cic.Univ univs.Type0) -> (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (matita_arithmetics_bigops.range A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nMin_spec_ind_body. Pour tous les éléments $_n$ et $_b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour toutes les fonctions $Q_$ des éléments $x_1075$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_1076$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_minimization.min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $x_1075$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_found_min_spec$ des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1080$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $m$ et des éléments $x_1079$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $matita_arithmetics_nat.plus$ appliqué à $_n$ et $_b$ et des éléments $x_1078$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué à $m$ et $matita_basics_bool.true$ et des fonctions $x_1077$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type", "label": "min_spec_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> _H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2", "predict": "min_spec_ind_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> _H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m)) -> _H_not_found_min_spec : (x_1081 : cic.Term cic.prop (matita_arithmetics_nat.lt _b matita_arithmetics_nat.plus _n _b) -> cic.Term cic.prop (Q_ (matita_arithmetics_minimization.find_min_spec _n _b _f x_1081))) -> cic.Term cic.prop (Q_ _b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nExteqF. Pour tous les éléments $A$ et $B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ et $_g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Univ$ tient pour $cic.prop$.\nassistant\n", "label": "postulate exteqF : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop", "predict": "postulate exteqF : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nDivides_pi_p_M1. Låt $m$ och $i$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_bigops.bigop$ applicerat på $i$ och funktionen som avbildar $p$ som $matita_basics_bool.andb$ applicerat på $matita_arithmetics_nat.leb$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $m$ och $p$ och $matita_arithmetics_primes.primeb$ applicerat på $p$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.times$ och funktionen som avbildar $p$ som $p$ och $matita_arithmetics_binomial.M$ applicerat på $m$.\nassistant\n", "label": "divides_pi_p_M1 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => p)) (matita_arithmetics_binomial.M m)) .", "predict": "divides_pi_p_M1 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => p)) (matita_arithmetics_binomial.M m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_682$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_682$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_682$.\nassistant\n", "label": "Sig_rect_CProp3 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_682 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_682 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_682) .", "predict": "Sig_rect_CProp3 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_682 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_682 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_682) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_inv_rect_CProp2. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1284$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1285$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Prod_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Prod_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLt_exp1. Pour tous les éléments $n$ et $m$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $n$ et $p$ et $matita_arithmetics_exp.exp$ appliqué à $m$ et $p$.\nassistant\n", "label": "axiom lt_exp1 (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))", "predict": "axiom lt_exp1 (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1569. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of", "label": "axiom let_clause_1569 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita", "predict": "axiom let_clause_1569 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDpi1__o__aop__o__op. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.\nassistant\n", "label": "axiom dpi1__o__aop__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) (_x_887 _x_888 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0", "predict": "axiom dpi1__o__aop__o__op (x0 : cic.Univ univs.Type0) (x1 : cic.Term univs.Type0 x0) (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) (_x_887 _x_888 : cic.Term univs.Type0 x0) : cic.Term univs.Type0 x0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDPair_inv_ind. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $x2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1104$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $x2$ applicerat på $dpi1$ och element $_z1105$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.DPair$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $x1$ och $x2$ och $dpi1$ och $_dpi2$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "Axiom DPair_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom DPair_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExp_2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom exp_2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n)) .", "predict": "Axiom exp_2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_to_andb_true. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.\nassistant\n", "label": "true_to_andb_true : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true) .", "predict": "true_to_andb_true : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSum_rect_Type4. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_526$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_inl$ from elements $x_527$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_527$, for all functions $_H_inr$ from elements $x_528$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_528$, for all elements $x_526$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_526$.\nassistant\n", "label": "Sum_rect_Type4 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type4) -> _H_inl : (x_527 : cic.Term univs.Type0 _A -> cic.Term univs.Type4 (Q_ (matita_basics_types.inl _A _B x_527))) -> _H_inr : (x_528 : cic.Term univs.Type0 _B -> cic.Term univs.Type4 (Q_ (matita_basics_types.inr _A _B x_528))) -> x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type4 (Q_ x_526) .", "predict": "Sum_rect_Type4 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type4) -> _H_inl : (x_527 : cic.Term univs.Type0 _A -> cic.Term univs.Type4 (Q_ (matita_basics_types.inl _A _B x_527))) -> _H_inr : (x_528 : cic.Term univs.Type0 _B -> cic.Term univs.Type4 (Q_ (matita_basics_types.inr _A _B x_528))) -> x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type4 (Q_ x_526) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nUnit_rect_CProp1. För alla funktioner $Q_$ från element $_x_517$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_it$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_517$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_517$.\nassistant\n", "label": "postulate unit_rect_CProp1 : (Q_ : (_x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_517)", "predict": "postulate unit_rect_CProp1 : (Q_ : (_x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_517)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_plus_n_r. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $matita_arithmetics_nat.plus$ applicerat på $m$ och $n$.\nassistant\n", "label": "postulate le_plus_n_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n))", "predict": "postulate le_plus_n_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_previous_prime5. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $ltml$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_primes.nth_prime$ applicerat på $n$ och $m$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom let_previous_prime5 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom let_previous_prime5 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nBool_rect_Type5. Låt $Q_$ vara en funktion från element $_x_332$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $univs.Type5$. Då för alla element $_H_true$ av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_332$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_332$.\nassistant\n", "label": "Axiom bool_rect_Type5 : forall Q_ : ((_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5), forall _H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false), forall x_332 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type5 (Q_ x_332) .", "predict": "Axiom bool_rect_Type5 : forall Q_ : ((_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5), forall _H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false), forall x_332 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type5 (Q_ x_332) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMax. För alla element $_n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate max : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate max : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nLe_Psi_exp4. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.pred$ applicerat på $n$ och $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate le_Psi_exp4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))", "predict": "postulate le_Psi_exp4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nSum_inv_rect_CProp2. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1020$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $x_572$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1021$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_572$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_572$, för alla funktioner $_H2$ från element $x_573$ av $cic.Term$ av $univs.Type0$ och $x2$ och element $_z1021$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_573$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_573$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Sum_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_572 : cic.Term univs.Type0 x1) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))), forall _H2 : ((x_573 : cic.Term univs.Type0 x2) -> (_z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLet_upper_bound2. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom let_upper_bound2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom let_upper_bound2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_rect_Type3_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.\nassistant\n", "label": "postulate Sum_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)", "predict": "postulate Sum_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLe_ind_body. Soit $_n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $Q_$ des éléments $x_417$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_418$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_n$ et $x_417$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_le_n$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $_n$ et $matita_arithmetics_nat.le_n$ appliqué à $_n$, pour toutes les fonctions $_H_le_S$ des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_419$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_n$ et $m$ et des éléments $_x_421$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $m$ et $x_419$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $m$ et $matita_arithmetics_nat.le_S$ appliqué à $_n$ et $m$ et $x_419$, pour tous les éléments $x_417$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $x_418$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_n$ et $x_417$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_417$ et $x_418$.\nassistant\n", "label": "axiom le_ind_body (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) : cic.Term cic.prop (Q_ x_417 x_418)", "predict": "axiom le_ind_body (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) : cic.Term cic.prop (Q_ x_417 x_418)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter_Or. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom filter_Or : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.Or _A _B), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_Or : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.Or _A _B), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNot_divides_to_dividesb_false. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $n$ och $m$ och $matita_basics_bool.false$.\nassistant\n", "label": "axiom not_divides_to_dividesb_false (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)", "predict": "axiom not_divides_to_dividesb_false (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nList_rect_CProp2_body. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_nil$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_768$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_767$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_770$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_767$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_768$ och $x_767$, för alla element $x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_766$.\nassistant\n", "label": "list_rect_CProp2_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_768 : cic.Term univs.Type0 _A -> x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_770 : cic.Term cic.prop (Q_ x_767) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_766) .", "predict": "list_rect_CProp2_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_768 : cic.Term univs.Type0 _A -> x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_770 : cic.Term cic.prop (Q_ x_767) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_766) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nEq_rect_CProp2. För alla element $A$ av $cic.Univ$ av $univs.Type2$, för alla element $_x$ av $cic.Term$ av $univs.Type2$ och $A$, för alla funktioner $Q_$ från element $x_31$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_32$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_31$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_refl$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$, för alla element $x_31$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_32$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_31$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_31$ och $x_32$.\nassistant\n", "label": "eq_rect_CProp2 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_31 : cic.Term univs.Type2 A -> _x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_31 : cic.Term univs.Type2 A -> x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Term cic.prop (Q_ x_31 x_32) .", "predict": "eq_rect_CProp2 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_31 : cic.Term univs.Type2 A -> _x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_31 : cic.Term univs.Type2 A -> x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Term cic.prop (Q_ x_31 x_32) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLe_S_S_to_le. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $n$ et $m$.\nassistant\n", "label": "le_S_S_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "le_S_S_to_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1032$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_582$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1033$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_582$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_582$, for all functions $_H2$ from elements $x_583$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1033$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_583$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_583$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sum_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1032 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_582 : cic.Term univs.Type0 x1) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_582))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_582))) -> (_H2 : (x_583 : cic.Term univs.Type0 x2) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sum_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1032 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_582 : cic.Term univs.Type0 x1) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_582))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_582))) -> (_H2 : (x_583 : cic.Term univs.Type0 x2) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nMem_map. Låt $A$ och $B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_lists_list.mem$ applicerat på $B$ och $b$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $f$ och $l$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och funktionen som avbildar $a$ som $matita_basics_logic.And$ applicerat på $matita_basics_lists_list.mem$ applicerat på $A$ och $a$ och $l$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $f$ applicerat på $a$ och $b$.\nassistant\n", "label": "postulate mem_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem B b (matita_basics_lists_list.map A B f l))) -> cic.Term cic.prop (matita_basics_logic.ex A (\\ a : cic.Term univs.Type0 A -> matita_basics_logic.And (matita_basics_lists_list.mem A a l) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f a) b)))", "predict": "postulate mem_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem B b (matita_basics_lists_list.map A B f l))) -> cic.Term cic.prop (matita_basics_logic.ex A (\\ a : cic.Term univs.Type0 A -> matita_basics_logic.And (matita_basics_lists_list.mem A a l) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f a) b)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMatch_divides. Let $_n$ and $_m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate match_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ return_sort) -> (case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNat_rect_CProp3. Låt $Q_$ vara en funktion från element $_x_401$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $_H_O$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.O$, för alla funktioner $_H_S$ från element $x_402$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_404$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_402$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_402$, för alla element $x_401$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_401$.\nassistant\n", "label": "axiom nat_rect_CProp3 (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_401)", "predict": "axiom nat_rect_CProp3 (Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) (x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_401)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTrue_rect_Type2_body. För alla funktioner $Q_$ från element $_x_48$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $univs.Type2$, för alla element $_H_I$ av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_logic.I$, för alla element $x_48$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_48$.\nassistant\n", "label": "True_rect_Type2_body : Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type2) -> _H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I) -> x_48 : cic.Term cic.prop matita_basics_logic.True -> cic.Term univs.Type2 (Q_ x_48) .", "predict": "True_rect_Type2_body : Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ univs.Type2) -> _H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I) -> x_48 : cic.Term cic.prop matita_basics_logic.True -> cic.Term univs.Type2 (Q_ x_48) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nOption. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då håller $cic.Univ$ för $univs.Type0$.\nassistant\n", "label": "postulate option : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate option : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLenght_to_nil. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l$ och $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l$ och $matita_basics_lists_list.nil$ applicerat på $A$.\nassistant\n", "label": "axiom lenght_to_nil (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))", "predict": "axiom lenght_to_nil (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nGcd_aux. För alla element $_p$ och $_m$ och $_n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate gcd_aux : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate gcd_aux : (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_16921. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x358$ and $x359$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x358$ and $matita_arithmetics_nat.times$ applied to $x358$ and $x359$ and $matita_arithmetics_nat.times$ applied to $x358$ and $matita_arithmetics_nat.S$ applied to $x359$.\nassistant\n", "label": "Axiom let_clause_16921 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359))) .", "predict": "Axiom let_clause_16921 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nLet_clause_15623. För alla element $m$ och $n$ och $a$ och $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $posm$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $pnm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, för alla element $c$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$,", "label": "let_clause_15623 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita", "predict": "let_clause_15623 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nTri_relation. Låt $__$ och $__1$ och $__2$ vara element av $cic.Univ$ av $univs.Type0$. Då håller $cic.Univ$ för $univs.Type0$.\nassistant\n", "label": "tri_relation : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 .", "predict": "tri_relation : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nExample2. $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_primes.smallest_factor$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate example2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "postulate example2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLprim_invariant. Låt $n$ och $i$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $acc$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $i$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_chebyshev_bertrand256.primes_below$ applicerat på $acc$ och $i$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_chebyshev_bertrand256.primes_below$ applicerat på $matita_arithmetics_chebyshev_bertrand256.lprim$ applicerat på $n$ och $i$ och $acc$ och $matita_arithmetics_nat.plus$ applicerat på $n$ och $i$.\nassistant\n", "label": "axiom lprim_invariant (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i))", "predict": "axiom lprim_invariant (n i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.lprim n i acc) (matita_arithmetics_nat.plus n i))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDpi1__o__op. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_basics_lists_list.Aop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_807$ and $_x_808$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.\nassistant\n", "label": "Axiom dpi1__o__op : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1)) -> cic.Univ univs.Type0), forall x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2), forall _x_807 : cic.Term univs.Type0 x0, forall _x_808 : cic.Term univs.Type0 x0, cic.Term univs.Type0 x0 .", "predict": "Axiom dpi1__o__op : forall x0 : cic.Univ univs.Type0, forall x1 : cic.Term univs.Type0 x0, forall x2 : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.Aop x0 x1)) -> cic.Univ univs.Type0), forall x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_basics_lists_list.Aop x0 x1) x2), forall _x_807 : cic.Term univs.Type0 x0, forall _x_808 : cic.Term univs.Type0 x0, cic.Term univs.Type0 x0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nVoid_rect_Type3. Soit $Q_$ une fonction des éléments $_x_485$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $univs.Type3$. Alors pour tous les éléments $x_485$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $univs.Type3$ et $Q_$ appliqué à $x_485$.\nassistant\n", "label": "Axiom void_rect_Type3 : forall Q_ : ((_x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type3), forall x_485 : cic.Term univs.Type0 matita_basics_types.void, cic.Term univs.Type3 (Q_ x_485) .", "predict": "Axiom void_rect_Type3 : forall Q_ : ((_x_485 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type3), forall x_485 : cic.Term univs.Type0 matita_basics_types.void, cic.Term univs.Type3 (Q_ x_485) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAppend. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "append : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) .", "predict": "append : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNat_rect_Type2_body. Soit $Q_$ une fonction des éléments $_x_381$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_H_O$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H_S$ des éléments $x_382$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_384$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $x_382$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_382$, pour tous les éléments $x_381$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_381$.\nassistant\n", "label": "axiom nat_rect_Type2_body (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type2 (Q_ x_381)", "predict": "axiom nat_rect_Type2_body (Q_ : (_x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2) (_H_O : cic.Term univs.Type2 (Q_ matita_arithmetics_nat.O)) (_H_S : (x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : cic.Term univs.Type2 (Q_ x_382)) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_nat.S x_382))) (x_381 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type2 (Q_ x_381)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nOption_rect_Type3_body. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_598$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type3$, för alla element $_H_None$ av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_599$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_599$, för alla element $x_598$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_598$.\nassistant\n", "label": "Axiom option_rect_Type3_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3), forall _H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))), forall x_598 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type3 (Q_ x_598) .", "predict": "Axiom option_rect_Type3_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3), forall _H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))), forall x_598 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type3 (Q_ x_598) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nNot_prime_to_primeb_false. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.prime$ applicerat på $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.primeb$ applicerat på $n$ och $matita_basics_bool.false$.\nassistant\n", "label": "axiom not_prime_to_primeb_false (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)", "predict": "axiom not_prime_to_primeb_false (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAop_inv_rect_Type2. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1518$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element", "label": "axiom Aop_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom Aop_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nNone. För alla element $A$ av $cic.Univ$ av $univs.Type0$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_types.option$ applicerat på $A$.\nassistant\n", "label": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)", "predict": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAnd_rect_CProp3. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_154$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_conj$ från element $x_156$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_155$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_156$ och $x_155$, för alla element $x_154$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_154$.\nassistant\n", "label": "And_rect_CProp3 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_156 : cic.Term cic.prop _A -> x_155 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_154) .", "predict": "And_rect_CProp3 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_156 : cic.Term cic.prop _A -> x_155 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_154) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMinus_plus_plus_l. Let $x$ and $y$ and $h$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $h$ and $matita_arithmetics_nat.plus$ applied to $y$ and $h$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$.\nassistant\n", "label": "axiom minus_plus_plus_l (x y h : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y))", "predict": "axiom minus_plus_plus_l (x y h : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.\nassistant\n", "label": "axiom list_rect_CProp3 (_A : cic.Univ univs.Type0) (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_761)", "predict": "axiom list_rect_CProp3 (_A : cic.Univ univs.Type0) (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_761)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMem_filter_l. Let $S$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $x$ and $matita_basics_bool.true$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $x$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $x$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$.\nassistant\n", "label": "Axiom mem_filter_l : forall S : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool), forall x : cic.Term univs.Type0 S, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true), forall __1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l), cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l)) .", "predict": "Axiom mem_filter_l : forall S : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool), forall x : cic.Term univs.Type0 S, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true), forall __1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l), cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_exp_Psi2. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "axiom le_exp_Psi2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))", "predict": "axiom le_exp_Psi2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDiv_mod_spec_to_eq. För alla element $a$ och $b$ och $q$ och $r$ och $q1$ och $r1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $a$ och $b$ och $q$ och $r$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $a$ och $b$ och $q1$ och $r1$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $q$ och $q1$.\nassistant\n", "label": "Axiom div_mod_spec_to_eq : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r), forall __1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q q1) .", "predict": "Axiom div_mod_spec_to_eq : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r), forall __1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q q1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAnd_rect_CProp2_body. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_158$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_conj$ från element $x_160$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_159$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_160$ och $x_159$, för alla element $x_158$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_158$.\nassistant\n", "label": "And_rect_CProp2_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_160 : cic.Term cic.prop _A -> x_159 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) -> x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_158) .", "predict": "And_rect_CProp2_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_160 : cic.Term cic.prop _A -> x_159 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) -> x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_158) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nAnd_inv_ind. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z323$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $x_120$ de $cic.Term$ de $cic.prop$ et de $x1$ et des éléments $x_119$ de $cic.Term$ de $cic.prop$ et de $x2$ et des éléments $_z324$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.And$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_120$ et $x_119$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_120$ et $x_119$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "And_inv_ind : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z323 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_120 : cic.Term cic.prop x1 -> x_119 : cic.Term cic.prop x2 -> _z324 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_120 x_119)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_120 x_119))) -> cic.Term cic.prop (P Hterm) .", "predict": "And_inv_ind : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z323 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_120 : cic.Term cic.prop x1 -> x_119 : cic.Term cic.prop x2 -> _z324 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_120 x_119)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_120 x_119))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.\nassistant\n", "label": "postulate le_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)", "predict": "postulate le_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nSum_inv_rect_Type1. Pour tous les éléments $x1$ et $x2$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z996$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des éléments $x_547$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z997$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_547$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_547$, pour toutes les fonctions $_H2$ des éléments $x_548$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z997$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_548$ à des éléments de $cic.Term$ de $univs.Type1$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_548$, $cic.Term$ tient pour $univs.Type1$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Sum_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ univs.Type1) -> _H1 : (x_547 : cic.Term univs.Type0 x1 -> _z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547)) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) -> _H2 : (x_548 : cic.Term univs.Type0 x2 -> _z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548)) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P Hterm) .", "predict": "Sum_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ univs.Type1) -> _H1 : (x_547 : cic.Term univs.Type0 x1 -> _z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547)) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) -> _H2 : (x_548 : cic.Term univs.Type0 x2 -> _z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548)) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEqb_n_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $n$ and $matita_basics_bool.true$.\nassistant\n", "label": "eqb_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n n) matita_basics_bool.true) .", "predict": "eqb_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n n) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMem_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate mem_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop", "predict": "postulate mem_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_bertrand. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom not_bertrand (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop", "predict": "axiom not_bertrand (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nMonotonic_le_minus_l. Låt $p$ och $q$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $q$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $q$ och $n$ och $matita_arithmetics_nat.minus$ applicerat på $p$ och $n$.\nassistant\n", "label": "Axiom monotonic_le_minus_l : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le q p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) .", "predict": "Axiom monotonic_le_minus_l : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le q p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExists_append_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$.\nassistant\n", "label": "Exists_append_r : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l2) -> cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2)) .", "predict": "Exists_append_r : A : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_lists_list.Exists A P l2) -> cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nReverse_single. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.\nassistant\n", "label": "postulate reverse_single : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))", "predict": "postulate reverse_single : (S : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMatch_Or. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $case_or_introl$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_logic.or_introl$ appliqué à $_A$ et $_B$ et $__$, pour toutes les fonctions $case_or_intror$ des éléments $__$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_logic.or_intror$ appliqué à $_A$ et $_B$ et $__$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "axiom match_Or (_A _B : cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort) (case_or_introl : (__ : cic.Term cic.prop _A) -> cic.Term return_sort (return_type (matita_basics_logic.or_introl _A _B __))) (case_or_intror : (__ : cic.Term cic.prop _B) -> cic.Term return_sort (return_type (matita_basics_logic.or_intror _A _B __))) (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) : cic.Term return_sort (return_type z)", "predict": "axiom match_Or (_A _B : cic.Univ cic.prop) (return_sort : cic.Sort) (return_type : (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) -> cic.Univ return_sort) (case_or_introl : (__ : cic.Term cic.prop _A) -> cic.Term return_sort (return_type (matita_basics_logic.or_introl _A _B __))) (case_or_intror : (__ : cic.Term cic.prop _B) -> cic.Term return_sort (return_type (matita_basics_logic.or_intror _A _B __))) (z : cic.Term cic.prop (matita_basics_logic.Or _A _B)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLePsi_r2. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $n$ och $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $n$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $n$ och $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applicerat på $n$.\nassistant\n", "label": "axiom lePsi_r2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "axiom lePsi_r2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLet_clause_1033. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $lt1n$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $x2515$ et $x2516$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $x2515$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x2516$ et $matita_arithmetics_div_and_mod.div$ appliqué à $x2515$ et $x2516$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $x2515$ et $x2516$.\nassistant\n", "label": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_inv_rect_CProp1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1488$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1489$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_855$ and $x_854$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1488 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) -> (_H1 : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1489 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_855 x_854))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nExp_Sn. Soient $b$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_exp.exp$ appliqué à $b$ et $matita_arithmetics_nat.S$ appliqué à $n$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $matita_arithmetics_exp.exp$ appliqué à $b$ et $n$.\nassistant\n", "label": "Axiom exp_Sn : forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp b (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times b (matita_arithmetics_exp.exp b n))) .", "predict": "Axiom exp_Sn : forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp b (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times b (matita_arithmetics_exp.exp b n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nAnd_rect_CProp0. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_166$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_conj$ från element $x_168$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_167$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_168$ och $x_167$, för alla element $x_166$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_166$.\nassistant\n", "label": "postulate And_rect_CProp0 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_168 : cic.Term cic.prop _A) -> (x_167 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) -> (x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_166)", "predict": "postulate And_rect_CProp0 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_168 : cic.Term cic.prop _A) -> (x_167 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) -> (x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_166)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nAnd_rect_CProp0. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_166$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_conj$ des éléments $x_168$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_167$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_168$ et $x_167$, pour tous les éléments $x_166$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_166$.\nassistant\n", "label": "Axiom And_rect_CProp0 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_168 : cic.Term cic.prop _A) -> (x_167 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))), forall x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_166) .", "predict": "Axiom And_rect_CProp0 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_168 : cic.Term cic.prop _A) -> (x_167 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))), forall x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_166) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_rect_Type0_r. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $x$ and $p$.\nassistant\n", "label": "postulate eq_rect_Type0_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type0 (P x p)", "predict": "postulate eq_rect_Type0_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type0 (P x p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLength_tail1. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_basics_lists_list.length$ appliqué à $A$ et $matita_basics_lists_list.tail$ appliqué à $A$ et $l$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$.\nassistant\n", "label": "Axiom length_tail1 : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l)) .", "predict": "Axiom length_tail1 : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l)), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nDivides_times_to_divides. För alla element $p$ och $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $p$ och $n$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $m$.\nassistant\n", "label": "Axiom divides_times_to_divides : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m)), cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_primes.divides p n) (matita_arithmetics_primes.divides p m)) .", "predict": "Axiom divides_times_to_divides : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m)), cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_primes.divides p n) (matita_arithmetics_primes.divides p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nSubR. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_R$ och $_S$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $A$, håller $cic.Univ$ för $cic.prop$.\nassistant\n", "label": "axiom subR (A : cic.Univ univs.Type0) (_R _S : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop", "predict": "axiom subR (A : cic.Univ univs.Type0) (_R _S : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_n_O_elim. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $matita_arithmetics_nat.O$, för alla funktioner $P$ från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $n$.\nassistant\n", "label": "Axiom le_n_O_elim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O), forall P : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __1 : cic.Term cic.prop (P matita_arithmetics_nat.O), cic.Term cic.prop (P n) .", "predict": "Axiom le_n_O_elim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O), forall P : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __1 : cic.Term cic.prop (P matita_arithmetics_nat.O), cic.Term cic.prop (P n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_clause_10331. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $len$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $lt2m$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $Hind$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_log.log$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $x2515$ och $x2516$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $c", "label": "axiom let_clause_10331 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n)) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "axiom let_clause_10331 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n)) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2515 (matita_arithmetics_div_and_mod.div x2516 x2515)) (matita_arithmetics_div_and_mod.mod x2516 x2515)) x2516)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIff_sym. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $A$.\nassistant\n", "label": "axiom iff_sym (A B : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff B A)", "predict": "axiom iff_sym (A B : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff B A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_p_ord_q_O. Let $p$ and $n$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $q$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom eq_p_ord_q_O (p n q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q matita_arithmetics_nat.O))", "predict": "axiom eq_p_ord_q_O (p n q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) q matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nUpto_body. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $A$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "upto_body : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "upto_body : A : cic.Univ univs.Type0 -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nFilter_range. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "postulate filter_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_15622. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$", "label": "axiom let_clause_15622 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (mat", "predict": "axiom let_clause_15622 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arith"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_rect_Type3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_nmk$ from functions $x_89$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_89$, for all elements $x_88$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_88$.\nassistant\n", "label": "postulate Not_rect_Type3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) -> (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) -> (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type3 (Q_ x_88)", "predict": "postulate Not_rect_Type3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type3) -> (_H_nmk : (x_89 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) -> (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type3 (Q_ x_88)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nLe_ind_body. För alla element $_n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $Q_$ från element $x_417$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_418$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_n$ och $x_417$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_le_n$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_n$ och $matita_arithmetics_nat.le_n$ applicerat på $_n$, för alla funktioner $_H_le_S$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $x_419$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_n$ och $m$ och element $_x_421$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $m$ och $x_419$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_nat.S$ applicerat på $m$ och $matita_arithmetics_nat.le_S$ applicerat på $_n$ och $m$ och $x_419$, för alla element $x_417$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $x_418$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_n$ och $x_417$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_417$ och $x_418$.\nassistant\n", "label": "Axiom le_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop), forall _H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n)), forall _H_le_S : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))), forall x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417), cic.Term cic.prop (Q_ x_417 x_418) .", "predict": "Axiom le_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop), forall _H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n)), forall _H_le_S : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))), forall x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417), cic.Term cic.prop (Q_ x_417 x_418) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nDividesb. Pour tous les éléments $__$ et $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_bool.bool$.\nassistant\n", "label": "axiom dividesb (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool", "predict": "axiom dividesb (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLength_map. För alla element $A$ och $B$ av $cic.Univ$ av $univs.Type0$, för alla element $l$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_basics_lists_list.length$ applicerat på $B$ och $matita_basics_lists_list.map$ applicerat på $A$ och $B$ och $f$ och $l$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l$.\nassistant\n", "label": "axiom length_map (A B : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l))", "predict": "axiom length_map (A B : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_inv_rect_CProp1. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z960$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z961$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom unit_inv_rect_CProp1 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) .", "predict": "Axiom unit_inv_rect_CProp1 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAbsurd. Let $A$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.False$.\nassistant\n", "label": "Axiom absurd : forall A : cic.Univ cic.prop, forall __ : cic.Term cic.prop A, forall __1 : cic.Term cic.prop (matita_basics_logic.Not A), cic.Term cic.prop matita_basics_logic.False .", "predict": "Axiom absurd : forall A : cic.Univ cic.prop, forall __ : cic.Term cic.prop A, forall __1 : cic.Term cic.prop (matita_basics_logic.Not A), cic.Term cic.prop matita_basics_logic.False ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nFoldr_body. Pour tous les éléments $A$ et $B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $_b$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $_l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, $cic.Term$ tient pour $univs.Type0$ et $B$.\nassistant\n", "label": "foldr_body : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _b : cic.Term univs.Type0 B -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 B .", "predict": "foldr_body : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _b : cic.Term univs.Type0 B -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 B ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTrue_to_le_min. Pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $n$ et $m$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $m$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$ et $m$.\nassistant\n", "label": "axiom true_to_le_min (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m)", "predict": "axiom true_to_le_min (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_931$.\nassistant\n", "label": "Axiom range_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_931) .", "predict": "Axiom range_rect_CProp5_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_931) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_16$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_17$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_16$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_16$ and $x_17$.\nassistant\n", "label": "axiom eq_rect_Type1_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) (x_16 : cic.Term univs.Type2 A) (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) : cic.Term univs.Type1 (Q_ x_16 x_17)", "predict": "axiom eq_rect_Type1_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_16 : cic.Term univs.Type2 A) -> (_x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) -> cic.Univ univs.Type1) (_H_refl : cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x))) (x_16 : cic.Term univs.Type2 A) (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16)) : cic.Term univs.Type1 (Q_ x_16 x_17)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nAop_inv_rect_Type1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x2$ de $cic.Term$ de $univs.Type0$ et de $x1$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1524$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$", "label": "axiom Aop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom Aop_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) (P : (_z1524 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type1) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b x2)) (op (op a b) x2))) -> (_z1525 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nFilter_range. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $_A$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nassistant\n", "label": "Axiom filter_range : forall _A : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_range : forall _A : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nLe_times_to_le_div. Soient $a$ et $b$ et $c$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.times$ appliqué à $b$ et $c$ et $a$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $c$ et $matita_arithmetics_div_and_mod.div$ appliqué à $a$ et $b$.\nassistant\n", "label": "axiom le_times_to_le_div (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) : cic.Term cic.prop (matita_arithmetics_nat.le c (matita_arithmetics_div_and_mod.div a b))", "predict": "axiom le_times_to_le_div (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) : cic.Term cic.prop (matita_arithmetics_nat.le c (matita_arithmetics_div_and_mod.div a b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAnd_rect_Type4_body. För alla element $_A$ och $_B$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_122$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H_conj$ från element $x_124$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_123$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_124$ och $x_123$, för alla element $x_122$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_122$.\nassistant\n", "label": "And_rect_Type4_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type4) -> _H_conj : (x_124 : cic.Term cic.prop _A -> x_123 : cic.Term cic.prop _B -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type4 (Q_ x_122) .", "predict": "And_rect_Type4_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type4) -> _H_conj : (x_124 : cic.Term cic.prop _A -> x_123 : cic.Term cic.prop _B -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type4 (Q_ x_122) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nProd_inv_rect_Type2. Pour tous les éléments $x1$ et $x2$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1254$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H1$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1255$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$ à des éléments de $cic.Term$ de $univs.Type2$ et de $P$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $x1$ et $x2$ et $_fst$ et $_snd$, $cic.Term$ tient pour $univs.Type2$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "Axiom Prod_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1254 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1255 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom Prod_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1254 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1255 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type2 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nInjective_plus_l. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.plus$ applied to $m$ and $n$.\nassistant\n", "label": "injective_plus_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.plus m n)) .", "predict": "injective_plus_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.plus m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nLt_O_ord_rem. Soient $p$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_ord.ord_rem$ appliqué à $n$ et $p$.\nassistant\n", "label": "lt_O_ord_rem : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_ord.ord_rem n p)) .", "predict": "lt_O_ord_rem : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_ord.ord_rem n p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFold_true. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $a$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $p$ applied to $i$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $op$ applied to $f$ applied to $a$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $p$ applied to $i$ and the function that maps $i$ to $f$ applied to $i$ and $l$.\nassistant\n", "label": "postulate fold_true : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (nil : cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (\\ i : cic.Term univs.Type0 A -> p i) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.cons A a l)) (op (f a) (matita_basics_lists_list.fold A B op nil (\\ i : cic.Term univs.Type0 A -> p i) (\\ i : cic.Term univs.Type0 A -> f i) l)))", "predict": "postulate fold_true : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (nil : cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (\\ i : cic.Term univs.Type0 A -> p i) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.cons A a l)) (op (f a) (matita_basics_lists_list.fold A B op nil (\\ i : cic.Term univs.Type0 A -> p i) (\\ i : cic.Term univs.Type0 A -> f i) l)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nACop_rect_Type5. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_893$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_893$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_893$.\nassistant\n", "label": "Axiom ACop_rect_Type5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type5 (Q_ x_893) .", "predict": "Axiom ACop_rect_Type5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term univs.Type5 (Q_ x_893) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nDiv_mod_spec_rect_CProp2. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_849$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_851$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_850$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_851$ och $x_850$, för alla element $x_849$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_849$.\nassistant\n", "label": "postulate div_mod_spec_rect_CProp2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)", "predict": "postulate div_mod_spec_rect_CProp2 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nNat_rect_CProp1_body. Soit $Q_$ une fonction des éléments $_x_409$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_O$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H_S$ des éléments $x_410$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_412$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_410$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_410$, pour tous les éléments $x_409$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_409$.\nassistant\n", "label": "axiom nat_rect_CProp1_body (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)", "predict": "axiom nat_rect_CProp1_body (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLt_to_leb_false. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_nat.leb$ appliqué à $n$ et $m$ et $matita_basics_bool.false$.\nassistant\n", "label": "Axiom lt_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) .", "predict": "Axiom lt_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMinus_minus_associative. Let $x$ and $y$ and $z$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $z$ and $y$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $y$ and $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $y$ and $z$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $z$.\nassistant\n", "label": "axiom minus_minus_associative (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le y x)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus x y) z))", "predict": "axiom minus_minus_associative (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le y x)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus x y) z))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nGcd_times_SO_to_gcd_SO. Soient $m$ et $n$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $matita_arithmetics_nat.times$ appliqué à $n$ et $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom gcd_times_SO_to_gcd_SO (m n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "axiom gcd_times_SO_to_gcd_SO (m n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1752$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita", "label": "axiom Dop_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1752 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1753 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Dop_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1752 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1753 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nProd_ind_body. Pour tous les éléments $_A$ et $_B$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_690$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_690$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_690$.\nassistant\n", "label": "Prod_ind_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_690) .", "predict": "Prod_ind_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_690) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nEq_to_bijn. Pour toutes les fonctions $f$ et $g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $__$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $i$ et $g$ appliqué à $i$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.bijn$ appliqué à $f$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.bijn$ appliqué à $g$ et $n$.\nassistant\n", "label": "postulate eq_to_bijn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f i) (g i))) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)", "predict": "postulate eq_to_bijn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f i) (g i))) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_to_leb_false. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "lt_to_leb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) .", "predict": "lt_to_leb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_CProp0. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_714$.\nassistant\n", "label": "axiom Prod_rect_CProp0 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_714)", "predict": "axiom Prod_rect_CProp0 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_714)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_rect_CProp5. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.\nassistant\n", "label": "postulate Sum_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)", "predict": "postulate Sum_rect_CProp5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_rect_Type0. For all functions $Q_$ from elements $_x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_I$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_52$.\nassistant\n", "label": "axiom True_rect_Type0 (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)", "predict": "axiom True_rect_Type0 (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nAnd_rect_Type2. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_134$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_conj$ från element $x_136$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_135$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_136$ och $x_135$, för alla element $x_134$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_134$.\nassistant\n", "label": "axiom And_rect_Type2 (_A _B : cic.Univ cic.prop) (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type2 (Q_ x_134)", "predict": "axiom And_rect_Type2 (_A _B : cic.Univ cic.prop) (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type2 (Q_ x_134)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nS_pred. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.pred$ applied to $n$ and $n$.\nassistant\n", "label": "axiom S_pred (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_nat.pred n)) n)", "predict": "axiom S_pred (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_nat.pred n)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nACop_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_889$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_889$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_889$.\nassistant\n", "label": "ACop_ind_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_889) .", "predict": "ACop_ind_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_889) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMem. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate mem : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop", "predict": "postulate mem : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nTranspose. Pour tous les éléments $__$ et $__1$ et $__2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom transpose : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom transpose : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nPlus_minus_plus_plus_l. Låt $z$ och $x$ och $y$ och $h$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $z$ och $matita_arithmetics_nat.plus$ applicerat på $x$ och $h$ och $matita_arithmetics_nat.plus$ applicerat på $y$ och $h$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $z$ och $x$ och $y$.\nassistant\n", "label": "Axiom plus_minus_plus_plus_l : forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall h : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z (matita_arithmetics_nat.plus x h)) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) y)) .", "predict": "Axiom plus_minus_plus_plus_l : forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall h : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z (matita_arithmetics_nat.plus x h)) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nFilter. Pour tous les éléments $T$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_p$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $T$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $_l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $T$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_lists_list.list$ appliqué à $T$.\nassistant\n", "label": "postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)", "predict": "postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nSig_inv_rect_CProp0. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1230$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1231$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nassistant\n", "label": "axiom Sig_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Sig_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_646$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_646$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_646$.\nassistant\n", "label": "postulate DPair_rect_Type2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type2) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type2 (Q_ x_646)", "predict": "postulate DPair_rect_Type2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type2) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_646 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type2 (Q_ x_646)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nOrd_rem. För alla element $__$ och $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate ord_rem : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate ord_rem : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_871$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil", "label": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_871)", "predict": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_871)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nDPair_rect_Type4. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_640$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H_mk_DPair$ des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $_f$ appliqué à $dpi1$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $A$ et $_f$ et $dpi1$ et $_dpi2$, pour tous les éléments $x_640$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_640$.\nassistant\n", "label": "Axiom DPair_rect_Type4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type4 (Q_ x_640) .", "predict": "Axiom DPair_rect_Type4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type4 (Q_ x_640) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLet_upper_bound2. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate let_upper_bound2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_upper_bound2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nB_SSSSO. $cic.Term$ håller för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_chebyshev_factorization.B$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.\nassistant\n", "label": "B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) .", "predict": "B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nAssoc. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $nil$, för alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $c$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $matita_basics_lists_list.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ och $c$.\nassistant\n", "label": "Axiom assoc : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c)) .", "predict": "Axiom assoc : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nNotb. Soit $__$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_basics_bool.bool$.\nassistant\n", "label": "notb : __ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "notb : __ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nLstar_step. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $R$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $b1$ et $b2$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b1$ et $b2$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$ et $b2$.\nassistant\n", "label": "Axiom lstar_step : forall B : cic.Univ univs.Type0, forall R : ((__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (R b1 b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2) .", "predict": "Axiom lstar_step : forall B : cic.Univ univs.Type0, forall R : ((__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (R b1 b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nLet_upper_bound3. För alla element $n$ och $m$ och $x$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom let_upper_bound3 (n m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom let_upper_bound3 (n m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nDiv_mod_spec_rect_Type5. Pour tous les éléments $_n$ et $_m$ et $_q$ et $_r$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Q_$ des éléments $_x_817$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $univs.Type5$, pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_819$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_818$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_819$ et $x_818$, pour tous les éléments $x_817$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_817$.\nassistant\n", "label": "div_mod_spec_rect_Type5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type5) -> _H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type5 (Q_ x_817) .", "predict": "div_mod_spec_rect_Type5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type5) -> _H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type5 (Q_ x_817) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nInr. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.\nassistant\n", "label": "postulate inr : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)", "predict": "postulate inr : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Sum A B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Agda.\nLe_div_times_m. Soient $a$ et $i$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $i$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $matita_arithmetics_div_and_mod.div$ appliqué à $m$ et $i$ et $m$ et $matita_arithmetics_div_and_mod.div$ appliqué à $a$ et $i$.\nassistant\n", "label": "postulate le_div_times_m : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div m i)) m) (matita_arithmetics_div_and_mod.div a i))", "predict": "postulate le_div_times_m : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div m i)) m) (matita_arithmetics_div_and_mod.div a i))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_rect_Type5_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.\nassistant\n", "label": "div_mod_spec_rect_Type5_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type5) -> _H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type5 (Q_ x_817) .", "predict": "div_mod_spec_rect_Type5_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type5) -> _H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type5 (Q_ x_817) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_min_r. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.\nassistant\n", "label": "le_min_r : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b)) .", "predict": "le_min_r : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExp_2. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom exp_2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n)) .", "predict": "Axiom exp_2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nList_rect_Type2. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_736$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type2$, för alla element $_H_nil$ av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_738$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_737$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_740$ av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $x_737$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_738$ och $x_737$, för alla element $x_736$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_736$.\nassistant\n", "label": "axiom list_rect_Type2 (_A : cic.Univ univs.Type0) (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type2 (Q_ x_736)", "predict": "axiom list_rect_Type2 (_A : cic.Univ univs.Type0) (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type2 (Q_ x_736)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nPermut_mod. För alla element $p$ och $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $p$ och $a$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på funktionen som avbildar $n$ som $matita_arithmetics_div_and_mod.mod$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $n$ och $p$ och $matita_arithmetics_nat.pred$ applicerat på $p$.\nassistant\n", "label": "permut_mod : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p)) .", "predict": "permut_mod : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nACop_rect_Type1. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_899$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_899$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_899$.\nassistant\n", "label": "ACop_rect_Type1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type1) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type1 (Q_ x_899) .", "predict": "ACop_rect_Type1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type1) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type1 (Q_ x_899) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Coq.\nEx_ind. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_235$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_ex_intro$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $x_236$ av $cic.Term$ av $cic.prop$ och $_P$ applicerat på $x$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.ex_intro$ applicerat på $A$ och $_P$ och $x$ och $x_236$, för alla element $x_235$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_235$.\nassistant\n", "label": "Axiom ex_ind : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop), forall _H_ex_intro : ((x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))), forall x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P), cic.Term cic.prop (Q_ x_235) .", "predict": "Axiom ex_ind : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop), forall _H_ex_intro : ((x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))), forall x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P), cic.Term cic.prop (Q_ x_235) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nEq_rect_Type0. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Då för alla element $_x$ av $cic.Term$ av $univs.Type2$ och $A$, för alla funktioner $Q_$ från element $x_19$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_20$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_19$ till element av $cic.Univ$ av $univs.Type0$, för alla element $_H_refl$ av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$, för alla element $x_19$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_20$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_19$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_19$ och $x_20$.\nassistant\n", "label": "eq_rect_Type0 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_19 : cic.Term univs.Type2 A -> _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Univ univs.Type0) -> _H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) -> x_19 : cic.Term univs.Type2 A -> x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Term univs.Type0 (Q_ x_19 x_20) .", "predict": "eq_rect_Type0 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_19 : cic.Term univs.Type2 A -> _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Univ univs.Type0) -> _H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) -> x_19 : cic.Term univs.Type2 A -> x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Term univs.Type0 (Q_ x_19 x_20) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nPermut_transpose_r. Pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $m$ et $i$ et $j$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $j$ et $m$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à la fonction qui envoie $n$ à $f$ appliqué à $matita_arithmetics_permutation.transpose$ appliqué à $i$ et $j$ et $n$ et $m$.\nassistant\n", "label": "axiom permut_transpose_r (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (m i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => f (matita_arithmetics_permutation.transpose i j n)) m)", "predict": "axiom permut_transpose_r (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (m i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => f (matita_arithmetics_permutation.transpose i j n)) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Lean.\nUnit_inv_ind. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$. Då för alla funktioner $P$ från element $_z906$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z907$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.unit$ och $Hterm$ och $matita_basics_types.it$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_types.it$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nassistant\n", "label": "axiom unit_inv_ind (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z906 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H1 : (_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) : cic.Term cic.prop (P Hterm)", "predict": "axiom unit_inv_ind (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z906 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H1 : (_z907 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nF_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.\nassistant\n", "label": "axiom f_ind (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (P a)", "predict": "axiom f_ind (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (P a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Dedukti.\nAnd_rect_CProp4. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $Q_$ från element $_x_146$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_conj$ från element $x_148$ av $cic.Term$ av $cic.prop$ och $_A$ och element $x_147$ av $cic.Term$ av $cic.prop$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.conj$ applicerat på $_A$ och $_B$ och $x_148$ och $x_147$, för alla element $x_146$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_146$.\nassistant\n", "label": "And_rect_CProp4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_148 : cic.Term cic.prop _A -> x_147 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_146) .", "predict": "And_rect_CProp4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_148 : cic.Term cic.prop _A -> x_147 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_146) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Dedukti.\nSig_rect_Type1_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $Q_$ des éléments $_x_674$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_674$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_674$.\nassistant\n", "label": "Sig_rect_Type1_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type1) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type1 (Q_ x_674) .", "predict": "Sig_rect_Type1_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type1) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type1 (Q_ x_674) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following Swedish statement into Agda.\nOption_rect_Type4. Låt $_A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_590$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$ till element av $cic.Univ$ av $univs.Type4$, för alla element $_H_None$ av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_types.None$ applicerat på $_A$, för alla funktioner $_H_Some$ från element $x_591$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $univs.Type4$ och $Q_$ applicerat på $matita_basics_types.Some$ applicerat på $_A$ och $x_591$, för alla element $x_590$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $_A$, håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_590$.\nassistant\n", "label": "postulate option_rect_Type4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type4) -> (_H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_591 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> (x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type4 (Q_ x_590)", "predict": "postulate option_rect_Type4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type4) -> (_H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_591 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> (x_590 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type4 (Q_ x_590)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMdef. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_binomial.bc$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.\nassistant\n", "label": "axiom Mdef (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.M m) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) m))", "predict": "axiom Mdef (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.M m) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nOption_rect_Type1_body. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$, pour tous les éléments $_H_None$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_607$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_607$, pour tous les éléments $x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_606$.\nassistant\n", "label": "axiom option_rect_Type1_body (_A : cic.Univ univs.Type0) (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type1 (Q_ x_606)", "predict": "axiom option_rect_Type1_body (_A : cic.Univ univs.Type0) (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type1 (Q_ x_606)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nMatch_bool. Soit $return_sort$ un élément de $cic.Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $return_sort$, pour tous les éléments $case_true$ de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_bool.true$, pour tous les éléments $case_false$ de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $matita_basics_bool.false$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nassistant\n", "label": "axiom match_bool (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) (z : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term return_sort (return_type z)", "predict": "axiom match_bool (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) (z : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Lean.\nTrue_rect_CProp0_body. Pour toutes les fonctions $Q_$ des éléments $_x_64$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $_H_I$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.I$, pour tous les éléments $x_64$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_64$.\nassistant\n", "label": "axiom True_rect_CProp0_body (Q_ : (_x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_64 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_64)", "predict": "axiom True_rect_CProp0_body (Q_ : (_x_64 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_64 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_64)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following French statement into Coq.\nTech_log. Pour tous les éléments $p$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_log.log$ appliqué à $p$ et $n$ et $matita_arithmetics_minimization.max$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et la fonction qui envoie $x$ à $matita_arithmetics_nat.leb$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $p$ et $x$ et $n$.\nassistant\n", "label": "Axiom tech_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (fun x => matita_arithmetics_nat.leb (matita_arithmetics_exp.exp p x) n))) .", "predict": "Axiom tech_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (fun x => matita_arithmetics_nat.leb (matita_arithmetics_exp.exp p x) n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_Psi_exp1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "axiom le_Psi_exp1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S n)))))", "predict": "axiom le_Psi_exp1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S n)))))"}